require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.nextTick()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected() {
            pendingCount--;
            if (pendingCount === 0) {
                deferred.reject(new Error(
                    "Can't get fulfillment value from any promise, all " +
                    "promises were rejected."
                ));
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'))

},{"_process":7}],2:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

},{"base64-js":3,"ieee754":4,"is-array":5}],3:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],4:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],5:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],6:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],7:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],8:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],9:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":8,"_process":7,"inherits":6}],10:[function(require,module,exports){
(function () {
    "use strict";

    // Module systems magic dance.

    /* istanbul ignore else */
    if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
        // NodeJS
        module.exports = chaiAsPromised;
    } else if (typeof define === "function" && define.amd) {
        // AMD
        define(function () {
            return chaiAsPromised;
        });
    } else {
        /*global self: false */

        // Other environment (usually <script> tag): plug in to global chai instance directly.
        chai.use(chaiAsPromised);

        // Expose as a property of the global object so that consumers can configure the `transferPromiseness` property.
        self.chaiAsPromised = chaiAsPromised;
    }

    chaiAsPromised.transferPromiseness = function (assertion, promise) {
        assertion.then = promise.then.bind(promise);
    };

    chaiAsPromised.transformAsserterArgs = function (values) {
        return values;
    };

    function chaiAsPromised(chai, utils) {
        var Assertion = chai.Assertion;
        var assert = chai.assert;

        function isJQueryPromise(thenable) {
            return typeof thenable.always === "function" &&
                   typeof thenable.done === "function" &&
                   typeof thenable.fail === "function" &&
                   typeof thenable.pipe === "function" &&
                   typeof thenable.progress === "function" &&
                   typeof thenable.state === "function";
        }

        function assertIsAboutPromise(assertion) {
            if (typeof assertion._obj.then !== "function") {
                throw new TypeError(utils.inspect(assertion._obj) + " is not a thenable.");
            }
            if (isJQueryPromise(assertion._obj)) {
                throw new TypeError("Chai as Promised is incompatible with jQuery's thenables, sorry! Please use a " +
                                    "Promises/A+ compatible library (see http://promisesaplus.com/).");
            }
        }

        function method(name, asserter) {
            utils.addMethod(Assertion.prototype, name, function () {
                assertIsAboutPromise(this);
                return asserter.apply(this, arguments);
            });
        }

        function property(name, asserter) {
            utils.addProperty(Assertion.prototype, name, function () {
                assertIsAboutPromise(this);
                return asserter.apply(this, arguments);
            });
        }

        function doNotify(promise, done) {
            promise.then(function () { done(); }, done);
        }

        // These are for clarity and to bypass Chai refusing to allow `undefined` as actual when used with `assert`.
        function assertIfNegated(assertion, message, extra) {
            assertion.assert(true, null, message, extra.expected, extra.actual);
        }

        function assertIfNotNegated(assertion, message, extra) {
            assertion.assert(false, message, null, extra.expected, extra.actual);
        }

        function getBasePromise(assertion) {
            // We need to chain subsequent asserters on top of ones in the chain already (consider
            // `eventually.have.property("foo").that.equals("bar")`), only running them after the existing ones pass.
            // So the first base-promise is `assertion._obj`, but after that we use the assertions themselves, i.e.
            // previously derived promises, to chain off of.
            return typeof assertion.then === "function" ? assertion : assertion._obj;
        }

        // Grab these first, before we modify `Assertion.prototype`.

        var propertyNames = Object.getOwnPropertyNames(Assertion.prototype);

        var propertyDescs = {};
        propertyNames.forEach(function (name) {
            propertyDescs[name] = Object.getOwnPropertyDescriptor(Assertion.prototype, name);
        });

        property("fulfilled", function () {
            var that = this;
            var derivedPromise = getBasePromise(that).then(
                function (value) {
                    that._obj = value;
                    assertIfNegated(that,
                                    "expected promise not to be fulfilled but it was fulfilled with #{act}",
                                    { actual: value });
                    return value;
                },
                function (reason) {
                    assertIfNotNegated(that,
                                       "expected promise to be fulfilled but it was rejected with #{act}",
                                       { actual: reason });
                }
            );

            chaiAsPromised.transferPromiseness(that, derivedPromise);
        });

        property("rejected", function () {
            var that = this;
            var derivedPromise = getBasePromise(that).then(
                function (value) {
                    that._obj = value;
                    assertIfNotNegated(that,
                                       "expected promise to be rejected but it was fulfilled with #{act}",
                                       { actual: value });
                    return value;
                },
                function (reason) {
                    assertIfNegated(that,
                                    "expected promise not to be rejected but it was rejected with #{act}",
                                    { actual: reason });

                    // Return the reason, transforming this into a fulfillment, to allow further assertions, e.g.
                    // `promise.should.be.rejected.and.eventually.equal("reason")`.
                    return reason;
                }
            );

            chaiAsPromised.transferPromiseness(that, derivedPromise);
        });

        method("rejectedWith", function (Constructor, message) {
            var desiredReason = null;
            var constructorName = null;

            if (Constructor instanceof RegExp || typeof Constructor === "string") {
                message = Constructor;
                Constructor = null;
            } else if (Constructor && Constructor instanceof Error) {
                desiredReason = Constructor;
                Constructor = null;
                message = null;
            } else if (typeof Constructor === "function") {
                constructorName = (new Constructor()).name;
            } else {
                Constructor = null;
            }

            var that = this;
            var derivedPromise = getBasePromise(that).then(
                function (value) {
                    var assertionMessage = null;
                    var expected = null;

                    if (Constructor) {
                        assertionMessage = "expected promise to be rejected with #{exp} but it was fulfilled with " +
                                           "#{act}";
                        expected = constructorName;
                    } else if (message) {
                        var verb = message instanceof RegExp ? "matching" : "including";
                        assertionMessage = "expected promise to be rejected with an error " + verb + " #{exp} but it " +
                                           "was fulfilled with #{act}";
                        expected = message;
                    } else if (desiredReason) {
                        assertionMessage = "expected promise to be rejected with #{exp} but it was fulfilled with " +
                                           "#{act}";
                        expected = desiredReason;
                    }

                    that._obj = value;

                    assertIfNotNegated(that, assertionMessage, { expected: expected, actual: value });
                },
                function (reason) {
                    if (Constructor) {
                        that.assert(reason instanceof Constructor,
                                    "expected promise to be rejected with #{exp} but it was rejected with #{act}",
                                    "expected promise not to be rejected with #{exp} but it was rejected with #{act}",
                                    constructorName,
                                    reason);
                    }

                    var reasonMessage = utils.type(reason) === "object" && "message" in reason ?
                                            reason.message :
                                            "" + reason;
                    if (message && reasonMessage !== null && reasonMessage !== undefined) {
                        if (message instanceof RegExp) {
                            that.assert(message.test(reasonMessage),
                                        "expected promise to be rejected with an error matching #{exp} but got #{act}",
                                        "expected promise not to be rejected with an error matching #{exp}",
                                        message,
                                        reasonMessage);
                        }
                        if (typeof message === "string") {
                            that.assert(reasonMessage.indexOf(message) !== -1,
                                        "expected promise to be rejected with an error including #{exp} but got #{act}",
                                        "expected promise not to be rejected with an error including #{exp}",
                                        message,
                                        reasonMessage);
                        }
                    }

                    if (desiredReason) {
                        that.assert(reason === desiredReason,
                                    "expected promise to be rejected with #{exp} but it was rejected with #{act}",
                                    "expected promise not to be rejected with #{exp}",
                                    desiredReason,
                                    reason);
                    }
                }
            );

            chaiAsPromised.transferPromiseness(that, derivedPromise);
        });

        property("eventually", function () {
            utils.flag(this, "eventually", true);
        });

        method("notify", function (done) {
            doNotify(getBasePromise(this), done);
        });

        method("become", function (value) {
            return this.eventually.deep.equal(value);
        });

        ////////
        // `eventually`

        // We need to be careful not to trigger any getters, thus `Object.getOwnPropertyDescriptor` usage.
        var methodNames = propertyNames.filter(function (name) {
            return name !== "assert" && typeof propertyDescs[name].value === "function";
        });

        methodNames.forEach(function (methodName) {
            Assertion.overwriteMethod(methodName, function (originalMethod) {
                return function () {
                    doAsserterAsyncAndAddThen(originalMethod, this, arguments);
                };
            });
        });

        var getterNames = propertyNames.filter(function (name) {
            return name !== "_obj" && typeof propertyDescs[name].get === "function";
        });

        getterNames.forEach(function (getterName) {
            // Chainable methods are things like `an`, which can work both for `.should.be.an.instanceOf` and as
            // `should.be.an("object")`. We need to handle those specially.
            var isChainableMethod = Assertion.prototype.__methods.hasOwnProperty(getterName);

            if (isChainableMethod) {
                Assertion.overwriteChainableMethod(
                    getterName,
                    function (originalMethod) {
                        return function() {
                            doAsserterAsyncAndAddThen(originalMethod, this, arguments);
                        };
                    },
                    function (originalGetter) {
                        return function() {
                            doAsserterAsyncAndAddThen(originalGetter, this);
                        };
                    }
                );
            } else {
                Assertion.overwriteProperty(getterName, function (originalGetter) {
                    return function () {
                        doAsserterAsyncAndAddThen(originalGetter, this);
                    };
                });
            }
        });

        function doAsserterAsyncAndAddThen(asserter, assertion, args) {
            // Since we're intercepting all methods/properties, we need to just pass through if they don't want
            // `eventually`, or if we've already fulfilled the promise (see below).
            if (!utils.flag(assertion, "eventually")) {
                return asserter.apply(assertion, args);
            }

            var derivedPromise = getBasePromise(assertion).then(function (value) {
                // Set up the environment for the asserter to actually run: `_obj` should be the fulfillment value, and
                // now that we have the value, we're no longer in "eventually" mode, so we won't run any of this code,
                // just the base Chai code that we get to via the short-circuit above.
                assertion._obj = value;
                utils.flag(assertion, "eventually", false);

                return args ? chaiAsPromised.transformAsserterArgs(args) : args;
            }).then(function (args) {
                asserter.apply(assertion, args);

                // Because asserters, for example `property`, can change the value of `_obj` (i.e. change the "object"
                // flag), we need to communicate this value change to subsequent chained asserters. Since we build a
                // promise chain paralleling the asserter chain, we can use it to communicate such changes.
                return assertion._obj;
            });

            chaiAsPromised.transferPromiseness(assertion, derivedPromise);
        }

        ///////
        // Now use the `Assertion` framework to build an `assert` interface.
        var originalAssertMethods = Object.getOwnPropertyNames(assert).filter(function (propName) {
            return typeof assert[propName] === "function";
        });

        assert.isFulfilled = function (promise, message) {
            return (new Assertion(promise, message)).to.be.fulfilled;
        };

        assert.isRejected = function (promise, toTestAgainst, message) {
            if (typeof toTestAgainst === "string") {
                message = toTestAgainst;
                toTestAgainst = undefined;
            }

            var assertion = (new Assertion(promise, message));
            return toTestAgainst !== undefined ? assertion.to.be.rejectedWith(toTestAgainst) : assertion.to.be.rejected;
        };

        assert.becomes = function (promise, value, message) {
            return assert.eventually.deepEqual(promise, value, message);
        };

        assert.doesNotBecome = function (promise, value, message) {
            return assert.eventually.notDeepEqual(promise, value, message);
        };

        assert.eventually = {};
        originalAssertMethods.forEach(function (assertMethodName) {
            assert.eventually[assertMethodName] = function (promise) {
                var otherArgs = Array.prototype.slice.call(arguments, 1);

                var customRejectionHandler;
                var message = arguments[assert[assertMethodName].length - 1];
                if (typeof message === "string") {
                    customRejectionHandler = function (reason) {
                        throw new chai.AssertionError(message + "\n\nOriginal reason: " + utils.inspect(reason));
                    };
                }

                var returnedPromise = promise.then(
                    function (fulfillmentValue) {
                        return assert[assertMethodName].apply(assert, [fulfillmentValue].concat(otherArgs));
                    },
                    customRejectionHandler
                );

                returnedPromise.notify = function (done) {
                    doNotify(returnedPromise, done);
                };

                return returnedPromise;
            };
        });
    }
}());

},{}],11:[function(require,module,exports){
module.exports = require('./lib/chai');

},{"./lib/chai":12}],12:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = '3.2.0';

/*!
 * Assertion Error
 */

exports.AssertionError = require('assertion-error');

/*!
 * Utils for plugins (not exported)
 */

var util = require('./chai/utils');

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Utility Functions
 */

exports.util = util;

/*!
 * Configuration
 */

var config = require('./chai/config');
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = require('./chai/assertion');
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require('./chai/core/assertions');
exports.use(core);

/*!
 * Expect interface
 */

var expect = require('./chai/interface/expect');
exports.use(expect);

/*!
 * Should interface
 */

var should = require('./chai/interface/should');
exports.use(should);

/*!
 * Assert interface
 */

var assert = require('./chai/interface/assert');
exports.use(assert);

},{"./chai/assertion":13,"./chai/config":14,"./chai/core/assertions":15,"./chai/interface/assert":16,"./chai/interface/expect":17,"./chai/interface/should":18,"./chai/utils":31,"assertion-error":39}],13:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('./config');

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, 'ssfi', stack || arguments.callee);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String or Function} message or function that returns message to display if expression fails
   * @param {String or Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};

},{"./config":14}],14:[function(require,module,exports){
module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};

},{}],15:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @api public
   */

  [ 'to', 'be', 'been'
  , 'is', 'and', 'has', 'have'
  , 'with', 'that', 'which', 'at'
  , 'of', 'same' ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * `.deep.property` special characters can be escaped
   * by adding two slashes before the `.` or `[]`.
   *
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name deep
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .any
   *
   * Sets the `any` flag, (opposite of the `all` flag)
   * later used in the `keys` assertion.
   *
   *     expect(foo).to.have.any.keys('bar', 'baz');
   *
   * @name any
   * @api public
   */

  Assertion.addProperty('any', function () {
    flag(this, 'any', true);
    flag(this, 'all', false)
  });


  /**
   * ### .all
   *
   * Sets the `all` flag (opposite of the `any` flag)
   * later used by the `keys` assertion.
   *
   *     expect(foo).to.have.all.keys('bar', 'baz');
   *
   * @name all
   * @api public
   */

  Assertion.addProperty('all', function () {
    flag(this, 'all', true);
    flag(this, 'any', false);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Promise).to.be.a('promise');
   *     expect(new Float32Array()).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   *     // es6 overrides
   *     expect({[Symbol.toStringTag]:()=>'foo'}).to.be.a('foo');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contains` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var expected = false;
    if (_.type(obj) === 'array' && _.type(val) === 'object') {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === 'object') {
      if (!flag(this, 'negate')) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {};
      for (var k in val) subset[k] = obj[k];
      expected = _.eql(subset, val);
    } else {
      expected = obj && ~obj.indexOf(val);
    }
    this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
  Assertion.addChainableMethod('includes', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everthing').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).to.not.be.null;
   *
   * @name null
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .NaN
   * Asserts that the target is `NaN`.
   *
   *     expect('foo').to.be.NaN;
   *     expect(4).not.to.be.NaN;
   *
   * @name NaN
   * @api public
   */

  Assertion.addProperty('NaN', function () {
    this.assert(
        isNaN(flag(this, 'object'))
        , 'expected #{this} to be NaN'
        , 'expected #{this} not to be NaN'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @api public
   */

  Assertion.addProperty('exist', function () {
    this.assert(
        null != flag(this, 'object')
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays and strings, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var obj = flag(this, 'object')
      , expected = obj;

    if (Array.isArray(obj) || 'string' === typeof object) {
      expected = obj.length;
    } else if (typeof obj === 'object') {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = Object.prototype.toString.call(obj);
    this.assert(
        '[object Arguments]' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , range = start + '..' + finish;
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };
   *
   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * Note that dots and bracket in `name` must be backslash-escaped when
   * the `deep` flag is set, while they must NOT be escaped when the `deep`
   * flag is not set.
   *
   *     // simple referencing
   *     var css = { '.link[target]': 42 };
   *     expect(css).to.have.property('.link[target]', 42);
   *
   *     // deep referencing
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @api public
   */

  Assertion.addMethod('property', function (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var isDeep = !!flag(this, 'deep')
      , descriptor = isDeep ? 'deep property ' : 'property '
      , negate = flag(this, 'negate')
      , obj = flag(this, 'object')
      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null
      , hasProperty = isDeep
        ? pathInfo.exists
        : _.hasProperty(name, obj)
      , value = isDeep
        ? pathInfo.value
        : obj[name];

    if (negate && arguments.length > 1) {
      if (undefined === value) {
        msg = (msg != null) ? msg + ': ' : '';
        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          hasProperty
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (arguments.length > 1) {
      this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    );
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, message]])
   *
   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.
   *
   *     expect('test').to.have.ownPropertyDescriptor('length');
   *     expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });
   *     expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });
   *     expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);
   *     expect('test').ownPropertyDescriptor('length').to.have.keys('value');
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} message _optional_
   * @api public
   */

  function assertOwnPropertyDescriptor (name, descriptor, msg) {
    if (typeof descriptor === 'string') {
      msg = descriptor;
      descriptor = null;
    }
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
    if (actualDescriptor && descriptor) {
      this.assert(
          _.eql(descriptor, actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)
        , descriptor
        , actualDescriptor
        , true
      );
    } else {
      this.assert(
          actualDescriptor
        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)
        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)
      );
    }
    flag(this, 'object', actualDescriptor);
  }

  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);

  /**
   * ### .length
   *
   * Sets the `doLength` flag later used as a chain precursor to a value
   * comparison for the `length` property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * *Deprecation notice:* Using `length` as an assertion will be deprecated
   * in version 2.4.0 and removed in 3.0.0. Code using the old style of
   * asserting for `length` property value using `length(value)` should be
   * switched to use `lengthOf(value)` instead.
   *
   * @name length
   * @api public
   */

  /**
   * ### .lengthOf(value[, message])
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.lengthOf(3);
   *     expect('foobar').to.have.lengthOf(6);
   *
   * @name lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).to.have.property('length');
    var len = obj.length;

    this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addMethod('lengthOf', assertLength);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @alias matches
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @api public
   */
  function assertMatch(re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  }

  Assertion.addMethod('match', assertMatch);
  Assertion.addMethod('matches', assertMatch);

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target contains any or all of the passed-in keys.
   * Use in combination with `any`, `all`, `contains`, or `have` will affect
   * what will pass.
   *
   * When used in conjunction with `any`, at least one key that is passed
   * in must exist in the target object. This is regardless whether or not
   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`
   * should be used in the assertion. If neither are used, the assertion is
   * defaulted to `all`.
   *
   * When both `all` and `contain` are used, the target object must have at
   * least all of the passed-in keys but may have more keys not listed.
   *
   * When both `all` and `have` are used, the target object must both contain
   * all of the passed-in keys AND the number of keys in the target object must
   * match the number of keys passed in (in other words, a target object must
   * have all and only all of the passed-in keys).
   *
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({'bar': 6});
   *
   *
   * @name keys
   * @alias key
   * @param {String...|Array|Object} keys
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , str
      , ok = true
      , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';

    switch (_.type(keys)) {
      case "array":
        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
        break;
      case "object":
        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
        keys = Object.keys(keys);
        break;
      default:
        keys = Array.prototype.slice.call(arguments);
    }

    if (!keys.length) throw new Error('keys required');

    var actual = Object.keys(obj)
      , expected = keys
      , len = keys.length
      , any = flag(this, 'any')
      , all = flag(this, 'all');

    if (!any && !all) {
      all = true;
    }

    // Has any
    if (any) {
      var intersection = expected.filter(function(key) {
        return ~actual.indexOf(key);
      });
      ok = intersection.length > 0;
    }

    // Has all
    if (all) {
      ok = keys.every(function(key){
        return ~actual.indexOf(key);
      });
      if (!flag(this, 'negate') && !flag(this, 'contains')) {
        ok = ok && keys.length == actual.length;
      }
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      if (all) {
        str = keys.join(', ') + ', and ' + last;
      }
      if (any) {
        str = keys.join(', ') + ', or ' + last;
      }
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
      , expected.slice(0).sort()
      , actual.sort()
      , true
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('function');

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor && constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === 'function') {
      name = constructor.prototype.name || constructor.name;
      if (name === 'Error' && constructor !== Error) {
        name = (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, 'object', err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, 'object', err);
          return this;
        }
      }

      // next, check message
      var message = 'error' === _.type(err) && "message" in err
        ? err.message
        : '' + err;

      if ((message != null) && errMsg && errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = ''
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' //_.inspect(desiredError)
          : 'an error';

    if (thrown) {
      actuallyGot = ' but #{act} was thrown'
    }

    this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, 'object', thrownError);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} message _optional_
   * @api public
   */

  function respondTo (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === _.type(obj) && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  }

  Assertion.addMethod('respondTo', respondTo);
  Assertion.addMethod('respondsTo', respondTo);

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} message _optional_
   * @api public
   */

  function satisfy (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(
        result
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , this.negate ? false : true
      , result
    );
  }
  
  Assertion.addMethod('satisfy', satisfy);
  Assertion.addMethod('satisfies', satisfy);

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('closeTo', function (expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj, msg).is.a('number');
    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {
      throw new Error('the arguments to closeTo must be numbers');
    }

    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  });

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj).to.be.an('array');
    new Assertion(subset).to.be.an('array');

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    if (flag(this, 'contains')) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    );
  });

  /**
   * ### .change(function)
   *
   * Asserts that a function changes an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 3 };
   *     var noChangeFn = function() { return 'foo' + 'bar'; }
   *     expect(fn).to.change(obj, 'val');
   *     expect(noChangFn).to.not.change(obj, 'val')
   *
   * @name change
   * @alias changes
   * @alias Change
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  function assertChanges (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      initial !== object[prop]
      , 'expected .' + prop + ' to change'
      , 'expected .' + prop + ' to not change'
    );
  }

  Assertion.addChainableMethod('change', assertChanges);
  Assertion.addChainableMethod('changes', assertChanges);

  /**
   * ### .increase(function)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     expect(fn).to.increase(obj, 'val');
   *
   * @name increase
   * @alias increases
   * @alias Increase
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  function assertIncreases (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial > 0
      , 'expected .' + prop + ' to increase'
      , 'expected .' + prop + ' to not increase'
    );
  }

  Assertion.addChainableMethod('increase', assertIncreases);
  Assertion.addChainableMethod('increases', assertIncreases);

  /**
   * ### .decrease(function)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     expect(fn).to.decrease(obj, 'val');
   *
   * @name decrease
   * @alias decreases
   * @alias Decrease
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  function assertDecreases (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial < 0
      , 'expected .' + prop + ' to decrease'
      , 'expected .' + prop + ' to not decrease'
    );
  }

  Assertion.addChainableMethod('decrease', assertDecreases);
  Assertion.addChainableMethod('decreases', assertDecreases);

  /**
   * ### .extensible
   *
   * Asserts that the target is extensible (can have new properties added to 
   * it).
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect({}).to.be.extensible;
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *
   * @name extensible
   * @api public
   */

  Assertion.addProperty('extensible', function() {
    var obj = flag(this, 'object');

    this.assert(
      Object.isExtensible(obj)
      , 'expected #{this} to be extensible'
      , 'expected #{this} to not be extensible'
    );
  });

  /**
   * ### .sealed
   *
   * Asserts that the target is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect({}).to.not.be.sealed;
   *
   * @name sealed
   * @api public
   */

  Assertion.addProperty('sealed', function() {
    var obj = flag(this, 'object');

    this.assert(
      Object.isSealed(obj)
      , 'expected #{this} to be sealed'
      , 'expected #{this} to not be sealed'
    );
  });

  /**
   * ### .frozen
   *
   * Asserts that the target is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect({}).to.not.be.frozen;
   *
   * @name frozen
   * @api public
   */

  Assertion.addProperty('frozen', function() {
    var obj = flag(this, 'object');

    this.assert(
      Object.isFrozen(obj)
      , 'expected #{this} to be frozen'
      , 'expected #{this} to not be frozen'
    );
  });

};

},{}],16:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.isOk = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg).to.be.above(abv);
  };

   /**
   * ### .isAbove(valueToCheck, valueToBeAbove, [message])
   *
   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`
   *
   *     assert.isAbove(5, 2, '5 is strictly greater than 2');
   *
   * @name isAbove
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAbove
   * @param {String} message
   * @api public
   */

  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg).to.be.below(blw);
  };

   /**
   * ### .isBelow(valueToCheck, valueToBeBelow, [message])
   *
   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`
   *
   *     assert.isBelow(3, 6, '3 is strictly less than 6');
   *
   * @name isBelow
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeBelow
   * @param {String} message
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is['true'];
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is['false'];
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isNaN
   * Asserts that value is NaN
   *
   *    assert.isNaN('foo', 'foo is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNaN = function (val, msg) {
    new Assertion(val, msg).to.be.NaN;
  };

  /**
   * ### .isNotNaN
   * Asserts that value is not NaN
   *
   *    assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */
  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg).not.to.be.NaN;
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object (as revealed by
   * `Object.prototype.toString`).
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object.
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('number');
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 5, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throws(fn, 'function throws a reference error');
   *     assert.throws(fn, /function throws a reference error/);
   *     assert.throws(fn, ReferenceError);
   *     assert.throws(fn, ReferenceError, 'function throws a reference error');
   *     assert.throws(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.throws = function (fn, errt, errs, msg) {
    if ('string' === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.throw(errt, errs);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if ('string' === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    var ok;
    switch(operator) {
      case '==':
        ok = val == val2;
        break;
      case '===':
        ok = val === val2;
        break;
      case '>':
        ok = val > val2;
        break;
      case '>=':
        ok = val >= val2;
        break;
      case '<':
        ok = val < val2;
        break;
      case '<=':
        ok = val <= val2;
        break;
      case '!=':
        ok = val != val2;
        break;
      case '!==':
        ok = val !== val2;
        break;
      default:
        throw new Error('Invalid operator "' + operator + '"');
    }
    var test = new Assertion(ok, msg);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.
   * Order is not taken into account.
   *
   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @api public
   */

  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.deep.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

   /**
   * ### .changes(function, object, property)
   *
   * Asserts that a function changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  assert.changes = function (fn, obj, prop) {
    new Assertion(fn).to.change(obj, prop);
  }

   /**
   * ### .doesNotChange(function, object, property)
   *
   * Asserts that a function does not changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { console.log('foo'); };
   *     assert.doesNotChange(fn, obj, 'val');
   *
   * @name doesNotChange
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  assert.doesNotChange = function (fn, obj, prop) {
    new Assertion(fn).to.not.change(obj, prop);
  }

   /**
   * ### .increases(function, object, property)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  assert.increases = function (fn, obj, prop) {
    new Assertion(fn).to.increase(obj, prop);
  }

   /**
   * ### .doesNotIncrease(function, object, property)
   *
   * Asserts that a function does not increase object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  assert.doesNotIncrease = function (fn, obj, prop) {
    new Assertion(fn).to.not.increase(obj, prop);
  }

   /**
   * ### .decreases(function, object, property)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  assert.decreases = function (fn, obj, prop) {
    new Assertion(fn).to.decrease(obj, prop);
  }

   /**
   * ### .doesNotDecrease(function, object, property)
   *
   * Asserts that a function does not decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  assert.doesNotDecrease = function (fn, obj, prop) {
    new Assertion(fn).to.not.decrease(obj, prop);
  }

  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @api public
   */

  assert.ifError = function (val) {
    if (val) {
      throw(val);
    }
  };

  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg).to.be.extensible;
  };

  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freese({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.extensible;
  };

  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg).to.be.sealed;
  };

  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.sealed;
  };

  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg).to.be.frozen;
  };

  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.frozen;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('isOk', 'ok')
  ('isNotOk', 'notOk')
  ('throws', 'throw')
  ('throws', 'Throw')
  ('isExtensible', 'extensible')
  ('isNotExtensible', 'notExtensible')
  ('isSealed', 'sealed')
  ('isNotSealed', 'notSealed')
  ('isFrozen', 'frozen')
  ('isNotFrozen', 'notFrozen');
};

},{}],17:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

  chai.expect.fail = function (actual, expected, message, operator) {
    message = message || 'expect.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, chai.expect.fail);
  };
};

},{}],18:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number || this instanceof Boolean ) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    /**
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      message = message || 'should.fail()';
      throw new chai.AssertionError(message, {
          actual: actual
        , expected: expected
        , operator: operator
      }, should.fail);
    };

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

},{}],19:[function(require,module,exports){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require('./transferFlags');
var flag = require('./flag');
var config = require('../config');

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = '__proto__' in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, 'ssfi');
          if (old_ssfi && config.includeStack === false)
            flag(this, 'ssfi', assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

},{"../config":14,"./flag":22,"./transferFlags":38}],20:[function(require,module,exports){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('../config');

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @name addMethod
 * @api public
 */
var flag = require('./flag');

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, 'ssfi');
    if (old_ssfi && config.includeStack === false)
      flag(this, 'ssfi', ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{"../config":14,"./flag":22}],21:[function(require,module,exports){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],22:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

},{}],23:[function(require,module,exports){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};

},{}],24:[function(require,module,exports){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

},{}],25:[function(require,module,exports){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag')
  , getActual = require('./getActual')
  , inspect = require('./inspect')
  , objDisplay = require('./objDisplay');

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  if(typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg
    .replace(/#{this}/g, objDisplay(val))
    .replace(/#{act}/g, objDisplay(actual))
    .replace(/#{exp}/g, objDisplay(expected));

  return flagMsg ? flagMsg + ': ' + msg : msg;
};

},{"./flag":22,"./getActual":23,"./inspect":32,"./objDisplay":33}],26:[function(require,module,exports){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match && match[1] ? match[1] : "";
};

},{}],27:[function(require,module,exports){
/*!
 * Chai - getPathInfo utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var hasProperty = require('./hasProperty');

/**
 * ### .getPathInfo(path, object)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} info
 * @name getPathInfo
 * @api public
 */

module.exports = function getPathInfo(path, obj) {
  var parsed = parsePath(path),
      last = parsed[parsed.length - 1];

  var info = {
    parent: parsed.length > 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: _getPathValue(parsed, obj)
  };
  info.exists = hasProperty(info.name, info.parent);

  return info;
};


/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/([^\\])\[/g, '$1.[')
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /^\[(\d+)\]$/
      , mArr = re.exec(value);
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value.replace(/\\([.\[\]])/g, '$1') };
  });
}


/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @param {Number} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj, index) {
  var tmp = obj
    , res;

  index = (index === undefined ? parsed.length : index);

  for (var i = 0, l = index; i < l; i++) {
    var part = parsed[i];
    if (tmp) {
      if ('undefined' !== typeof part.p)
        tmp = tmp[part.p];
      else if ('undefined' !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
}

},{"./hasProperty":30}],28:[function(require,module,exports){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

var getPathInfo = require('./getPathInfo');

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @name getPathValue
 * @api public
 */
module.exports = function(path, obj) {
  var info = getPathInfo(path, obj);
  return info.value;
}; 

},{"./getPathInfo":27}],29:[function(require,module,exports){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

},{}],30:[function(require,module,exports){
/*!
 * Chai - hasProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var type = require('type-detect');

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has
 * named property or numeric array index.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with natives
 * and null/undefined values.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty('str', obj);  // true
 *     hasProperty('constructor', obj);  // true
 *     hasProperty('bar', obj);  // false
 *     
 *     hasProperty('length', obj.str); // true
 *     hasProperty(1, obj.str);  // true
 *     hasProperty(5, obj.str);  // false
 *
 *     hasProperty('length', obj.arr);  // true
 *     hasProperty(2, obj.arr);  // true
 *     hasProperty(3, obj.arr);  // false
 *
 * @param {Objuect} object
 * @param {String|Number} name
 * @returns {Boolean} whether it exists
 * @name getPathInfo
 * @api public
 */

var literals = {
    'number': Number
  , 'string': String
};

module.exports = function hasProperty(name, obj) {
  var ot = type(obj);

  // Bad Object, obviously no props at all
  if(ot === 'null' || ot === 'undefined')
    return false;

  // The `in` operator does not work with certain literals
  // box these before the check
  if(literals[ot] && typeof obj !== 'object')
    obj = new literals[ot](obj);

  return name in obj;
};

},{"type-detect":44}],31:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require('./test');

/*!
 * type utility
 */

exports.type = require('type-detect');

/*!
 * message utility
 */

exports.getMessage = require('./getMessage');

/*!
 * actual utility
 */

exports.getActual = require('./getActual');

/*!
 * Inspect util
 */

exports.inspect = require('./inspect');

/*!
 * Object Display util
 */

exports.objDisplay = require('./objDisplay');

/*!
 * Flag utility
 */

exports.flag = require('./flag');

/*!
 * Flag transferring utility
 */

exports.transferFlags = require('./transferFlags');

/*!
 * Deep equal utility
 */

exports.eql = require('deep-eql');

/*!
 * Deep path value
 */

exports.getPathValue = require('./getPathValue');

/*!
 * Deep path info
 */

exports.getPathInfo = require('./getPathInfo');

/*!
 * Check if a property exists
 */

exports.hasProperty = require('./hasProperty');

/*!
 * Function name
 */

exports.getName = require('./getName');

/*!
 * add Property
 */

exports.addProperty = require('./addProperty');

/*!
 * add Method
 */

exports.addMethod = require('./addMethod');

/*!
 * overwrite Property
 */

exports.overwriteProperty = require('./overwriteProperty');

/*!
 * overwrite Method
 */

exports.overwriteMethod = require('./overwriteMethod');

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require('./addChainableMethod');

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require('./overwriteChainableMethod');


},{"./addChainableMethod":19,"./addMethod":20,"./addProperty":21,"./flag":22,"./getActual":23,"./getMessage":25,"./getName":26,"./getPathInfo":27,"./getPathValue":28,"./hasProperty":30,"./inspect":32,"./objDisplay":33,"./overwriteChainableMethod":34,"./overwriteMethod":35,"./overwriteProperty":36,"./test":37,"./transferFlags":38,"deep-eql":40,"type-detect":44}],32:[function(require,module,exports){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require('./getName');
var getProperties = require('./getProperties');
var getEnumerableProperties = require('./getEnumerableProperties');

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If this is a DOM element, try to get the outer HTML.
  if (isDOMElement(value)) {
    if ('outerHTML' in value) {
      return value.outerHTML;
      // This value does not have an outerHTML attribute,
      //   it could still be an XML element
    } else {
      // Attempt to serialize it
      try {
        if (document.xmlVersion) {
          var xmlSerializer = new XMLSerializer();
          return xmlSerializer.serializeToString(value);
        } else {
          // Firefox 11- do not support outerHTML
          //   It does, however, support innerHTML
          //   Use the following to render the element
          var ns = "http://www.w3.org/1999/xhtml";
          var container = document.createElementNS(ns, '_');

          container.appendChild(value.cloneNode(false));
          html = container.innerHTML
            .replace('><', '>' + value.innerHTML + '<');
          container.innerHTML = '';
          return html;
        }
      } catch (err) {
        // This could be a non-native DOM implementation,
        //   continue with the normal flow:
        //   printing the element as if it is an object.
      }
    }
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      var name = getName(value);
      var nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var name = getName(value);
    var nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      if (value === 0 && (1/value) === -Infinity) {
        return ctx.stylize('-0', 'number');
      }
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"./getEnumerableProperties":24,"./getName":26,"./getProperties":29}],33:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require('./inspect');
var config = require('../config');

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};

},{"../config":14,"./inspect":32}],34:[function(require,module,exports){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],35:[function(require,module,exports){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method && 'function' === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

},{}],36:[function(require,module,exports){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],37:[function(require,module,exports){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag');

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};

},{"./flag":22}],38:[function(require,module,exports){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @name transferFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};

},{}],39:[function(require,module,exports){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    this.stack = new Error().stack;
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],40:[function(require,module,exports){
module.exports = require('./lib/eql');

},{"./lib/eql":41}],41:[function(require,module,exports){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require('type-detect');

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require('buffer').Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if ('date' === type(a)) {
    return dateEqual(a, b);
  } else if ('regexp' === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if ('arguments' === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if (('object' !== type(a) && 'object' !== type(b))
  && ('array' !== type(a) && 'array' !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a && b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if ('date' !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if ('regexp' !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if ('arguments' !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i < a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null && a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i < m.length; i++) {
      if ((m[i][0] === a && m[i][1] === b)
      ||  (m[i][0] === b && m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

},{"buffer":2,"type-detect":42}],42:[function(require,module,exports){
module.exports = require('./lib/type');

},{"./lib/type":43}],43:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Array]': 'array'
  , '[object RegExp]': 'regexp'
  , '[object Function]': 'function'
  , '[object Arguments]': 'arguments'
  , '[object Date]': 'date'
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}],44:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./lib/type":45,"dup":42}],45:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */
var objectTypeRegexp = /^\[object (.*)\]$/;

function getType(obj) {
  var type = Object.prototype.toString.call(obj).match(objectTypeRegexp)[1].toLowerCase();
  // Let "new String('')" return 'object'
  if (typeof Promise === 'function' && obj instanceof Promise) return 'promise';
  // PhantomJS has type "DOMWindow" for null
  if (obj === null) return 'null';
  // PhantomJS has type "DOMWindow" for undefined
  if (obj === undefined) return 'undefined';
  return type;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library() {
  if (!(this instanceof Library)) return new Library();
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function(type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function(obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}],46:[function(require,module,exports){
"use strict";
(function(fixtures){
    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
        // NodeJS
        module.exports = fixtures;
    } else if (typeof define === 'function' && define.amd){
        define(function(){
            return fixtures;
        });
    } else{
        var global = (false || eval)('this');
        global.fixtures = fixtures;
    }

}(new function(){
        var fixturesCache = {};
        var self = this;

        self.containerId = 'js-fixtures';
        self.path = 'spec/javascripts/fixtures';
        self.window = function(){
            var iframe = document.getElementById(self.containerId);
            if (!iframe) return null;

            return iframe.contentWindow || iframe.contentDocument; 
        };
        self.body = function(){
            if (!self.window()) return null;

            var content = self.window().document.body.innerHTML;
            return content; 
        };
        self.load = function(html){
            var cb = typeof arguments[arguments.length - 1] === 'function' ? arguments[arguments.length -1] : null;
            addToContainer(self.read.apply(self, arguments), cb);
        };
        self.set = function(html){
            addToContainer(html);
        };
        self.cache = function(){
            self.read.apply(self, arguments);
        };
        self.sandbox = function(obj){
            addToContainer(objToHTML(obj));
        };
        self.read = function(){
            var htmlChunks = '';

            Array.prototype.slice.call(arguments, 0).forEach(function(argument){
                if (typeof argument === 'string') htmlChunks += getFixtureHtml(argument);
            });
            return htmlChunks;
        };
        self.clearCache = function(){
            fixturesCache = {};
        };
        self.cleanUp = function(){
            var iframe = document.getElementById(self.containerId);
            if(!iframe) return null;

            iframe.parentNode.removeChild(iframe);
        };
        var createContainer  = function(html){
            var cb = typeof arguments[arguments.length - 1] === 'function' ? arguments[arguments.length -1] : null;
            var iframe = document.createElement('iframe');
            iframe.setAttribute('id', self.containerId);
            iframe.style.opacity = 0;
            iframe.style.filter = 'alpha(0)';

            document.body.appendChild(iframe);
            var doc = iframe.contentWindow || iframe.contentDocument;
            doc = doc.document ? doc.document : doc;

            if (cb){
                var iframeReady = setInterval(function(){
                    if (doc.readyState === 'complete'){
                        clearInterval(iframeReady);
                        cb();
                    }
                }, 0);
            }

            doc.open();
            doc.defaultView.onerror = captureErrors;
            doc.write(html);
            doc.close();
        };
        var addToContainer = function(html, cb){
            var container = document.getElementById(self.containerId);
            if (!container) createContainer.apply(self, arguments);
            else self.window().document.body.innerHTML += html;
        };
        var captureErrors = function(){
            if (window.onerror){
                // Rewrite the message prefix to indicate that the error
                // occurred in the fixture.
                arguments[0] = arguments[0].replace(/^[^:]*/, "Uncaught fixture error");
                window.onerror.apply(window, arguments);
            }
            return true;
        };
        var getFixtureHtml = function(url){
            if (typeof fixturesCache[url] === 'undefined'){
                loadFixtureIntoCache(url);
            }
            return fixturesCache[url];
        };
        var loadFixtureIntoCache = function(relativeUrl){
            var url = makeFixtureUrl(relativeUrl);
            var request = new XMLHttpRequest();
            request.open('GET', url + '?' + new Date().getTime(), false);
            request.send(null);
            fixturesCache[relativeUrl] = request.responseText;
        };
        var makeFixtureUrl = function(relativeUrl){
            return self.path.match('/$') ? self.path + relativeUrl : self.path + '/' + relativeUrl;
        };
        var objToHTML = function(obj){
            var divElem = document.createElement('div'); 
            for (var key in obj){
                if (key === 'class'){ // IE < 9 compatibility
                    divElem.className = obj[key];
                    continue;
                }
                divElem.setAttribute(key, obj[key]);
            }
            return divElem.outerHTML;
        };
    }
));

},{}],47:[function(require,module,exports){
(function (process){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.nextTick()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected() {
            pendingCount--;
            if (pendingCount === 0) {
                deferred.reject(new Error(
                    "Can't get fulfillment value from any promise, all " +
                    "promises were rejected."
                ));
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'))

},{"_process":7}],48:[function(require,module,exports){
'use strict';

var randomFromSeed = require('./random/random-from-seed');

var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
var alphabet;
var previousSeed;

var shuffled;

function reset() {
    shuffled = false;
}

function setCharacters(_alphabet_) {
    if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
        }
        return;
    }

    if (_alphabet_ === alphabet) {
        return;
    }

    if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
    }

    var unique = _alphabet_.split('').filter(function(item, ind, arr){
       return ind !== arr.lastIndexOf(item);
    });

    if (unique.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
    }

    alphabet = _alphabet_;
    reset();
}

function characters(_alphabet_) {
    setCharacters(_alphabet_);
    return alphabet;
}

function setSeed(seed) {
    randomFromSeed.seed(seed);
    if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
    }
}

function shuffle() {
    if (!alphabet) {
        setCharacters(ORIGINAL);
    }

    var sourceArray = alphabet.split('');
    var targetArray = [];
    var r = randomFromSeed.nextValue();
    var characterIndex;

    while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join('');
}

function getShuffled() {
    if (shuffled) {
        return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
}

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
function lookup(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
}

module.exports = {
    characters: characters,
    seed: setSeed,
    lookup: lookup,
    shuffled: getShuffled
};

},{"./random/random-from-seed":54}],49:[function(require,module,exports){
'use strict';
var alphabet = require('./alphabet');

/**
 * Decode the id to get the version and worker
 * Mainly for debugging and testing.
 * @param id - the shortid-generated id.
 */
function decode(id) {
    var characters = alphabet.shuffled();
    return {
        version: characters.indexOf(id.substr(0, 1)) & 0x0f,
        worker: characters.indexOf(id.substr(1, 1)) & 0x0f
    };
}

module.exports = decode;

},{"./alphabet":48}],50:[function(require,module,exports){
'use strict';

var randomByte = require('./random/random-byte');

function encode(lookup, number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByte() );
        done = number < (Math.pow(16, loopCounter + 1 ) );
        loopCounter++;
    }
    return str;
}

module.exports = encode;

},{"./random/random-byte":53}],51:[function(require,module,exports){
'use strict';

var alphabet = require('./alphabet');
var encode = require('./encode');
var decode = require('./decode');
var isValid = require('./is-valid');

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
var REDUCE_TIME = 1426452414093;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
var version = 5;

// if you are using cluster or multiple servers use this to make each instance
// has a unique value for worker
// Note: I don't know if this is automatically set when using third
// party cluster solutions such as pm2.
var clusterWorkerId = require('./util/cluster-worker-id') || 0;

// Counter is used when shortid is called multiple times in one second.
var counter;

// Remember the last time shortid was called in case counter is needed.
var previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
function generate() {

    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

    if (seconds === previousSeconds) {
        counter++;
    } else {
        counter = 0;
        previousSeconds = seconds;
    }

    str = str + encode(alphabet.lookup, version);
    str = str + encode(alphabet.lookup, clusterWorkerId);
    if (counter > 0) {
        str = str + encode(alphabet.lookup, counter);
    }
    str = str + encode(alphabet.lookup, seconds);

    return str;
}


/**
 * Set the seed.
 * Highly recommended if you don't want people to try to figure out your id schema.
 * exposed as shortid.seed(int)
 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
 */
function seed(seedValue) {
    alphabet.seed(seedValue);
    return module.exports;
}

/**
 * Set the cluster worker or machine id
 * exposed as shortid.worker(int)
 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
 * returns shortid module so it can be chained.
 */
function worker(workerId) {
    clusterWorkerId = workerId;
    return module.exports;
}

/**
 *
 * sets new characters to use in the alphabet
 * returns the shuffled alphabet
 */
function characters(newCharacters) {
    if (newCharacters !== undefined) {
        alphabet.characters(newCharacters);
    }

    return alphabet.shuffled();
}


// Export all other functions as properties of the generate function
module.exports = generate;
module.exports.generate = generate;
module.exports.seed = seed;
module.exports.worker = worker;
module.exports.characters = characters;
module.exports.decode = decode;
module.exports.isValid = isValid;

},{"./alphabet":48,"./decode":49,"./encode":50,"./is-valid":52,"./util/cluster-worker-id":55}],52:[function(require,module,exports){
'use strict';
var alphabet = require('./alphabet');

function isShortId(id) {
    if (!id || typeof id !== 'string' || id.length < 6 ) {
        return false;
    }

    var characters = alphabet.characters();
    var invalidCharacters = id.split('').map(function(char){
        if (characters.indexOf(char) === -1) {
            return char;
        }
    }).join('').split('').join('');

    return invalidCharacters.length === 0;
}

module.exports = isShortId;

},{"./alphabet":48}],53:[function(require,module,exports){
'use strict';

var crypto = window.crypto || window.msCrypto; // IE 11 uses window.msCrypto

function randomByte() {
    if (!crypto || !crypto.getRandomValues) {
        return Math.floor(Math.random() * 256) & 0x30;
    }
    var dest = new Uint8Array(1);
    crypto.getRandomValues(dest);
    return dest[0] & 0x30;
}

module.exports = randomByte;

},{}],54:[function(require,module,exports){
'use strict';

// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

var seed = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
function getNextValue() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed/(233280.0);
}

function setSeed(_seed_) {
    seed = _seed_;
}

module.exports = {
    nextValue: getNextValue,
    seed: setSeed
};

},{}],55:[function(require,module,exports){
'use strict';

module.exports = 0;

},{}],56:[function(require,module,exports){
(function (sinonChai) {
    "use strict";

    // Module systems magic dance.

    /* istanbul ignore else */
    if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
        // NodeJS
        module.exports = sinonChai;
    } else if (typeof define === "function" && define.amd) {
        // AMD
        define(function () {
            return sinonChai;
        });
    } else {
        // Other environment (usually <script> tag): plug in to global chai instance directly.
        chai.use(sinonChai);
    }
}(function sinonChai(chai, utils) {
    "use strict";

    var slice = Array.prototype.slice;

    function isSpy(putativeSpy) {
        return typeof putativeSpy === "function" &&
               typeof putativeSpy.getCall === "function" &&
               typeof putativeSpy.calledWithExactly === "function";
    }

    function timesInWords(count) {
        return count === 1 ? "once" :
               count === 2 ? "twice" :
               count === 3 ? "thrice" :
               (count || 0) + " times";
    }

    function isCall(putativeCall) {
        return putativeCall && isSpy(putativeCall.proxy);
    }

    function assertCanWorkWith(assertion) {
        if (!isSpy(assertion._obj) && !isCall(assertion._obj)) {
            throw new TypeError(utils.inspect(assertion._obj) + " is not a spy or a call to a spy!");
        }
    }

    function getMessages(spy, action, nonNegatedSuffix, always, args) {
        var verbPhrase = always ? "always have " : "have ";
        nonNegatedSuffix = nonNegatedSuffix || "";
        if (isSpy(spy.proxy)) {
            spy = spy.proxy;
        }

        function printfArray(array) {
            return spy.printf.apply(spy, array);
        }

        return {
            affirmative: function () {
                return printfArray(["expected %n to " + verbPhrase + action + nonNegatedSuffix].concat(args));
            },
            negative: function () {
                return printfArray(["expected %n to not " + verbPhrase + action].concat(args));
            }
        };
    }

    function sinonProperty(name, action, nonNegatedSuffix) {
        utils.addProperty(chai.Assertion.prototype, name, function () {
            assertCanWorkWith(this);

            var messages = getMessages(this._obj, action, nonNegatedSuffix, false);
            this.assert(this._obj[name], messages.affirmative, messages.negative);
        });
    }

    function sinonPropertyAsBooleanMethod(name, action, nonNegatedSuffix) {
        utils.addMethod(chai.Assertion.prototype, name, function (arg) {
            assertCanWorkWith(this);

            var messages = getMessages(this._obj, action, nonNegatedSuffix, false, [timesInWords(arg)]);
            this.assert(this._obj[name] === arg, messages.affirmative, messages.negative);
        });
    }

    function createSinonMethodHandler(sinonName, action, nonNegatedSuffix) {
        return function () {
            assertCanWorkWith(this);

            var alwaysSinonMethod = "always" + sinonName[0].toUpperCase() + sinonName.substring(1);
            var shouldBeAlways = utils.flag(this, "always") && typeof this._obj[alwaysSinonMethod] === "function";
            var sinonMethod = shouldBeAlways ? alwaysSinonMethod : sinonName;

            var messages = getMessages(this._obj, action, nonNegatedSuffix, shouldBeAlways, slice.call(arguments));
            this.assert(this._obj[sinonMethod].apply(this._obj, arguments), messages.affirmative, messages.negative);
        };
    }

    function sinonMethodAsProperty(name, action, nonNegatedSuffix) {
        var handler = createSinonMethodHandler(name, action, nonNegatedSuffix);
        utils.addProperty(chai.Assertion.prototype, name, handler);
    }

    function exceptionalSinonMethod(chaiName, sinonName, action, nonNegatedSuffix) {
        var handler = createSinonMethodHandler(sinonName, action, nonNegatedSuffix);
        utils.addMethod(chai.Assertion.prototype, chaiName, handler);
    }

    function sinonMethod(name, action, nonNegatedSuffix) {
        exceptionalSinonMethod(name, name, action, nonNegatedSuffix);
    }

    utils.addProperty(chai.Assertion.prototype, "always", function () {
        utils.flag(this, "always", true);
    });

    sinonProperty("called", "been called", " at least once, but it was never called");
    sinonPropertyAsBooleanMethod("callCount", "been called exactly %1", ", but it was called %c%C");
    sinonProperty("calledOnce", "been called exactly once", ", but it was called %c%C");
    sinonProperty("calledTwice", "been called exactly twice", ", but it was called %c%C");
    sinonProperty("calledThrice", "been called exactly thrice", ", but it was called %c%C");
    sinonMethodAsProperty("calledWithNew", "been called with new");
    sinonMethod("calledBefore", "been called before %1");
    sinonMethod("calledAfter", "been called after %1");
    sinonMethod("calledOn", "been called with %1 as this", ", but it was called with %t instead");
    sinonMethod("calledWith", "been called with arguments %*", "%C");
    sinonMethod("calledWithExactly", "been called with exact arguments %*", "%C");
    sinonMethod("calledWithMatch", "been called with arguments matching %*", "%C");
    sinonMethod("returned", "returned %1");
    exceptionalSinonMethod("thrown", "threw", "thrown %1");
}));

},{}],57:[function(require,module,exports){
/**
 * Sinon core utilities. For internal use only.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
var sinon = (function () { // eslint-disable-line no-unused-vars
    "use strict";

    var sinonModule;
    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        sinonModule = module.exports = require("./sinon/util/core");
        require("./sinon/extend");
        require("./sinon/typeOf");
        require("./sinon/times_in_words");
        require("./sinon/spy");
        require("./sinon/call");
        require("./sinon/behavior");
        require("./sinon/stub");
        require("./sinon/mock");
        require("./sinon/collection");
        require("./sinon/assert");
        require("./sinon/sandbox");
        require("./sinon/test");
        require("./sinon/test_case");
        require("./sinon/match");
        require("./sinon/format");
        require("./sinon/log_error");
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require, module.exports, module);
        sinonModule = module.exports;
    } else {
        sinonModule = {};
    }

    return sinonModule;
}());

},{"./sinon/assert":58,"./sinon/behavior":59,"./sinon/call":60,"./sinon/collection":61,"./sinon/extend":62,"./sinon/format":63,"./sinon/log_error":64,"./sinon/match":65,"./sinon/mock":66,"./sinon/sandbox":67,"./sinon/spy":68,"./sinon/stub":69,"./sinon/test":70,"./sinon/test_case":71,"./sinon/times_in_words":72,"./sinon/typeOf":73,"./sinon/util/core":74}],58:[function(require,module,exports){
(function (global){
/**
 * @depend times_in_words.js
 * @depend util/core.js
 * @depend match.js
 * @depend format.js
 */
/**
 * Assertions matching the test spy retrieval interface.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal, global) {
    "use strict";

    var slice = Array.prototype.slice;

    function makeApi(sinon) {
        var assert;

        function verifyIsStub() {
            var method;

            for (var i = 0, l = arguments.length; i < l; ++i) {
                method = arguments[i];

                if (!method) {
                    assert.fail("fake is not a spy");
                }

                if (method.proxy && method.proxy.isSinonProxy) {
                    verifyIsStub(method.proxy);
                } else {
                    if (typeof method !== "function") {
                        assert.fail(method + " is not a function");
                    }

                    if (typeof method.getCall !== "function") {
                        assert.fail(method + " is not stubbed");
                    }
                }

            }
        }

        function failAssertion(object, msg) {
            object = object || global;
            var failMethod = object.fail || assert.fail;
            failMethod.call(object, msg);
        }

        function mirrorPropAsAssertion(name, method, message) {
            if (arguments.length === 2) {
                message = method;
                method = name;
            }

            assert[name] = function (fake) {
                verifyIsStub(fake);

                var args = slice.call(arguments, 1);
                var failed = false;

                if (typeof method === "function") {
                    failed = !method(fake);
                } else {
                    failed = typeof fake[method] === "function" ?
                        !fake[method].apply(fake, args) : !fake[method];
                }

                if (failed) {
                    failAssertion(this, (fake.printf || fake.proxy.printf).apply(fake, [message].concat(args)));
                } else {
                    assert.pass(name);
                }
            };
        }

        function exposedName(prefix, prop) {
            return !prefix || /^fail/.test(prop) ? prop :
                prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);
        }

        assert = {
            failException: "AssertError",

            fail: function fail(message) {
                var error = new Error(message);
                error.name = this.failException || assert.failException;

                throw error;
            },

            pass: function pass() {},

            callOrder: function assertCallOrder() {
                verifyIsStub.apply(null, arguments);
                var expected = "";
                var actual = "";

                if (!sinon.calledInOrder(arguments)) {
                    try {
                        expected = [].join.call(arguments, ", ");
                        var calls = slice.call(arguments);
                        var i = calls.length;
                        while (i) {
                            if (!calls[--i].called) {
                                calls.splice(i, 1);
                            }
                        }
                        actual = sinon.orderByFirstCall(calls).join(", ");
                    } catch (e) {
                        // If this fails, we'll just fall back to the blank string
                    }

                    failAssertion(this, "expected " + expected + " to be " +
                                "called in order but were called as " + actual);
                } else {
                    assert.pass("callOrder");
                }
            },

            callCount: function assertCallCount(method, count) {
                verifyIsStub(method);

                if (method.callCount !== count) {
                    var msg = "expected %n to be called " + sinon.timesInWords(count) +
                        " but was called %c%C";
                    failAssertion(this, method.printf(msg));
                } else {
                    assert.pass("callCount");
                }
            },

            expose: function expose(target, options) {
                if (!target) {
                    throw new TypeError("target is null or undefined");
                }

                var o = options || {};
                var prefix = typeof o.prefix === "undefined" && "assert" || o.prefix;
                var includeFail = typeof o.includeFail === "undefined" || !!o.includeFail;

                for (var method in this) {
                    if (method !== "expose" && (includeFail || !/^(fail)/.test(method))) {
                        target[exposedName(prefix, method)] = this[method];
                    }
                }

                return target;
            },

            match: function match(actual, expectation) {
                var matcher = sinon.match(expectation);
                if (matcher.test(actual)) {
                    assert.pass("match");
                } else {
                    var formatted = [
                        "expected value to match",
                        "    expected = " + sinon.format(expectation),
                        "    actual = " + sinon.format(actual)
                    ];

                    failAssertion(this, formatted.join("\n"));
                }
            }
        };

        mirrorPropAsAssertion("called", "expected %n to have been called at least once but was never called");
        mirrorPropAsAssertion("notCalled", function (spy) {
            return !spy.called;
        }, "expected %n to not have been called but was called %c%C");
        mirrorPropAsAssertion("calledOnce", "expected %n to be called once but was called %c%C");
        mirrorPropAsAssertion("calledTwice", "expected %n to be called twice but was called %c%C");
        mirrorPropAsAssertion("calledThrice", "expected %n to be called thrice but was called %c%C");
        mirrorPropAsAssertion("calledOn", "expected %n to be called with %1 as this but was called with %t");
        mirrorPropAsAssertion(
            "alwaysCalledOn",
            "expected %n to always be called with %1 as this but was called with %t"
        );
        mirrorPropAsAssertion("calledWithNew", "expected %n to be called with new");
        mirrorPropAsAssertion("alwaysCalledWithNew", "expected %n to always be called with new");
        mirrorPropAsAssertion("calledWith", "expected %n to be called with arguments %*%C");
        mirrorPropAsAssertion("calledWithMatch", "expected %n to be called with match %*%C");
        mirrorPropAsAssertion("alwaysCalledWith", "expected %n to always be called with arguments %*%C");
        mirrorPropAsAssertion("alwaysCalledWithMatch", "expected %n to always be called with match %*%C");
        mirrorPropAsAssertion("calledWithExactly", "expected %n to be called with exact arguments %*%C");
        mirrorPropAsAssertion("alwaysCalledWithExactly", "expected %n to always be called with exact arguments %*%C");
        mirrorPropAsAssertion("neverCalledWith", "expected %n to never be called with arguments %*%C");
        mirrorPropAsAssertion("neverCalledWithMatch", "expected %n to never be called with match %*%C");
        mirrorPropAsAssertion("threw", "%n did not throw exception%C");
        mirrorPropAsAssertion("alwaysThrew", "%n did not always throw exception%C");

        sinon.assert = assert;
        return assert;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./match");
        require("./format");
        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon, // eslint-disable-line no-undef
    typeof global !== "undefined" ? global : self
));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./format":63,"./match":65,"./util/core":74}],59:[function(require,module,exports){
(function (process){
/**
 * @depend util/core.js
 * @depend extend.js
 */
/**
 * Stub behavior
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @author Tim Fischbach (mail@timfischbach.de)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    var slice = Array.prototype.slice;
    var join = Array.prototype.join;
    var useLeftMostCallback = -1;
    var useRightMostCallback = -2;

    var nextTick = (function () {
        if (typeof process === "object" && typeof process.nextTick === "function") {
            return process.nextTick;
        }

        if (typeof setImmediate === "function") {
            return setImmediate;
        }

        return function (callback) {
            setTimeout(callback, 0);
        };
    })();

    function throwsException(error, message) {
        if (typeof error === "string") {
            this.exception = new Error(message || "");
            this.exception.name = error;
        } else if (!error) {
            this.exception = new Error("Error");
        } else {
            this.exception = error;
        }

        return this;
    }

    function getCallback(behavior, args) {
        var callArgAt = behavior.callArgAt;

        if (callArgAt >= 0) {
            return args[callArgAt];
        }

        var argumentList;

        if (callArgAt === useLeftMostCallback) {
            argumentList = args;
        }

        if (callArgAt === useRightMostCallback) {
            argumentList = slice.call(args).reverse();
        }

        var callArgProp = behavior.callArgProp;

        for (var i = 0, l = argumentList.length; i < l; ++i) {
            if (!callArgProp && typeof argumentList[i] === "function") {
                return argumentList[i];
            }

            if (callArgProp && argumentList[i] &&
                typeof argumentList[i][callArgProp] === "function") {
                return argumentList[i][callArgProp];
            }
        }

        return null;
    }

    function makeApi(sinon) {
        function getCallbackError(behavior, func, args) {
            if (behavior.callArgAt < 0) {
                var msg;

                if (behavior.callArgProp) {
                    msg = sinon.functionName(behavior.stub) +
                        " expected to yield to '" + behavior.callArgProp +
                        "', but no object with such a property was passed.";
                } else {
                    msg = sinon.functionName(behavior.stub) +
                        " expected to yield, but no callback was passed.";
                }

                if (args.length > 0) {
                    msg += " Received [" + join.call(args, ", ") + "]";
                }

                return msg;
            }

            return "argument at index " + behavior.callArgAt + " is not a function: " + func;
        }

        function callCallback(behavior, args) {
            if (typeof behavior.callArgAt === "number") {
                var func = getCallback(behavior, args);

                if (typeof func !== "function") {
                    throw new TypeError(getCallbackError(behavior, func, args));
                }

                if (behavior.callbackAsync) {
                    nextTick(function () {
                        func.apply(behavior.callbackContext, behavior.callbackArguments);
                    });
                } else {
                    func.apply(behavior.callbackContext, behavior.callbackArguments);
                }
            }
        }

        var proto = {
            create: function create(stub) {
                var behavior = sinon.extend({}, sinon.behavior);
                delete behavior.create;
                behavior.stub = stub;

                return behavior;
            },

            isPresent: function isPresent() {
                return (typeof this.callArgAt === "number" ||
                        this.exception ||
                        typeof this.returnArgAt === "number" ||
                        this.returnThis ||
                        this.returnValueDefined);
            },

            invoke: function invoke(context, args) {
                callCallback(this, args);

                if (this.exception) {
                    throw this.exception;
                } else if (typeof this.returnArgAt === "number") {
                    return args[this.returnArgAt];
                } else if (this.returnThis) {
                    return context;
                }

                return this.returnValue;
            },

            onCall: function onCall(index) {
                return this.stub.onCall(index);
            },

            onFirstCall: function onFirstCall() {
                return this.stub.onFirstCall();
            },

            onSecondCall: function onSecondCall() {
                return this.stub.onSecondCall();
            },

            onThirdCall: function onThirdCall() {
                return this.stub.onThirdCall();
            },

            withArgs: function withArgs(/* arguments */) {
                throw new Error(
                    "Defining a stub by invoking \"stub.onCall(...).withArgs(...)\" " +
                    "is not supported. Use \"stub.withArgs(...).onCall(...)\" " +
                    "to define sequential behavior for calls with certain arguments."
                );
            },

            callsArg: function callsArg(pos) {
                if (typeof pos !== "number") {
                    throw new TypeError("argument index is not number");
                }

                this.callArgAt = pos;
                this.callbackArguments = [];
                this.callbackContext = undefined;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            callsArgOn: function callsArgOn(pos, context) {
                if (typeof pos !== "number") {
                    throw new TypeError("argument index is not number");
                }
                if (typeof context !== "object") {
                    throw new TypeError("argument context is not an object");
                }

                this.callArgAt = pos;
                this.callbackArguments = [];
                this.callbackContext = context;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            callsArgWith: function callsArgWith(pos) {
                if (typeof pos !== "number") {
                    throw new TypeError("argument index is not number");
                }

                this.callArgAt = pos;
                this.callbackArguments = slice.call(arguments, 1);
                this.callbackContext = undefined;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            callsArgOnWith: function callsArgWith(pos, context) {
                if (typeof pos !== "number") {
                    throw new TypeError("argument index is not number");
                }
                if (typeof context !== "object") {
                    throw new TypeError("argument context is not an object");
                }

                this.callArgAt = pos;
                this.callbackArguments = slice.call(arguments, 2);
                this.callbackContext = context;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            yields: function () {
                this.callArgAt = useLeftMostCallback;
                this.callbackArguments = slice.call(arguments, 0);
                this.callbackContext = undefined;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            yieldsRight: function () {
                this.callArgAt = useRightMostCallback;
                this.callbackArguments = slice.call(arguments, 0);
                this.callbackContext = undefined;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            yieldsOn: function (context) {
                if (typeof context !== "object") {
                    throw new TypeError("argument context is not an object");
                }

                this.callArgAt = useLeftMostCallback;
                this.callbackArguments = slice.call(arguments, 1);
                this.callbackContext = context;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            yieldsTo: function (prop) {
                this.callArgAt = useLeftMostCallback;
                this.callbackArguments = slice.call(arguments, 1);
                this.callbackContext = undefined;
                this.callArgProp = prop;
                this.callbackAsync = false;

                return this;
            },

            yieldsToOn: function (prop, context) {
                if (typeof context !== "object") {
                    throw new TypeError("argument context is not an object");
                }

                this.callArgAt = useLeftMostCallback;
                this.callbackArguments = slice.call(arguments, 2);
                this.callbackContext = context;
                this.callArgProp = prop;
                this.callbackAsync = false;

                return this;
            },

            throws: throwsException,
            throwsException: throwsException,

            returns: function returns(value) {
                this.returnValue = value;
                this.returnValueDefined = true;
                this.exception = undefined;

                return this;
            },

            returnsArg: function returnsArg(pos) {
                if (typeof pos !== "number") {
                    throw new TypeError("argument index is not number");
                }

                this.returnArgAt = pos;

                return this;
            },

            returnsThis: function returnsThis() {
                this.returnThis = true;

                return this;
            }
        };

        function createAsyncVersion(syncFnName) {
            return function () {
                var result = this[syncFnName].apply(this, arguments);
                this.callbackAsync = true;
                return result;
            };
        }

        // create asynchronous versions of callsArg* and yields* methods
        for (var method in proto) {
            // need to avoid creating anotherasync versions of the newly added async methods
            if (proto.hasOwnProperty(method) && method.match(/^(callsArg|yields)/) && !method.match(/Async/)) {
                proto[method + "Async"] = createAsyncVersion(method);
            }
        }

        sinon.behavior = proto;
        return proto;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./extend");
        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

}).call(this,require('_process'))

},{"./extend":62,"./util/core":74,"_process":7}],60:[function(require,module,exports){
/**
  * @depend util/core.js
  * @depend match.js
  * @depend format.js
  */
/**
  * Spy calls
  *
  * @author Christian Johansen (christian@cjohansen.no)
  * @author Maximilian Antoni (mail@maxantoni.de)
  * @license BSD
  *
  * Copyright (c) 2010-2013 Christian Johansen
  * Copyright (c) 2013 Maximilian Antoni
  */
(function (sinonGlobal) {
    "use strict";

    var slice = Array.prototype.slice;

    function makeApi(sinon) {
        function throwYieldError(proxy, text, args) {
            var msg = sinon.functionName(proxy) + text;
            if (args.length) {
                msg += " Received [" + slice.call(args).join(", ") + "]";
            }
            throw new Error(msg);
        }

        var callProto = {
            calledOn: function calledOn(thisValue) {
                if (sinon.match && sinon.match.isMatcher(thisValue)) {
                    return thisValue.test(this.thisValue);
                }
                return this.thisValue === thisValue;
            },

            calledWith: function calledWith() {
                var l = arguments.length;
                if (l > this.args.length) {
                    return false;
                }
                for (var i = 0; i < l; i += 1) {
                    if (!sinon.deepEqual(arguments[i], this.args[i])) {
                        return false;
                    }
                }

                return true;
            },

            calledWithMatch: function calledWithMatch() {
                var l = arguments.length;
                if (l > this.args.length) {
                    return false;
                }
                for (var i = 0; i < l; i += 1) {
                    var actual = this.args[i];
                    var expectation = arguments[i];
                    if (!sinon.match || !sinon.match(expectation).test(actual)) {
                        return false;
                    }
                }
                return true;
            },

            calledWithExactly: function calledWithExactly() {
                return arguments.length === this.args.length &&
                    this.calledWith.apply(this, arguments);
            },

            notCalledWith: function notCalledWith() {
                return !this.calledWith.apply(this, arguments);
            },

            notCalledWithMatch: function notCalledWithMatch() {
                return !this.calledWithMatch.apply(this, arguments);
            },

            returned: function returned(value) {
                return sinon.deepEqual(value, this.returnValue);
            },

            threw: function threw(error) {
                if (typeof error === "undefined" || !this.exception) {
                    return !!this.exception;
                }

                return this.exception === error || this.exception.name === error;
            },

            calledWithNew: function calledWithNew() {
                return this.proxy.prototype && this.thisValue instanceof this.proxy;
            },

            calledBefore: function (other) {
                return this.callId < other.callId;
            },

            calledAfter: function (other) {
                return this.callId > other.callId;
            },

            callArg: function (pos) {
                this.args[pos]();
            },

            callArgOn: function (pos, thisValue) {
                this.args[pos].apply(thisValue);
            },

            callArgWith: function (pos) {
                this.callArgOnWith.apply(this, [pos, null].concat(slice.call(arguments, 1)));
            },

            callArgOnWith: function (pos, thisValue) {
                var args = slice.call(arguments, 2);
                this.args[pos].apply(thisValue, args);
            },

            "yield": function () {
                this.yieldOn.apply(this, [null].concat(slice.call(arguments, 0)));
            },

            yieldOn: function (thisValue) {
                var args = this.args;
                for (var i = 0, l = args.length; i < l; ++i) {
                    if (typeof args[i] === "function") {
                        args[i].apply(thisValue, slice.call(arguments, 1));
                        return;
                    }
                }
                throwYieldError(this.proxy, " cannot yield since no callback was passed.", args);
            },

            yieldTo: function (prop) {
                this.yieldToOn.apply(this, [prop, null].concat(slice.call(arguments, 1)));
            },

            yieldToOn: function (prop, thisValue) {
                var args = this.args;
                for (var i = 0, l = args.length; i < l; ++i) {
                    if (args[i] && typeof args[i][prop] === "function") {
                        args[i][prop].apply(thisValue, slice.call(arguments, 2));
                        return;
                    }
                }
                throwYieldError(this.proxy, " cannot yield to '" + prop +
                    "' since no callback was passed.", args);
            },

            getStackFrames: function () {
                // Omit the error message and the two top stack frames in sinon itself:
                return this.stack && this.stack.split("\n").slice(3);
            },

            toString: function () {
                var callStr = this.proxy.toString() + "(";
                var args = [];

                for (var i = 0, l = this.args.length; i < l; ++i) {
                    args.push(sinon.format(this.args[i]));
                }

                callStr = callStr + args.join(", ") + ")";

                if (typeof this.returnValue !== "undefined") {
                    callStr += " => " + sinon.format(this.returnValue);
                }

                if (this.exception) {
                    callStr += " !" + this.exception.name;

                    if (this.exception.message) {
                        callStr += "(" + this.exception.message + ")";
                    }
                }
                if (this.stack) {
                    callStr += this.getStackFrames()[0].replace(/^\s*(?:at\s+|@)?/, " at ");

                }

                return callStr;
            }
        };

        callProto.invokeCallback = callProto.yield;

        function createSpyCall(spy, thisValue, args, returnValue, exception, id, stack) {
            if (typeof id !== "number") {
                throw new TypeError("Call id is not a number");
            }
            var proxyCall = sinon.create(callProto);
            proxyCall.proxy = spy;
            proxyCall.thisValue = thisValue;
            proxyCall.args = args;
            proxyCall.returnValue = returnValue;
            proxyCall.exception = exception;
            proxyCall.callId = id;
            proxyCall.stack = stack;

            return proxyCall;
        }
        createSpyCall.toString = callProto.toString; // used by mocks

        sinon.spyCall = createSpyCall;
        return createSpyCall;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./match");
        require("./format");
        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./format":63,"./match":65,"./util/core":74}],61:[function(require,module,exports){
/**
 * @depend util/core.js
 * @depend spy.js
 * @depend stub.js
 * @depend mock.js
 */
/**
 * Collections of stubs, spies and mocks.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    var push = [].push;
    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function getFakes(fakeCollection) {
        if (!fakeCollection.fakes) {
            fakeCollection.fakes = [];
        }

        return fakeCollection.fakes;
    }

    function each(fakeCollection, method) {
        var fakes = getFakes(fakeCollection);

        for (var i = 0, l = fakes.length; i < l; i += 1) {
            if (typeof fakes[i][method] === "function") {
                fakes[i][method]();
            }
        }
    }

    function compact(fakeCollection) {
        var fakes = getFakes(fakeCollection);
        var i = 0;
        while (i < fakes.length) {
            fakes.splice(i, 1);
        }
    }

    function makeApi(sinon) {
        var collection = {
            verify: function resolve() {
                each(this, "verify");
            },

            restore: function restore() {
                each(this, "restore");
                compact(this);
            },

            reset: function restore() {
                each(this, "reset");
            },

            verifyAndRestore: function verifyAndRestore() {
                var exception;

                try {
                    this.verify();
                } catch (e) {
                    exception = e;
                }

                this.restore();

                if (exception) {
                    throw exception;
                }
            },

            add: function add(fake) {
                push.call(getFakes(this), fake);
                return fake;
            },

            spy: function spy() {
                return this.add(sinon.spy.apply(sinon, arguments));
            },

            stub: function stub(object, property, value) {
                if (property) {
                    var original = object[property];

                    if (typeof original !== "function") {
                        if (!hasOwnProperty.call(object, property)) {
                            throw new TypeError("Cannot stub non-existent own property " + property);
                        }

                        object[property] = value;

                        return this.add({
                            restore: function () {
                                object[property] = original;
                            }
                        });
                    }
                }
                if (!property && !!object && typeof object === "object") {
                    var stubbedObj = sinon.stub.apply(sinon, arguments);

                    for (var prop in stubbedObj) {
                        if (typeof stubbedObj[prop] === "function") {
                            this.add(stubbedObj[prop]);
                        }
                    }

                    return stubbedObj;
                }

                return this.add(sinon.stub.apply(sinon, arguments));
            },

            mock: function mock() {
                return this.add(sinon.mock.apply(sinon, arguments));
            },

            inject: function inject(obj) {
                var col = this;

                obj.spy = function () {
                    return col.spy.apply(col, arguments);
                };

                obj.stub = function () {
                    return col.stub.apply(col, arguments);
                };

                obj.mock = function () {
                    return col.mock.apply(col, arguments);
                };

                return obj;
            }
        };

        sinon.collection = collection;
        return collection;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./mock");
        require("./spy");
        require("./stub");
        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./mock":66,"./spy":68,"./stub":69,"./util/core":74}],62:[function(require,module,exports){
/**
 * @depend util/core.js
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {

        // Adapted from https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug
        var hasDontEnumBug = (function () {
            var obj = {
                constructor: function () {
                    return "0";
                },
                toString: function () {
                    return "1";
                },
                valueOf: function () {
                    return "2";
                },
                toLocaleString: function () {
                    return "3";
                },
                prototype: function () {
                    return "4";
                },
                isPrototypeOf: function () {
                    return "5";
                },
                propertyIsEnumerable: function () {
                    return "6";
                },
                hasOwnProperty: function () {
                    return "7";
                },
                length: function () {
                    return "8";
                },
                unique: function () {
                    return "9";
                }
            };

            var result = [];
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    result.push(obj[prop]());
                }
            }
            return result.join("") !== "0123456789";
        })();

        /* Public: Extend target in place with all (own) properties from sources in-order. Thus, last source will
         *         override properties in previous sources.
         *
         * target - The Object to extend
         * sources - Objects to copy properties from.
         *
         * Returns the extended target
         */
        function extend(target /*, sources */) {
            var sources = Array.prototype.slice.call(arguments, 1);
            var source, i, prop;

            for (i = 0; i < sources.length; i++) {
                source = sources[i];

                for (prop in source) {
                    if (source.hasOwnProperty(prop)) {
                        target[prop] = source[prop];
                    }
                }

                // Make sure we copy (own) toString method even when in JScript with DontEnum bug
                // See https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug
                if (hasDontEnumBug && source.hasOwnProperty("toString") && source.toString !== target.toString) {
                    target.toString = source.toString;
                }
            }

            return target;
        }

        sinon.extend = extend;
        return sinon.extend;
    }

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        module.exports = makeApi(sinon);
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./util/core":74}],63:[function(require,module,exports){
/**
 * @depend util/core.js
 */
/**
 * Format functions
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2014 Christian Johansen
 */
(function (sinonGlobal, formatio) {
    "use strict";

    function makeApi(sinon) {
        function valueFormatter(value) {
            return "" + value;
        }

        function getFormatioFormatter() {
            var formatter = formatio.configure({
                    quoteStrings: false,
                    limitChildrenCount: 250
                });

            function format() {
                return formatter.ascii.apply(formatter, arguments);
            }

            return format;
        }

        function getNodeFormatter() {
            try {
                var util = require("util");
            } catch (e) {
                /* Node, but no util module - would be very old, but better safe than sorry */
            }

            function format(v) {
                var isObjectWithNativeToString = typeof v === "object" && v.toString === Object.prototype.toString;
                return isObjectWithNativeToString ? util.inspect(v) : v;
            }

            return util ? format : valueFormatter;
        }

        var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
        var formatter;

        if (isNode) {
            try {
                formatio = require("formatio");
            }
            catch (e) {} // eslint-disable-line no-empty
        }

        if (formatio) {
            formatter = getFormatioFormatter();
        } else if (isNode) {
            formatter = getNodeFormatter();
        } else {
            formatter = valueFormatter;
        }

        sinon.format = formatter;
        return sinon.format;
    }

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        module.exports = makeApi(sinon);
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon, // eslint-disable-line no-undef
    typeof formatio === "object" && formatio // eslint-disable-line no-undef
));

},{"./util/core":74,"formatio":81,"util":9}],64:[function(require,module,exports){
/**
 * @depend util/core.js
 */
/**
 * Logs errors
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2014 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    // cache a reference to setTimeout, so that our reference won't be stubbed out
    // when using fake timers and errors will still get logged
    // https://github.com/cjohansen/Sinon.JS/issues/381
    var realSetTimeout = setTimeout;

    function makeApi(sinon) {

        function log() {}

        function logError(label, err) {
            var msg = label + " threw exception: ";

            sinon.log(msg + "[" + err.name + "] " + err.message);

            if (err.stack) {
                sinon.log(err.stack);
            }

            logError.setTimeout(function () {
                err.message = msg + err.message;
                throw err;
            }, 0);
        }

        // wrap realSetTimeout with something we can stub in tests
        logError.setTimeout = function (func, timeout) {
            realSetTimeout(func, timeout);
        };

        var exports = {};
        exports.log = sinon.log = log;
        exports.logError = sinon.logError = logError;

        return exports;
    }

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        module.exports = makeApi(sinon);
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./util/core":74}],65:[function(require,module,exports){
/**
 * @depend util/core.js
 * @depend typeOf.js
 */
/*jslint eqeqeq: false, onevar: false, plusplus: false*/
/*global module, require, sinon*/
/**
 * Match functions
 *
 * @author Maximilian Antoni (mail@maxantoni.de)
 * @license BSD
 *
 * Copyright (c) 2012 Maximilian Antoni
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        function assertType(value, type, name) {
            var actual = sinon.typeOf(value);
            if (actual !== type) {
                throw new TypeError("Expected type of " + name + " to be " +
                    type + ", but was " + actual);
            }
        }

        var matcher = {
            toString: function () {
                return this.message;
            }
        };

        function isMatcher(object) {
            return matcher.isPrototypeOf(object);
        }

        function matchObject(expectation, actual) {
            if (actual === null || actual === undefined) {
                return false;
            }
            for (var key in expectation) {
                if (expectation.hasOwnProperty(key)) {
                    var exp = expectation[key];
                    var act = actual[key];
                    if (isMatcher(exp)) {
                        if (!exp.test(act)) {
                            return false;
                        }
                    } else if (sinon.typeOf(exp) === "object") {
                        if (!matchObject(exp, act)) {
                            return false;
                        }
                    } else if (!sinon.deepEqual(exp, act)) {
                        return false;
                    }
                }
            }
            return true;
        }

        function match(expectation, message) {
            var m = sinon.create(matcher);
            var type = sinon.typeOf(expectation);
            switch (type) {
            case "object":
                if (typeof expectation.test === "function") {
                    m.test = function (actual) {
                        return expectation.test(actual) === true;
                    };
                    m.message = "match(" + sinon.functionName(expectation.test) + ")";
                    return m;
                }
                var str = [];
                for (var key in expectation) {
                    if (expectation.hasOwnProperty(key)) {
                        str.push(key + ": " + expectation[key]);
                    }
                }
                m.test = function (actual) {
                    return matchObject(expectation, actual);
                };
                m.message = "match(" + str.join(", ") + ")";
                break;
            case "number":
                m.test = function (actual) {
                    // we need type coercion here
                    return expectation == actual; // eslint-disable-line eqeqeq
                };
                break;
            case "string":
                m.test = function (actual) {
                    if (typeof actual !== "string") {
                        return false;
                    }
                    return actual.indexOf(expectation) !== -1;
                };
                m.message = "match(\"" + expectation + "\")";
                break;
            case "regexp":
                m.test = function (actual) {
                    if (typeof actual !== "string") {
                        return false;
                    }
                    return expectation.test(actual);
                };
                break;
            case "function":
                m.test = expectation;
                if (message) {
                    m.message = message;
                } else {
                    m.message = "match(" + sinon.functionName(expectation) + ")";
                }
                break;
            default:
                m.test = function (actual) {
                    return sinon.deepEqual(expectation, actual);
                };
            }
            if (!m.message) {
                m.message = "match(" + expectation + ")";
            }
            return m;
        }

        matcher.or = function (m2) {
            if (!arguments.length) {
                throw new TypeError("Matcher expected");
            } else if (!isMatcher(m2)) {
                m2 = match(m2);
            }
            var m1 = this;
            var or = sinon.create(matcher);
            or.test = function (actual) {
                return m1.test(actual) || m2.test(actual);
            };
            or.message = m1.message + ".or(" + m2.message + ")";
            return or;
        };

        matcher.and = function (m2) {
            if (!arguments.length) {
                throw new TypeError("Matcher expected");
            } else if (!isMatcher(m2)) {
                m2 = match(m2);
            }
            var m1 = this;
            var and = sinon.create(matcher);
            and.test = function (actual) {
                return m1.test(actual) && m2.test(actual);
            };
            and.message = m1.message + ".and(" + m2.message + ")";
            return and;
        };

        match.isMatcher = isMatcher;

        match.any = match(function () {
            return true;
        }, "any");

        match.defined = match(function (actual) {
            return actual !== null && actual !== undefined;
        }, "defined");

        match.truthy = match(function (actual) {
            return !!actual;
        }, "truthy");

        match.falsy = match(function (actual) {
            return !actual;
        }, "falsy");

        match.same = function (expectation) {
            return match(function (actual) {
                return expectation === actual;
            }, "same(" + expectation + ")");
        };

        match.typeOf = function (type) {
            assertType(type, "string", "type");
            return match(function (actual) {
                return sinon.typeOf(actual) === type;
            }, "typeOf(\"" + type + "\")");
        };

        match.instanceOf = function (type) {
            assertType(type, "function", "type");
            return match(function (actual) {
                return actual instanceof type;
            }, "instanceOf(" + sinon.functionName(type) + ")");
        };

        function createPropertyMatcher(propertyTest, messagePrefix) {
            return function (property, value) {
                assertType(property, "string", "property");
                var onlyProperty = arguments.length === 1;
                var message = messagePrefix + "(\"" + property + "\"";
                if (!onlyProperty) {
                    message += ", " + value;
                }
                message += ")";
                return match(function (actual) {
                    if (actual === undefined || actual === null ||
                            !propertyTest(actual, property)) {
                        return false;
                    }
                    return onlyProperty || sinon.deepEqual(value, actual[property]);
                }, message);
            };
        }

        match.has = createPropertyMatcher(function (actual, property) {
            if (typeof actual === "object") {
                return property in actual;
            }
            return actual[property] !== undefined;
        }, "has");

        match.hasOwn = createPropertyMatcher(function (actual, property) {
            return actual.hasOwnProperty(property);
        }, "hasOwn");

        match.bool = match.typeOf("boolean");
        match.number = match.typeOf("number");
        match.string = match.typeOf("string");
        match.object = match.typeOf("object");
        match.func = match.typeOf("function");
        match.array = match.typeOf("array");
        match.regexp = match.typeOf("regexp");
        match.date = match.typeOf("date");

        sinon.match = match;
        return match;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./typeOf");
        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./typeOf":73,"./util/core":74}],66:[function(require,module,exports){
/**
 * @depend times_in_words.js
 * @depend util/core.js
 * @depend call.js
 * @depend extend.js
 * @depend match.js
 * @depend spy.js
 * @depend stub.js
 * @depend format.js
 */
/**
 * Mock functions.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        var push = [].push;
        var match = sinon.match;

        function mock(object) {
            // if (typeof console !== undefined && console.warn) {
            //     console.warn("mock will be removed from Sinon.JS v2.0");
            // }

            if (!object) {
                return sinon.expectation.create("Anonymous mock");
            }

            return mock.create(object);
        }

        function each(collection, callback) {
            if (!collection) {
                return;
            }

            for (var i = 0, l = collection.length; i < l; i += 1) {
                callback(collection[i]);
            }
        }

        function arrayEquals(arr1, arr2, compareLength) {
            if (compareLength && (arr1.length !== arr2.length)) {
                return false;
            }

            for (var i = 0, l = arr1.length; i < l; i++) {
                if (!sinon.deepEqual(arr1[i], arr2[i])) {
                    return false;
                }
            }
            return true;
        }

        sinon.extend(mock, {
            create: function create(object) {
                if (!object) {
                    throw new TypeError("object is null");
                }

                var mockObject = sinon.extend({}, mock);
                mockObject.object = object;
                delete mockObject.create;

                return mockObject;
            },

            expects: function expects(method) {
                if (!method) {
                    throw new TypeError("method is falsy");
                }

                if (!this.expectations) {
                    this.expectations = {};
                    this.proxies = [];
                }

                if (!this.expectations[method]) {
                    this.expectations[method] = [];
                    var mockObject = this;

                    sinon.wrapMethod(this.object, method, function () {
                        return mockObject.invokeMethod(method, this, arguments);
                    });

                    push.call(this.proxies, method);
                }

                var expectation = sinon.expectation.create(method);
                push.call(this.expectations[method], expectation);

                return expectation;
            },

            restore: function restore() {
                var object = this.object;

                each(this.proxies, function (proxy) {
                    if (typeof object[proxy].restore === "function") {
                        object[proxy].restore();
                    }
                });
            },

            verify: function verify() {
                var expectations = this.expectations || {};
                var messages = [];
                var met = [];

                each(this.proxies, function (proxy) {
                    each(expectations[proxy], function (expectation) {
                        if (!expectation.met()) {
                            push.call(messages, expectation.toString());
                        } else {
                            push.call(met, expectation.toString());
                        }
                    });
                });

                this.restore();

                if (messages.length > 0) {
                    sinon.expectation.fail(messages.concat(met).join("\n"));
                } else if (met.length > 0) {
                    sinon.expectation.pass(messages.concat(met).join("\n"));
                }

                return true;
            },

            invokeMethod: function invokeMethod(method, thisValue, args) {
                var expectations = this.expectations && this.expectations[method] ? this.expectations[method] : [];
                var expectationsWithMatchingArgs = [];
                var currentArgs = args || [];
                var i, available;

                for (i = 0; i < expectations.length; i += 1) {
                    var expectedArgs = expectations[i].expectedArguments || [];
                    if (arrayEquals(expectedArgs, currentArgs, expectations[i].expectsExactArgCount)) {
                        expectationsWithMatchingArgs.push(expectations[i]);
                    }
                }

                for (i = 0; i < expectationsWithMatchingArgs.length; i += 1) {
                    if (!expectationsWithMatchingArgs[i].met() &&
                        expectationsWithMatchingArgs[i].allowsCall(thisValue, args)) {
                        return expectationsWithMatchingArgs[i].apply(thisValue, args);
                    }
                }

                var messages = [];
                var exhausted = 0;

                for (i = 0; i < expectationsWithMatchingArgs.length; i += 1) {
                    if (expectationsWithMatchingArgs[i].allowsCall(thisValue, args)) {
                        available = available || expectationsWithMatchingArgs[i];
                    } else {
                        exhausted += 1;
                    }
                }

                if (available && exhausted === 0) {
                    return available.apply(thisValue, args);
                }

                for (i = 0; i < expectations.length; i += 1) {
                    push.call(messages, "    " + expectations[i].toString());
                }

                messages.unshift("Unexpected call: " + sinon.spyCall.toString.call({
                    proxy: method,
                    args: args
                }));

                sinon.expectation.fail(messages.join("\n"));
            }
        });

        var times = sinon.timesInWords;
        var slice = Array.prototype.slice;

        function callCountInWords(callCount) {
            if (callCount === 0) {
                return "never called";
            }

            return "called " + times(callCount);
        }

        function expectedCallCountInWords(expectation) {
            var min = expectation.minCalls;
            var max = expectation.maxCalls;

            if (typeof min === "number" && typeof max === "number") {
                var str = times(min);

                if (min !== max) {
                    str = "at least " + str + " and at most " + times(max);
                }

                return str;
            }

            if (typeof min === "number") {
                return "at least " + times(min);
            }

            return "at most " + times(max);
        }

        function receivedMinCalls(expectation) {
            var hasMinLimit = typeof expectation.minCalls === "number";
            return !hasMinLimit || expectation.callCount >= expectation.minCalls;
        }

        function receivedMaxCalls(expectation) {
            if (typeof expectation.maxCalls !== "number") {
                return false;
            }

            return expectation.callCount === expectation.maxCalls;
        }

        function verifyMatcher(possibleMatcher, arg) {
            var isMatcher = match && match.isMatcher(possibleMatcher);

            return isMatcher && possibleMatcher.test(arg) || true;
        }

        sinon.expectation = {
            minCalls: 1,
            maxCalls: 1,

            create: function create(methodName) {
                var expectation = sinon.extend(sinon.stub.create(), sinon.expectation);
                delete expectation.create;
                expectation.method = methodName;

                return expectation;
            },

            invoke: function invoke(func, thisValue, args) {
                this.verifyCallAllowed(thisValue, args);

                return sinon.spy.invoke.apply(this, arguments);
            },

            atLeast: function atLeast(num) {
                if (typeof num !== "number") {
                    throw new TypeError("'" + num + "' is not number");
                }

                if (!this.limitsSet) {
                    this.maxCalls = null;
                    this.limitsSet = true;
                }

                this.minCalls = num;

                return this;
            },

            atMost: function atMost(num) {
                if (typeof num !== "number") {
                    throw new TypeError("'" + num + "' is not number");
                }

                if (!this.limitsSet) {
                    this.minCalls = null;
                    this.limitsSet = true;
                }

                this.maxCalls = num;

                return this;
            },

            never: function never() {
                return this.exactly(0);
            },

            once: function once() {
                return this.exactly(1);
            },

            twice: function twice() {
                return this.exactly(2);
            },

            thrice: function thrice() {
                return this.exactly(3);
            },

            exactly: function exactly(num) {
                if (typeof num !== "number") {
                    throw new TypeError("'" + num + "' is not a number");
                }

                this.atLeast(num);
                return this.atMost(num);
            },

            met: function met() {
                return !this.failed && receivedMinCalls(this);
            },

            verifyCallAllowed: function verifyCallAllowed(thisValue, args) {
                if (receivedMaxCalls(this)) {
                    this.failed = true;
                    sinon.expectation.fail(this.method + " already called " + times(this.maxCalls));
                }

                if ("expectedThis" in this && this.expectedThis !== thisValue) {
                    sinon.expectation.fail(this.method + " called with " + thisValue + " as thisValue, expected " +
                        this.expectedThis);
                }

                if (!("expectedArguments" in this)) {
                    return;
                }

                if (!args) {
                    sinon.expectation.fail(this.method + " received no arguments, expected " +
                        sinon.format(this.expectedArguments));
                }

                if (args.length < this.expectedArguments.length) {
                    sinon.expectation.fail(this.method + " received too few arguments (" + sinon.format(args) +
                        "), expected " + sinon.format(this.expectedArguments));
                }

                if (this.expectsExactArgCount &&
                    args.length !== this.expectedArguments.length) {
                    sinon.expectation.fail(this.method + " received too many arguments (" + sinon.format(args) +
                        "), expected " + sinon.format(this.expectedArguments));
                }

                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {

                    if (!verifyMatcher(this.expectedArguments[i], args[i])) {
                        sinon.expectation.fail(this.method + " received wrong arguments " + sinon.format(args) +
                            ", didn't match " + this.expectedArguments.toString());
                    }

                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {
                        sinon.expectation.fail(this.method + " received wrong arguments " + sinon.format(args) +
                            ", expected " + sinon.format(this.expectedArguments));
                    }
                }
            },

            allowsCall: function allowsCall(thisValue, args) {
                if (this.met() && receivedMaxCalls(this)) {
                    return false;
                }

                if ("expectedThis" in this && this.expectedThis !== thisValue) {
                    return false;
                }

                if (!("expectedArguments" in this)) {
                    return true;
                }

                args = args || [];

                if (args.length < this.expectedArguments.length) {
                    return false;
                }

                if (this.expectsExactArgCount &&
                    args.length !== this.expectedArguments.length) {
                    return false;
                }

                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {
                    if (!verifyMatcher(this.expectedArguments[i], args[i])) {
                        return false;
                    }

                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {
                        return false;
                    }
                }

                return true;
            },

            withArgs: function withArgs() {
                this.expectedArguments = slice.call(arguments);
                return this;
            },

            withExactArgs: function withExactArgs() {
                this.withArgs.apply(this, arguments);
                this.expectsExactArgCount = true;
                return this;
            },

            on: function on(thisValue) {
                this.expectedThis = thisValue;
                return this;
            },

            toString: function () {
                var args = (this.expectedArguments || []).slice();

                if (!this.expectsExactArgCount) {
                    push.call(args, "[...]");
                }

                var callStr = sinon.spyCall.toString.call({
                    proxy: this.method || "anonymous mock expectation",
                    args: args
                });

                var message = callStr.replace(", [...", "[, ...") + " " +
                    expectedCallCountInWords(this);

                if (this.met()) {
                    return "Expectation met: " + message;
                }

                return "Expected " + message + " (" +
                    callCountInWords(this.callCount) + ")";
            },

            verify: function verify() {
                if (!this.met()) {
                    sinon.expectation.fail(this.toString());
                } else {
                    sinon.expectation.pass(this.toString());
                }

                return true;
            },

            pass: function pass(message) {
                sinon.assert.pass(message);
            },

            fail: function fail(message) {
                var exception = new Error(message);
                exception.name = "ExpectationError";

                throw exception;
            }
        };

        sinon.mock = mock;
        return mock;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./times_in_words");
        require("./call");
        require("./extend");
        require("./match");
        require("./spy");
        require("./stub");
        require("./format");

        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./call":60,"./extend":62,"./format":63,"./match":65,"./spy":68,"./stub":69,"./times_in_words":72,"./util/core":74}],67:[function(require,module,exports){
/**
 * @depend util/core.js
 * @depend extend.js
 * @depend collection.js
 * @depend util/fake_timers.js
 * @depend util/fake_server_with_clock.js
 */
/**
 * Manages fake collections as well as fake utilities such as Sinon's
 * timers and fake XHR implementation in one convenient object.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        var push = [].push;

        function exposeValue(sandbox, config, key, value) {
            if (!value) {
                return;
            }

            if (config.injectInto && !(key in config.injectInto)) {
                config.injectInto[key] = value;
                sandbox.injectedKeys.push(key);
            } else {
                push.call(sandbox.args, value);
            }
        }

        function prepareSandboxFromConfig(config) {
            var sandbox = sinon.create(sinon.sandbox);

            if (config.useFakeServer) {
                if (typeof config.useFakeServer === "object") {
                    sandbox.serverPrototype = config.useFakeServer;
                }

                sandbox.useFakeServer();
            }

            if (config.useFakeTimers) {
                if (typeof config.useFakeTimers === "object") {
                    sandbox.useFakeTimers.apply(sandbox, config.useFakeTimers);
                } else {
                    sandbox.useFakeTimers();
                }
            }

            return sandbox;
        }

        sinon.sandbox = sinon.extend(sinon.create(sinon.collection), {
            useFakeTimers: function useFakeTimers() {
                this.clock = sinon.useFakeTimers.apply(sinon, arguments);

                return this.add(this.clock);
            },

            serverPrototype: sinon.fakeServer,

            useFakeServer: function useFakeServer() {
                var proto = this.serverPrototype || sinon.fakeServer;

                if (!proto || !proto.create) {
                    return null;
                }

                this.server = proto.create();
                return this.add(this.server);
            },

            inject: function (obj) {
                sinon.collection.inject.call(this, obj);

                if (this.clock) {
                    obj.clock = this.clock;
                }

                if (this.server) {
                    obj.server = this.server;
                    obj.requests = this.server.requests;
                }

                obj.match = sinon.match;

                return obj;
            },

            restore: function () {
                sinon.collection.restore.apply(this, arguments);
                this.restoreContext();
            },

            restoreContext: function () {
                if (this.injectedKeys) {
                    for (var i = 0, j = this.injectedKeys.length; i < j; i++) {
                        delete this.injectInto[this.injectedKeys[i]];
                    }
                    this.injectedKeys = [];
                }
            },

            create: function (config) {
                if (!config) {
                    return sinon.create(sinon.sandbox);
                }

                var sandbox = prepareSandboxFromConfig(config);
                sandbox.args = sandbox.args || [];
                sandbox.injectedKeys = [];
                sandbox.injectInto = config.injectInto;
                var prop,
                    value;
                var exposed = sandbox.inject({});

                if (config.properties) {
                    for (var i = 0, l = config.properties.length; i < l; i++) {
                        prop = config.properties[i];
                        value = exposed[prop] || prop === "sandbox" && sandbox;
                        exposeValue(sandbox, config, prop, value);
                    }
                } else {
                    exposeValue(sandbox, config, "sandbox", value);
                }

                return sandbox;
            },

            match: sinon.match
        });

        sinon.sandbox.useFakeXMLHttpRequest = sinon.sandbox.useFakeServer;

        return sinon.sandbox;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./extend");
        require("./util/fake_server_with_clock");
        require("./util/fake_timers");
        require("./collection");
        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./collection":61,"./extend":62,"./util/core":74,"./util/fake_server_with_clock":77,"./util/fake_timers":78}],68:[function(require,module,exports){
/**
  * @depend times_in_words.js
  * @depend util/core.js
  * @depend extend.js
  * @depend call.js
  * @depend format.js
  */
/**
  * Spy functions
  *
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
  * Copyright (c) 2010-2013 Christian Johansen
  */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        var push = Array.prototype.push;
        var slice = Array.prototype.slice;
        var callId = 0;

        function spy(object, property, types) {
            if (!property && typeof object === "function") {
                return spy.create(object);
            }

            if (!object && !property) {
                return spy.create(function () { });
            }

            if (types) {
                var methodDesc = sinon.getPropertyDescriptor(object, property);
                for (var i = 0; i < types.length; i++) {
                    methodDesc[types[i]] = spy.create(methodDesc[types[i]]);
                }
                return sinon.wrapMethod(object, property, methodDesc);
            }

            return sinon.wrapMethod(object, property, spy.create(object[property]));
        }

        function matchingFake(fakes, args, strict) {
            if (!fakes) {
                return undefined;
            }

            for (var i = 0, l = fakes.length; i < l; i++) {
                if (fakes[i].matches(args, strict)) {
                    return fakes[i];
                }
            }
        }

        function incrementCallCount() {
            this.called = true;
            this.callCount += 1;
            this.notCalled = false;
            this.calledOnce = this.callCount === 1;
            this.calledTwice = this.callCount === 2;
            this.calledThrice = this.callCount === 3;
        }

        function createCallProperties() {
            this.firstCall = this.getCall(0);
            this.secondCall = this.getCall(1);
            this.thirdCall = this.getCall(2);
            this.lastCall = this.getCall(this.callCount - 1);
        }

        var vars = "a,b,c,d,e,f,g,h,i,j,k,l";
        function createProxy(func, proxyLength) {
            // Retain the function length:
            var p;
            if (proxyLength) {
                eval("p = (function proxy(" + vars.substring(0, proxyLength * 2 - 1) + // eslint-disable-line no-eval
                    ") { return p.invoke(func, this, slice.call(arguments)); });");
            } else {
                p = function proxy() {
                    return p.invoke(func, this, slice.call(arguments));
                };
            }
            p.isSinonProxy = true;
            return p;
        }

        var uuid = 0;

        // Public API
        var spyApi = {
            reset: function () {
                if (this.invoking) {
                    var err = new Error("Cannot reset Sinon function while invoking it. " +
                                        "Move the call to .reset outside of the callback.");
                    err.name = "InvalidResetException";
                    throw err;
                }

                this.called = false;
                this.notCalled = true;
                this.calledOnce = false;
                this.calledTwice = false;
                this.calledThrice = false;
                this.callCount = 0;
                this.firstCall = null;
                this.secondCall = null;
                this.thirdCall = null;
                this.lastCall = null;
                this.args = [];
                this.returnValues = [];
                this.thisValues = [];
                this.exceptions = [];
                this.callIds = [];
                this.stacks = [];
                if (this.fakes) {
                    for (var i = 0; i < this.fakes.length; i++) {
                        this.fakes[i].reset();
                    }
                }

                return this;
            },

            create: function create(func, spyLength) {
                var name;

                if (typeof func !== "function") {
                    func = function () { };
                } else {
                    name = sinon.functionName(func);
                }

                if (!spyLength) {
                    spyLength = func.length;
                }

                var proxy = createProxy(func, spyLength);

                sinon.extend(proxy, spy);
                delete proxy.create;
                sinon.extend(proxy, func);

                proxy.reset();
                proxy.prototype = func.prototype;
                proxy.displayName = name || "spy";
                proxy.toString = sinon.functionToString;
                proxy.instantiateFake = sinon.spy.create;
                proxy.id = "spy#" + uuid++;

                return proxy;
            },

            invoke: function invoke(func, thisValue, args) {
                var matching = matchingFake(this.fakes, args);
                var exception, returnValue;

                incrementCallCount.call(this);
                push.call(this.thisValues, thisValue);
                push.call(this.args, args);
                push.call(this.callIds, callId++);

                // Make call properties available from within the spied function:
                createCallProperties.call(this);

                try {
                    this.invoking = true;

                    if (matching) {
                        returnValue = matching.invoke(func, thisValue, args);
                    } else {
                        returnValue = (this.func || func).apply(thisValue, args);
                    }

                    var thisCall = this.getCall(this.callCount - 1);
                    if (thisCall.calledWithNew() && typeof returnValue !== "object") {
                        returnValue = thisValue;
                    }
                } catch (e) {
                    exception = e;
                } finally {
                    delete this.invoking;
                }

                push.call(this.exceptions, exception);
                push.call(this.returnValues, returnValue);
                push.call(this.stacks, new Error().stack);

                // Make return value and exception available in the calls:
                createCallProperties.call(this);

                if (exception !== undefined) {
                    throw exception;
                }

                return returnValue;
            },

            named: function named(name) {
                this.displayName = name;
                return this;
            },

            getCall: function getCall(i) {
                if (i < 0 || i >= this.callCount) {
                    return null;
                }

                return sinon.spyCall(this, this.thisValues[i], this.args[i],
                                        this.returnValues[i], this.exceptions[i],
                                        this.callIds[i], this.stacks[i]);
            },

            getCalls: function () {
                var calls = [];
                var i;

                for (i = 0; i < this.callCount; i++) {
                    calls.push(this.getCall(i));
                }

                return calls;
            },

            calledBefore: function calledBefore(spyFn) {
                if (!this.called) {
                    return false;
                }

                if (!spyFn.called) {
                    return true;
                }

                return this.callIds[0] < spyFn.callIds[spyFn.callIds.length - 1];
            },

            calledAfter: function calledAfter(spyFn) {
                if (!this.called || !spyFn.called) {
                    return false;
                }

                return this.callIds[this.callCount - 1] > spyFn.callIds[spyFn.callCount - 1];
            },

            withArgs: function () {
                var args = slice.call(arguments);

                if (this.fakes) {
                    var match = matchingFake(this.fakes, args, true);

                    if (match) {
                        return match;
                    }
                } else {
                    this.fakes = [];
                }

                var original = this;
                var fake = this.instantiateFake();
                fake.matchingAguments = args;
                fake.parent = this;
                push.call(this.fakes, fake);

                fake.withArgs = function () {
                    return original.withArgs.apply(original, arguments);
                };

                for (var i = 0; i < this.args.length; i++) {
                    if (fake.matches(this.args[i])) {
                        incrementCallCount.call(fake);
                        push.call(fake.thisValues, this.thisValues[i]);
                        push.call(fake.args, this.args[i]);
                        push.call(fake.returnValues, this.returnValues[i]);
                        push.call(fake.exceptions, this.exceptions[i]);
                        push.call(fake.callIds, this.callIds[i]);
                    }
                }
                createCallProperties.call(fake);

                return fake;
            },

            matches: function (args, strict) {
                var margs = this.matchingAguments;

                if (margs.length <= args.length &&
                    sinon.deepEqual(margs, args.slice(0, margs.length))) {
                    return !strict || margs.length === args.length;
                }
            },

            printf: function (format) {
                var spyInstance = this;
                var args = slice.call(arguments, 1);
                var formatter;

                return (format || "").replace(/%(.)/g, function (match, specifyer) {
                    formatter = spyApi.formatters[specifyer];

                    if (typeof formatter === "function") {
                        return formatter.call(null, spyInstance, args);
                    } else if (!isNaN(parseInt(specifyer, 10))) {
                        return sinon.format(args[specifyer - 1]);
                    }

                    return "%" + specifyer;
                });
            }
        };

        function delegateToCalls(method, matchAny, actual, notCalled) {
            spyApi[method] = function () {
                if (!this.called) {
                    if (notCalled) {
                        return notCalled.apply(this, arguments);
                    }
                    return false;
                }

                var currentCall;
                var matches = 0;

                for (var i = 0, l = this.callCount; i < l; i += 1) {
                    currentCall = this.getCall(i);

                    if (currentCall[actual || method].apply(currentCall, arguments)) {
                        matches += 1;

                        if (matchAny) {
                            return true;
                        }
                    }
                }

                return matches === this.callCount;
            };
        }

        delegateToCalls("calledOn", true);
        delegateToCalls("alwaysCalledOn", false, "calledOn");
        delegateToCalls("calledWith", true);
        delegateToCalls("calledWithMatch", true);
        delegateToCalls("alwaysCalledWith", false, "calledWith");
        delegateToCalls("alwaysCalledWithMatch", false, "calledWithMatch");
        delegateToCalls("calledWithExactly", true);
        delegateToCalls("alwaysCalledWithExactly", false, "calledWithExactly");
        delegateToCalls("neverCalledWith", false, "notCalledWith", function () {
            return true;
        });
        delegateToCalls("neverCalledWithMatch", false, "notCalledWithMatch", function () {
            return true;
        });
        delegateToCalls("threw", true);
        delegateToCalls("alwaysThrew", false, "threw");
        delegateToCalls("returned", true);
        delegateToCalls("alwaysReturned", false, "returned");
        delegateToCalls("calledWithNew", true);
        delegateToCalls("alwaysCalledWithNew", false, "calledWithNew");
        delegateToCalls("callArg", false, "callArgWith", function () {
            throw new Error(this.toString() + " cannot call arg since it was not yet invoked.");
        });
        spyApi.callArgWith = spyApi.callArg;
        delegateToCalls("callArgOn", false, "callArgOnWith", function () {
            throw new Error(this.toString() + " cannot call arg since it was not yet invoked.");
        });
        spyApi.callArgOnWith = spyApi.callArgOn;
        delegateToCalls("yield", false, "yield", function () {
            throw new Error(this.toString() + " cannot yield since it was not yet invoked.");
        });
        // "invokeCallback" is an alias for "yield" since "yield" is invalid in strict mode.
        spyApi.invokeCallback = spyApi.yield;
        delegateToCalls("yieldOn", false, "yieldOn", function () {
            throw new Error(this.toString() + " cannot yield since it was not yet invoked.");
        });
        delegateToCalls("yieldTo", false, "yieldTo", function (property) {
            throw new Error(this.toString() + " cannot yield to '" + property +
                "' since it was not yet invoked.");
        });
        delegateToCalls("yieldToOn", false, "yieldToOn", function (property) {
            throw new Error(this.toString() + " cannot yield to '" + property +
                "' since it was not yet invoked.");
        });

        spyApi.formatters = {
            c: function (spyInstance) {
                return sinon.timesInWords(spyInstance.callCount);
            },

            n: function (spyInstance) {
                return spyInstance.toString();
            },

            C: function (spyInstance) {
                var calls = [];

                for (var i = 0, l = spyInstance.callCount; i < l; ++i) {
                    var stringifiedCall = "    " + spyInstance.getCall(i).toString();
                    if (/\n/.test(calls[i - 1])) {
                        stringifiedCall = "\n" + stringifiedCall;
                    }
                    push.call(calls, stringifiedCall);
                }

                return calls.length > 0 ? "\n" + calls.join("\n") : "";
            },

            t: function (spyInstance) {
                var objects = [];

                for (var i = 0, l = spyInstance.callCount; i < l; ++i) {
                    push.call(objects, sinon.format(spyInstance.thisValues[i]));
                }

                return objects.join(", ");
            },

            "*": function (spyInstance, args) {
                var formatted = [];

                for (var i = 0, l = args.length; i < l; ++i) {
                    push.call(formatted, sinon.format(args[i]));
                }

                return formatted.join(", ");
            }
        };

        sinon.extend(spy, spyApi);

        spy.spyCall = sinon.spyCall;
        sinon.spy = spy;

        return spy;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var core = require("./util/core");
        require("./call");
        require("./extend");
        require("./times_in_words");
        require("./format");
        module.exports = makeApi(core);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./call":60,"./extend":62,"./format":63,"./times_in_words":72,"./util/core":74}],69:[function(require,module,exports){
/**
 * @depend util/core.js
 * @depend extend.js
 * @depend spy.js
 * @depend behavior.js
 */
/**
 * Stub functions
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        function stub(object, property, func) {
            if (!!func && typeof func !== "function" && typeof func !== "object") {
                throw new TypeError("Custom stub should be a function or a property descriptor");
            }

            var wrapper,
                prop;

            if (func) {
                if (typeof func === "function") {
                    wrapper = sinon.spy && sinon.spy.create ? sinon.spy.create(func) : func;
                } else {
                    wrapper = func;
                    if (sinon.spy && sinon.spy.create) {
                        var types = sinon.objectKeys(wrapper);
                        for (var i = 0; i < types.length; i++) {
                            wrapper[types[i]] = sinon.spy.create(wrapper[types[i]]);
                        }
                    }
                }
            } else {
                var stubLength = 0;
                if (typeof object === "object" && typeof object[property] === "function") {
                    stubLength = object[property].length;
                }
                wrapper = stub.create(stubLength);
            }

            if (!object && typeof property === "undefined") {
                return sinon.stub.create();
            }

            if (typeof property === "undefined" && typeof object === "object") {
                for (prop in object) {
                    if (typeof sinon.getPropertyDescriptor(object, prop).value === "function") {
                        stub(object, prop);
                    }
                }

                return object;
            }

            return sinon.wrapMethod(object, property, wrapper);
        }


        /*eslint-disable no-use-before-define*/
        function getParentBehaviour(stubInstance) {
            return (stubInstance.parent && getCurrentBehavior(stubInstance.parent));
        }

        function getDefaultBehavior(stubInstance) {
            return stubInstance.defaultBehavior ||
                    getParentBehaviour(stubInstance) ||
                    sinon.behavior.create(stubInstance);
        }

        function getCurrentBehavior(stubInstance) {
            var behavior = stubInstance.behaviors[stubInstance.callCount - 1];
            return behavior && behavior.isPresent() ? behavior : getDefaultBehavior(stubInstance);
        }
        /*eslint-enable no-use-before-define*/

        var uuid = 0;

        var proto = {
            create: function create(stubLength) {
                var functionStub = function () {
                    return getCurrentBehavior(functionStub).invoke(this, arguments);
                };

                functionStub.id = "stub#" + uuid++;
                var orig = functionStub;
                functionStub = sinon.spy.create(functionStub, stubLength);
                functionStub.func = orig;

                sinon.extend(functionStub, stub);
                functionStub.instantiateFake = sinon.stub.create;
                functionStub.displayName = "stub";
                functionStub.toString = sinon.functionToString;

                functionStub.defaultBehavior = null;
                functionStub.behaviors = [];

                return functionStub;
            },

            resetBehavior: function () {
                var i;

                this.defaultBehavior = null;
                this.behaviors = [];

                delete this.returnValue;
                delete this.returnArgAt;
                this.returnThis = false;

                if (this.fakes) {
                    for (i = 0; i < this.fakes.length; i++) {
                        this.fakes[i].resetBehavior();
                    }
                }
            },

            onCall: function onCall(index) {
                if (!this.behaviors[index]) {
                    this.behaviors[index] = sinon.behavior.create(this);
                }

                return this.behaviors[index];
            },

            onFirstCall: function onFirstCall() {
                return this.onCall(0);
            },

            onSecondCall: function onSecondCall() {
                return this.onCall(1);
            },

            onThirdCall: function onThirdCall() {
                return this.onCall(2);
            }
        };

        function createBehavior(behaviorMethod) {
            return function () {
                this.defaultBehavior = this.defaultBehavior || sinon.behavior.create(this);
                this.defaultBehavior[behaviorMethod].apply(this.defaultBehavior, arguments);
                return this;
            };
        }

        for (var method in sinon.behavior) {
            if (sinon.behavior.hasOwnProperty(method) &&
                !proto.hasOwnProperty(method) &&
                method !== "create" &&
                method !== "withArgs" &&
                method !== "invoke") {
                proto[method] = createBehavior(method);
            }
        }

        sinon.extend(stub, proto);
        sinon.stub = stub;

        return stub;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var core = require("./util/core");
        require("./behavior");
        require("./spy");
        require("./extend");
        module.exports = makeApi(core);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./behavior":59,"./extend":62,"./spy":68,"./util/core":74}],70:[function(require,module,exports){
/**
 * @depend util/core.js
 * @depend sandbox.js
 */
/**
 * Test function, sandboxes fakes
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        var slice = Array.prototype.slice;

        function test(callback) {
            var type = typeof callback;

            if (type !== "function") {
                throw new TypeError("sinon.test needs to wrap a test function, got " + type);
            }

            function sinonSandboxedTest() {
                var config = sinon.getConfig(sinon.config);
                config.injectInto = config.injectIntoThis && this || config.injectInto;
                var sandbox = sinon.sandbox.create(config);
                var args = slice.call(arguments);
                var oldDone = args.length && args[args.length - 1];
                var exception, result;

                if (typeof oldDone === "function") {
                    args[args.length - 1] = function sinonDone(res) {
                        if (res) {
                            sandbox.restore();
                            throw exception;
                        } else {
                            sandbox.verifyAndRestore();
                        }
                        oldDone(res);
                    };
                }

                try {
                    result = callback.apply(this, args.concat(sandbox.args));
                } catch (e) {
                    exception = e;
                }

                if (typeof oldDone !== "function") {
                    if (typeof exception !== "undefined") {
                        sandbox.restore();
                        throw exception;
                    } else {
                        sandbox.verifyAndRestore();
                    }
                }

                return result;
            }

            if (callback.length) {
                return function sinonAsyncSandboxedTest(done) { // eslint-disable-line no-unused-vars
                    return sinonSandboxedTest.apply(this, arguments);
                };
            }

            return sinonSandboxedTest;
        }

        test.config = {
            injectIntoThis: true,
            injectInto: null,
            properties: ["spy", "stub", "mock", "clock", "server", "requests"],
            useFakeTimers: true,
            useFakeServer: true
        };

        sinon.test = test;
        return test;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var core = require("./util/core");
        require("./sandbox");
        module.exports = makeApi(core);
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require, module.exports, module);
    } else if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(typeof sinon === "object" && sinon || null)); // eslint-disable-line no-undef

},{"./sandbox":67,"./util/core":74}],71:[function(require,module,exports){
/**
 * @depend util/core.js
 * @depend test.js
 */
/**
 * Test case, sandboxes all test functions
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    function createTest(property, setUp, tearDown) {
        return function () {
            if (setUp) {
                setUp.apply(this, arguments);
            }

            var exception, result;

            try {
                result = property.apply(this, arguments);
            } catch (e) {
                exception = e;
            }

            if (tearDown) {
                tearDown.apply(this, arguments);
            }

            if (exception) {
                throw exception;
            }

            return result;
        };
    }

    function makeApi(sinon) {
        function testCase(tests, prefix) {
            if (!tests || typeof tests !== "object") {
                throw new TypeError("sinon.testCase needs an object with test functions");
            }

            prefix = prefix || "test";
            var rPrefix = new RegExp("^" + prefix);
            var methods = {};
            var setUp = tests.setUp;
            var tearDown = tests.tearDown;
            var testName,
                property,
                method;

            for (testName in tests) {
                if (tests.hasOwnProperty(testName) && !/^(setUp|tearDown)$/.test(testName)) {
                    property = tests[testName];

                    if (typeof property === "function" && rPrefix.test(testName)) {
                        method = property;

                        if (setUp || tearDown) {
                            method = createTest(property, setUp, tearDown);
                        }

                        methods[testName] = sinon.test(method);
                    } else {
                        methods[testName] = tests[testName];
                    }
                }
            }

            return methods;
        }

        sinon.testCase = testCase;
        return testCase;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var core = require("./util/core");
        require("./test");
        module.exports = makeApi(core);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./test":70,"./util/core":74}],72:[function(require,module,exports){
/**
 * @depend util/core.js
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {

        function timesInWords(count) {
            switch (count) {
                case 1:
                    return "once";
                case 2:
                    return "twice";
                case 3:
                    return "thrice";
                default:
                    return (count || 0) + " times";
            }
        }

        sinon.timesInWords = timesInWords;
        return sinon.timesInWords;
    }

    function loadDependencies(require, exports, module) {
        var core = require("./util/core");
        module.exports = makeApi(core);
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./util/core":74}],73:[function(require,module,exports){
/**
 * @depend util/core.js
 */
/**
 * Format functions
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2014 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        function typeOf(value) {
            if (value === null) {
                return "null";
            } else if (value === undefined) {
                return "undefined";
            }
            var string = Object.prototype.toString.call(value);
            return string.substring(8, string.length - 1).toLowerCase();
        }

        sinon.typeOf = typeOf;
        return sinon.typeOf;
    }

    function loadDependencies(require, exports, module) {
        var core = require("./util/core");
        module.exports = makeApi(core);
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./util/core":74}],74:[function(require,module,exports){
/**
 * @depend ../../sinon.js
 */
/**
 * Sinon core utilities. For internal use only.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    var div = typeof document !== "undefined" && document.createElement("div");
    var hasOwn = Object.prototype.hasOwnProperty;

    function isDOMNode(obj) {
        var success = false;

        try {
            obj.appendChild(div);
            success = div.parentNode === obj;
        } catch (e) {
            return false;
        } finally {
            try {
                obj.removeChild(div);
            } catch (e) {
                // Remove failed, not much we can do about that
            }
        }

        return success;
    }

    function isElement(obj) {
        return div && obj && obj.nodeType === 1 && isDOMNode(obj);
    }

    function isFunction(obj) {
        return typeof obj === "function" || !!(obj && obj.constructor && obj.call && obj.apply);
    }

    function isReallyNaN(val) {
        return typeof val === "number" && isNaN(val);
    }

    function mirrorProperties(target, source) {
        for (var prop in source) {
            if (!hasOwn.call(target, prop)) {
                target[prop] = source[prop];
            }
        }
    }

    function isRestorable(obj) {
        return typeof obj === "function" && typeof obj.restore === "function" && obj.restore.sinon;
    }

    // Cheap way to detect if we have ES5 support.
    var hasES5Support = "keys" in Object;

    function makeApi(sinon) {
        sinon.wrapMethod = function wrapMethod(object, property, method) {
            if (!object) {
                throw new TypeError("Should wrap property of object");
            }

            if (typeof method !== "function" && typeof method !== "object") {
                throw new TypeError("Method wrapper should be a function or a property descriptor");
            }

            function checkWrappedMethod(wrappedMethod) {
                var error;

                if (!isFunction(wrappedMethod)) {
                    error = new TypeError("Attempted to wrap " + (typeof wrappedMethod) + " property " +
                                        property + " as function");
                } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {
                    error = new TypeError("Attempted to wrap " + property + " which is already wrapped");
                } else if (wrappedMethod.calledBefore) {
                    var verb = wrappedMethod.returns ? "stubbed" : "spied on";
                    error = new TypeError("Attempted to wrap " + property + " which is already " + verb);
                }

                if (error) {
                    if (wrappedMethod && wrappedMethod.stackTrace) {
                        error.stack += "\n--------------\n" + wrappedMethod.stackTrace;
                    }
                    throw error;
                }
            }

            var error, wrappedMethod, i;

            // IE 8 does not support hasOwnProperty on the window object and Firefox has a problem
            // when using hasOwn.call on objects from other frames.
            var owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwn.call(object, property);

            if (hasES5Support) {
                var methodDesc = (typeof method === "function") ? {value: method} : method;
                var wrappedMethodDesc = sinon.getPropertyDescriptor(object, property);

                if (!wrappedMethodDesc) {
                    error = new TypeError("Attempted to wrap " + (typeof wrappedMethod) + " property " +
                                        property + " as function");
                } else if (wrappedMethodDesc.restore && wrappedMethodDesc.restore.sinon) {
                    error = new TypeError("Attempted to wrap " + property + " which is already wrapped");
                }
                if (error) {
                    if (wrappedMethodDesc && wrappedMethodDesc.stackTrace) {
                        error.stack += "\n--------------\n" + wrappedMethodDesc.stackTrace;
                    }
                    throw error;
                }

                var types = sinon.objectKeys(methodDesc);
                for (i = 0; i < types.length; i++) {
                    wrappedMethod = wrappedMethodDesc[types[i]];
                    checkWrappedMethod(wrappedMethod);
                }

                mirrorProperties(methodDesc, wrappedMethodDesc);
                for (i = 0; i < types.length; i++) {
                    mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]);
                }
                Object.defineProperty(object, property, methodDesc);
            } else {
                wrappedMethod = object[property];
                checkWrappedMethod(wrappedMethod);
                object[property] = method;
                method.displayName = property;
            }

            method.displayName = property;

            // Set up a stack trace which can be used later to find what line of
            // code the original method was created on.
            method.stackTrace = (new Error("Stack Trace for original")).stack;

            method.restore = function () {
                // For prototype properties try to reset by delete first.
                // If this fails (ex: localStorage on mobile safari) then force a reset
                // via direct assignment.
                if (!owned) {
                    // In some cases `delete` may throw an error
                    try {
                        delete object[property];
                    } catch (e) {} // eslint-disable-line no-empty
                    // For native code functions `delete` fails without throwing an error
                    // on Chrome < 43, PhantomJS, etc.
                } else if (hasES5Support) {
                    Object.defineProperty(object, property, wrappedMethodDesc);
                }

                // Use strict equality comparison to check failures then force a reset
                // via direct assignment.
                if (object[property] === method) {
                    object[property] = wrappedMethod;
                }
            };

            method.restore.sinon = true;

            if (!hasES5Support) {
                mirrorProperties(method, wrappedMethod);
            }

            return method;
        };

        sinon.create = function create(proto) {
            var F = function () {};
            F.prototype = proto;
            return new F();
        };

        sinon.deepEqual = function deepEqual(a, b) {
            if (sinon.match && sinon.match.isMatcher(a)) {
                return a.test(b);
            }

            if (typeof a !== "object" || typeof b !== "object") {
                return isReallyNaN(a) && isReallyNaN(b) || a === b;
            }

            if (isElement(a) || isElement(b)) {
                return a === b;
            }

            if (a === b) {
                return true;
            }

            if ((a === null && b !== null) || (a !== null && b === null)) {
                return false;
            }

            if (a instanceof RegExp && b instanceof RegExp) {
                return (a.source === b.source) && (a.global === b.global) &&
                    (a.ignoreCase === b.ignoreCase) && (a.multiline === b.multiline);
            }

            var aString = Object.prototype.toString.call(a);
            if (aString !== Object.prototype.toString.call(b)) {
                return false;
            }

            if (aString === "[object Date]") {
                return a.valueOf() === b.valueOf();
            }

            var prop;
            var aLength = 0;
            var bLength = 0;

            if (aString === "[object Array]" && a.length !== b.length) {
                return false;
            }

            for (prop in a) {
                if (a.hasOwnProperty(prop)) {
                    aLength += 1;

                    if (!(prop in b)) {
                        return false;
                    }

                    if (!deepEqual(a[prop], b[prop])) {
                        return false;
                    }
                }
            }

            for (prop in b) {
                if (b.hasOwnProperty(prop)) {
                    bLength += 1;
                }
            }

            return aLength === bLength;
        };

        sinon.functionName = function functionName(func) {
            var name = func.displayName || func.name;

            // Use function decomposition as a last resort to get function
            // name. Does not rely on function decomposition to work - if it
            // doesn't debugging will be slightly less informative
            // (i.e. toString will say 'spy' rather than 'myFunc').
            if (!name) {
                var matches = func.toString().match(/function ([^\s\(]+)/);
                name = matches && matches[1];
            }

            return name;
        };

        sinon.functionToString = function toString() {
            if (this.getCall && this.callCount) {
                var thisValue,
                    prop;
                var i = this.callCount;

                while (i--) {
                    thisValue = this.getCall(i).thisValue;

                    for (prop in thisValue) {
                        if (thisValue[prop] === this) {
                            return prop;
                        }
                    }
                }
            }

            return this.displayName || "sinon fake";
        };

        sinon.objectKeys = function objectKeys(obj) {
            if (obj !== Object(obj)) {
                throw new TypeError("sinon.objectKeys called on a non-object");
            }

            var keys = [];
            var key;
            for (key in obj) {
                if (hasOwn.call(obj, key)) {
                    keys.push(key);
                }
            }

            return keys;
        };

        sinon.getPropertyDescriptor = function getPropertyDescriptor(object, property) {
            var proto = object;
            var descriptor;

            while (proto && !(descriptor = Object.getOwnPropertyDescriptor(proto, property))) {
                proto = Object.getPrototypeOf(proto);
            }
            return descriptor;
        };

        sinon.getConfig = function (custom) {
            var config = {};
            custom = custom || {};
            var defaults = sinon.defaultConfig;

            for (var prop in defaults) {
                if (defaults.hasOwnProperty(prop)) {
                    config[prop] = custom.hasOwnProperty(prop) ? custom[prop] : defaults[prop];
                }
            }

            return config;
        };

        sinon.defaultConfig = {
            injectIntoThis: true,
            injectInto: null,
            properties: ["spy", "stub", "mock", "clock", "server", "requests"],
            useFakeTimers: true,
            useFakeServer: true
        };

        sinon.timesInWords = function timesInWords(count) {
            return count === 1 && "once" ||
                count === 2 && "twice" ||
                count === 3 && "thrice" ||
                (count || 0) + " times";
        };

        sinon.calledInOrder = function (spies) {
            for (var i = 1, l = spies.length; i < l; i++) {
                if (!spies[i - 1].calledBefore(spies[i]) || !spies[i].called) {
                    return false;
                }
            }

            return true;
        };

        sinon.orderByFirstCall = function (spies) {
            return spies.sort(function (a, b) {
                // uuid, won't ever be equal
                var aCall = a.getCall(0);
                var bCall = b.getCall(0);
                var aId = aCall && aCall.callId || -1;
                var bId = bCall && bCall.callId || -1;

                return aId < bId ? -1 : 1;
            });
        };

        sinon.createStubInstance = function (constructor) {
            if (typeof constructor !== "function") {
                throw new TypeError("The constructor should be a function.");
            }
            return sinon.stub(sinon.create(constructor.prototype));
        };

        sinon.restore = function (object) {
            if (object !== null && typeof object === "object") {
                for (var prop in object) {
                    if (isRestorable(object[prop])) {
                        object[prop].restore();
                    }
                }
            } else if (isRestorable(object)) {
                object.restore();
            }
        };

        return sinon;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports) {
        makeApi(exports);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{}],75:[function(require,module,exports){
/**
 * Minimal Event interface implementation
 *
 * Original implementation by Sven Fuchs: https://gist.github.com/995028
 * Modifications and tests by Christian Johansen.
 *
 * @author Sven Fuchs (svenfuchs@artweb-design.de)
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2011 Sven Fuchs, Christian Johansen
 */
if (typeof sinon === "undefined") {
    this.sinon = {};
}

(function () {
    "use strict";

    var push = [].push;

    function makeApi(sinon) {
        sinon.Event = function Event(type, bubbles, cancelable, target) {
            this.initEvent(type, bubbles, cancelable, target);
        };

        sinon.Event.prototype = {
            initEvent: function (type, bubbles, cancelable, target) {
                this.type = type;
                this.bubbles = bubbles;
                this.cancelable = cancelable;
                this.target = target;
            },

            stopPropagation: function () {},

            preventDefault: function () {
                this.defaultPrevented = true;
            }
        };

        sinon.ProgressEvent = function ProgressEvent(type, progressEventRaw, target) {
            this.initEvent(type, false, false, target);
            this.loaded = progressEventRaw.loaded || null;
            this.total = progressEventRaw.total || null;
            this.lengthComputable = !!progressEventRaw.total;
        };

        sinon.ProgressEvent.prototype = new sinon.Event();

        sinon.ProgressEvent.prototype.constructor = sinon.ProgressEvent;

        sinon.CustomEvent = function CustomEvent(type, customData, target) {
            this.initEvent(type, false, false, target);
            this.detail = customData.detail || null;
        };

        sinon.CustomEvent.prototype = new sinon.Event();

        sinon.CustomEvent.prototype.constructor = sinon.CustomEvent;

        sinon.EventTarget = {
            addEventListener: function addEventListener(event, listener) {
                this.eventListeners = this.eventListeners || {};
                this.eventListeners[event] = this.eventListeners[event] || [];
                push.call(this.eventListeners[event], listener);
            },

            removeEventListener: function removeEventListener(event, listener) {
                var listeners = this.eventListeners && this.eventListeners[event] || [];

                for (var i = 0, l = listeners.length; i < l; ++i) {
                    if (listeners[i] === listener) {
                        return listeners.splice(i, 1);
                    }
                }
            },

            dispatchEvent: function dispatchEvent(event) {
                var type = event.type;
                var listeners = this.eventListeners && this.eventListeners[type] || [];

                for (var i = 0; i < listeners.length; i++) {
                    if (typeof listeners[i] === "function") {
                        listeners[i].call(this, event);
                    } else {
                        listeners[i].handleEvent(event);
                    }
                }

                return !!event.defaultPrevented;
            }
        };
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require) {
        var sinon = require("./core");
        makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require);
    } else {
        makeApi(sinon); // eslint-disable-line no-undef
    }
}());

},{"./core":74}],76:[function(require,module,exports){
/**
 * @depend fake_xdomain_request.js
 * @depend fake_xml_http_request.js
 * @depend ../format.js
 * @depend ../log_error.js
 */
/**
 * The Sinon "server" mimics a web server that receives requests from
 * sinon.FakeXMLHttpRequest and provides an API to respond to those requests,
 * both synchronously and asynchronously. To respond synchronuously, canned
 * answers have to be provided upfront.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function () {
    "use strict";

    var push = [].push;

    function responseArray(handler) {
        var response = handler;

        if (Object.prototype.toString.call(handler) !== "[object Array]") {
            response = [200, {}, handler];
        }

        if (typeof response[2] !== "string") {
            throw new TypeError("Fake server response body should be string, but was " +
                                typeof response[2]);
        }

        return response;
    }

    var wloc = typeof window !== "undefined" ? window.location : {};
    var rCurrLoc = new RegExp("^" + wloc.protocol + "//" + wloc.host);

    function matchOne(response, reqMethod, reqUrl) {
        var rmeth = response.method;
        var matchMethod = !rmeth || rmeth.toLowerCase() === reqMethod.toLowerCase();
        var url = response.url;
        var matchUrl = !url || url === reqUrl || (typeof url.test === "function" && url.test(reqUrl));

        return matchMethod && matchUrl;
    }

    function match(response, request) {
        var requestUrl = request.url;

        if (!/^https?:\/\//.test(requestUrl) || rCurrLoc.test(requestUrl)) {
            requestUrl = requestUrl.replace(rCurrLoc, "");
        }

        if (matchOne(response, this.getHTTPMethod(request), requestUrl)) {
            if (typeof response.response === "function") {
                var ru = response.url;
                var args = [request].concat(ru && typeof ru.exec === "function" ? ru.exec(requestUrl).slice(1) : []);
                return response.response.apply(response, args);
            }

            return true;
        }

        return false;
    }

    function makeApi(sinon) {
        sinon.fakeServer = {
            create: function (config) {
                var server = sinon.create(this);
                server.configure(config);
                if (!sinon.xhr.supportsCORS) {
                    this.xhr = sinon.useFakeXDomainRequest();
                } else {
                    this.xhr = sinon.useFakeXMLHttpRequest();
                }
                server.requests = [];

                this.xhr.onCreate = function (xhrObj) {
                    server.addRequest(xhrObj);
                };

                return server;
            },
            configure: function (config) {
                var whitelist = {
                    "autoRespond": true,
                    "autoRespondAfter": true,
                    "respondImmediately": true,
                    "fakeHTTPMethods": true
                };
                var setting;

                config = config || {};
                for (setting in config) {
                    if (whitelist.hasOwnProperty(setting) && config.hasOwnProperty(setting)) {
                        this[setting] = config[setting];
                    }
                }
            },
            addRequest: function addRequest(xhrObj) {
                var server = this;
                push.call(this.requests, xhrObj);

                xhrObj.onSend = function () {
                    server.handleRequest(this);

                    if (server.respondImmediately) {
                        server.respond();
                    } else if (server.autoRespond && !server.responding) {
                        setTimeout(function () {
                            server.responding = false;
                            server.respond();
                        }, server.autoRespondAfter || 10);

                        server.responding = true;
                    }
                };
            },

            getHTTPMethod: function getHTTPMethod(request) {
                if (this.fakeHTTPMethods && /post/i.test(request.method)) {
                    var matches = (request.requestBody || "").match(/_method=([^\b;]+)/);
                    return matches ? matches[1] : request.method;
                }

                return request.method;
            },

            handleRequest: function handleRequest(xhr) {
                if (xhr.async) {
                    if (!this.queue) {
                        this.queue = [];
                    }

                    push.call(this.queue, xhr);
                } else {
                    this.processRequest(xhr);
                }
            },

            log: function log(response, request) {
                var str;

                str = "Request:\n" + sinon.format(request) + "\n\n";
                str += "Response:\n" + sinon.format(response) + "\n\n";

                sinon.log(str);
            },

            respondWith: function respondWith(method, url, body) {
                if (arguments.length === 1 && typeof method !== "function") {
                    this.response = responseArray(method);
                    return;
                }

                if (!this.responses) {
                    this.responses = [];
                }

                if (arguments.length === 1) {
                    body = method;
                    url = method = null;
                }

                if (arguments.length === 2) {
                    body = url;
                    url = method;
                    method = null;
                }

                push.call(this.responses, {
                    method: method,
                    url: url,
                    response: typeof body === "function" ? body : responseArray(body)
                });
            },

            respond: function respond() {
                if (arguments.length > 0) {
                    this.respondWith.apply(this, arguments);
                }

                var queue = this.queue || [];
                var requests = queue.splice(0, queue.length);

                for (var i = 0; i < requests.length; i++) {
                    this.processRequest(requests[i]);
                }
            },

            processRequest: function processRequest(request) {
                try {
                    if (request.aborted) {
                        return;
                    }

                    var response = this.response || [404, {}, ""];

                    if (this.responses) {
                        for (var l = this.responses.length, i = l - 1; i >= 0; i--) {
                            if (match.call(this, this.responses[i], request)) {
                                response = this.responses[i].response;
                                break;
                            }
                        }
                    }

                    if (request.readyState !== 4) {
                        this.log(response, request);

                        request.respond(response[0], response[1], response[2]);
                    }
                } catch (e) {
                    sinon.logError("Fake server request processing", e);
                }
            },

            restore: function restore() {
                return this.xhr.restore && this.xhr.restore.apply(this.xhr, arguments);
            }
        };
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./core");
        require("./fake_xdomain_request");
        require("./fake_xml_http_request");
        require("../format");
        makeApi(sinon);
        module.exports = sinon;
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require, module.exports, module);
    } else {
        makeApi(sinon); // eslint-disable-line no-undef
    }
}());

},{"../format":63,"./core":74,"./fake_xdomain_request":79,"./fake_xml_http_request":80}],77:[function(require,module,exports){
/**
 * @depend fake_server.js
 * @depend fake_timers.js
 */
/**
 * Add-on for sinon.fakeServer that automatically handles a fake timer along with
 * the FakeXMLHttpRequest. The direct inspiration for this add-on is jQuery
 * 1.3.x, which does not use xhr object's onreadystatehandler at all - instead,
 * it polls the object for completion with setInterval. Dispite the direct
 * motivation, there is nothing jQuery-specific in this file, so it can be used
 * in any environment where the ajax implementation depends on setInterval or
 * setTimeout.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function () {
    "use strict";

    function makeApi(sinon) {
        function Server() {}
        Server.prototype = sinon.fakeServer;

        sinon.fakeServerWithClock = new Server();

        sinon.fakeServerWithClock.addRequest = function addRequest(xhr) {
            if (xhr.async) {
                if (typeof setTimeout.clock === "object") {
                    this.clock = setTimeout.clock;
                } else {
                    this.clock = sinon.useFakeTimers();
                    this.resetClock = true;
                }

                if (!this.longestTimeout) {
                    var clockSetTimeout = this.clock.setTimeout;
                    var clockSetInterval = this.clock.setInterval;
                    var server = this;

                    this.clock.setTimeout = function (fn, timeout) {
                        server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);

                        return clockSetTimeout.apply(this, arguments);
                    };

                    this.clock.setInterval = function (fn, timeout) {
                        server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);

                        return clockSetInterval.apply(this, arguments);
                    };
                }
            }

            return sinon.fakeServer.addRequest.call(this, xhr);
        };

        sinon.fakeServerWithClock.respond = function respond() {
            var returnVal = sinon.fakeServer.respond.apply(this, arguments);

            if (this.clock) {
                this.clock.tick(this.longestTimeout || 0);
                this.longestTimeout = 0;

                if (this.resetClock) {
                    this.clock.restore();
                    this.resetClock = false;
                }
            }

            return returnVal;
        };

        sinon.fakeServerWithClock.restore = function restore() {
            if (this.clock) {
                this.clock.restore();
            }

            return sinon.fakeServer.restore.apply(this, arguments);
        };
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require) {
        var sinon = require("./core");
        require("./fake_server");
        require("./fake_timers");
        makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require);
    } else {
        makeApi(sinon); // eslint-disable-line no-undef
    }
}());

},{"./core":74,"./fake_server":76,"./fake_timers":78}],78:[function(require,module,exports){
/**
 * Fake timer API
 * setTimeout
 * setInterval
 * clearTimeout
 * clearInterval
 * tick
 * reset
 * Date
 *
 * Inspired by jsUnitMockTimeOut from JsUnit
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function () {
    "use strict";

    function makeApi(s, lol) {
        /*global lolex */
        var llx = typeof lolex !== "undefined" ? lolex : lol;

        s.useFakeTimers = function () {
            var now;
            var methods = Array.prototype.slice.call(arguments);

            if (typeof methods[0] === "string") {
                now = 0;
            } else {
                now = methods.shift();
            }

            var clock = llx.install(now || 0, methods);
            clock.restore = clock.uninstall;
            return clock;
        };

        s.clock = {
            create: function (now) {
                return llx.createClock(now);
            }
        };

        s.timers = {
            setTimeout: setTimeout,
            clearTimeout: clearTimeout,
            setImmediate: (typeof setImmediate !== "undefined" ? setImmediate : undefined),
            clearImmediate: (typeof clearImmediate !== "undefined" ? clearImmediate : undefined),
            setInterval: setInterval,
            clearInterval: clearInterval,
            Date: Date
        };
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, epxorts, module, lolex) {
        var core = require("./core");
        makeApi(core, lolex);
        module.exports = core;
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require, module.exports, module, require("lolex"));
    } else {
        makeApi(sinon); // eslint-disable-line no-undef
    }
}());

},{"./core":74,"lolex":82}],79:[function(require,module,exports){
(function (global){
/**
 * @depend core.js
 * @depend ../extend.js
 * @depend event.js
 * @depend ../log_error.js
 */
/**
 * Fake XDomainRequest object
 */
if (typeof sinon === "undefined") {
    this.sinon = {};
}

// wrapper for global
(function (global) {
    "use strict";

    var xdr = { XDomainRequest: global.XDomainRequest };
    xdr.GlobalXDomainRequest = global.XDomainRequest;
    xdr.supportsXDR = typeof xdr.GlobalXDomainRequest !== "undefined";
    xdr.workingXDR = xdr.supportsXDR ? xdr.GlobalXDomainRequest : false;

    function makeApi(sinon) {
        sinon.xdr = xdr;

        function FakeXDomainRequest() {
            this.readyState = FakeXDomainRequest.UNSENT;
            this.requestBody = null;
            this.requestHeaders = {};
            this.status = 0;
            this.timeout = null;

            if (typeof FakeXDomainRequest.onCreate === "function") {
                FakeXDomainRequest.onCreate(this);
            }
        }

        function verifyState(x) {
            if (x.readyState !== FakeXDomainRequest.OPENED) {
                throw new Error("INVALID_STATE_ERR");
            }

            if (x.sendFlag) {
                throw new Error("INVALID_STATE_ERR");
            }
        }

        function verifyRequestSent(x) {
            if (x.readyState === FakeXDomainRequest.UNSENT) {
                throw new Error("Request not sent");
            }
            if (x.readyState === FakeXDomainRequest.DONE) {
                throw new Error("Request done");
            }
        }

        function verifyResponseBodyType(body) {
            if (typeof body !== "string") {
                var error = new Error("Attempted to respond to fake XDomainRequest with " +
                                    body + ", which is not a string.");
                error.name = "InvalidBodyException";
                throw error;
            }
        }

        sinon.extend(FakeXDomainRequest.prototype, sinon.EventTarget, {
            open: function open(method, url) {
                this.method = method;
                this.url = url;

                this.responseText = null;
                this.sendFlag = false;

                this.readyStateChange(FakeXDomainRequest.OPENED);
            },

            readyStateChange: function readyStateChange(state) {
                this.readyState = state;
                var eventName = "";
                switch (this.readyState) {
                case FakeXDomainRequest.UNSENT:
                    break;
                case FakeXDomainRequest.OPENED:
                    break;
                case FakeXDomainRequest.LOADING:
                    if (this.sendFlag) {
                        //raise the progress event
                        eventName = "onprogress";
                    }
                    break;
                case FakeXDomainRequest.DONE:
                    if (this.isTimeout) {
                        eventName = "ontimeout";
                    } else if (this.errorFlag || (this.status < 200 || this.status > 299)) {
                        eventName = "onerror";
                    } else {
                        eventName = "onload";
                    }
                    break;
                }

                // raising event (if defined)
                if (eventName) {
                    if (typeof this[eventName] === "function") {
                        try {
                            this[eventName]();
                        } catch (e) {
                            sinon.logError("Fake XHR " + eventName + " handler", e);
                        }
                    }
                }
            },

            send: function send(data) {
                verifyState(this);

                if (!/^(get|head)$/i.test(this.method)) {
                    this.requestBody = data;
                }
                this.requestHeaders["Content-Type"] = "text/plain;charset=utf-8";

                this.errorFlag = false;
                this.sendFlag = true;
                this.readyStateChange(FakeXDomainRequest.OPENED);

                if (typeof this.onSend === "function") {
                    this.onSend(this);
                }
            },

            abort: function abort() {
                this.aborted = true;
                this.responseText = null;
                this.errorFlag = true;

                if (this.readyState > sinon.FakeXDomainRequest.UNSENT && this.sendFlag) {
                    this.readyStateChange(sinon.FakeXDomainRequest.DONE);
                    this.sendFlag = false;
                }
            },

            setResponseBody: function setResponseBody(body) {
                verifyRequestSent(this);
                verifyResponseBodyType(body);

                var chunkSize = this.chunkSize || 10;
                var index = 0;
                this.responseText = "";

                do {
                    this.readyStateChange(FakeXDomainRequest.LOADING);
                    this.responseText += body.substring(index, index + chunkSize);
                    index += chunkSize;
                } while (index < body.length);

                this.readyStateChange(FakeXDomainRequest.DONE);
            },

            respond: function respond(status, contentType, body) {
                // content-type ignored, since XDomainRequest does not carry this
                // we keep the same syntax for respond(...) as for FakeXMLHttpRequest to ease
                // test integration across browsers
                this.status = typeof status === "number" ? status : 200;
                this.setResponseBody(body || "");
            },

            simulatetimeout: function simulatetimeout() {
                this.status = 0;
                this.isTimeout = true;
                // Access to this should actually throw an error
                this.responseText = undefined;
                this.readyStateChange(FakeXDomainRequest.DONE);
            }
        });

        sinon.extend(FakeXDomainRequest, {
            UNSENT: 0,
            OPENED: 1,
            LOADING: 3,
            DONE: 4
        });

        sinon.useFakeXDomainRequest = function useFakeXDomainRequest() {
            sinon.FakeXDomainRequest.restore = function restore(keepOnCreate) {
                if (xdr.supportsXDR) {
                    global.XDomainRequest = xdr.GlobalXDomainRequest;
                }

                delete sinon.FakeXDomainRequest.restore;

                if (keepOnCreate !== true) {
                    delete sinon.FakeXDomainRequest.onCreate;
                }
            };
            if (xdr.supportsXDR) {
                global.XDomainRequest = sinon.FakeXDomainRequest;
            }
            return sinon.FakeXDomainRequest;
        };

        sinon.FakeXDomainRequest = FakeXDomainRequest;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./core");
        require("../extend");
        require("./event");
        require("../log_error");
        makeApi(sinon);
        module.exports = sinon;
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require, module.exports, module);
    } else {
        makeApi(sinon); // eslint-disable-line no-undef
    }
})(typeof global !== "undefined" ? global : self);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../extend":62,"../log_error":64,"./core":74,"./event":75}],80:[function(require,module,exports){
(function (global){
/**
 * @depend core.js
 * @depend ../extend.js
 * @depend event.js
 * @depend ../log_error.js
 */
/**
 * Fake XMLHttpRequest object
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal, global) {
    "use strict";

    function getWorkingXHR(globalScope) {
        var supportsXHR = typeof globalScope.XMLHttpRequest !== "undefined";
        if (supportsXHR) {
            return globalScope.XMLHttpRequest;
        }

        var supportsActiveX = typeof globalScope.ActiveXObject !== "undefined";
        if (supportsActiveX) {
            return function () {
                return new globalScope.ActiveXObject("MSXML2.XMLHTTP.3.0");
            };
        }

        return false;
    }

    var supportsProgress = typeof ProgressEvent !== "undefined";
    var supportsCustomEvent = typeof CustomEvent !== "undefined";
    var supportsFormData = typeof FormData !== "undefined";
    var sinonXhr = { XMLHttpRequest: global.XMLHttpRequest };
    sinonXhr.GlobalXMLHttpRequest = global.XMLHttpRequest;
    sinonXhr.GlobalActiveXObject = global.ActiveXObject;
    sinonXhr.supportsActiveX = typeof sinonXhr.GlobalActiveXObject !== "undefined";
    sinonXhr.supportsXHR = typeof sinonXhr.GlobalXMLHttpRequest !== "undefined";
    sinonXhr.workingXHR = getWorkingXHR(global);
    sinonXhr.supportsCORS = sinonXhr.supportsXHR && "withCredentials" in (new sinonXhr.GlobalXMLHttpRequest());

    var unsafeHeaders = {
        "Accept-Charset": true,
        "Accept-Encoding": true,
        Connection: true,
        "Content-Length": true,
        Cookie: true,
        Cookie2: true,
        "Content-Transfer-Encoding": true,
        Date: true,
        Expect: true,
        Host: true,
        "Keep-Alive": true,
        Referer: true,
        TE: true,
        Trailer: true,
        "Transfer-Encoding": true,
        Upgrade: true,
        "User-Agent": true,
        Via: true
    };

    // An upload object is created for each
    // FakeXMLHttpRequest and allows upload
    // events to be simulated using uploadProgress
    // and uploadError.
    function UploadProgress() {
        this.eventListeners = {
            progress: [],
            load: [],
            abort: [],
            error: []
        };
    }

    UploadProgress.prototype.addEventListener = function addEventListener(event, listener) {
        this.eventListeners[event].push(listener);
    };

    UploadProgress.prototype.removeEventListener = function removeEventListener(event, listener) {
        var listeners = this.eventListeners[event] || [];

        for (var i = 0, l = listeners.length; i < l; ++i) {
            if (listeners[i] === listener) {
                return listeners.splice(i, 1);
            }
        }
    };

    UploadProgress.prototype.dispatchEvent = function dispatchEvent(event) {
        var listeners = this.eventListeners[event.type] || [];

        for (var i = 0, listener; (listener = listeners[i]) != null; i++) {
            listener(event);
        }
    };

    // Note that for FakeXMLHttpRequest to work pre ES5
    // we lose some of the alignment with the spec.
    // To ensure as close a match as possible,
    // set responseType before calling open, send or respond;
    function FakeXMLHttpRequest() {
        this.readyState = FakeXMLHttpRequest.UNSENT;
        this.requestHeaders = {};
        this.requestBody = null;
        this.status = 0;
        this.statusText = "";
        this.upload = new UploadProgress();
        this.responseType = "";
        this.response = "";
        if (sinonXhr.supportsCORS) {
            this.withCredentials = false;
        }

        var xhr = this;
        var events = ["loadstart", "load", "abort", "loadend"];

        function addEventListener(eventName) {
            xhr.addEventListener(eventName, function (event) {
                var listener = xhr["on" + eventName];

                if (listener && typeof listener === "function") {
                    listener.call(this, event);
                }
            });
        }

        for (var i = events.length - 1; i >= 0; i--) {
            addEventListener(events[i]);
        }

        if (typeof FakeXMLHttpRequest.onCreate === "function") {
            FakeXMLHttpRequest.onCreate(this);
        }
    }

    function verifyState(xhr) {
        if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {
            throw new Error("INVALID_STATE_ERR");
        }

        if (xhr.sendFlag) {
            throw new Error("INVALID_STATE_ERR");
        }
    }

    function getHeader(headers, header) {
        header = header.toLowerCase();

        for (var h in headers) {
            if (h.toLowerCase() === header) {
                return h;
            }
        }

        return null;
    }

    // filtering to enable a white-list version of Sinon FakeXhr,
    // where whitelisted requests are passed through to real XHR
    function each(collection, callback) {
        if (!collection) {
            return;
        }

        for (var i = 0, l = collection.length; i < l; i += 1) {
            callback(collection[i]);
        }
    }
    function some(collection, callback) {
        for (var index = 0; index < collection.length; index++) {
            if (callback(collection[index]) === true) {
                return true;
            }
        }
        return false;
    }
    // largest arity in XHR is 5 - XHR#open
    var apply = function (obj, method, args) {
        switch (args.length) {
        case 0: return obj[method]();
        case 1: return obj[method](args[0]);
        case 2: return obj[method](args[0], args[1]);
        case 3: return obj[method](args[0], args[1], args[2]);
        case 4: return obj[method](args[0], args[1], args[2], args[3]);
        case 5: return obj[method](args[0], args[1], args[2], args[3], args[4]);
        }
    };

    FakeXMLHttpRequest.filters = [];
    FakeXMLHttpRequest.addFilter = function addFilter(fn) {
        this.filters.push(fn);
    };
    var IE6Re = /MSIE 6/;
    FakeXMLHttpRequest.defake = function defake(fakeXhr, xhrArgs) {
        var xhr = new sinonXhr.workingXHR(); // eslint-disable-line new-cap

        each([
            "open",
            "setRequestHeader",
            "send",
            "abort",
            "getResponseHeader",
            "getAllResponseHeaders",
            "addEventListener",
            "overrideMimeType",
            "removeEventListener"
        ], function (method) {
            fakeXhr[method] = function () {
                return apply(xhr, method, arguments);
            };
        });

        var copyAttrs = function (args) {
            each(args, function (attr) {
                try {
                    fakeXhr[attr] = xhr[attr];
                } catch (e) {
                    if (!IE6Re.test(navigator.userAgent)) {
                        throw e;
                    }
                }
            });
        };

        var stateChange = function stateChange() {
            fakeXhr.readyState = xhr.readyState;
            if (xhr.readyState >= FakeXMLHttpRequest.HEADERS_RECEIVED) {
                copyAttrs(["status", "statusText"]);
            }
            if (xhr.readyState >= FakeXMLHttpRequest.LOADING) {
                copyAttrs(["responseText", "response"]);
            }
            if (xhr.readyState === FakeXMLHttpRequest.DONE) {
                copyAttrs(["responseXML"]);
            }
            if (fakeXhr.onreadystatechange) {
                fakeXhr.onreadystatechange.call(fakeXhr, { target: fakeXhr });
            }
        };

        if (xhr.addEventListener) {
            for (var event in fakeXhr.eventListeners) {
                if (fakeXhr.eventListeners.hasOwnProperty(event)) {

                    /*eslint-disable no-loop-func*/
                    each(fakeXhr.eventListeners[event], function (handler) {
                        xhr.addEventListener(event, handler);
                    });
                    /*eslint-enable no-loop-func*/
                }
            }
            xhr.addEventListener("readystatechange", stateChange);
        } else {
            xhr.onreadystatechange = stateChange;
        }
        apply(xhr, "open", xhrArgs);
    };
    FakeXMLHttpRequest.useFilters = false;

    function verifyRequestOpened(xhr) {
        if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {
            throw new Error("INVALID_STATE_ERR - " + xhr.readyState);
        }
    }

    function verifyRequestSent(xhr) {
        if (xhr.readyState === FakeXMLHttpRequest.DONE) {
            throw new Error("Request done");
        }
    }

    function verifyHeadersReceived(xhr) {
        if (xhr.async && xhr.readyState !== FakeXMLHttpRequest.HEADERS_RECEIVED) {
            throw new Error("No headers received");
        }
    }

    function verifyResponseBodyType(body) {
        if (typeof body !== "string") {
            var error = new Error("Attempted to respond to fake XMLHttpRequest with " +
                                 body + ", which is not a string.");
            error.name = "InvalidBodyException";
            throw error;
        }
    }

    FakeXMLHttpRequest.parseXML = function parseXML(text) {
        var xmlDoc;

        if (typeof DOMParser !== "undefined") {
            var parser = new DOMParser();
            xmlDoc = parser.parseFromString(text, "text/xml");
        } else {
            xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async = "false";
            xmlDoc.loadXML(text);
        }

        return xmlDoc;
    };

    FakeXMLHttpRequest.statusCodes = {
        100: "Continue",
        101: "Switching Protocols",
        200: "OK",
        201: "Created",
        202: "Accepted",
        203: "Non-Authoritative Information",
        204: "No Content",
        205: "Reset Content",
        206: "Partial Content",
        207: "Multi-Status",
        300: "Multiple Choice",
        301: "Moved Permanently",
        302: "Found",
        303: "See Other",
        304: "Not Modified",
        305: "Use Proxy",
        307: "Temporary Redirect",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Request Entity Too Large",
        414: "Request-URI Too Long",
        415: "Unsupported Media Type",
        416: "Requested Range Not Satisfiable",
        417: "Expectation Failed",
        422: "Unprocessable Entity",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Timeout",
        505: "HTTP Version Not Supported"
    };

    function makeApi(sinon) {
        sinon.xhr = sinonXhr;

        sinon.extend(FakeXMLHttpRequest.prototype, sinon.EventTarget, {
            async: true,

            open: function open(method, url, async, username, password) {
                this.method = method;
                this.url = url;
                this.async = typeof async === "boolean" ? async : true;
                this.username = username;
                this.password = password;
                this.responseText = null;
                this.response = this.responseType === "json" ? null : "";
                this.responseXML = null;
                this.requestHeaders = {};
                this.sendFlag = false;

                if (FakeXMLHttpRequest.useFilters === true) {
                    var xhrArgs = arguments;
                    var defake = some(FakeXMLHttpRequest.filters, function (filter) {
                        return filter.apply(this, xhrArgs);
                    });
                    if (defake) {
                        return FakeXMLHttpRequest.defake(this, arguments);
                    }
                }
                this.readyStateChange(FakeXMLHttpRequest.OPENED);
            },

            readyStateChange: function readyStateChange(state) {
                this.readyState = state;

                var readyStateChangeEvent = new sinon.Event("readystatechange", false, false, this);

                if (typeof this.onreadystatechange === "function") {
                    try {
                        this.onreadystatechange(readyStateChangeEvent);
                    } catch (e) {
                        sinon.logError("Fake XHR onreadystatechange handler", e);
                    }
                }

                switch (this.readyState) {
                    case FakeXMLHttpRequest.DONE:
                        if (supportsProgress) {
                            this.upload.dispatchEvent(new sinon.ProgressEvent("progress", {loaded: 100, total: 100}));
                            this.dispatchEvent(new sinon.ProgressEvent("progress", {loaded: 100, total: 100}));
                        }
                        this.upload.dispatchEvent(new sinon.Event("load", false, false, this));
                        this.dispatchEvent(new sinon.Event("load", false, false, this));
                        this.dispatchEvent(new sinon.Event("loadend", false, false, this));
                        break;
                }

                this.dispatchEvent(readyStateChangeEvent);
            },

            setRequestHeader: function setRequestHeader(header, value) {
                verifyState(this);

                if (unsafeHeaders[header] || /^(Sec-|Proxy-)/.test(header)) {
                    throw new Error("Refused to set unsafe header \"" + header + "\"");
                }

                if (this.requestHeaders[header]) {
                    this.requestHeaders[header] += "," + value;
                } else {
                    this.requestHeaders[header] = value;
                }
            },

            // Helps testing
            setResponseHeaders: function setResponseHeaders(headers) {
                verifyRequestOpened(this);
                this.responseHeaders = {};

                for (var header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        this.responseHeaders[header] = headers[header];
                    }
                }

                if (this.async) {
                    this.readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED);
                } else {
                    this.readyState = FakeXMLHttpRequest.HEADERS_RECEIVED;
                }
            },

            // Currently treats ALL data as a DOMString (i.e. no Document)
            send: function send(data) {
                verifyState(this);

                if (!/^(get|head)$/i.test(this.method)) {
                    var contentType = getHeader(this.requestHeaders, "Content-Type");
                    if (this.requestHeaders[contentType]) {
                        var value = this.requestHeaders[contentType].split(";");
                        this.requestHeaders[contentType] = value[0] + ";charset=utf-8";
                    } else if (supportsFormData && !(data instanceof FormData)) {
                        this.requestHeaders["Content-Type"] = "text/plain;charset=utf-8";
                    }

                    this.requestBody = data;
                }

                this.errorFlag = false;
                this.sendFlag = this.async;
                this.response = this.responseType === "json" ? null : "";
                this.readyStateChange(FakeXMLHttpRequest.OPENED);

                if (typeof this.onSend === "function") {
                    this.onSend(this);
                }

                this.dispatchEvent(new sinon.Event("loadstart", false, false, this));
            },

            abort: function abort() {
                this.aborted = true;
                this.responseText = null;
                this.response = this.responseType === "json" ? null : "";
                this.errorFlag = true;
                this.requestHeaders = {};
                this.responseHeaders = {};

                if (this.readyState > FakeXMLHttpRequest.UNSENT && this.sendFlag) {
                    this.readyStateChange(FakeXMLHttpRequest.DONE);
                    this.sendFlag = false;
                }

                this.readyState = FakeXMLHttpRequest.UNSENT;

                this.dispatchEvent(new sinon.Event("abort", false, false, this));

                this.upload.dispatchEvent(new sinon.Event("abort", false, false, this));

                if (typeof this.onerror === "function") {
                    this.onerror();
                }
            },

            getResponseHeader: function getResponseHeader(header) {
                if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {
                    return null;
                }

                if (/^Set-Cookie2?$/i.test(header)) {
                    return null;
                }

                header = getHeader(this.responseHeaders, header);

                return this.responseHeaders[header] || null;
            },

            getAllResponseHeaders: function getAllResponseHeaders() {
                if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {
                    return "";
                }

                var headers = "";

                for (var header in this.responseHeaders) {
                    if (this.responseHeaders.hasOwnProperty(header) &&
                        !/^Set-Cookie2?$/i.test(header)) {
                        headers += header + ": " + this.responseHeaders[header] + "\r\n";
                    }
                }

                return headers;
            },

            setResponseBody: function setResponseBody(body) {
                verifyRequestSent(this);
                verifyHeadersReceived(this);
                verifyResponseBodyType(body);

                var chunkSize = this.chunkSize || 10;
                var index = 0;
                this.responseText = "";

                do {
                    if (this.async) {
                        this.readyStateChange(FakeXMLHttpRequest.LOADING);
                    }

                    this.responseText += body.substring(index, index + chunkSize);
                    index += chunkSize;
                } while (index < body.length);

                var type = this.getResponseHeader("Content-Type");

                if (this.responseText &&
                    (!type || /(text\/xml)|(application\/xml)|(\+xml)/.test(type))) {
                    try {
                        this.responseXML = FakeXMLHttpRequest.parseXML(this.responseText);
                    } catch (e) {
                        // Unable to parse XML - no biggie
                    }
                }

                this.response = this.responseType === "json" ? JSON.parse(this.responseText) : this.responseText;
                this.readyStateChange(FakeXMLHttpRequest.DONE);
            },

            respond: function respond(status, headers, body) {
                this.status = typeof status === "number" ? status : 200;
                this.statusText = FakeXMLHttpRequest.statusCodes[this.status];
                this.setResponseHeaders(headers || {});
                this.setResponseBody(body || "");
            },

            uploadProgress: function uploadProgress(progressEventRaw) {
                if (supportsProgress) {
                    this.upload.dispatchEvent(new sinon.ProgressEvent("progress", progressEventRaw));
                }
            },

            downloadProgress: function downloadProgress(progressEventRaw) {
                if (supportsProgress) {
                    this.dispatchEvent(new sinon.ProgressEvent("progress", progressEventRaw));
                }
            },

            uploadError: function uploadError(error) {
                if (supportsCustomEvent) {
                    this.upload.dispatchEvent(new sinon.CustomEvent("error", {detail: error}));
                }
            }
        });

        sinon.extend(FakeXMLHttpRequest, {
            UNSENT: 0,
            OPENED: 1,
            HEADERS_RECEIVED: 2,
            LOADING: 3,
            DONE: 4
        });

        sinon.useFakeXMLHttpRequest = function () {
            FakeXMLHttpRequest.restore = function restore(keepOnCreate) {
                if (sinonXhr.supportsXHR) {
                    global.XMLHttpRequest = sinonXhr.GlobalXMLHttpRequest;
                }

                if (sinonXhr.supportsActiveX) {
                    global.ActiveXObject = sinonXhr.GlobalActiveXObject;
                }

                delete FakeXMLHttpRequest.restore;

                if (keepOnCreate !== true) {
                    delete FakeXMLHttpRequest.onCreate;
                }
            };
            if (sinonXhr.supportsXHR) {
                global.XMLHttpRequest = FakeXMLHttpRequest;
            }

            if (sinonXhr.supportsActiveX) {
                global.ActiveXObject = function ActiveXObject(objId) {
                    if (objId === "Microsoft.XMLHTTP" || /^Msxml2\.XMLHTTP/i.test(objId)) {

                        return new FakeXMLHttpRequest();
                    }

                    return new sinonXhr.GlobalActiveXObject(objId);
                };
            }

            return FakeXMLHttpRequest;
        };

        sinon.FakeXMLHttpRequest = FakeXMLHttpRequest;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./core");
        require("../extend");
        require("./event");
        require("../log_error");
        makeApi(sinon);
        module.exports = sinon;
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon, // eslint-disable-line no-undef
    typeof global !== "undefined" ? global : self
));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../extend":62,"../log_error":64,"./core":74,"./event":75}],81:[function(require,module,exports){
(function (global){
((typeof define === "function" && define.amd && function (m) {
    define("formatio", ["samsam"], m);
}) || (typeof module === "object" && function (m) {
    module.exports = m(require("samsam"));
}) || function (m) { this.formatio = m(this.samsam); }
)(function (samsam) {
    "use strict";

    var formatio = {
        excludeConstructors: ["Object", /^.$/],
        quoteStrings: true,
        limitChildrenCount: 0
    };

    var hasOwn = Object.prototype.hasOwnProperty;

    var specialObjects = [];
    if (typeof global !== "undefined") {
        specialObjects.push({ object: global, value: "[object global]" });
    }
    if (typeof document !== "undefined") {
        specialObjects.push({
            object: document,
            value: "[object HTMLDocument]"
        });
    }
    if (typeof window !== "undefined") {
        specialObjects.push({ object: window, value: "[object Window]" });
    }

    function functionName(func) {
        if (!func) { return ""; }
        if (func.displayName) { return func.displayName; }
        if (func.name) { return func.name; }
        var matches = func.toString().match(/function\s+([^\(]+)/m);
        return (matches && matches[1]) || "";
    }

    function constructorName(f, object) {
        var name = functionName(object && object.constructor);
        var excludes = f.excludeConstructors ||
                formatio.excludeConstructors || [];

        var i, l;
        for (i = 0, l = excludes.length; i < l; ++i) {
            if (typeof excludes[i] === "string" && excludes[i] === name) {
                return "";
            } else if (excludes[i].test && excludes[i].test(name)) {
                return "";
            }
        }

        return name;
    }

    function isCircular(object, objects) {
        if (typeof object !== "object") { return false; }
        var i, l;
        for (i = 0, l = objects.length; i < l; ++i) {
            if (objects[i] === object) { return true; }
        }
        return false;
    }

    function ascii(f, object, processed, indent) {
        if (typeof object === "string") {
            var qs = f.quoteStrings;
            var quote = typeof qs !== "boolean" || qs;
            return processed || quote ? '"' + object + '"' : object;
        }

        if (typeof object === "function" && !(object instanceof RegExp)) {
            return ascii.func(object);
        }

        processed = processed || [];

        if (isCircular(object, processed)) { return "[Circular]"; }

        if (Object.prototype.toString.call(object) === "[object Array]") {
            return ascii.array.call(f, object, processed);
        }

        if (!object) { return String((1/object) === -Infinity ? "-0" : object); }
        if (samsam.isElement(object)) { return ascii.element(object); }

        if (typeof object.toString === "function" &&
                object.toString !== Object.prototype.toString) {
            return object.toString();
        }

        var i, l;
        for (i = 0, l = specialObjects.length; i < l; i++) {
            if (object === specialObjects[i].object) {
                return specialObjects[i].value;
            }
        }

        return ascii.object.call(f, object, processed, indent);
    }

    ascii.func = function (func) {
        return "function " + functionName(func) + "() {}";
    };

    ascii.array = function (array, processed) {
        processed = processed || [];
        processed.push(array);
        var pieces = [];
        var i, l;
        l = (this.limitChildrenCount > 0) ? 
            Math.min(this.limitChildrenCount, array.length) : array.length;

        for (i = 0; i < l; ++i) {
            pieces.push(ascii(this, array[i], processed));
        }

        if(l < array.length)
            pieces.push("[... " + (array.length - l) + " more elements]");

        return "[" + pieces.join(", ") + "]";
    };

    ascii.object = function (object, processed, indent) {
        processed = processed || [];
        processed.push(object);
        indent = indent || 0;
        var pieces = [], properties = samsam.keys(object).sort();
        var length = 3;
        var prop, str, obj, i, k, l;
        l = (this.limitChildrenCount > 0) ? 
            Math.min(this.limitChildrenCount, properties.length) : properties.length;

        for (i = 0; i < l; ++i) {
            prop = properties[i];
            obj = object[prop];

            if (isCircular(obj, processed)) {
                str = "[Circular]";
            } else {
                str = ascii(this, obj, processed, indent + 2);
            }

            str = (/\s/.test(prop) ? '"' + prop + '"' : prop) + ": " + str;
            length += str.length;
            pieces.push(str);
        }

        var cons = constructorName(this, object);
        var prefix = cons ? "[" + cons + "] " : "";
        var is = "";
        for (i = 0, k = indent; i < k; ++i) { is += " "; }

        if(l < properties.length)
            pieces.push("[... " + (properties.length - l) + " more elements]");

        if (length + indent > 80) {
            return prefix + "{\n  " + is + pieces.join(",\n  " + is) + "\n" +
                is + "}";
        }
        return prefix + "{ " + pieces.join(", ") + " }";
    };

    ascii.element = function (element) {
        var tagName = element.tagName.toLowerCase();
        var attrs = element.attributes, attr, pairs = [], attrName, i, l, val;

        for (i = 0, l = attrs.length; i < l; ++i) {
            attr = attrs.item(i);
            attrName = attr.nodeName.toLowerCase().replace("html:", "");
            val = attr.nodeValue;
            if (attrName !== "contenteditable" || val !== "inherit") {
                if (!!val) { pairs.push(attrName + "=\"" + val + "\""); }
            }
        }

        var formatted = "<" + tagName + (pairs.length > 0 ? " " : "");
        var content = element.innerHTML;

        if (content.length > 20) {
            content = content.substr(0, 20) + "[...]";
        }

        var res = formatted + pairs.join(" ") + ">" + content +
                "</" + tagName + ">";

        return res.replace(/ contentEditable="inherit"/, "");
    };

    function Formatio(options) {
        for (var opt in options) {
            this[opt] = options[opt];
        }
    }

    Formatio.prototype = {
        functionName: functionName,

        configure: function (options) {
            return new Formatio(options);
        },

        constructorName: function (object) {
            return constructorName(this, object);
        },

        ascii: function (object, processed, indent) {
            return ascii(this, object, processed, indent);
        }
    };

    return Formatio.prototype;
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"samsam":83}],82:[function(require,module,exports){
(function (global){
/*global global, window*/
/**
 * @author Christian Johansen (christian@cjohansen.no) and contributors
 * @license BSD
 *
 * Copyright (c) 2010-2014 Christian Johansen
 */

(function (global) {
    "use strict";

    // Make properties writable in IE, as per
    // http://www.adequatelygood.com/Replacing-setTimeout-Globally.html
    // JSLint being anal
    var glbl = global;

    global.setTimeout = glbl.setTimeout;
    global.clearTimeout = glbl.clearTimeout;
    global.setImmediate = glbl.setImmediate;
    global.clearImmediate = glbl.clearImmediate;
    global.setInterval = glbl.setInterval;
    global.clearInterval = glbl.clearInterval;
    global.Date = glbl.Date;

    // node expects setTimeout/setInterval to return a fn object w/ .ref()/.unref()
    // browsers, a number.
    // see https://github.com/cjohansen/Sinon.JS/pull/436

    var NOOP = function () { return undefined; };
    var timeoutResult = setTimeout(NOOP, 0);
    var addTimerReturnsObject = typeof timeoutResult === "object";
    clearTimeout(timeoutResult);

    var NativeDate = Date;
    var uniqueTimerId = 1;

    /**
     * Parse strings like "01:10:00" (meaning 1 hour, 10 minutes, 0 seconds) into
     * number of milliseconds. This is used to support human-readable strings passed
     * to clock.tick()
     */
    function parseTime(str) {
        if (!str) {
            return 0;
        }

        var strings = str.split(":");
        var l = strings.length, i = l;
        var ms = 0, parsed;

        if (l > 3 || !/^(\d\d:){0,2}\d\d?$/.test(str)) {
            throw new Error("tick only understands numbers and 'h:m:s'");
        }

        while (i--) {
            parsed = parseInt(strings[i], 10);

            if (parsed >= 60) {
                throw new Error("Invalid time " + str);
            }

            ms += parsed * Math.pow(60, (l - i - 1));
        }

        return ms * 1000;
    }

    /**
     * Used to grok the `now` parameter to createClock.
     */
    function getEpoch(epoch) {
        if (!epoch) { return 0; }
        if (typeof epoch.getTime === "function") { return epoch.getTime(); }
        if (typeof epoch === "number") { return epoch; }
        throw new TypeError("now should be milliseconds since UNIX epoch");
    }

    function inRange(from, to, timer) {
        return timer && timer.callAt >= from && timer.callAt <= to;
    }

    function mirrorDateProperties(target, source) {
        var prop;
        for (prop in source) {
            if (source.hasOwnProperty(prop)) {
                target[prop] = source[prop];
            }
        }

        // set special now implementation
        if (source.now) {
            target.now = function now() {
                return target.clock.now;
            };
        } else {
            delete target.now;
        }

        // set special toSource implementation
        if (source.toSource) {
            target.toSource = function toSource() {
                return source.toSource();
            };
        } else {
            delete target.toSource;
        }

        // set special toString implementation
        target.toString = function toString() {
            return source.toString();
        };

        target.prototype = source.prototype;
        target.parse = source.parse;
        target.UTC = source.UTC;
        target.prototype.toUTCString = source.prototype.toUTCString;

        return target;
    }

    function createDate() {
        function ClockDate(year, month, date, hour, minute, second, ms) {
            // Defensive and verbose to avoid potential harm in passing
            // explicit undefined when user does not pass argument
            switch (arguments.length) {
            case 0:
                return new NativeDate(ClockDate.clock.now);
            case 1:
                return new NativeDate(year);
            case 2:
                return new NativeDate(year, month);
            case 3:
                return new NativeDate(year, month, date);
            case 4:
                return new NativeDate(year, month, date, hour);
            case 5:
                return new NativeDate(year, month, date, hour, minute);
            case 6:
                return new NativeDate(year, month, date, hour, minute, second);
            default:
                return new NativeDate(year, month, date, hour, minute, second, ms);
            }
        }

        return mirrorDateProperties(ClockDate, NativeDate);
    }

    function addTimer(clock, timer) {
        if (timer.func === undefined) {
            throw new Error("Callback must be provided to timer calls");
        }

        if (!clock.timers) {
            clock.timers = {};
        }

        timer.id = uniqueTimerId++;
        timer.createdAt = clock.now;
        timer.callAt = clock.now + (timer.delay || (clock.duringTick ? 1 : 0));

        clock.timers[timer.id] = timer;

        if (addTimerReturnsObject) {
            return {
                id: timer.id,
                ref: NOOP,
                unref: NOOP
            };
        }

        return timer.id;
    }


    function compareTimers(a, b) {
        // Sort first by absolute timing
        if (a.callAt < b.callAt) {
            return -1;
        }
        if (a.callAt > b.callAt) {
            return 1;
        }

        // Sort next by immediate, immediate timers take precedence
        if (a.immediate && !b.immediate) {
            return -1;
        }
        if (!a.immediate && b.immediate) {
            return 1;
        }

        // Sort next by creation time, earlier-created timers take precedence
        if (a.createdAt < b.createdAt) {
            return -1;
        }
        if (a.createdAt > b.createdAt) {
            return 1;
        }

        // Sort next by id, lower-id timers take precedence
        if (a.id < b.id) {
            return -1;
        }
        if (a.id > b.id) {
            return 1;
        }

        // As timer ids are unique, no fallback `0` is necessary
    }

    function firstTimerInRange(clock, from, to) {
        var timers = clock.timers,
            timer = null,
            id,
            isInRange;

        for (id in timers) {
            if (timers.hasOwnProperty(id)) {
                isInRange = inRange(from, to, timers[id]);

                if (isInRange && (!timer || compareTimers(timer, timers[id]) === 1)) {
                    timer = timers[id];
                }
            }
        }

        return timer;
    }

    function callTimer(clock, timer) {
        var exception;

        if (typeof timer.interval === "number") {
            clock.timers[timer.id].callAt += timer.interval;
        } else {
            delete clock.timers[timer.id];
        }

        try {
            if (typeof timer.func === "function") {
                timer.func.apply(null, timer.args);
            } else {
                eval(timer.func);
            }
        } catch (e) {
            exception = e;
        }

        if (!clock.timers[timer.id]) {
            if (exception) {
                throw exception;
            }
            return;
        }

        if (exception) {
            throw exception;
        }
    }

    function timerType(timer) {
        if (timer.immediate) {
            return "Immediate";
        } else if (typeof timer.interval !== "undefined") {
            return "Interval";
        } else {
            return "Timeout";
        }
    }

    function clearTimer(clock, timerId, ttype) {
        if (!timerId) {
            // null appears to be allowed in most browsers, and appears to be
            // relied upon by some libraries, like Bootstrap carousel
            return;
        }

        if (!clock.timers) {
            clock.timers = [];
        }

        // in Node, timerId is an object with .ref()/.unref(), and
        // its .id field is the actual timer id.
        if (typeof timerId === "object") {
            timerId = timerId.id;
        }

        if (clock.timers.hasOwnProperty(timerId)) {
            // check that the ID matches a timer of the correct type
            var timer = clock.timers[timerId];
            if (timerType(timer) === ttype) {
                delete clock.timers[timerId];
            } else {
				throw new Error("Cannot clear timer: timer created with set" + ttype + "() but cleared with clear" + timerType(timer) + "()");
			}
        }
    }

    function uninstall(clock, target) {
        var method,
            i,
            l;

        for (i = 0, l = clock.methods.length; i < l; i++) {
            method = clock.methods[i];

            if (target[method].hadOwnProperty) {
                target[method] = clock["_" + method];
            } else {
                try {
                    delete target[method];
                } catch (ignore) {}
            }
        }

        // Prevent multiple executions which will completely remove these props
        clock.methods = [];
    }

    function hijackMethod(target, method, clock) {
        var prop;

        clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(target, method);
        clock["_" + method] = target[method];

        if (method === "Date") {
            var date = mirrorDateProperties(clock[method], target[method]);
            target[method] = date;
        } else {
            target[method] = function () {
                return clock[method].apply(clock, arguments);
            };

            for (prop in clock[method]) {
                if (clock[method].hasOwnProperty(prop)) {
                    target[method][prop] = clock[method][prop];
                }
            }
        }

        target[method].clock = clock;
    }

    var timers = {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout,
        setImmediate: global.setImmediate,
        clearImmediate: global.clearImmediate,
        setInterval: setInterval,
        clearInterval: clearInterval,
        Date: Date
    };

    var keys = Object.keys || function (obj) {
        var ks = [],
            key;

        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ks.push(key);
            }
        }

        return ks;
    };

    exports.timers = timers;

    function createClock(now) {
        var clock = {
            now: getEpoch(now),
            timeouts: {},
            Date: createDate()
        };

        clock.Date.clock = clock;

        clock.setTimeout = function setTimeout(func, timeout) {
            return addTimer(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 2),
                delay: timeout
            });
        };

        clock.clearTimeout = function clearTimeout(timerId) {
            return clearTimer(clock, timerId, "Timeout");
        };

        clock.setInterval = function setInterval(func, timeout) {
            return addTimer(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 2),
                delay: timeout,
                interval: timeout
            });
        };

        clock.clearInterval = function clearInterval(timerId) {
            return clearTimer(clock, timerId, "Interval");
        };

        clock.setImmediate = function setImmediate(func) {
            return addTimer(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 1),
                immediate: true
            });
        };

        clock.clearImmediate = function clearImmediate(timerId) {
            return clearTimer(clock, timerId, "Immediate");
        };

        clock.tick = function tick(ms) {
            ms = typeof ms === "number" ? ms : parseTime(ms);
            var tickFrom = clock.now, tickTo = clock.now + ms, previous = clock.now;
            var timer = firstTimerInRange(clock, tickFrom, tickTo);
            var oldNow;

            clock.duringTick = true;

            var firstException;
            while (timer && tickFrom <= tickTo) {
                if (clock.timers[timer.id]) {
                    tickFrom = clock.now = timer.callAt;
                    try {
                        oldNow = clock.now;
                        callTimer(clock, timer);
                        // compensate for any setSystemTime() call during timer callback
                        if (oldNow !== clock.now) {
                            tickFrom += clock.now - oldNow;
                            tickTo += clock.now - oldNow;
                            previous += clock.now - oldNow;
                        }
                    } catch (e) {
                        firstException = firstException || e;
                    }
                }

                timer = firstTimerInRange(clock, previous, tickTo);
                previous = tickFrom;
            }

            clock.duringTick = false;
            clock.now = tickTo;

            if (firstException) {
                throw firstException;
            }

            return clock.now;
        };

        clock.reset = function reset() {
            clock.timers = {};
        };

        clock.setSystemTime = function setSystemTime(now) {
            // determine time difference
            var newNow = getEpoch(now);
            var difference = newNow - clock.now;

            // update 'system clock'
            clock.now = newNow;

            // update timers and intervals to keep them stable
            for (var id in clock.timers) {
                if (clock.timers.hasOwnProperty(id)) {
                    var timer = clock.timers[id];
                    timer.createdAt += difference;
                    timer.callAt += difference;
                }
            }
        };

        return clock;
    }
    exports.createClock = createClock;

    exports.install = function install(target, now, toFake) {
        var i,
            l;

        if (typeof target === "number") {
            toFake = now;
            now = target;
            target = null;
        }

        if (!target) {
            target = global;
        }

        var clock = createClock(now);

        clock.uninstall = function () {
            uninstall(clock, target);
        };

        clock.methods = toFake || [];

        if (clock.methods.length === 0) {
            clock.methods = keys(timers);
        }

        for (i = 0, l = clock.methods.length; i < l; i++) {
            hijackMethod(target, clock.methods[i], clock);
        }

        return clock;
    };

}(global || this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],83:[function(require,module,exports){
((typeof define === "function" && define.amd && function (m) { define("samsam", m); }) ||
 (typeof module === "object" &&
      function (m) { module.exports = m(); }) || // Node
 function (m) { this.samsam = m(); } // Browser globals
)(function () {
    var o = Object.prototype;
    var div = typeof document !== "undefined" && document.createElement("div");

    function isNaN(value) {
        // Unlike global isNaN, this avoids type coercion
        // typeof check avoids IE host object issues, hat tip to
        // lodash
        var val = value; // JsLint thinks value !== value is "weird"
        return typeof value === "number" && value !== val;
    }

    function getClass(value) {
        // Returns the internal [[Class]] by calling Object.prototype.toString
        // with the provided value as this. Return value is a string, naming the
        // internal class, e.g. "Array"
        return o.toString.call(value).split(/[ \]]/)[1];
    }

    /**
     * @name samsam.isArguments
     * @param Object object
     *
     * Returns ``true`` if ``object`` is an ``arguments`` object,
     * ``false`` otherwise.
     */
    function isArguments(object) {
        if (getClass(object) === 'Arguments') { return true; }
        if (typeof object !== "object" || typeof object.length !== "number" ||
                getClass(object) === "Array") {
            return false;
        }
        if (typeof object.callee == "function") { return true; }
        try {
            object[object.length] = 6;
            delete object[object.length];
        } catch (e) {
            return true;
        }
        return false;
    }

    /**
     * @name samsam.isElement
     * @param Object object
     *
     * Returns ``true`` if ``object`` is a DOM element node. Unlike
     * Underscore.js/lodash, this function will return ``false`` if ``object``
     * is an *element-like* object, i.e. a regular object with a ``nodeType``
     * property that holds the value ``1``.
     */
    function isElement(object) {
        if (!object || object.nodeType !== 1 || !div) { return false; }
        try {
            object.appendChild(div);
            object.removeChild(div);
        } catch (e) {
            return false;
        }
        return true;
    }

    /**
     * @name samsam.keys
     * @param Object object
     *
     * Return an array of own property names.
     */
    function keys(object) {
        var ks = [], prop;
        for (prop in object) {
            if (o.hasOwnProperty.call(object, prop)) { ks.push(prop); }
        }
        return ks;
    }

    /**
     * @name samsam.isDate
     * @param Object value
     *
     * Returns true if the object is a ``Date``, or *date-like*. Duck typing
     * of date objects work by checking that the object has a ``getTime``
     * function whose return value equals the return value from the object's
     * ``valueOf``.
     */
    function isDate(value) {
        return typeof value.getTime == "function" &&
            value.getTime() == value.valueOf();
    }

    /**
     * @name samsam.isNegZero
     * @param Object value
     *
     * Returns ``true`` if ``value`` is ``-0``.
     */
    function isNegZero(value) {
        return value === 0 && 1 / value === -Infinity;
    }

    /**
     * @name samsam.equal
     * @param Object obj1
     * @param Object obj2
     *
     * Returns ``true`` if two objects are strictly equal. Compared to
     * ``===`` there are two exceptions:
     *
     *   - NaN is considered equal to NaN
     *   - -0 and +0 are not considered equal
     */
    function identical(obj1, obj2) {
        if (obj1 === obj2 || (isNaN(obj1) && isNaN(obj2))) {
            return obj1 !== 0 || isNegZero(obj1) === isNegZero(obj2);
        }
    }


    /**
     * @name samsam.deepEqual
     * @param Object obj1
     * @param Object obj2
     *
     * Deep equal comparison. Two values are "deep equal" if:
     *
     *   - They are equal, according to samsam.identical
     *   - They are both date objects representing the same time
     *   - They are both arrays containing elements that are all deepEqual
     *   - They are objects with the same set of properties, and each property
     *     in ``obj1`` is deepEqual to the corresponding property in ``obj2``
     *
     * Supports cyclic objects.
     */
    function deepEqualCyclic(obj1, obj2) {

        // used for cyclic comparison
        // contain already visited objects
        var objects1 = [],
            objects2 = [],
        // contain pathes (position in the object structure)
        // of the already visited objects
        // indexes same as in objects arrays
            paths1 = [],
            paths2 = [],
        // contains combinations of already compared objects
        // in the manner: { "$1['ref']$2['ref']": true }
            compared = {};

        /**
         * used to check, if the value of a property is an object
         * (cyclic logic is only needed for objects)
         * only needed for cyclic logic
         */
        function isObject(value) {

            if (typeof value === 'object' && value !== null &&
                    !(value instanceof Boolean) &&
                    !(value instanceof Date)    &&
                    !(value instanceof Number)  &&
                    !(value instanceof RegExp)  &&
                    !(value instanceof String)) {

                return true;
            }

            return false;
        }

        /**
         * returns the index of the given object in the
         * given objects array, -1 if not contained
         * only needed for cyclic logic
         */
        function getIndex(objects, obj) {

            var i;
            for (i = 0; i < objects.length; i++) {
                if (objects[i] === obj) {
                    return i;
                }
            }

            return -1;
        }

        // does the recursion for the deep equal check
        return (function deepEqual(obj1, obj2, path1, path2) {
            var type1 = typeof obj1;
            var type2 = typeof obj2;

            // == null also matches undefined
            if (obj1 === obj2 ||
                    isNaN(obj1) || isNaN(obj2) ||
                    obj1 == null || obj2 == null ||
                    type1 !== "object" || type2 !== "object") {

                return identical(obj1, obj2);
            }

            // Elements are only equal if identical(expected, actual)
            if (isElement(obj1) || isElement(obj2)) { return false; }

            var isDate1 = isDate(obj1), isDate2 = isDate(obj2);
            if (isDate1 || isDate2) {
                if (!isDate1 || !isDate2 || obj1.getTime() !== obj2.getTime()) {
                    return false;
                }
            }

            if (obj1 instanceof RegExp && obj2 instanceof RegExp) {
                if (obj1.toString() !== obj2.toString()) { return false; }
            }

            var class1 = getClass(obj1);
            var class2 = getClass(obj2);
            var keys1 = keys(obj1);
            var keys2 = keys(obj2);

            if (isArguments(obj1) || isArguments(obj2)) {
                if (obj1.length !== obj2.length) { return false; }
            } else {
                if (type1 !== type2 || class1 !== class2 ||
                        keys1.length !== keys2.length) {
                    return false;
                }
            }

            var key, i, l,
                // following vars are used for the cyclic logic
                value1, value2,
                isObject1, isObject2,
                index1, index2,
                newPath1, newPath2;

            for (i = 0, l = keys1.length; i < l; i++) {
                key = keys1[i];
                if (!o.hasOwnProperty.call(obj2, key)) {
                    return false;
                }

                // Start of the cyclic logic

                value1 = obj1[key];
                value2 = obj2[key];

                isObject1 = isObject(value1);
                isObject2 = isObject(value2);

                // determine, if the objects were already visited
                // (it's faster to check for isObject first, than to
                // get -1 from getIndex for non objects)
                index1 = isObject1 ? getIndex(objects1, value1) : -1;
                index2 = isObject2 ? getIndex(objects2, value2) : -1;

                // determine the new pathes of the objects
                // - for non cyclic objects the current path will be extended
                //   by current property name
                // - for cyclic objects the stored path is taken
                newPath1 = index1 !== -1
                    ? paths1[index1]
                    : path1 + '[' + JSON.stringify(key) + ']';
                newPath2 = index2 !== -1
                    ? paths2[index2]
                    : path2 + '[' + JSON.stringify(key) + ']';

                // stop recursion if current objects are already compared
                if (compared[newPath1 + newPath2]) {
                    return true;
                }

                // remember the current objects and their pathes
                if (index1 === -1 && isObject1) {
                    objects1.push(value1);
                    paths1.push(newPath1);
                }
                if (index2 === -1 && isObject2) {
                    objects2.push(value2);
                    paths2.push(newPath2);
                }

                // remember that the current objects are already compared
                if (isObject1 && isObject2) {
                    compared[newPath1 + newPath2] = true;
                }

                // End of cyclic logic

                // neither value1 nor value2 is a cycle
                // continue with next level
                if (!deepEqual(value1, value2, newPath1, newPath2)) {
                    return false;
                }
            }

            return true;

        }(obj1, obj2, '$1', '$2'));
    }

    var match;

    function arrayContains(array, subset) {
        if (subset.length === 0) { return true; }
        var i, l, j, k;
        for (i = 0, l = array.length; i < l; ++i) {
            if (match(array[i], subset[0])) {
                for (j = 0, k = subset.length; j < k; ++j) {
                    if (!match(array[i + j], subset[j])) { return false; }
                }
                return true;
            }
        }
        return false;
    }

    /**
     * @name samsam.match
     * @param Object object
     * @param Object matcher
     *
     * Compare arbitrary value ``object`` with matcher.
     */
    match = function match(object, matcher) {
        if (matcher && typeof matcher.test === "function") {
            return matcher.test(object);
        }

        if (typeof matcher === "function") {
            return matcher(object) === true;
        }

        if (typeof matcher === "string") {
            matcher = matcher.toLowerCase();
            var notNull = typeof object === "string" || !!object;
            return notNull &&
                (String(object)).toLowerCase().indexOf(matcher) >= 0;
        }

        if (typeof matcher === "number") {
            return matcher === object;
        }

        if (typeof matcher === "boolean") {
            return matcher === object;
        }

        if (typeof(matcher) === "undefined") {
            return typeof(object) === "undefined";
        }

        if (matcher === null) {
            return object === null;
        }

        if (getClass(object) === "Array" && getClass(matcher) === "Array") {
            return arrayContains(object, matcher);
        }

        if (matcher && typeof matcher === "object") {
            if (matcher === object) {
                return true;
            }
            var prop;
            for (prop in matcher) {
                var value = object[prop];
                if (typeof value === "undefined" &&
                        typeof object.getAttribute === "function") {
                    value = object.getAttribute(prop);
                }
                if (matcher[prop] === null || typeof matcher[prop] === 'undefined') {
                    if (value !== matcher[prop]) {
                        return false;
                    }
                } else if (typeof  value === "undefined" || !match(value, matcher[prop])) {
                    return false;
                }
            }
            return true;
        }

        throw new Error("Matcher was not a string, a number, a " +
                        "function, a boolean or an object");
    };

    return {
        isArguments: isArguments,
        isElement: isElement,
        isDate: isDate,
        isNegZero: isNegZero,
        identical: identical,
        deepEqual: deepEqualCyclic,
        match: match,
        keys: keys
    };
});

},{}],84:[function(require,module,exports){
/*!
 * Sizzle CSS Selector Engine v2.2.0
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-10
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "[id='" + nid + "'] " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Limit the fix to IE with document.documentMode and IE >=9 with document.defaultView
	if ( document.documentMode && (parent = document.defaultView) && parent.top !== parent ) {
		// Support: IE 11
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				return m ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( (oldCache = uniqueCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

// EXPOSE
if ( typeof define === "function" && define.amd ) {
	define(function() { return Sizzle; });
// Sizzle requires that there be a global window in Common-JS like environments
} else if ( typeof module !== "undefined" && module.exports ) {
	module.exports = Sizzle;
} else {
	window.Sizzle = Sizzle;
}
// EXPOSE

})( window );

},{}],85:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],86:[function(require,module,exports){
module.exports = require('./src/voom');


},{"./src/voom":89}],87:[function(require,module,exports){
module.exports={
  "_args": [
    [
      {
        "raw": "voom@^1.0.8",
        "scope": null,
        "escapedName": "voom",
        "name": "voom",
        "rawSpec": "^1.0.8",
        "spec": ">=1.0.8 <2.0.0",
        "type": "range"
      },
      "/Users/Russ/Sites/nitro-xmpp-client-connection"
    ]
  ],
  "_from": "voom@>=1.0.8 <2.0.0",
  "_id": "voom@1.0.8",
  "_inCache": true,
  "_installable": true,
  "_location": "/voom",
  "_nodeVersion": "5.2.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/voom-1.0.8.tgz_1475696929192_0.2945524323731661"
  },
  "_npmUser": {
    "name": "tragle",
    "email": "tragle@gmail.com"
  },
  "_npmVersion": "3.3.12",
  "_phantomChildren": {},
  "_requested": {
    "raw": "voom@^1.0.8",
    "scope": null,
    "escapedName": "voom",
    "name": "voom",
    "rawSpec": "^1.0.8",
    "spec": ">=1.0.8 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/voom/-/voom-1.0.8.tgz",
  "_shasum": "e2cf8cab65cdbfce511a9ca9bcd63ed543cf04e6",
  "_shrinkwrap": null,
  "_spec": "voom@^1.0.8",
  "_where": "/Users/Russ/Sites/nitro-xmpp-client-connection",
  "author": {
    "name": "Tom Ragle"
  },
  "bugs": {
    "url": "https://github.com/tragle/voom/issues"
  },
  "dependencies": {
    "pkginfo": "^0.4.0"
  },
  "description": "value oriented object map",
  "devDependencies": {
    "chai": "^3.5.0",
    "mocha": "^3.0.2"
  },
  "directories": {},
  "dist": {
    "shasum": "e2cf8cab65cdbfce511a9ca9bcd63ed543cf04e6",
    "tarball": "https://registry.npmjs.org/voom/-/voom-1.0.8.tgz"
  },
  "gitHead": "3be69b6c860b884eac3d3903917ea9bf91e0555f",
  "homepage": "https://github.com/tragle/voom#readme",
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "tragle",
      "email": "tragle@gmail.com"
    }
  ],
  "name": "voom",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/tragle/voom.git"
  },
  "scripts": {
    "test": "mocha --reporter spec"
  },
  "version": "1.0.8"
}

},{}],88:[function(require,module,exports){
"use strict";

// [array], [array] -> Bool
var arraysAreEqual = exports.arraysAreEqual = function (arrayA, arrayB) {
  if (arrayA.length !== arrayB.length) return false;
  for (var i = 0; i < arrayA.length; i++) {
    if (arrayA[i] !== arrayB[i]) return false;
  }
  return true;
};

// {obj} -> {obj}
var clone = exports.clone = function (obj) {
  function visit(obj, copy) {
    for (var n in obj) {
      if (isObject(obj[n])) {
        copy[n] = {};
        visit(obj[n], copy[n]);
      } else if (isArray(obj[n])) {
        copy[n] = obj[n].map(function(item) {
          if (isObject(item)) return clone(item);
          return item;
        });
      } else {
        copy[n] = obj[n];
      }
    }
    return copy;
  }
  return visit(obj, {});
};

// fn -> fn([array])
var collector = exports.collector = function (fn) {
  return function (array) {
    var results = [], res;
    if (!isArray(array)) return results;
    for (var i = 0; i < array.length; i++) {
      res = fn(array[i]);
      if (!isNull(res) && !isUndefined(res)) results.push(res);
    }
    return results;
  };
};

// fn -> delayed() -> fn
var delay = exports.delay = function (fn) {
  return function delayed () {
    return fn;
  }
};

// [source], [target], fn -> [results]
var distribute = exports.distribute = function (source, target, fn) {
  var factor = source.length / target.length,
    results = [];
  fn = fn || function (a, b) {return [a, b];};
  for (var i = 0; i < target.length; i++) {
    results = results.concat(fn(source[Math.floor(i * factor)], target[i]));
  }
  return results;
};

// [list], pred -> bool
var every = exports.every = function (list, pred) {
  for (var i = 0; i < list.length; i++) {
    if (!pred(list[i])) return false;
  }
  return true;
}

// {}, val -> [path]
var findPath = exports.findPath = function (obj, val, includeArrays) {
  var path = [];
  val = isFunction(val) ? val.name : val;
  function visit(source) {
    for (var n in source) {
      var sourceName = isFunction(source[n]) ? source[n].name : source[n];
      path.push(n);
      if (sourceName === val) return true; 
      if (isObject(sourceName)) 
        if (visit(sourceName)) return true;
      if (includeArrays && isArray(sourceName))
        if (visit(sourceName)) return true;
      path.pop();
    }
  }
  visit(obj);
  return path;
};

// val -> input -> val | void
var gate = exports.gate = function (val) {
  return function (input) {
    if (input === val) return val;
  }
};

// [[arrays]] -> [[groups]]
var groupArrays = exports.groupArrays = function (arrays) {
  var groups = [];
  arrays = arrays.slice(0);

  while (arrays.length) {
    var array = arrays.pop();
    if (!groups.length) {
      groups.push([array]);
      continue
    }
    for (var i in groups) {
      if (arraysAreEqual(array, groups[i][0])) {
        groups[i].push(array);
      } else {
        groups.push([array]);
      }
    }
  }
  return groups;
};

// val -> val 
var identity = exports.identity = function (val) {
  return val;
};

// val -> Bool
var isArray = exports.isArray = function (val) {
  return Array.isArray(val);
};

// val -> Bool
var isEmpty = exports.isEmpty = function (val) {
  return !isValue(val) || !!(val.length === 0);
};

// val -> Bool
var isFunction = exports.isFunction = function (val) {
  return typeof val === 'function';
};

// val -> Bool
var isNull = exports.isNull = function (val) {
  return val === null;
};

// val -> Bool
var isObject = exports.isObject = function (val) {
  return !!val && val.constructor && val.constructor === Object;
};

// val -> Bool
var isPrimitive = exports.isPrimitive = function (val) {
  return isValue(val) && !isObject(val) && !isArray(val) && !isFunction(val);
};

// val -> Bool
var isUndefined = exports.isUndefined = function (val) {
  return val === void 0;
};

// val -> Bool
var isValue = exports.isValue = function (val) {
  return !isNull(val) && !isUndefined(val);
};

// [array], n -> [array]
var last = exports.last = function (array, n) {
  if (!array.length) return;
  var len = n ? array.length - n : array.length - 1;
  return Array.prototype.slice.call(array, len, array.length)
};

// {obj} -> {obj}
var nullify = exports.nullify = function (obj) {
  traverse(obj, function(_obj, n) {
    _obj[n] = isArray(_obj[n]) ? [] : null;
  });
  return obj
};

// fns -> fn
var pipe = exports.pipe = function () {
  if (!arguments.length) return identity;
  if (arguments.length === 1) return arguments[0];
  var fns = arguments;
  return function (x) {
    for (var i = 0; i < fns.length; i++) {
      x = fns[i](x);
    }
    return x;
  }
};

// {obj}, [path]  -> value
var readPath = exports.readPath = function (obj, path) {
  if (!path.length) return;
  if (path.length > 1) return readPath(obj[path[0]], path.slice(1));
  return obj[path[0]];
};

// val -> [val]
var toArray = exports.toArray = function (val) {
  if (isUndefined(val) || isNull(val)) return [];
  if (isArray(val)) return val;
  return [val];
};

// {source}, fn({source}, {target}, n, [path]), {target} -> void 
var traverse = exports.traverse = function (source, fn, target) {
  var path = [];
  function visit (source, target, fn) {
    for (var n in source) {
      path.push(n);
      if (isObject(source[n])) {
        visit(source[n], target, fn);
      } else {
        fn(source, n, target, path.slice(0));
      }
      path.pop();
    }
  }
  visit(source, target, fn);
  return target;
};

// val -> input -> val
var value = exports.value = function (val) {
  return function (input) {
    if (isValue(val) && isValue(input)) return val;
  }
};





},{}],89:[function(require,module,exports){
var version = require('../package.json').version;
var lib = require('./lib.js');

module.exports = function () {

  function getTransformIndex (obj) {
    var index = {};
    lib.traverse (obj, function (_obj, n) {
      var path = lib.findPath(reader, _obj[n]),
        fn = lib.isFunction(_obj[n]) ? _obj[n] : lib.identity;
      index[pathToKey(path)] = fn; 
    });
    return index;
  }

  function getTransform (sources, key) {
    if (!sources || !sources.length) return lib.identity;
    if (!lib.isArray(sources)) return;
    var fns = sources.map(function(source) {
      if (lib.isFunction(source)) return source;
      if (lib.isObject(source)) return lib.isFunction(source[key]) ? source[key] : lib.identity;
      return f(source);
    });
    return lib.pipe.apply(null, fns);
  }

  function getAssigner (obj, key, transforms) {
    transforms = transforms || [];
    if (lib.isFunction(obj[key])) transforms.push(obj[key]);
    var fn = getTransform(transforms, key);
    fn = lib.isFunction(fn) ? fn : lib.identity;
    return function (val) {
      obj[key] = fn(val, obj, key);
    };
  }

  function pathToKey (path) {
    return path.join('::||');
  }

  function keyToPath (key) {
    return key.split('::||');
  }

  function getPathsForObj (reader, obj) {
    var paths = {};
    for (var k in obj) {
      var val = obj[k] ;
      if (lib.isObject(val)) 
        return getPathsForObj(reader, val);
      if (lib.isFunction(val)) val = val.name;
      paths[val] = lib.findPath(reader, val, true);
    }
    return paths;
  }

  function getPaths (reader, obj) {
    var targetPaths = getPathsForObj(reader, obj),
      result = {arrays: [], nonArrays: []};
    for (var tn in targetPaths) {
      var depth = targetPaths[tn].filter(function(key) {
        return key === "0";
      }).length;
      if (depth === 0) result.nonArrays.push(targetPaths[tn]);
      if (depth === 1) result.arrays.push(targetPaths[tn].slice(0, targetPaths[tn].indexOf("0")));
      if (depth > 1) throw new Error ("Unable to map nested arrays", "voom.js");
    }
    return result;
  }

  function indexArrayMap (index, indexKey, writer, writerKey, readerNode, writerArray) {
    index[indexKey] = getAssigner(writer, writerKey, [f(readerNode, writerArray)]);
  }

  function indexArrayMerges (index, paths, source, n, reader, writer, transforms) {
    for (var i in paths) {
      if (paths[i].length) {
        var readerVal = lib.readPath(reader, paths[i])[0];
        var mapFn = f(readerVal, source[n][0]);
        var mergeFn = function (left, right) {
          var newObj = mapFn(left);
          return lib.traverse(newObj, function(_newObj, n, target) {
            if (!lib.isNull(_newObj[n])) target[n] = _newObj[n];
          }, right);
        };
        index[pathToKey(paths[i][0])] = lib.delay(getAssigner(source, n, 
          [function(readerColl) {
            return lib.distribute(readerColl, source[n], mergeFn);
          }]));
      }
    }
  }

  function indexNonArrayMaps (index, paths, _writer, n, reader, writer, transforms) {
    for (var na in paths) {
      var nonArrayPath = paths[na];
      var readerVal = lib.readPath(reader, nonArrayPath);
      var keyToWrite = function() {
        for (var sn in _writer[n][0]) {
          if (_writer[n][0][sn] === readerVal) return sn;
        }
      }();
      var mapFn = function (val, obj, key) {
        return obj[key].map(function(item) {
          if (lib.isObject(item)) {
            item[keyToWrite] = val;
            return item;
          }
        });
      };
      var assigner = lib.delay(getAssigner(_writer, n, [mapFn]));
      index[pathToKey(nonArrayPath)] = assigner;
    } 
  }

  function indexCollection (index, _writer, n, reader, writer, transforms) {
    var paths = getPaths(reader, _writer[n]),
      arrayPaths = paths.arrays,
      nonArrayPaths = paths.nonArrays,
      pathGroups = lib.groupArrays(arrayPaths).sort(function (a,b){
        return b.length - a.length;
      });
    if (pathGroups.length) {
      var topPath = pathGroups[0], 
        otherPaths = pathGroups.slice(1);
      if (topPath.length) 
        indexArrayMap(index, pathToKey(topPath[0]), _writer, n, lib.readPath(reader, topPath[0]), _writer[n]);
      if (otherPaths.length)
        indexArrayMerges(index, otherPaths, _writer, n, reader, writer, transforms);
    }
    if (nonArrayPaths.length) {
      indexNonArrayMaps (index, nonArrayPaths, _writer, n, reader, writer, transforms);
    }
  }

  function getMapIndex (reader, writer, transforms) {
    transforms = transforms || [];
    return lib.traverse (writer, function (_writer, n, index) {
      if (lib.isArray(_writer[n])) {
        if (lib.isObject(_writer[n][0])) {
          indexCollection(index, _writer, n, reader, writer, transforms);
        }
      } else {
        var path = lib.findPath(reader, _writer[n]);
        var readerVal = lib.readPath(reader, path);
        if (path && readerVal) {
          var transform = lib.isFunction(readerVal) ? readerVal : [];
          index[pathToKey(path)] = getAssigner(_writer, n, transforms.concat(transform));
        } 
      }
    }, {});
  }

  function mapper (reader, writer, transforms) {
    var index = getMapIndex (reader, writer, transforms) || {};
    return function (obj) {
      var queue = [];
      writer = lib.nullify(writer);
      lib.traverse(index, function(_index, n) {
        var writeFn = _index[n];
        var val = lib.readPath(obj, keyToPath(n));
        if (lib.isFunction(writeFn) && writeFn.name === 'delayed')
          queue.push(writeFn, val);
        if (lib.isFunction(writeFn)) writeFn(val);
      }, writer);
      for (var i = 0; i < queue.length; i+=2)
        queue[i]().call(null, queue[i+1]);
      return lib.clone(writer);
    }
  }

  function f () {
    var args = Array.prototype.slice.call(arguments);
    if (!args.length) return lib.identity;
    var reader = args[0], 
      writer = args.length > 1 ? lib.last(args, 1)[0] : null,
      transforms = args.length > 2 ? args.slice(1, args.length - 1) : [];
    if (lib.isObject(writer)) writer = lib.clone(writer)

    if (lib.isFunction(reader) && args.length === 1) 
      return reader;

    if (lib.every(args, lib.isFunction.bind(lib)))
      return lib.pipe(reader, getTransform(transforms), writer);

    if (lib.isFunction(writer))
      return lib.pipe(f.apply(null, args.slice(0, args.length - 1)), writer);

    if (lib.isFunction(reader))
      return lib.pipe(reader, f.apply(null, args.slice(1)));

    if (lib.isObject(reader) && args.length === 1) 
      return mapper(reader, reader);

    if (lib.isObject(reader) && lib.isObject(writer)) 
      return mapper(reader, writer, transforms);

    if (lib.isObject(reader) && lib.isArray(writer)) 
      return lib.pipe(lib.toArray, f([reader], writer));

    if (lib.isArray(reader) && args.length === 1) 
      return lib.collector(f(reader[0], reader[0]));

    if (lib.isArray(reader) && lib.isArray(writer)) 
      return lib.collector(f(reader[0], writer[0]));

    if (lib.isPrimitive(reader) && args.length === 1) 
      return lib.gate(reader);

    if (lib.isPrimitive(reader) && lib.isPrimitive(writer)) 
      return lib.pipe(lib.gate(reader), getTransform(transforms), lib.value(writer));

    throw new Error ("Invalid arguments", "voom.js");

  }

  return {
    f: f,
    version: version
  };

}();


},{"../package.json":87,"./lib.js":88}],90:[function(require,module,exports){
/*
 Copyright 2011-2013 Abdulla Abdurakhmanov
 Original sources are available at https://code.google.com/p/x2js/

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
/**
 * Modified by JekaMoroz for npm usage
 */

module.exports = function X2JS(config) {
    'use strict';

    var VERSION = "1.1.8";

    config = config || {};
    initConfigDefaults();
    initRequiredPolyfills();

    function initConfigDefaults() {
        if(config.escapeMode === undefined) {
            config.escapeMode = true;
        }
        config.attributePrefix = config.attributePrefix || "_";
        config.arrayAccessForm = config.arrayAccessForm || "none";
        config.emptyNodeForm = config.emptyNodeForm || "text";
        if(config.enableToStringFunc === undefined) {
            config.enableToStringFunc = true;
        }
        config.arrayAccessFormPaths = config.arrayAccessFormPaths || [];
        if(config.skipEmptyTextNodesForObj === undefined) {
            config.skipEmptyTextNodesForObj = true;
        }
        if(config.stripWhitespaces === undefined) {
            config.stripWhitespaces = true;
        }
        config.datetimeAccessFormPaths = config.datetimeAccessFormPaths || [];
    }

    var DOMNodeTypes = {
        ELEMENT_NODE 	   : 1,
        TEXT_NODE    	   : 3,
        CDATA_SECTION_NODE : 4,
        COMMENT_NODE	   : 8,
        DOCUMENT_NODE 	   : 9
    };

    function initRequiredPolyfills() {
        function pad(number) {
            var r = String(number);
            if ( r.length === 1 ) {
                r = '0' + r;
            }
            return r;
        }
        // Hello IE8-
        if(typeof String.prototype.trim !== 'function') {
            String.prototype.trim = function() {
                return this.replace(/^\s+|^\n+|(\s|\n)+$/g, '');
            }
        }
        if(typeof Date.prototype.toISOString !== 'function') {
            // Implementation from http://stackoverflow.com/questions/2573521/how-do-i-output-an-iso-8601-formatted-string-in-javascript
            Date.prototype.toISOString = function() {
                return this.getUTCFullYear()
                    + '-' + pad( this.getUTCMonth() + 1 )
                    + '-' + pad( this.getUTCDate() )
                    + 'T' + pad( this.getUTCHours() )
                    + ':' + pad( this.getUTCMinutes() )
                    + ':' + pad( this.getUTCSeconds() )
                    + '.' + String( (this.getUTCMilliseconds()/1000).toFixed(3) ).slice( 2, 5 )
                    + 'Z';
            };
        }
    }

    function getNodeLocalName( node ) {
        var nodeLocalName = node.localName;
        if(nodeLocalName == null) // Yeah, this is IE!!
            nodeLocalName = node.baseName;
        if(nodeLocalName == null || nodeLocalName=="") // =="" is IE too
            nodeLocalName = node.nodeName;
        return nodeLocalName;
    }

    function getNodePrefix(node) {
        return node.prefix;
    }

    function escapeXmlChars(str) {
        if(typeof(str) == "string")
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;');
        else
            return str;
    }

    function unescapeXmlChars(str) {
        return str.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&#x2F;/g, '\/');
    }

    function toArrayAccessForm(obj, childName, path) {
        switch(config.arrayAccessForm) {
            case "property":
                if(!(obj[childName] instanceof Array))
                    obj[childName+"_asArray"] = [obj[childName]];
                else
                    obj[childName+"_asArray"] = obj[childName];
                break;
            /*case "none":
             break;*/
        }

        if(!(obj[childName] instanceof Array) && config.arrayAccessFormPaths.length > 0) {
            var idx = 0;
            for(; idx < config.arrayAccessFormPaths.length; idx++) {
                var arrayPath = config.arrayAccessFormPaths[idx];
                if( typeof arrayPath === "string" ) {
                    if(arrayPath == path)
                        break;
                }
                else
                if( arrayPath instanceof RegExp) {
                    if(arrayPath.test(path))
                        break;
                }
                else
                if( typeof arrayPath === "function") {
                    if(arrayPath(obj, childName, path))
                        break;
                }
            }
            if(idx!=config.arrayAccessFormPaths.length) {
                obj[childName] = [obj[childName]];
            }
        }
    }

    function fromXmlDateTime(prop) {
        // Implementation based up on http://stackoverflow.com/questions/8178598/xml-datetime-to-javascript-date-object
        // Improved to support full spec and optional parts
        var bits = prop.split(/[-T:+Z]/g);

        var d = new Date(bits[0], bits[1]-1, bits[2]);
        var secondBits = bits[5].split("\.");
        d.setHours(bits[3], bits[4], secondBits[0]);
        if(secondBits.length>1)
            d.setMilliseconds(secondBits[1]);

        // Get supplied time zone offset in minutes
        if(bits[6] && bits[7]) {
            var offsetMinutes = bits[6] * 60 + Number(bits[7]);
            var sign = /\d\d-\d\d:\d\d$/.test(prop)? '-' : '+';

            // Apply the sign
            offsetMinutes = 0 + (sign == '-'? -1 * offsetMinutes : offsetMinutes);

            // Apply offset and local timezone
            d.setMinutes(d.getMinutes() - offsetMinutes - d.getTimezoneOffset())
        }
        else
        if(prop.indexOf("Z", prop.length - 1) !== -1) {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));
        }

        // d is now a local time equivalent to the supplied time
        return d;
    }

    function checkFromXmlDateTimePaths(value, childName, fullPath) {
        if(config.datetimeAccessFormPaths.length > 0) {
            var path = fullPath.split("\.#")[0];
            var idx = 0;
            for(; idx < config.datetimeAccessFormPaths.length; idx++) {
                var dtPath = config.datetimeAccessFormPaths[idx];
                if( typeof dtPath === "string" ) {
                    if(dtPath == path)
                        break;
                }
                else
                if( dtPath instanceof RegExp) {
                    if(dtPath.test(path))
                        break;
                }
                else
                if( typeof dtPath === "function") {
                    if(dtPath(obj, childName, path))
                        break;
                }
            }
            if(idx!=config.datetimeAccessFormPaths.length) {
                return fromXmlDateTime(value);
            }
            else
                return value;
        }
        else
            return value;
    }

    function parseDOMChildren( node, path ) {
        if(node.nodeType == DOMNodeTypes.DOCUMENT_NODE) {
            var result = new Object;
            var nodeChildren = node.childNodes;
            // Alternative for firstElementChild which is not supported in some environments
            for(var cidx=0; cidx <nodeChildren.length; cidx++) {
                var child = nodeChildren.item(cidx);
                if(child.nodeType == DOMNodeTypes.ELEMENT_NODE) {
                    var childName = getNodeLocalName(child);
                    result[childName] = parseDOMChildren(child, childName);
                }
            }
            return result;
        }
        else
        if(node.nodeType == DOMNodeTypes.ELEMENT_NODE) {
            var result = new Object;
            result.__cnt=0;

            var nodeChildren = node.childNodes;

            // Children nodes
            for(var cidx=0; cidx <nodeChildren.length; cidx++) {
                var child = nodeChildren.item(cidx); // nodeChildren[cidx];
                var childName = getNodeLocalName(child);

                if(child.nodeType!= DOMNodeTypes.COMMENT_NODE) {
                    result.__cnt++;
                    if(result[childName] == null) {
                        result[childName] = parseDOMChildren(child, path+"."+childName);
                        toArrayAccessForm(result, childName, path+"."+childName);
                    }
                    else {
                        if(result[childName] != null) {
                            if( !(result[childName] instanceof Array)) {
                                result[childName] = [result[childName]];
                                toArrayAccessForm(result, childName, path+"."+childName);
                            }
                        }
                        (result[childName])[result[childName].length] = parseDOMChildren(child, path+"."+childName);
                    }
                }
            }

            // Attributes
            for(var aidx=0; aidx <node.attributes.length; aidx++) {
                var attr = node.attributes.item(aidx); // [aidx];
                result.__cnt++;
                result[config.attributePrefix+attr.name]=attr.value;
            }

            // Node namespace prefix
            var nodePrefix = getNodePrefix(node);
            if(nodePrefix!=null && nodePrefix!="") {
                result.__cnt++;
                result.__prefix=nodePrefix;
            }

            if(result["#text"]!=null) {
                result.__text = result["#text"];
                if(result.__text instanceof Array) {
                    result.__text = result.__text.join("\n");
                }
                if(config.escapeMode)
                    result.__text = unescapeXmlChars(result.__text);
                if(config.stripWhitespaces)
                    result.__text = result.__text.trim();
                delete result["#text"];
                if(config.arrayAccessForm=="property")
                    delete result["#text_asArray"];
                result.__text = checkFromXmlDateTimePaths(result.__text, childName, path+"."+childName);
            }
            if(result["#cdata-section"]!=null) {
                result.__cdata = result["#cdata-section"];
                delete result["#cdata-section"];
                if(config.arrayAccessForm=="property")
                    delete result["#cdata-section_asArray"];
            }

            if( result.__cnt == 1 && result.__text!=null  ) {
                result = result.__text;
            }
            else
            if( result.__cnt == 0 && config.emptyNodeForm=="text" ) {
                result = '';
            }
            else
            if ( result.__cnt > 1 && result.__text!=null && config.skipEmptyTextNodesForObj) {
                if( (config.stripWhitespaces && result.__text=="") || (result.__text.trim()=="")) {
                    delete result.__text;
                }
            }
            delete result.__cnt;

            if( config.enableToStringFunc && (result.__text!=null || result.__cdata!=null )) {
                result.toString = function() {
                    return (this.__text!=null? this.__text:'')+( this.__cdata!=null ? this.__cdata:'');
                };
            }

            return result;
        }
        else
        if(node.nodeType == DOMNodeTypes.TEXT_NODE || node.nodeType == DOMNodeTypes.CDATA_SECTION_NODE) {
            return node.nodeValue;
        }
    }

    function startTag(jsonObj, element, attrList, closed) {
        var resultStr = "<"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+":"):"") + element;
        if(attrList!=null) {
            for(var aidx = 0; aidx < attrList.length; aidx++) {
                var attrName = attrList[aidx];
                var attrVal = jsonObj[attrName];
                if(config.escapeMode)
                    attrVal=escapeXmlChars(attrVal);
                resultStr+=" "+attrName.substr(config.attributePrefix.length)+"='"+attrVal+"'";
            }
        }
        if(!closed)
            resultStr+=">";
        else
            resultStr+="/>";
        return resultStr;
    }

    function endTag(jsonObj,elementName) {
        return "</"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+":"):"")+elementName+">";
    }

    function endsWith(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }

    function jsonXmlSpecialElem ( jsonObj, jsonObjField ) {
        if((config.arrayAccessForm=="property" && endsWith(jsonObjField.toString(),("_asArray")))
            || jsonObjField.toString().indexOf(config.attributePrefix)==0
            || jsonObjField.toString().indexOf("__")==0
            || (jsonObj[jsonObjField] instanceof Function) )
            return true;
        else
            return false;
    }

    function jsonXmlElemCount ( jsonObj ) {
        var elementsCnt = 0;
        if(jsonObj instanceof Object ) {
            for( var it in jsonObj  ) {
                if(jsonXmlSpecialElem ( jsonObj, it) )
                    continue;
                elementsCnt++;
            }
        }
        return elementsCnt;
    }

    function parseJSONAttributes ( jsonObj ) {
        var attrList = [];
        if(jsonObj instanceof Object ) {
            for( var ait in jsonObj  ) {
                if(ait.toString().indexOf("__")== -1 && ait.toString().indexOf(config.attributePrefix)==0) {
                    attrList.push(ait);
                }
            }
        }
        return attrList;
    }

    function parseJSONTextAttrs ( jsonTxtObj ) {
        var result ="";

        if(jsonTxtObj.__cdata!=null) {
            result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";
        }

        if(jsonTxtObj.__text!=null) {
            if(config.escapeMode)
                result+=escapeXmlChars(jsonTxtObj.__text);
            else
                result+=jsonTxtObj.__text;
        }
        return result;
    }

    function parseJSONTextObject ( jsonTxtObj ) {
        var result ="";

        if( jsonTxtObj instanceof Object ) {
            result+=parseJSONTextAttrs ( jsonTxtObj );
        }
        else
        if(jsonTxtObj!=null) {
            if(config.escapeMode)
                result+=escapeXmlChars(jsonTxtObj);
            else
                result+=jsonTxtObj;
        }

        return result;
    }

    function parseJSONArray ( jsonArrRoot, jsonArrObj, attrList ) {
        var result = "";
        if(jsonArrRoot.length == 0) {
            result+=startTag(jsonArrRoot, jsonArrObj, attrList, true);
        }
        else {
            for(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {
                result+=startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), false);
                result+=parseJSONObject(jsonArrRoot[arIdx]);
                result+=endTag(jsonArrRoot[arIdx],jsonArrObj);
            }
        }
        return result;
    }

    function parseJSONObject ( jsonObj ) {
        var result = "";

        var elementsCnt = jsonXmlElemCount ( jsonObj );

        if(elementsCnt > 0) {
            for( var it in jsonObj ) {

                if(jsonXmlSpecialElem ( jsonObj, it) )
                    continue;

                var subObj = jsonObj[it];

                var attrList = parseJSONAttributes( subObj )

                if(subObj == null || subObj == undefined) {
                    result+=startTag(subObj, it, attrList, true);
                }
                else
                if(subObj instanceof Object) {

                    if(subObj instanceof Array) {
                        result+=parseJSONArray( subObj, it, attrList );
                    }
                    else if(subObj instanceof Date) {
                        result+=startTag(subObj, it, attrList, false);
                        result+=subObj.toISOString();
                        result+=endTag(subObj,it);
                    }
                    else {
                        var subObjElementsCnt = jsonXmlElemCount ( subObj );
                        if(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {
                            result+=startTag(subObj, it, attrList, false);
                            result+=parseJSONObject(subObj);
                            result+=endTag(subObj,it);
                        }
                        else {
                            result+=startTag(subObj, it, attrList, true);
                        }
                    }
                }
                else {
                    result+=startTag(subObj, it, attrList, false);
                    result+=parseJSONTextObject(subObj);
                    result+=endTag(subObj,it);
                }
            }
        }
        result+=parseJSONTextObject(jsonObj);

        return result;
    }

    this.parseXmlString = function(xmlDocStr) {
        var isIEParser = window.ActiveXObject || "ActiveXObject" in window;
        if (xmlDocStr === undefined) {
            return null;
        }
        var xmlDoc;
        if (window.DOMParser) {
            var parser=new window.DOMParser();
            var parsererrorNS = null;
            // IE9+ now is here
            if(!isIEParser) {
                try {
                    parsererrorNS = parser.parseFromString("INVALID", "text/xml").childNodes[0].namespaceURI;
                }
                catch(err) {
                    parsererrorNS = null;
                }
            }
            try {
                xmlDoc = parser.parseFromString( xmlDocStr, "text/xml" );
                if( parsererrorNS!= null && xmlDoc.getElementsByTagNameNS(parsererrorNS, "parsererror").length > 0) {
                    //throw new Error('Error parsing XML: '+xmlDocStr);
                    xmlDoc = null;
                }
            }
            catch(err) {
                xmlDoc = null;
            }
        }
        else {
            // IE :(
            if(xmlDocStr.indexOf("<?")==0) {
                xmlDocStr = xmlDocStr.substr( xmlDocStr.indexOf("?>") + 2 );
            }
            xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async="false";
            xmlDoc.loadXML(xmlDocStr);
        }
        return xmlDoc;
    };

    this.asArray = function(prop) {
        if(prop instanceof Array)
            return prop;
        else
            return [prop];
    };

    this.toXmlDateTime = function(dt) {
        if(dt instanceof Date)
            return dt.toISOString();
        else
        if(typeof(dt) === 'number' )
            return new Date(dt).toISOString();
        else
            return null;
    };

    this.asDateTime = function(prop) {
        if(typeof(prop) == "string") {
            return fromXmlDateTime(prop);
        }
        else
            return prop;
    };

    this.xml2json = function (xmlDoc) {
        return parseDOMChildren ( xmlDoc );
    };

    this.xml_str2json = function (xmlDocStr) {
        var xmlDoc = this.parseXmlString(xmlDocStr);
        if(xmlDoc!=null)
            return this.xml2json(xmlDoc);
        else
            return null;
    };

    this.json2xml_str = function (jsonObj) {
        return parseJSONObject ( jsonObj );
    };

    this.json2xml = function (jsonObj) {
        var xmlDocStr = this.json2xml_str (jsonObj);
        return this.parseXmlString(xmlDocStr);
    };

    this.getVersion = function () {
        return VERSION;
    };

}

},{}],"adapters/adapters":[function(require,module,exports){
var PresenceShow, PresenceType, X2JS, XMPPPresence, _, hasProps, presenceShowToStatus, presenceToStatus, x2js,
  hasProp = {}.hasOwnProperty;

_ = require('underscore');

X2JS = require('xml-json-parser');

PresenceType = require('enum/presence_type');

PresenceShow = require('enum/presence_show');

XMPPPresence = require('enum/xmpp_presence');

x2js = new X2JS();

exports.convertToJSON = _.bind(function(data) {
  return this.jsonAttrs(this.xmlToJSON(data));
}, this);

exports.xmlToJSON = function(data) {
  return x2js.xml2json(data);
};

exports.jsonAttrs = function(data, options) {
  var attrObjectName, nameTransform, processAttrs, ref, regexp, textPropertyName, textRegexp;
  if (options == null) {
    options = {};
  }
  ref = _.defaults(options, {
    attrObjectName: 'attributes',
    textPropertyName: 'text',
    regexp: /^_/,
    textRegexp: /^__text/,
    nameTransform: function(name) {
      return name.slice(1);
    }
  }), attrObjectName = ref.attrObjectName, textPropertyName = ref.textPropertyName, regexp = ref.regexp, textRegexp = ref.textRegexp, nameTransform = ref.nameTransform;
  processAttrs = function(obj) {
    var attrs, el, i, key, len, text, value;
    if (!hasProps(obj)) {
      return obj;
    }
    if (_.isArray(obj)) {
      for (i = 0, len = obj.length; i < len; i++) {
        el = obj[i];
        processAttrs(el);
      }
    } else {
      attrs = {};
      text = '';
      for (key in obj) {
        if (!hasProp.call(obj, key)) continue;
        value = obj[key];
        if (key.match(textRegexp)) {
          text = value;
          delete obj[key];
        } else if (key.match(regexp)) {
          attrs[nameTransform(key)] = value;
          delete obj[key];
        } else {
          processAttrs(value);
        }
      }
      if (!_.isEmpty(attrs)) {
        obj[attrObjectName] = attrs;
      }
      if (text) {
        obj[textPropertyName] = text;
      }
    }
    return obj;
  };
  return processAttrs(data);
};

exports.convertToJSON = _.bind(function(data) {
  return this.jsonAttrs(this.xmlToJSON(data) || data);
}, this);

exports.parseXMPPPresence = _.bind(function(data) {
  var attributes, ref, show, type;
  data = this.convertToJSON(data);
  ref = this.convertToJSON(data), attributes = ref.attributes, show = ref.show;
  type = attributes != null ? attributes.type : void 0;
  return {
    jid: Strophe.getBareJidFromJid(data.attributes.from),
    email: data.attributes.email || "",
    presence: presenceToStatus(type, show),
    status: ""
  };
}, this);

presenceToStatus = function(type, show) {
  if (type === PresenceType.UNAVAILABLE) {
    return XMPPPresence.UNAVAILABLE;
  } else if (show) {
    return presenceShowToStatus(show);
  } else {
    return XMPPPresence.AVAILABLE;
  }
};

presenceShowToStatus = function(show) {
  switch (show) {
    case PresenceShow.AWAY:
    case PresenceShow.EXTENDED_AWAY:
    case PresenceShow.DND:
      return show;
    default:
      return XMPPPresence.AVAILABLE;
  }
};

hasProps = function(obj) {
  if (obj == null) {
    obj = {};
  }
  return _.isObject(obj) && !_.isEmpty(obj);
};

module.exports = exports;


},{"enum/presence_show":"enum/presence_show","enum/presence_type":"enum/presence_type","enum/xmpp_presence":"enum/xmpp_presence","underscore":85,"xml-json-parser":90}],"adapters/data_payload":[function(require,module,exports){
var _, adapters, getStropheAdapters;

_ = require('underscore');

adapters = require('adapters/adapters');

module.exports.getData = function(stanza) {
  var adapterFunctions, convertToJSON;
  convertToJSON = adapters.convertToJSON;
  adapterFunctions = _.extend({}, adapters, getStropheAdapters());
  if (!stanza) {
    return {};
  }
  return {
    xml: stanza,
    json: convertToJSON(stanza),
    adapters: adapterFunctions
  };
};

getStropheAdapters = function() {
  return {
    getBareJID: Strophe.getBareJidFromJid,
    getResource: function(jid) {
      return Strophe.getResourceFromJid(jid) || "";
    }
  };
};


},{"adapters/adapters":"adapters/adapters","underscore":85}],"adapters/preferences":[function(require,module,exports){
var ActiveConversationId, ActiveConversationName, ActiveConversationType, ActivityMonitorWInt, AllowUnreadBool, ChatConvoXInt, CloseParticipantsBool, CloseSidebarBool, ContactIds, ContainerWInt, ConvPrevInt, DefaultBgColor, DefaultColorThemeStr, DefaultTextColor, EnableIntnlKbBool, FocusedConversationId, FontSizeStr, FontStyleStr, GroupCollapsedBool, GroupId, GroupName, HideOfflineContactsBool, IdleTimeInt, MainContentRtInt, MainContentWInt, MessageThemeStr, ParticipantViewSortStr, ParticipantsWInt, ShowCompanyBool, SidebarWInt, UIParticipantsWInt, WindowWInt, X2JS, YahooEnabledBool, YahooUserStr, _, alertsSchema, blastsSchema, conversationsSchema, emSchema, f, globalSchema, hardTrim, toJSON, toXML, validBool, validLimit, validNumber, validPrimitive, validString, validValue, voom, x2js,
  slice = [].slice;

voom = require('voom');

X2JS = require('xml-json-parser');

_ = require('underscore');

f = voom.f;

x2js = new X2JS();

validBool = function(data) {
  var ref;
  if (_.isBoolean(data)) {
    return data;
  }
  if (_.isString(data)) {
    if (data === 'true') {
      return true;
    }
    if (data === 'false') {
      return false;
    }
  }
  return console.warn('[Preferences] Invalid boolean at', validBool != null ? (ref = validBool.caller) != null ? ref.name : void 0 : void 0, ':', data);
};

validNumber = function(data) {
  var ref;
  if (_.isNumber(data)) {
    return data;
  }
  if (_.isString(data)) {
    return +data;
  }
  return console.warn('[Preferences] Invalid number at', validNumber != null ? (ref = validNumber.caller) != null ? ref.name : void 0 : void 0, ':', data);
};

validString = function(data) {
  var ref;
  if (_.isString(data)) {
    return data;
  }
  return console.warn('[Preferences] Invalid string at', validString != null ? (ref = validString.caller) != null ? ref.name : void 0 : void 0, ':', data);
};

validPrimitive = function(data) {
  var ref;
  if (!_.isObject(data)) {
    return data;
  }
  return console.warn('[Preferences] Invalid primitive at', validPrimitive != null ? (ref = validPrimitive.caller) != null ? ref.name : void 0 : void 0, ':', data);
};

validValue = function() {
  var location, ref, vals;
  location = validValue != null ? (ref = validValue.caller) != null ? ref.name : void 0 : void 0;
  vals = Array.prototype.slice.call(arguments);
  return function(data) {
    if (!_.contains(vals, data)) {
      console.warn('[Preferences] Invalid value at', location, ':', data, 'not in', vals.toString());
    }
    return data;
  };
};

validLimit = function(num, options) {
  var location, ref, ref1, trim;
  if (options == null) {
    options = {};
  }
  ref1 = _.defaults(options, {
    trim: true,
    location: validLimit != null ? (ref = validLimit.caller) != null ? ref.name : void 0 : void 0
  }), trim = ref1.trim, location = ref1.location;
  return function(data) {
    if (_.isArray(data) && (data.length > num)) {
      console.warn('[Preferences] Data exceeds limit at', location, ':', data.length, '>', num);
      if (trim) {
        data = data.slice(0, num);
      }
    }
    return data;
  };
};

ActiveConversationId = function(data) {
  return validString(data);
};

ActiveConversationName = function(data) {
  return validString(data);
};

ActiveConversationType = function(data) {
  return validValue('chat', 'managedchat', 'bilateral', 'multiparty', 'blast', 'mergedchat')(data);
};

ActivityMonitorWInt = function(data) {
  return validNumber(data);
};

AllowUnreadBool = function(data) {
  return validBool(data);
};

ChatConvoXInt = function(data) {
  return validNumber(data);
};

CloseParticipantsBool = function(data) {
  return validBool(data);
};

CloseSidebarBool = function(data) {
  return validBool(data);
};

ContactIds = function(data) {
  return validLimit(100)(data);
};

ContainerWInt = function(data) {
  return validNumber(data);
};

ConvPrevInt = function(data) {
  return validNumber(data);
};

DefaultColorThemeStr = function(data) {
  return validString(data);
};

DefaultBgColor = function(data) {
  return validString(data);
};

DefaultTextColor = function(data) {
  return validString(data);
};

EnableIntnlKbBool = function(data) {
  return validBool(data);
};

FocusedConversationId = function(data) {
  return validString(data);
};

FontSizeStr = function(data) {
  return validValue('sm', 'med', 'lg', 'xl')(data);
};

FontStyleStr = function(data) {
  return validValue('arial', 'times', 'courier', 'verdana', 'georgia')(data);
};

GroupCollapsedBool = function(data) {
  return validBool(data);
};

GroupId = function(data) {
  return validPrimitive(data);
};

GroupName = function(data) {
  return validString(data);
};

HideOfflineContactsBool = function(data) {
  return validBool(data);
};

IdleTimeInt = function(data) {
  return validNumber(data);
};

MainContentRtInt = function(data) {
  return validNumber(data);
};

MainContentWInt = function(data) {
  return validNumber(data);
};

MessageThemeStr = function(data) {
  return validValue('compact', 'expanded')(data);
};

ParticipantsWInt = function(data) {
  return validNumber(data);
};

ParticipantViewSortStr = function(data) {
  return validValue('first_name', 'last_name', 'company')(data);
};

ShowCompanyBool = function(data) {
  return validBool(data);
};

SidebarWInt = function(data) {
  return validNumber(data);
};

UIParticipantsWInt = function(data) {
  return validNumber(data);
};

WindowWInt = function(data) {
  return validNumber(data);
};

YahooEnabledBool = function(data) {
  return validBool(data);
};

YahooUserStr = function(data) {
  return validString(data);
};

globalSchema = {
  'Preferences': {
    'FocusedConversation': FocusedConversationId
  }
};

emSchema = {
  'Preferences': {
    'AllowUnreadChatroomIndicator': {
      '_enabled': AllowUnreadBool
    },
    'CloseParticipants': {
      '_enabled': CloseParticipantsBool
    },
    'CloseSidebar': {
      '_enabled': CloseSidebarBool
    },
    'ConversationDefaultColors': {
      '_theme': DefaultColorThemeStr,
      '_backgroundColor': DefaultBgColor,
      '_textColor': DefaultTextColor
    },
    'ConversationPreviewLines': ConvPrevInt,
    'EnableInternationalKeyboard': {
      '_enabled': EnableIntnlKbBool
    },
    'FontSize': FontSizeStr,
    'FontStyle': FontStyleStr,
    'Groups': {
      'Group': [
        {
          '_id': GroupId,
          '_name': GroupName,
          '_collapsed': GroupCollapsedBool
        }
      ]
    },
    'HideOfflineContacts': {
      '_enabled': HideOfflineContactsBool
    },
    'HighlightWords': 'HighlightWordsParser',
    'MessageTheme': {
      '_showCompany': ShowCompanyBool,
      '__text': MessageThemeStr
    },
    'ParticipantsWidth': ParticipantsWInt,
    'ParticipantViewSort': ParticipantViewSortStr,
    'StoredIdleTimeInMinutes': IdleTimeInt,
    'UISizes': {
      'ActivityMonitorWidth': ActivityMonitorWInt,
      'ChatConvoX': ChatConvoXInt,
      'MainContentContainerWidth': ContainerWInt,
      'MainContentRight': MainContentRtInt,
      'MainContentWidth': MainContentWInt,
      'ParticipantsWidth': UIParticipantsWInt,
      'SidebarWidth': SidebarWInt,
      'WindowWidth': WindowWInt
    },
    'YahooAutoLogin': {
      '_enabled': YahooEnabledBool
    },
    'YahooUserName': YahooUserStr
  }
};

alertsSchema = {
  'Preferences': {
    'PersonalAlerts': 'PersonalAlertsParser',
    'GlobalAlerts': 'GlobalAlertsParser'
  }
};

conversationsSchema = {
  'Preferences': {
    'ActiveConversations': {
      'Conversation': [
        {
          '_id': ActiveConversationId,
          '_name': ActiveConversationName,
          '_type': ActiveConversationType,
          '_contactIds': ContactIds
        }
      ]
    }
  }
};

blastsSchema = {
  'Preferences': {
    'AggregateConversations': {
      'AggregateConversation': [
        {
          '_id': 'ActiveConversationId',
          '_name': 'ActiveConversationName',
          '_type': 'ActiveConversationType',
          'RecipientId': 'ContactIds'
        }
      ]
    }
  }
};

hardTrim = function(data) {
  var alerts, convs, groups, ref, ref1, ref2, ref3, ref4, ref5;
  if (_.isArray((groups = data != null ? (ref = data.Preferences) != null ? (ref1 = ref.Groups) != null ? ref1.Group : void 0 : void 0 : void 0))) {
    data.Preferences.Groups.Group = validLimit(64, {
      location: 'Groups'
    })(groups);
  }
  if (_.isArray((convs = data != null ? (ref2 = data.Preferences) != null ? (ref3 = ref2.ActiveConversations) != null ? ref3.Conversation : void 0 : void 0 : void 0))) {
    data.Preferences.ActiveConversations.Conversation = validLimit(50, {
      location: 'ActiveConversations'
    })(convs);
  }
  if (_.isArray((alerts = data != null ? (ref4 = data.Preferences) != null ? (ref5 = ref4.PersonalAlerts) != null ? ref5.Alert : void 0 : void 0 : void 0))) {
    data.Preferences.PersonalAlerts.Alert = validLimit(700, {
      location: 'PersonalAlerts'
    })(alerts);
  }
  return data;
};

toXML = x2js.json2xml.bind(x2js);

toJSON = x2js.xml_str2json.bind(x2js);

exports.toNitro = function() {
  var convertAlerts, convertBlasts, convertConvs, convertEM, convertGlobal, identity, onlyBlasts, post, schema, transforms;
  schema = arguments[0], transforms = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  identity = function(x) {
    return x;
  };
  onlyBlasts = function(data) {
    var blasts, convs, ref, ref1;
    convs = _.array(data != null ? (ref = data.Preferences) != null ? (ref1 = ref.AggregateConversations) != null ? ref1.AggregateConversation : void 0 : void 0 : void 0);
    blasts = convs.filter(function(conv) {
      return conv._type === 'blast';
    });
    return {
      'Preferences': {
        'AggregateConversations': {
          'AggregateConversation': blasts
        }
      }
    };
  };
  if (transforms.length) {
    post = voom.f.apply(null, transforms);
  } else {
    post = identity;
  }
  convertGlobal = f(schema, globalSchema, post, hardTrim);
  convertConvs = f(schema, conversationsSchema, post, hardTrim);
  convertEM = f(schema, emSchema, post, hardTrim);
  convertAlerts = f(schema, alertsSchema, post, hardTrim);
  convertBlasts = f(conversationsSchema, blastsSchema, onlyBlasts, post, hardTrim);
  return function(data) {
    var convertedConvs;
    convertedConvs = convertConvs(data);
    return {
      'global': toXML(convertGlobal(data)),
      'conversations': toXML(convertedConvs),
      'em': toXML(convertEM(data)),
      'alerts': toXML(convertAlerts(data)),
      'blasts': toXML(convertBlasts(convertedConvs))
    };
  };
};

exports.fromNitro = function() {
  var convertAlerts, convertConvs, convertEM, convertGlobal, identity, pre, ref, ref1, ref2, ref3, schemas, transforms;
  schemas = arguments[0], transforms = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  identity = function(x) {
    return x;
  };
  if (transforms.length) {
    pre = voom.f.apply(null, transforms);
  } else {
    pre = identity;
  }
  convertGlobal = f(toJSON, pre, globalSchema, (ref = schemas.global) != null ? ref : schemas);
  convertConvs = f(toJSON, pre, conversationsSchema, (ref1 = schemas.conversations) != null ? ref1 : schemas);
  convertEM = f(toJSON, pre, emSchema, (ref2 = schemas.em) != null ? ref2 : schemas);
  convertAlerts = f(toJSON, pre, alertsSchema, (ref3 = schemas.alerts) != null ? ref3 : schemas);
  return function(data) {
    var alerts, blasts, conversations, em, global;
    if (data == null) {
      data = {};
    }
    global = data.global ? convertGlobal(data.global) : '';
    conversations = data.conversations ? convertConvs(data.conversations) : '';
    em = data.em ? convertEM(data.em) : '';
    alerts = data.alerts ? convertAlerts(data.alerts) : '';
    blasts = '';
    return {
      'global': global,
      'conversations': conversations,
      'em': em,
      'alerts': alerts,
      'blasts': blasts
    };
  };
};

exports.toXML = toXML;

exports.toJSON = toJSON;

exports.f = voom.f;


},{"underscore":85,"voom":86,"xml-json-parser":90}],"components/blocklist":[function(require,module,exports){
var Blocklist, NitroPromise, Q, Utils, _, adapters, stropheBlocklist;

_ = require('underscore');

_.mixin(require('util/retryer'));

Utils = require('util/utils');

Q = require('q');

NitroPromise = require('util/promise');

stropheBlocklist = require('strophe/strophe_blocklist');

adapters = require('adapters/adapters');

module.exports = Blocklist = (function() {
  var PrivateBlocklist, instance;

  function Blocklist() {}

  Blocklist.NAME = 'component.blocklist';

  instance = null;

  Blocklist.get = function(options) {
    var createInstance;
    if (options == null) {
      options = {};
    }
    createInstance = function() {
      return new PrivateBlocklist(options);
    };
    return instance != null ? instance : instance = createInstance();
  };

  Blocklist.destroy = Utils.returnBool(function() {
    return instance = null;
  });

  PrivateBlocklist = (function() {
    var sendBlocklistIQ, sendIQ;

    PrivateBlocklist.prototype.helper = null;

    sendIQ = null;

    function PrivateBlocklist(options) {
      var ref;
      if (options == null) {
        options = {};
      }
      ref = _.defaults(options, {
        helper: stropheBlocklist
      }), this.helper = ref.helper, sendIQ = ref.sendIQ;
    }

    PrivateBlocklist.prototype.getBlocklist = function() {
      var stanza;
      stanza = this.helper.getBlocklistStanza();
      return sendBlocklistIQ(stanza);
    };

    PrivateBlocklist.prototype.block = function(jids) {
      var stanza;
      if (jids == null) {
        jids = [];
      }
      jids = Utils.array(jids);
      stanza = this.helper.getBlockStanza(jids);
      return sendBlocklistIQ(stanza);
    };

    PrivateBlocklist.prototype.unblock = function(jids) {
      var stanza;
      if (jids == null) {
        jids = [];
      }
      jids = Utils.array(jids);
      stanza = this.helper.getUnblockStanza(jids);
      return sendBlocklistIQ(stanza);
    };

    sendBlocklistIQ = function(stanza, options) {
      if (options == null) {
        options = {};
      }
      return NitroPromise(function(resolve, reject) {
        return sendIQ({
          element: stanza,
          resolve: resolve,
          reject: reject
        });
      });
    };

    return PrivateBlocklist;

  })();

  return Blocklist;

})();


},{"adapters/adapters":"adapters/adapters","q":47,"strophe/strophe_blocklist":"strophe/strophe_blocklist","underscore":85,"util/promise":"util/promise","util/retryer":"util/retryer","util/utils":"util/utils"}],"components/gateway":[function(require,module,exports){
var Gateway, GatewayError, GatewayState, NitroPromise, PresenceType, Q, XMPPPresence, XMPPUtils, _;

_ = require('underscore');

Q = require('q');

PresenceType = require('enum/presence_type');

XMPPPresence = require('enum/xmpp_presence');

GatewayState = require('enum/gateway_state');

GatewayError = require('enum/gateway_error');

XMPPUtils = require('util/xmpp_utils');

NitroPromise = require('util/promise');

module.exports = Gateway = (function() {
  var attemptRegistration, attemptUnregistration, getPendingMessage, limitedRegistrationSendIQ, send, sendIQ;

  Gateway.prototype.jid = null;

  Gateway.prototype.helper = null;

  Gateway.prototype._registerDfd = null;

  Gateway.prototype._unregisterDfd = null;

  send = null;

  sendIQ = null;

  limitedRegistrationSendIQ = null;

  function Gateway(options) {
    this.helper = options.helper, send = options.send, sendIQ = options.sendIQ;
    limitedRegistrationSendIQ = _.limit(sendIQ, {
      max: 5,
      time: 60 * 1000,
      context: this
    });
  }

  Gateway.prototype.register = function(options) {
    var pendingMsg, promise;
    if (options == null) {
      options = {};
    }
    if (this._registerDfd) {
      promise = this._registerDfd.promise;
      if (promise.isPending()) {
        pendingMsg = getPendingMessage(this.status);
        this._registerDfd.notify(status, pendingMsg);
        return promise;
      }
    }
    return attemptRegistration.call(this, options);
  };

  Gateway.prototype.unregister = function(reason) {
    var pendingMsg, promise;
    if (this._unregisterDfd) {
      promise = this._unregisterDfd.promise;
      if (promise.isPending()) {
        pendingMsg = getPendingMessage(this.status);
        this._unregisterDfd.notify(status, pendingMsg);
        return promise;
      }
    }
    return attemptUnregistration.call(this, reason);
  };

  Gateway.prototype.setPresence = function(options) {
    var jid, presence, ref, type;
    if (options == null) {
      options = {};
    }
    ref = _.defaults(options, {
      jid: this.jid,
      type: XMPPUtils.xmppPresenceToType(presence)
    }), jid = ref.jid, type = ref.type, presence = ref.presence;
    return NitroPromise((function(_this) {
      return function(resolve, reject, progress) {
        var show, stanza;
        show = XMPPUtils.xmppPresenceToShow(presence);
        stanza = _this.helper.getSubscriptionStanza(jid, type, show);
        return send({
          element: stanza,
          resolve: resolve
        });
      };
    })(this));
  };

  Gateway.prototype.toggleConnection = function(nitroConnected, selfJID) {
    var bareJID, domain;
    this.nitroConnected = nitroConnected;
    if (selfJID == null) {
      selfJID = '';
    }
    if (this.nitroConnected) {
      bareJID = Strophe.getBareJidFromJid(selfJID);
      domain = XMPPUtils.getXMPPDomain(bareJID);
      this.jid = "yahoo." + domain;
    } else {
      this.status = GatewayState.UNREGISTERED;
      this.jid = null;
    }
    return this;
  };

  Gateway.prototype.addContact = function(contact) {
    var groups, jid, name, promise, ref;
    if (typeof contact === 'string') {
      contact = {
        jid: contact
      };
    }
    ref = _.defaults(contact, {
      jid: '',
      name: "",
      groups: []
    }), jid = ref.jid, name = ref.name, groups = ref.groups;
    return promise = NitroPromise((function(_this) {
      return function(resolve, reject) {
        if (!jid) {
          return reject("Attempting to add an invalid contact to the Roster");
        }
        return send({
          element: _this.helper.getAddContactStanza(jid),
          resolve: resolve,
          reject: reject
        });
      };
    })(this));
  };

  Gateway.prototype.acceptInvite = function(contact) {
    var groups, jid, name, promise, ref;
    if (typeof contact === 'string') {
      contact = {
        jid: contact
      };
    }
    ref = _.defaults(contact, {
      jid: '',
      name: "",
      groups: []
    }), jid = ref.jid, name = ref.name, groups = ref.groups;
    return promise = NitroPromise((function(_this) {
      return function(resolve, reject) {
        if (!jid) {
          return reject("Attempting to add an invalid contact to the Roster");
        }
        return send({
          element: _this.helper.getAllowContactStanza(jid),
          resolve: resolve,
          reject: reject
        });
      };
    })(this));
  };

  Gateway.prototype.removeContact = function(jid) {
    return NitroPromise((function(_this) {
      return function(resolve, reject) {
        return send({
          element: _this.helper.getRemoveContactStanza(jid),
          resolve: resolve,
          reject: reject
        });
      };
    })(this));
  };

  attemptRegistration = function(options) {
    var autoLogin, element, limitError, password, username;
    if (options == null) {
      options = {};
    }
    this._registerDfd = Q.defer();
    username = options.username, password = options.password, autoLogin = options.autoLogin;
    if (!(username && (password || autoLogin))) {
      this._registerDfd.reject(GatewayError.INVALID_CREDENTIALS);
      return this._registerDfd.promise;
    }
    if (!this.nitroConnected) {
      this._registerDfd.reject(GatewayError.NO_NITRO_CONNECTION);
      return this._registerDfd.promise;
    }
    element = this.helper.getRegisterStanza(this.jid, username, password, autoLogin);
    limitError = limitedRegistrationSendIQ({
      element: element,
      resolve: this._registerDfd.resolve,
      reject: this._registerDfd.reject
    });
    if (limitError instanceof Error) {
      console.error("[Gateway]", limitError.message);
      this._registerDfd.reject({
        json: {
          error: limitError.message
        }
      });
    }
    return this._registerDfd.promise;
  };

  attemptUnregistration = function(reason) {
    var stanza;
    this._registerDfd = Q.defer();
    stanza = this.helper.getUnregisterStanza(this.jid);
    sendIQ({
      element: stanza,
      resolve: this._registerDfd.resolve,
      reject: this._registerDfd.reject
    });
    return this._registerDfd.promise;
  };

  getPendingMessage = function(status) {
    switch (status) {
      case GatewayState.REGISTERING:
        return GatewayError.ALREADY_REGISTERING;
      case Connection.SUBSCRIBING:
        return GatewayError.ALREADY_SUBSCRIBING;
      case GatewayState.UNREGISTERING:
        return GatewayError.ALREADY_UNREGISTERING;
      case Connection.UNSUBSCRIBING:
        return GatewayError.ALREADY_UNSUBSCRIBING;
      default:
        return "";
    }
  };

  return Gateway;

})();


},{"enum/gateway_error":"enum/gateway_error","enum/gateway_state":"enum/gateway_state","enum/presence_type":"enum/presence_type","enum/xmpp_presence":"enum/xmpp_presence","q":47,"underscore":85,"util/promise":"util/promise","util/xmpp_utils":"util/xmpp_utils"}],"components/messaging":[function(require,module,exports){
var Matchers, Messaging, NitroPromise, Q, Utils, _, stropheMessaging;

Q = require('Q');

NitroPromise = require('util/promise');

_ = require('underscore');

Utils = require('util/utils');

Matchers = require('util/matchers');

stropheMessaging = require('strophe/strophe_messaging');

Messaging = (function() {
  var PrivateMessaging, instance;

  function Messaging() {}

  Messaging.NAME = 'component.messaging';

  instance = null;

  Messaging.get = function(options) {
    var createInstance;
    createInstance = function() {
      return new PrivateMessaging(options);
    };
    return instance != null ? instance : instance = createInstance();
  };

  Messaging.destroy = Utils.returnBool(function() {
    return instance = null;
  });

  PrivateMessaging = (function() {
    var send, sendIQ;

    send = null;

    sendIQ = null;

    function PrivateMessaging(options) {
      var ref;
      if (options == null) {
        options = {};
      }
      ref = _.defaults(options, {
        helper: stropheMessaging
      }), this.helper = ref.helper, send = ref.send, sendIQ = ref.sendIQ;
    }

    PrivateMessaging.prototype.send = function(message) {
      var body, id, jid, type;
      if (message == null) {
        message = {};
      }
      jid = message.jid, body = message.body, type = message.type, id = message.id;
      return NitroPromise((function(_this) {
        return function(resolve, reject) {
          if (!(jid && body)) {
            return reject("Invalid message");
          }
          return send({
            element: _this.helper.getSendStanza(jid, body, type, id),
            resolve: resolve
          });
        };
      })(this));
    };

    PrivateMessaging.prototype.sendTyping = function(jid) {
      return NitroPromise((function(_this) {
        return function(resolve, reject) {
          if (!jid) {
            return reject("Invalid message");
          }
          send({
            element: _this.helper.getTypingStanza(jid)
          });
          return {
            resolve: resolve
          };
        };
      })(this));
    };

    PrivateMessaging.prototype.getHistory = function(options) {
      var before, jid, max;
      if (options == null) {
        options = {};
      }
      jid = options.jid, before = options.before, max = options.max;
      return NitroPromise((function(_this) {
        return function(resolve, reject) {
          var getHistoryStanza;
          if (!jid) {
            return reject("Invalid conversation jid passed to history query");
          }
          getHistoryStanza = Matchers.isManagedGroupchat(jid) ? _this.helper.getManagedHistoryStanza : Matchers.isGroupchat(jid) ? _this.helper.getGroupchatHistoryStanza : _this.helper.getChatHistoryStanza;
          return sendIQ({
            element: getHistoryStanza(jid, before, max),
            resolve: resolve,
            reject: reject
          });
        };
      })(this));
    };

    return PrivateMessaging;

  })();

  return Messaging;

})();

module.exports = Messaging;


},{"Q":1,"strophe/strophe_messaging":"strophe/strophe_messaging","underscore":85,"util/matchers":"util/matchers","util/promise":"util/promise","util/utils":"util/utils"}],"components/muc":[function(require,module,exports){
var Config, MUC, MUCField, MUCRole, Matchers, NitroPromise, Q, Sizzle, Utils, _, stropheMUC;

Q = require('Q');

NitroPromise = require('util/promise');

_ = require('underscore');

Sizzle = require('sizzle');

Config = require('config');

stropheMUC = require('strophe/strophe_muc');

MUCField = require('enum/muc_field');

MUCRole = require('enum/muc_role');

Utils = require('util/utils');

Matchers = require('util/matchers');

module.exports = MUC = (function() {
  var PrivateMUC, instance;

  function MUC() {}

  MUC.NAME = 'component.muc';

  MUC.INVALID_GROUPCHAT_JID = "Rejected due to an invalid groupchat jid";

  instance = null;

  MUC.get = function(options) {
    var createInstance;
    createInstance = function() {
      return new PrivateMUC(options);
    };
    return instance != null ? instance : instance = createInstance();
  };

  MUC.destroy = Utils.returnBool(function() {
    return instance = null;
  });

  PrivateMUC = (function() {
    var eventManager, getInvalidJIDString, getJID, getJIDRejectedPromise, isValidMUCJID, regexMUCDomain, regexMUCLocal, regexUserDomain, regexUserLocal, send, sendIQ, sendMUCRequest;

    send = null;

    sendIQ = null;

    getJID = null;

    eventManager = null;

    PrivateMUC.prototype.helper = null;

    regexUserLocal = /^([\w\\'"]\.?)+/i;

    regexUserDomain = /^(collab\.(reutest|thomsonreuters|icp2\.mpp\.reutest)\.com)$/i;

    regexMUCLocal = /^([\w\\'"~\$`!\+-={}\[\]]\.?)+/i;

    regexMUCDomain = /^(conference|legacychat)\.((reuasmb|reuters)\.net|array12\.msgtst\.reuters\.com)$/i;

    isValidMUCJID = function(jid) {
      var parts;
      if (!_.isString(jid)) {
        return false;
      }
      if ((parts = jid.split('@')).length !== 2) {
        return false;
      }
      return regexMUCLocal.test(parts[0]) && regexMUCDomain.test(parts[1]);
    };

    function PrivateMUC(options) {
      var ref;
      ref = _.defaults(options, {
        helper: stropheMUC
      }), this.helper = ref.helper, send = ref.send, sendIQ = ref.sendIQ, getJID = ref.getJID, eventManager = ref.eventManager;
    }

    PrivateMUC.prototype.selfJIDAsMUCResource = function() {
      var jid;
      if (jid = Strophe.getBareJidFromJid(getJID())) {
        return jid.replace('@', '__');
      } else {
        return '';
      }
    };

    PrivateMUC.prototype.getBareSelfJID = function() {
      return Strophe.getBareJidFromJid(getJID());
    };

    PrivateMUC.prototype.create = function(options) {
      var acceptDefaultConfiguration, jid, name;
      if (options == null) {
        options = {};
      }
      jid = options.jid, name = options.name;
      acceptDefaultConfiguration = _.bind(this.acceptDefaultConfiguration, this);
      return NitroPromise((function(_this) {
        return function(resolve, reject) {
          if (!isValidMUCJID(jid)) {
            return reject(getInvalidJIDString(jid));
          }
          return _this.join(jid).then(function(stanza) {
            return acceptDefaultConfiguration({
              jid: jid,
              name: name
            }).then(resolve);
          }).fail(reject);
        };
      })(this));
    };

    PrivateMUC.prototype.destroy = function(jid) {
      if (!isValidMUCJID(jid)) {
        return getJIDRejectedPromise(jid);
      }
      return sendMUCRequest(sendIQ, this.helper.getDestroyGroupchatStanza(jid));
    };

    PrivateMUC.prototype.acceptDefaultConfiguration = function(options) {
      var jid, name;
      jid = options.jid, name = options.name;
      if (!isValidMUCJID(jid)) {
        return getJIDRejectedPromise(jid);
      }
      return sendMUCRequest(sendIQ, this.helper.getGroupchatConfigForm(jid, MUCField.ROOM_NAME, name));
    };

    PrivateMUC.prototype.join = function(jid) {
      if (!isValidMUCJID(jid)) {
        return getJIDRejectedPromise(jid);
      }
      return sendMUCRequest(send, this.helper.getJoinStanza(jid, this.selfJIDAsMUCResource()));
    };

    PrivateMUC.prototype.leave = function(jid) {
      if (!isValidMUCJID(jid)) {
        return getJIDRejectedPromise(jid);
      }
      return sendMUCRequest(send, this.helper.getLeaveStanza(jid));
    };

    PrivateMUC.prototype.roomDisco = function(jid) {
      var stanzaHelper;
      if (!isValidMUCJID(jid)) {
        return getJIDRejectedPromise(jid);
      }
      stanzaHelper = Matchers.isManagedGroupchat(jid) ? this.helper.getManagedRoomDiscoStanza : this.helper.getRoomDiscoStanza;
      return sendMUCRequest(sendIQ, stanzaHelper(jid));
    };

    PrivateMUC.prototype.requestMemberList = function(jid, affiliations) {
      if (affiliations == null) {
        affiliations = MUCRole.OWNER;
      }
      if (!isValidMUCJID(jid)) {
        return getJIDRejectedPromise(jid);
      }
      affiliations = Utils.array(affiliations);
      return sendMUCRequest(sendIQ, this.helper.getMemberListStanza(jid, affiliations));
    };

    PrivateMUC.prototype.sendMediatedInvite = function(jid, invitees, type) {
      var stanza;
      if (invitees == null) {
        invitees = [];
      }
      if (type == null) {
        type = '';
      }
      if (!isValidMUCJID(jid)) {
        return getJIDRejectedPromise(jid);
      }
      stanza = this.helper.getMediatedInviteStanza(jid, this.getBareSelfJID(), invitees, type);
      return sendMUCRequest(send, stanza);
    };

    PrivateMUC.prototype.declineMediatedInvite = function(jid, inviter, reason) {
      var stanza;
      if (reason == null) {
        reason = '';
      }
      if (!isValidMUCJID(jid)) {
        return getJIDRejectedPromise(jid);
      }
      stanza = this.helper.getDeclineMediatedInviteStanza(jid, inviter, reason);
      return sendMUCRequest(send, stanza);
    };

    PrivateMUC.prototype.search = function(match, arg) {
      var jid, max, ref;
      max = (arg != null ? arg : {}).max;
      if (!_.isString(match)) {
        return Q.reject(new Error("invalid search term"));
      }
      jid = "legacychat." + (Config.get('xmpp.domain'));
      if (!((1 < (ref = parseInt(max)) && ref <= 50))) {
        max = null;
      }
      return sendMUCRequest(sendIQ, this.helper.getSearchStanza(jid, match, max));
    };

    PrivateMUC.prototype.kick = function(jid, users, reason) {
      if (users == null) {
        users = [];
      }
      if (reason == null) {
        reason = '';
      }
      if (!isValidMUCJID(jid)) {
        return getJIDRejectedPromise(jid);
      }
      return sendMUCRequest(sendIQ, this.helper.getKickStanza(jid, users, reason));
    };

    sendMUCRequest = function(fn, stanza) {
      if (stanza == null) {
        stanza = null;
      }
      return NitroPromise(function(resolve, reject) {
        var data;
        if (!stanza) {
          return reject("A valid stanza was not formed for this request");
        }
        if (!_.isFunction(fn)) {
          return reject("No function was provided");
        }
        data = {
          element: stanza,
          resolve: resolve,
          reject: reject
        };
        return fn(data);
      });
    };

    getJIDRejectedPromise = function(jid) {
      return Q.reject(new Error(getInvalidJIDString(jid)));
    };

    getInvalidJIDString = function(jid) {
      return MUC.INVALID_GROUPCHAT_JID + ": " + jid;
    };

    return PrivateMUC;

  })();

  return MUC;

})();


},{"Q":1,"config":"config","enum/muc_field":"enum/muc_field","enum/muc_role":"enum/muc_role","sizzle":84,"strophe/strophe_muc":"strophe/strophe_muc","underscore":85,"util/matchers":"util/matchers","util/promise":"util/promise","util/utils":"util/utils"}],"components/roster":[function(require,module,exports){
var NitroPromise, PresenceType, Q, Roster, Utils, _, stropheRoster;

Q = require('q');

NitroPromise = require('util/promise');

_ = require('underscore');

Utils = require('util/utils');

PresenceType = require('enum/presence_type');

stropheRoster = require('strophe/strophe_roster');

PresenceType = require('enum/presence_type');

module.exports = Roster = (function() {
  var PrivateRoster, instance;

  function Roster() {}

  Roster.NAME = 'component.roster';

  instance = null;

  Roster.get = function(options) {
    var createInstance;
    if (options == null) {
      options = {};
    }
    createInstance = function() {
      return new PrivateRoster(options);
    };
    return instance != null ? instance : instance = createInstance();
  };

  Roster.destroy = Utils.returnBool(function() {
    return instance = null;
  });

  Roster.hasEmailDomain = function(jid) {
    return /@email\./i.test(jid);
  };

  PrivateRoster = (function() {
    var send, sendIQ, sendPresenceType;

    PrivateRoster.prototype.helper = null;

    send = null;

    sendIQ = null;

    function PrivateRoster(options) {
      var ref;
      if (options == null) {
        options = {};
      }
      ref = _.defaults(options, {
        helper: stropheRoster
      }), this.helper = ref.helper, send = ref.send, sendIQ = ref.sendIQ;
    }

    PrivateRoster.prototype.getRoster = function() {
      return NitroPromise((function(_this) {
        return function(resolve, reject) {
          return sendIQ({
            element: _this.helper.getRosterStanza(),
            resolve: resolve,
            reject: reject
          });
        };
      })(this));
    };

    PrivateRoster.prototype.addContact = function(contact) {
      var groups, jid, name, promise, ref;
      if (contact == null) {
        contact = {};
      }
      if (typeof contact === 'string') {
        contact = {
          jid: contact
        };
      }
      ref = _.defaults(contact, {
        jid: '',
        name: "",
        groups: []
      }), jid = ref.jid, name = ref.name, groups = ref.groups;
      promise = NitroPromise((function(_this) {
        return function(resolve, reject) {
          var error;
          if (!jid) {
            error = new Error("Attempting to add an invalid contact to the Roster");
            return reject(error);
          }
          return sendIQ({
            element: _this.helper.getAddStanza(jid, name, groups),
            resolve: resolve,
            reject: reject
          });
        };
      })(this));
      promise.fail(function(error) {
        var data, errorElem, ref1;
        data = error.data;
        if (errorElem = data != null ? (ref1 = data.json) != null ? ref1.error : void 0 : void 0) {
          error.message = errorElem.text.text;
          error.code = parseInt(errorElem.attributes.code, 10);
        }
        throw error;
      });
      return promise;
    };

    PrivateRoster.prototype.removeContact = function(contact) {
      var jid;
      if (contact == null) {
        contact = {};
      }
      if (typeof contact === 'string') {
        contact = {
          jid: contact
        };
      }
      jid = _.defaults(contact, {
        jid: ''
      }).jid;
      return NitroPromise((function(_this) {
        return function(resolve, reject) {
          if (!jid) {
            return reject("Attempting to remove an invalid contact from the Roster");
          }
          return sendIQ({
            element: _this.helper.getRemoveStanza(jid),
            resolve: resolve,
            reject: reject
          });
        };
      })(this));
    };

    PrivateRoster.prototype.updateContact = function(contact) {
      return this.addContact(contact);
    };

    PrivateRoster.prototype.invite = function(contact) {
      if (contact == null) {
        contact = {};
      }
      return this.subscribe(contact);
    };

    PrivateRoster.prototype.subscribe = function(contact) {
      return sendPresenceType.call(this, contact, PresenceType.SUBSCRIBE);
    };

    PrivateRoster.prototype.subscribed = function(contact) {
      return sendPresenceType.call(this, contact, PresenceType.SUBSCRIBED);
    };

    PrivateRoster.prototype.unsubscribe = function(contact) {
      if (contact == null) {
        contact = {};
      }
      return sendPresenceType.call(this, contact, PresenceType.UNSUBSCRIBE);
    };

    sendPresenceType = function(contact, presenceType) {
      var jid;
      if (contact == null) {
        contact = '';
      }
      if (presenceType == null) {
        presenceType = '';
      }
      if (typeof contact === 'string') {
        contact = {
          jid: contact
        };
      }
      jid = _.defaults(contact, {
        jid: ''
      }).jid;
      return NitroPromise((function(_this) {
        return function(resolve, reject) {
          var stanza;
          if (!jid || !_.isString(jid)) {
            return reject("Attempting to send " + presenceType + " to an invalid contact");
          }
          if (!presenceType || !_.isString(presenceType)) {
            return reject("Presence type is not specified");
          }
          stanza = _this.helper.getPresenceSubscriptionStanza(jid, presenceType);
          return send({
            resolve: resolve,
            element: stanza
          });
        };
      })(this));
    };

    return PrivateRoster;

  })();

  return Roster;

})();


},{"enum/presence_type":"enum/presence_type","q":47,"strophe/strophe_roster":"strophe/strophe_roster","underscore":85,"util/promise":"util/promise","util/utils":"util/utils"}],"components/storage":[function(require,module,exports){
var NitroPromise, Q, Storage, Utils, _, converter, stropheStorage,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_ = require('underscore');

_.mixin(require('util/retryer'));

Utils = require('util/utils');

Q = require('q');

NitroPromise = require('util/promise');

stropheStorage = require('strophe/strophe_storage');

converter = require('adapters/preferences');

module.exports = Storage = (function() {
  var PrivateStorage, instance;

  function Storage() {}

  Storage.NAME = 'component.storage';

  instance = null;

  Storage.get = function(options) {
    var createInstance;
    if (options == null) {
      options = {};
    }
    createInstance = function() {
      return new PrivateStorage(options);
    };
    return instance != null ? instance : instance = createInstance();
  };

  Storage.destroy = Utils.returnBool(function() {
    return instance = null;
  });

  PrivateStorage = (function() {
    var sendIQ, sendMockRequest, sendRequest, sendStorageIQ;

    PrivateStorage.MAX_ATTEMPTS = 3;

    PrivateStorage.prototype.helper = null;

    sendIQ = null;

    function PrivateStorage(options) {
      var ref;
      if (options == null) {
        options = {};
      }
      this.getAllPreferences = bind(this.getAllPreferences, this);
      ref = _.defaults(options, {
        helper: stropheStorage
      }), this.helper = ref.helper, sendIQ = ref.sendIQ;
    }

    PrivateStorage.prototype.getPreferences = function() {
      return sendRequest(this.helper.getPreferencesStanza());
    };

    PrivateStorage.prototype.setPreferences = function(preferences) {
      if (preferences == null) {
        preferences = {};
      }
      return sendRequest(this.helper.setPreferencesStanza(preferences));
    };

    PrivateStorage.prototype.setAllPreferences = function(preferences) {
      var ref, ref1, ref2, ref3, ref4;
      return Q.all([this.setGlobalPreferences((preferences != null ? (ref = preferences.global) != null ? ref.firstChild : void 0 : void 0) || ''), this.setEMPreferences((preferences != null ? (ref1 = preferences.em) != null ? ref1.firstChild : void 0 : void 0) || ''), this.setBlastPreferences((preferences != null ? (ref2 = preferences.blasts) != null ? ref2.firstChild : void 0 : void 0) || ''), this.setConversationPreferences((preferences != null ? (ref3 = preferences.conversations) != null ? ref3.firstChild : void 0 : void 0) || ''), this.setAlertPreferences((preferences != null ? (ref4 = preferences.alerts) != null ? ref4.firstChild : void 0 : void 0) || '')]);
    };

    PrivateStorage.prototype.setGlobalPreferences = function(preferences) {
      var stanza;
      if (preferences == null) {
        preferences = {};
      }
      if (!preferences) {
        return;
      }
      stanza = this.helper.setGlobalPreferencesStanza(preferences);
      if (stanza) {
        return sendRequest(stanza);
      }
    };

    PrivateStorage.prototype.setEMPreferences = function(preferences) {
      var stanza;
      if (preferences == null) {
        preferences = {};
      }
      if (!preferences) {
        return;
      }
      stanza = this.helper.setEMPreferencesStanza(preferences);
      if (stanza) {
        return sendRequest(stanza);
      }
    };

    PrivateStorage.prototype.setBlastPreferences = function(preferences) {
      var stanza;
      if (preferences == null) {
        preferences = {};
      }
      if (!preferences) {
        return;
      }
      stanza = this.helper.setBlastPreferencesStanza(preferences);
      if (stanza) {
        return sendRequest(stanza);
      }
    };

    PrivateStorage.prototype.setConversationPreferences = function(preferences) {
      var stanza;
      if (preferences == null) {
        preferences = {};
      }
      if (!preferences) {
        return;
      }
      stanza = this.helper.setConversationPreferencesStanza(preferences);
      if (stanza) {
        return sendRequest(stanza);
      }
    };

    PrivateStorage.prototype.setAlertPreferences = function(preferences) {
      var stanza;
      if (preferences == null) {
        preferences = {};
      }
      if (!preferences) {
        return;
      }
      stanza = this.helper.setAlertPreferencesStanza(preferences);
      if (stanza) {
        return sendRequest(stanza);
      }
    };

    PrivateStorage.prototype.getAllPreferences = function() {
      return Q.all([this.getGlobalPreferences(), this.getEMPreferences(), this.getBlastPreferences(), this.getConversationPreferences(), this.getAlertPreferences()]);
    };

    PrivateStorage.prototype.getGlobalPreferences = function() {
      return sendRequest(this.helper.getGlobalPreferencesStanza());
    };

    PrivateStorage.prototype.getEMPreferences = function() {
      return sendRequest(this.helper.getEMPreferencesStanza());
    };

    PrivateStorage.prototype.getBlastPreferences = function() {
      return sendRequest(this.helper.getBlastsPreferencesStanza());
    };

    PrivateStorage.prototype.getConversationPreferences = function() {
      return sendRequest(this.helper.getConversationPreferencesStanza());
    };

    PrivateStorage.prototype.getAlertPreferences = function() {
      return sendRequest(this.helper.getAlertsPreferencesStanza());
    };

    PrivateStorage.prototype.clearPreferences = function() {
      return sendRequest(this.helper.clearPreferencesStanza());
    };

    PrivateStorage.prototype.clearAllPreferences = function() {
      return Q.all([sendRequest(this.helper.clearPreferencesStanza()), sendRequest(this.helper.clearGlobalPreferencesStanza()), sendRequest(this.helper.clearEMPreferencesStanza()), sendRequest(this.helper.clearBlastsPreferencesStanza()), sendRequest(this.helper.clearConversationsPreferencesStanza()), sendRequest(this.helper.clearAlertsPreferencesStanza())]);
    };

    PrivateStorage.prototype.toNitro = converter.toNitro;

    PrivateStorage.prototype.fromNitro = converter.fromNitro;

    PrivateStorage.prototype.getBookmarks = function() {
      return sendRequest(this.helper.getBookmarksStanza());
    };

    PrivateStorage.prototype.setBookmarks = function(chatrooms) {
      var stanza;
      stanza = this.helper.setBookmarksStanza(chatrooms);
      return sendRequest(stanza);
    };

    sendRequest = function() {
      var retryRequest;
      retryRequest = _.retry(sendStorageIQ, {
        max: PrivateStorage.MAX_ATTEMPTS
      });
      return retryRequest.apply(null, arguments);
    };

    sendMockRequest = function(stanza) {
      return console.log(stanza.toString());
    };

    sendStorageIQ = function(stanza, options) {
      var max;
      if (options == null) {
        options = {};
      }
      max = options.max;
      console.log("[Storage] sendPreferencesIQ via _.retry, attempt " + options.attempt + " of " + PrivateStorage.MAX_ATTEMPTS);
      return NitroPromise(function(resolve, reject) {
        return sendIQ({
          element: stanza,
          resolve: resolve,
          reject: reject
        });
      });
    };

    return PrivateStorage;

  })();

  return Storage;

})();


},{"adapters/preferences":"adapters/preferences","q":47,"strophe/strophe_storage":"strophe/strophe_storage","underscore":85,"util/promise":"util/promise","util/retryer":"util/retryer","util/utils":"util/utils"}],"components/yahoo":[function(require,module,exports){


},{}],"config":[function(require,module,exports){
var Config, _;

_ = require('underscore');

Config = (function() {
  var _cached, _custom, _defaults, _params;

  function Config() {}

  Config.ENV_PRODUCTION = 'prod';

  Config.ENV_BETA = 'beta';

  Config.ENV_ALPHA = 'alpha';

  Config.ENV_DEV = 'dev';

  Config.ENV_FILE = 'file';

  _params = {};

  (function() {
    var params;
    if ((params = window.location.search).length) {
      params = params.substr(1);
      return _.each(params.split('&'), function(param) {
        param = param.split('=');
        return _params[param[0]] = param[1];
      });
    }
  })();

  _defaults = {
    name: 'Nitro XMPP Client Connection',
    nitroPath: 'nhttp-bind'
  };

  _custom = {};

  _cached = {};

  Config.prototype.get = function(key) {
    var value, valueType;
    value = _params[key] || _cached[key] || _custom[key] || _defaults[key];
    if ((valueType = typeof value) === 'function') {
      return _cached[key] = value();
    } else if (valueType !== 'undefined') {
      return _cached[key] = value;
    } else {
      return null;
    }
  };

  Config.prototype.set = function(key, value) {
    return _custom[key] = value;
  };

  Config.prototype.read = function() {
    _.each(_defaults, (function(_this) {
      return function(value, key) {
        return _this.get(key);
      };
    })(this));
    _.each(_custom, (function(_this) {
      return function(value, key) {
        return _this.get(key);
      };
    })(this));
    return this;
  };

  Config.prototype.reset = function(key) {
    if (key) {
      return delete _cached[key];
    } else {
      return _cached = {};
    }
  };

  Config.prototype.all = function() {
    console.log('custom', _custom);
    return console.log('cached', _cached);
  };

  return Config;

})();

module.exports = new Config();


},{"underscore":85}],"connection":[function(require,module,exports){
var Blocklist, Config, Connection, EventHandler, EventManager, Events, Gateway, GatewayName, IOEvent, MUC, Messaging, NitroPromise, Q, RateLimiter, Roster, ShortID, Sizzle, Status, StatusLabels, Storage, Strophe, StropheIO, XMPPPresence, XMPPUtils, _, dataPayload, stropheDisco, strophePresence, stropheYahooGateway;

_ = require('underscore');

Sizzle = require('sizzle');

Q = require('q');

NitroPromise = require('util/promise');

Strophe = require('strophe');

ShortID = require('shortid');

RateLimiter = require('util/rate_limiter');

Config = require('config');

Roster = require('components/roster');

Storage = require('components/storage');

Blocklist = require('components/blocklist');

MUC = require('components/muc');

Messaging = require('components/messaging');

Gateway = require('components/gateway');

GatewayName = require('enum/gateways');

EventManager = require('events/event_manager');

EventHandler = require('events/event_handler');

Events = require('events/events');

IOEvent = require('events/io_event');

Status = require('enum/status');

XMPPPresence = require('enum/xmpp_presence');

StatusLabels = require('enum/status_labels');

strophePresence = require('strophe/strophe_presence');

stropheYahooGateway = require('strophe/strophe_yahoo_gateway');

stropheDisco = require('strophe/strophe_disco');

StropheIO = require('strophe/strophe_io');

dataPayload = require('adapters/data_payload');

XMPPUtils = require('util/xmpp_utils');

module.exports = window.Connection = Connection = (function() {
  var PrivateConnection, instance;

  function Connection() {}

  Connection.version = '0.0.1';

  Connection.TEST_KEY = "Connection.TEST_KEY";

  Connection.FATAL_FAILURE = Status.FATAL_FAILURE;

  Connection.XMPPPresence = XMPPPresence;

  Connection.Events = Events;

  instance = null;

  Connection.get = function(options) {
    var appName, appVersion, createInstance, service;
    if (options == null) {
      options = {};
    }
    appName = options.appName, appVersion = options.appVersion, service = options.service;
    createInstance = function() {
      if (!appName) {
        throw new Error("You must provide an application name.");
      }
      if (!appVersion) {
        throw new Error("You must provide an application version name.");
      }
      return new PrivateConnection(options);
    };
    return instance != null ? instance : instance = createInstance();
  };

  Connection.destroy = function() {
    if ((instance != null ? instance.getAppName() : void 0) === this.TEST_KEY) {
      instance = null;
      return true;
    } else {
      return false;
    }
  };

  PrivateConnection = (function() {
    var attemptConnection, attemptDisconnection, checkForError, createComponents, createConnector, doDisco, getConnectDfdMethod, getPendingMessage, normalizeService, onConnectionStatus, registerComponent, rejectWithData, resolveWithData, send, sendIQ, setCredentials, toggleConnection;

    PrivateConnection.prototype.eventManager = null;

    PrivateConnection.prototype._connection = null;

    PrivateConnection.prototype._appName = '';

    PrivateConnection.prototype._appVersion = '';

    PrivateConnection.prototype._service = '';

    PrivateConnection.prototype._password = null;

    PrivateConnection.prototype._connectionDfd = null;

    PrivateConnection.prototype._connectionStatus = Status.DISCONNECTED;

    PrivateConnection.prototype._messaging = null;

    PrivateConnection.prototype._roster = null;

    PrivateConnection.prototype._storage = null;

    PrivateConnection.prototype._blocklist = null;

    PrivateConnection.prototype._muc = null;

    PrivateConnection.prototype._yahoo = null;

    PrivateConnection.prototype._connectToServer = null;

    PrivateConnection.prototype._tempJID = null;

    PrivateConnection.prototype._statuses = [Status.CONNECTING, Status.CONNFAIL, Status.CONNTIMEOUT, Status.AUTHENTICATING, Status.AUTHFAIL, Status.CONNECTED, Status.DISCONNECTED, Status.DISCONNECTING, Status.FATAL_FAILURE];

    PrivateConnection.prototype._components = {};

    PrivateConnection.prototype._connectionToggleSubs = null;

    function PrivateConnection(options) {
      var appName, appVersion, boundAddHandler, boundDeleteHandler, boundSend, boundSendIQ, ref, service;
      if (options == null) {
        options = {};
      }
      ref = _.defaults(options, {
        service: Config.get('nitroPath')
      }), appName = ref.appName, appVersion = ref.appVersion, service = ref.service;
      this._appName = appName;
      this._appVersion = appVersion;
      this._service = normalizeService(service);
      this._connection = new Strophe.Connection(this._service, {
        customHeaders: {
          'Client-Revision': options.clientRevision
        }
      });
      StropheIO.connectIOListeners({
        connection: this._connection,
        getRawInputListeners: function() {
          return StropheIO.rawInputListeners;
        },
        getRawOutputListeners: function() {
          return StropheIO.rawOutputListeners;
        },
        getXMLInputListeners: function() {
          return StropheIO.xmlInputListeners;
        },
        getXMLOutputListeners: function() {
          return StropheIO.xmlOutputListeners;
        }
      });
      boundSend = _.bind(send, this);
      boundSendIQ = _.bind(sendIQ, this);
      boundAddHandler = _.bind(this._connection.addHandler, this._connection);
      boundDeleteHandler = _.bind(this._connection.deleteHandler, this._connection);
      this.eventManager = EventManager.get({
        addHandler: boundAddHandler,
        deleteHandler: boundDeleteHandler,
        config: Events.getConfig(),
        handlerClass: EventHandler
      });
      this._connectToServer = createConnector({
        func: this._connection.connect,
        context: this._connection
      });
      createComponents.call(this, {
        components: this._components,
        send: boundSend,
        sendIQ: boundSendIQ
      });
      this._connectionToggleSubs = [this.eventManager, this._yahoo];
    }

    normalizeService = function(service) {
      if (_.isString(service)) {
        if (!/^\//.test(service)) {
          service = "/" + service;
        }
        if (!/\/$/.test(service)) {
          service = service + "/";
        }
        return service;
      } else {
        return Config.get('nitroPath');
      }
    };

    createComponents = function(arg) {
      var components, send, sendIQ, yahooOpts;
      components = arg.components, send = arg.send, sendIQ = arg.sendIQ;
      this._roster = registerComponent(components, Roster.NAME, Roster.get({
        send: send,
        sendIQ: sendIQ
      }));
      this._muc = registerComponent(components, MUC.NAME, MUC.get({
        send: send,
        sendIQ: sendIQ,
        status: this.status.bind(this),
        getJID: this.getJID.bind(this),
        eventManager: this.eventManager
      }));
      this._storage = registerComponent(this._components, Storage.NAME, Storage.get({
        sendIQ: sendIQ
      }));
      this._blocklist = registerComponent(components, Blocklist.NAME, Blocklist.get({
        sendIQ: sendIQ
      }));
      this._messaging = registerComponent(components, Messaging.NAME, Messaging.get({
        send: send,
        sendIQ: sendIQ
      }));
      yahooOpts = {
        send: send,
        sendIQ: sendIQ,
        helper: stropheYahooGateway
      };
      return this._yahoo = registerComponent(components, GatewayName.YAHOO, new Gateway(yahooOpts));
    };

    PrivateConnection.prototype.getComponents = function() {
      return this._components;
    };

    PrivateConnection.prototype.getConfigValue = function(key) {
      return Config.get(key);
    };

    PrivateConnection.prototype.getAppName = function() {
      return this._appName;
    };

    PrivateConnection.prototype.getAppVersion = function() {
      return this._appVersion;
    };

    PrivateConnection.prototype.getService = function() {
      return this._service;
    };

    PrivateConnection.prototype.getJID = function() {
      return this._connection.jid;
    };

    PrivateConnection.prototype.getComponent = function(name) {
      var components;
      if (name == null) {
        name = '';
      }
      components = this.getComponents();
      return (components != null ? components[name] : void 0) || (function() {
        throw new Error("Component '" + name + "' does not exist.");
      })();
    };

    PrivateConnection.prototype.addStropheListener = function(options) {
      var inputListeners, ioType, listener, outputListeners, ref, type;
      if (options == null) {
        options = {};
      }
      ref = _.defaults(options, {
        listener: [],
        type: IOEvent.RAW,
        ioType: ''
      }), listener = ref.listener, type = ref.type, ioType = ref.ioType;
      if (type === IOEvent.XML) {
        inputListeners = StropheIO.xmlInputListeners;
        outputListeners = StropheIO.xmlOutputListeners;
      } else {
        inputListeners = StropheIO.rawInputListeners;
        outputListeners = StropheIO.rawOutputListeners;
      }
      switch (ioType) {
        case IOEvent.INPUT:
          return StropheIO.addIOListener(listener, inputListeners);
        case IOEvent.OUTPUT:
          return StropheIO.addIOListener(listener, outputListeners);
        default:
          StropheIO.addIOListener(listener, inputListeners);
          return StropheIO.addIOListener(listener, outputListeners);
      }
    };

    PrivateConnection.prototype.connect = function(options) {
      var pendingMsg, promise, status;
      if (options == null) {
        options = {};
      }
      status = this.status();
      if (this._connectionDfd) {
        promise = this._connectionDfd.promise;
        if (promise.isPending()) {
          pendingMsg = getPendingMessage(status);
          this._connectionDfd.notify(status, pendingMsg);
          return promise;
        }
      }
      if (status === Status.CONNECTED) {
        return Q(status);
      }
      return attemptConnection.call(this, options);
    };

    PrivateConnection.prototype.disconnect = function(options) {
      var pendingMsg, promise, status;
      if (options == null) {
        options = {};
      }
      status = this.status();
      if (status === Status.DISCONNECTED) {
        return Q(status);
      }
      if (this._disconnectionDfd) {
        promise = this._disconnectionDfd.promise;
        if (promise.isPending()) {
          pendingMsg = getPendingMessage(status);
          this._disconnectionDfd.notify(status, pendingMsg);
          return promise;
        }
      }
      return attemptDisconnection.call(this, options);
    };

    PrivateConnection.prototype.status = function() {
      return this._connectionStatus;
    };

    PrivateConnection.prototype.isConnected = function() {
      return this.status() === Status.CONNECTED;
    };

    PrivateConnection.prototype.setPresence = function(status, options) {
      var initial;
      if (status == null) {
        status = '';
      }
      if (options == null) {
        options = {};
      }
      initial = _.defaults(options, {
        initial: false
      }).initial;
      return NitroPromise((function(_this) {
        return function(resolve, reject) {
          var error, invisibleStanza, sendOpts, show, stanza, visibleStanza;
          if (!_.contains(XMPPPresence, status)) {
            error = new Error("Attempted to set an invalid presence");
            return reject(error);
          }
          sendOpts = {
            resolve: resolve,
            reject: reject
          };
          if (status === XMPPPresence.INVISIBLE) {
            invisibleStanza = strophePresence.getVisibleStanza(false);
            sendIQ.call(_this, _.extend({}, sendOpts, {
              element: invisibleStanza
            }));
            if (initial) {
              status = XMPPPresence.AVAILABLE;
              show = XMPPUtils.xmppPresenceToShow(status);
              stanza = strophePresence.getPresenceStanza('', '', show);
              send.call(_this, _.extend({}, {
                element: stanza
              }));
            }
            return;
          }
          if (!initial) {
            visibleStanza = strophePresence.getVisibleStanza();
            sendIQ.call(_this, _.extend({}, sendOpts, {
              element: visibleStanza
            }));
          }
          show = XMPPUtils.xmppPresenceToShow(status);
          stanza = strophePresence.getPresenceStanza('', '', show);
          return send.call(_this, _.extend({}, {
            element: stanza,
            resolve: resolve,
            reject: reject
          }));
        };
      })(this));
    };

    PrivateConnection.prototype.setInitialPresence = function(status) {
      if (status == null) {
        status = '';
      }
      return this.setPresence(status, {
        initial: true
      });
    };

    registerComponent = function(components, name, instance) {
      return components[name] = instance;
    };

    createConnector = function(options) {
      var connector, context, func, limitOptions;
      if (options == null) {
        options = {};
      }
      func = options.func, context = options.context;
      limitOptions = {
        max: 5,
        time: 60 * 1000,
        context: context,
        errorMessage: "Too many connection attempts have been made."
      };
      connector = new RateLimiter(func, limitOptions);
      connector.addAlias('afterServerFailure');
      connector.addAlias('afterLongPollFailure', {
        max: 3,
        time: 6 * 60 * 1000
      });
      return connector;
    };

    attemptConnection = function(options) {
      var callback, connectionHandler, credentials, jid, limitError, password, promise, ref;
      if (options == null) {
        options = {};
      }
      ref = _.defaults(options, {
        callback: function() {}
      }), jid = ref.jid, password = ref.password, callback = ref.callback;
      this._connectionDfd = Q.defer();
      promise = this._connectionDfd.promise;
      promise["finally"]((function(_this) {
        return function() {
          return _this._connectionDfd = null;
        };
      })(this));
      if (!(credentials = setCredentials.call(this, jid, password))) {
        this._connectionDfd.reject("Can not connect due to missing credentials");
        return promise;
      }
      connectionHandler = _.bind(onConnectionStatus, this, this._connectionDfd, callback);
      jid = credentials[0], password = credentials[1];
      limitError = this._connectToServer.invoke(jid, password, connectionHandler);
      if (limitError instanceof Error) {
        console.error("[Connection]", limitError.message);
        connectionHandler(Status.FATAL_FAILURE, {
          error: limitError
        });
      }
      Config.set('xmpp.domain', XMPPUtils.getXMPPDomain(jid));
      return promise;
    };

    attemptDisconnection = function(options) {
      var promise;
      if (options == null) {
        options = {};
      }
      this._disconnectionDfd = Q.defer();
      promise = this._disconnectionDfd.promise;
      promise["finally"]((function(_this) {
        return function() {
          return _this._disconnectionDfd = null;
        };
      })(this));
      this._connection.disconnect(options);
      return promise;
    };

    doDisco = function() {
      return Q.promise((function(_this) {
        return function(resolve, reject) {
          return send.call(_this, _.extend({}, {
            element: stropheDisco.getDiscoStanza(Config.get('xmpp.domain')),
            resolve: resolve,
            reject: reject
          }));
        };
      })(this));
    };

    setCredentials = function(newJID, newPassword) {
      if (newJID) {
        this._tempJID = newJID;
      }
      if (newPassword) {
        this._password = newPassword;
      }
      if (this._tempJID && this._password) {
        return [this._tempJID, this._password];
      } else {
        return false;
      }
    };

    onConnectionStatus = function(connectionDeferred, callback, status, options) {
      var dfdMethod, ref;
      if (options == null) {
        options = {};
      }
      console.log("[Connection][" + (new Date().toTimeString()) + "] Status:", StatusLabels[status]);
      if (_.contains(this._statuses, status)) {
        this._connectionStatus = status;
      }
      switch (this._connectionStatus) {
        case Status.CONNECTED:
          toggleConnection.call(this, true);
          doDisco.call(this);
          break;
        case Status.DISCONNECTED:
        case Status.CONNTIMEOUT:
        case Status.CONNFAIL:
          this._connection.reset();
          if ((ref = this._disconnectionDfd) != null) {
            ref.resolve();
          }
          toggleConnection.call(this, false);
      }
      dfdMethod = getConnectDfdMethod(this._connectionStatus);
      options = _.extend({}, options, {
        status: this._connectionStatus
      });
      if (connectionDeferred && dfdMethod) {
        connectionDeferred[dfdMethod](options);
      }
      if (_.isFunction(callback)) {
        callback(options);
      }
      return this;
    };

    getConnectDfdMethod = function(status) {
      switch (status) {
        case Status.CONNECTING:
        case Status.AUTHENTICATING:
          return 'notify';
        case Status.CONNECTED:
          return 'resolve';
        case Status.CONNFAIL:
        case Status.AUTHFAIL:
        case Status.DISCONNECTED:
        case Status.FATAL_FAILURE:
          return 'reject';
        case Status.CONNTIMEOUT:
        case Status.AUTHFAIL:
        case Status.DISCONNECTED:
        case Status.FATAL_FAILURE:
          return 'reject';
        default:
          return '';
      }
    };

    toggleConnection = function(connected) {
      var i, len, ref, subscriber;
      if (connected == null) {
        connected = true;
      }
      ref = this._connectionToggleSubs || [];
      for (i = 0, len = ref.length; i < len; i++) {
        subscriber = ref[i];
        subscriber.toggleConnection(connected, this.getJID());
      }
      return this;
    };

    getPendingMessage = function(status) {
      switch (status) {
        case Status.CONNECTING:
          return "Aleady connecting to the Nitro server";
        case Status.AUTHENTICATING:
          return "Already authenticating with the Nitro server";
        case Status.DISCONNECTED:
          return "Already disconnecting from the Nitro server";
        default:
          return "";
      }
    };

    send = function(options) {
      var element, error, errorMsg, reject, resolve;
      if (options == null) {
        options = {};
      }
      element = options.element, resolve = options.resolve, reject = options.reject;
      if (errorMsg = checkForError(element, this.isConnected())) {
        error = new Error(errorMsg);
        return typeof reject === "function" ? reject(error) : void 0;
      }
      this._connection.send(element);
      resolve = resolveWithData(resolve);
      return resolve(element.tree());
    };

    sendIQ = function(options) {
      var element, error, errorMsg, reject, resolve;
      if (options == null) {
        options = {};
      }
      element = options.element, resolve = options.resolve, reject = options.reject;
      if (errorMsg = checkForError(element, this.isConnected())) {
        error = new Error(errorMsg);
        return typeof reject === "function" ? reject(error) : void 0;
      }
      resolve = resolveWithData(resolve);
      reject = rejectWithData(reject);
      return this._connection.sendIQ(element, resolve, reject);
    };

    resolveWithData = function(resolve) {
      return function(stanza) {
        var data;
        data = dataPayload.getData(stanza);
        if (_.isFunction(resolve)) {
          return resolve.call(null, data);
        }
      };
    };

    rejectWithData = function(reject) {
      return resolveWithData(reject);
    };

    checkForError = function(element, isConnected) {
      switch (false) {
        case element instanceof Strophe.Builder:
          return "Data is not a Strophe.Builder instance";
        case isConnected:
          return "Can not call sendIQ unless user is CONNECTED";
        default:
          return "";
      }
    };

    return PrivateConnection;

  })();

  return Connection;

})();


},{"adapters/data_payload":"adapters/data_payload","components/blocklist":"components/blocklist","components/gateway":"components/gateway","components/messaging":"components/messaging","components/muc":"components/muc","components/roster":"components/roster","components/storage":"components/storage","config":"config","enum/gateways":"enum/gateways","enum/status":"enum/status","enum/status_labels":"enum/status_labels","enum/xmpp_presence":"enum/xmpp_presence","events/event_handler":"events/event_handler","events/event_manager":"events/event_manager","events/events":"events/events","events/io_event":"events/io_event","q":47,"shortid":51,"sizzle":84,"strophe":"lib/strophe","strophe/strophe_disco":"strophe/strophe_disco","strophe/strophe_io":"strophe/strophe_io","strophe/strophe_presence":"strophe/strophe_presence","strophe/strophe_yahoo_gateway":"strophe/strophe_yahoo_gateway","underscore":85,"util/promise":"util/promise","util/rate_limiter":"util/rate_limiter","util/xmpp_utils":"util/xmpp_utils"}],"enum/ack_ns":[function(require,module,exports){
module.exports = {
  NITRO_RECEIPTS: 'nitro:xmpp:receipts',
  STANDARD_RECEIPTS: 'urn:xmpp:receipts'
};


},{}],"enum/chat_states_ns":[function(require,module,exports){
module.exports = {
  CHAT_STATES: 'http://jabber.org/protocol/chatstates'
};


},{}],"enum/compliance_error":[function(require,module,exports){
module.exports = {
  MESSAGE_BLOCK: 'message.block',
  MESSAGE_SOFT_BLOCK: 'message.soft.block',
  MESSAGE_SOFT_BLOCK_FLAG: 8239,
  MESSAGE_BLOCK_CODE: '405',
  MESSAGE_HARD_BLOCK_CODE: '406'
};


},{}],"enum/gateway_error":[function(require,module,exports){
module.exports = {
  INVALID_CREDENTIALS: 'invalid_credentials',
  NO_NITRO_CONNECTION: 'no_nitro_connection',
  ALREADY_REGISTERING: 'already_registering',
  ALREADY_UNREGISTERING: 'already_unregistered',
  ALREADY_SUBSCRIBING: 'already_subscribing',
  ALREADY_UNSUBSCRIBING: 'already_unsubscribing'
};


},{}],"enum/gateway_state":[function(require,module,exports){
module.exports = {
  REGISTERING: 'registering',
  REGISTERED: 'registered',
  SUBSCRIBING: 'subscribing',
  SUBSCRIBED: 'subscribed',
  UNREGISTERING: 'unregistering',
  UNREGISTERED: 'unregistered'
};


},{}],"enum/gateways":[function(require,module,exports){
module.exports = {
  YAHOO: 'yahoo'
};


},{}],"enum/history_ns":[function(require,module,exports){
module.exports = {
  CHAT_HISTORY: 'urn:xmpp:mam:tmp',
  RSM: 'http://jabber.org/protocol/rsm',
  DELAY: 'urn:xmpp:delay',
  SEARCH: 'jabber:iq:search'
};


},{}],"enum/message_type":[function(require,module,exports){
module.exports = {
  CHAT: 'chat',
  GROUPCHAT: 'groupchat'
};


},{}],"enum/muc_error_type":[function(require,module,exports){
module.exports = {
  AUTH: 'auth',
  CANCEL: 'cancel',
  MODIFY: 'modify',
  WAIT: 'wait'
};


},{}],"enum/muc_error":[function(require,module,exports){
module.exports = {
  ITEM_NOT_FOUND: 'item-not-found'
};


},{}],"enum/muc_field":[function(require,module,exports){
module.exports = {
  ROOM_NAME: 'muc#roomconfig_roomname',
  FORM_TYPE: 'FORM_TYPE'
};


},{}],"enum/muc_node":[function(require,module,exports){
module.exports = {
  WCP: 'wcpchatroom',
  CONFERENCE: 'conference',
  DESK: 'desk'
};


},{}],"enum/muc_ns":[function(require,module,exports){
module.exports = {
  ROOT: 'http://jabber.org/protocol/muc',
  OWNER: 'http://jabber.org/protocol/muc#owner',
  ADMIN: 'http://jabber.org/protocol/muc#admin',
  USER: 'http://jabber.org/protocol/muc#user',
  DISCO_INFO: 'http://jabber.org/protocol/disco#info'
};


},{}],"enum/muc_role":[function(require,module,exports){
module.exports = {
  OWNER: 'owner',
  ADMIN: 'admin',
  PARTICIPANT: 'participant',
  MODERATOR: 'moderator',
  NONE: 'none',
  MEMBER: 'member'
};


},{}],"enum/muc_types":[function(require,module,exports){
module.exports = {
  MANAGED: "managed",
  BILATERAL: "bilateral",
  DESK: "desk"
};


},{}],"enum/presence_show":[function(require,module,exports){
module.exports = {
  AWAY: 'away',
  CHAT: 'invisible',
  DND: 'dnd',
  EXTENDED_AWAY: 'xa'
};


},{}],"enum/presence_type":[function(require,module,exports){
module.exports = {
  UNAVAILABLE: 'unavailable',
  SUBSCRIBE: 'subscribe',
  SUBSCRIBED: 'subscribed',
  UNSUBSCRIBE: 'unsubscribe',
  UNSUBSCRIBED: 'unsubscribed',
  PROBE: 'probe',
  ERROR: 'error'
};


},{}],"enum/status_labels":[function(require,module,exports){
module.exports = ['Error', 'Connecting', 'ConnFail', 'Authenticating', 'AuthFail', 'Connected', 'Disconnected', 'Disconnecting', 'Attached', 'Redirect', 'ConnTimeout'];


},{}],"enum/status":[function(require,module,exports){
var Strophe;

Strophe = require('strophe');

module.exports = {
  CONNECTING: Strophe.Status.CONNECTING,
  CONNFAIL: Strophe.Status.CONNFAIL,
  AUTHENTICATING: Strophe.Status.AUTHENTICATING,
  AUTHFAIL: Strophe.Status.AUTHFAIL,
  CONNECTED: Strophe.Status.CONNECTED,
  DISCONNECTED: Strophe.Status.DISCONNECTED,
  DISCONNECTING: Strophe.Status.DISCONNECTING,
  FATAL_FAILURE: 8,
  REDIRECT: 9,
  CONNTIMEOUT: 10
};


},{"strophe":"lib/strophe"}],"enum/subscription_status":[function(require,module,exports){
module.exports = {
  SUBSCRIBING: 'subscribing',
  SUBSCRIBED: 'subscribed',
  UNSUBSCRIBING: 'unsubscribing',
  UNSUBSCRIBED: 'unsubscribed'
};


},{}],"enum/xmpp_presence":[function(require,module,exports){
var PresenceShow, PresenceType;

PresenceType = require('enum/presence_type');

PresenceShow = require('enum/presence_show');

module.exports = {
  AVAILABLE: 'available',
  AWAY: PresenceShow.AWAY,
  EXTENDED_AWAY: PresenceShow.EXTENDED_AWAY,
  DND: PresenceShow.DND,
  UNAVAILABLE: PresenceType.UNAVAILABLE,
  INVISIBLE: 'invisible'
};


},{"enum/presence_show":"enum/presence_show","enum/presence_type":"enum/presence_type"}],"enum/yahoo_error":[function(require,module,exports){
module.exports = {
  NOT_REGISTERED: 'not-registered'
};


},{}],"events/event_filters":[function(require,module,exports){
var ChatStatesNS, Config, EventFilters, MUCErrorType, Matchers, Sizzle, Strophe, XMPPUtils, _;

_ = require('underscore');

_.mixin(require('util/not'));

Sizzle = require('sizzle');

Config = require('config');

Strophe = require('strophe');

XMPPUtils = require('util/xmpp_utils');

Matchers = require('util/matchers');

MUCErrorType = require('enum/muc_error_type');

ChatStatesNS = require('enum/chat_states_ns');

module.exports = EventFilters = (function() {
  var filterByJID, getMatcher;

  function EventFilters() {}

  EventFilters.SELF_JID = 'selfJID';

  EventFilters.isMUC = function(stanza) {
    return !!Sizzle('x[xmlns="http://jabber.org/protocol/muc#user"]', stanza).length || Matchers.isGroupchat(stanza.getAttribute('from'));
  };

  EventFilters.isntMUC = _.not(EventFilters.isMUC);

  EventFilters.isMUCInvite = function(stanza) {
    return EventFilters.isMUC(stanza) && !!Sizzle('invite', stanza).length;
  };

  EventFilters.isntMUCInvite = _.not(EventFilters.isMUCInvite);

  EventFilters.isMUCSubject = function(stanza) {
    return stanza.getAttribute('type') === 'groupchat' && !!Sizzle('subject', stanza).length;
  };

  EventFilters.isntMUCSubject = _.not(EventFilters.isMUCSubject);

  EventFilters.isHistoryFin = function(stanza) {
    return !!Sizzle('fin', stanza).length;
  };

  EventFilters.isntHistoryFin = _.not(EventFilters.isHistoryFin);

  EventFilters.hasType = function(stanza) {
    return !_.isEmpty(stanza.getAttribute('type'));
  };

  EventFilters.hasntType = _.not(EventFilters.hasType);

  EventFilters.isSelf = function(stanza, selfJID) {
    return stanza.getAttribute('from') === selfJID.replace("'", "\\27") || stanza.getAttribute('from') === selfJID;
  };

  EventFilters.isntSelf = _.not(EventFilters.isSelf);

  EventFilters.isSubscribed = function(stanza) {
    return stanza.getAttribute('type') === 'subscribed';
  };

  EventFilters.isntSubscribed = _.not(EventFilters.isSubscribed);

  EventFilters.isSubscribe = function(stanza) {
    return stanza.getAttribute('type') === 'subscribe';
  };

  EventFilters.isntSubscribe = _.not(EventFilters.isSubscribe);

  EventFilters.isUnsubscribe = function(stanza) {
    return stanza.getAttribute('type') === 'unsubscribe';
  };

  EventFilters.isntUnsubscribe = _.not(EventFilters.isUnsubscribe);

  EventFilters.isRecipientUnavailable = function(stanza, selfJID) {
    return !!Sizzle('recipient-unavailable', stanza).length;
  };

  EventFilters.isMUCSelf = function(stanza, selfJID) {
    var bareSelfJID, jid, resource;
    resource = Strophe.getResourceFromJid(stanza.getAttribute('from'));
    if (!resource) {
      return false;
    }
    bareSelfJID = Strophe.getBareJidFromJid(selfJID);
    jid = resource.replace('__', '@');
    jid = Strophe.unescapeNode(jid);
    return bareSelfJID === XMPPUtils.emailToJID(jid, Config.get('xmpp.domain')) || bareSelfJID === jid;
  };

  EventFilters.isntMUCSelf = _.not(EventFilters.isMUCSelf);

  EventFilters.isChatAck = function(stanza) {
    var amp;
    if (amp = Sizzle('amp', stanza)[0]) {
      return !!Sizzle('rule', stanza).length;
    } else {
      return false;
    }
  };

  EventFilters.isDelayed = function(stanza) {
    return !!Sizzle('delay', stanza).length;
  };

  EventFilters.isntDelayed = _.not(EventFilters.isDelayed);

  EventFilters.isGroupchatAck = function(stanza, selfJID) {
    return this.isMUCSelf(stanza, selfJID);
  };

  EventFilters.isClientAck = function(stanza) {
    return !!Sizzle('response', stanza).length;
  };

  EventFilters.isPreferences = function(stanza) {
    return !!Sizzle('[xmlns="storage:preferences"]', stanza).length;
  };

  EventFilters.isBookmarks = function(stanza) {
    return !!Sizzle('[xmlns="storage:bookmarks"]', stanza).length;
  };

  EventFilters.isRosterRemoved = function(stanza) {
    var ref;
    return ((ref = Sizzle('item', stanza)[0]) != null ? ref.getAttribute('subscription') : void 0) === "remove";
  };

  EventFilters.isRosterAdded = _.not(EventFilters.isRosterRemoved);

  EventFilters.isBlocklistBlocked = function(stanza) {
    return !!Sizzle('block', stanza).length;
  };

  EventFilters.isBlocklistUnblocked = function(stanza) {
    return !!Sizzle('unblock', stanza).length;
  };

  EventFilters.isYahooGateway = function(stanza) {
    return /^yahoo\./i.test(stanza.getAttribute('from'));
  };

  EventFilters.isntYahooGateway = _.not(EventFilters.isYahooGateway);

  EventFilters.isError = function(stanza) {
    return stanza.getAttribute('type') === 'error';
  };

  EventFilters.isntError = _.not(EventFilters.isError);

  EventFilters.hasDecline = function(stanza) {
    return !!Sizzle('decline', stanza).length;
  };

  EventFilters.hasntDecline = _.not(EventFilters.hasDecline);

  EventFilters.hasPolicyViolation = function(stanza) {
    return !!Sizzle('policy-violation', stanza).length;
  };

  EventFilters.hasntPolicyViolation = _.not(EventFilters.hasPolicyViolation);

  EventFilters.hasInvitee = function(stanza) {
    return !!Sizzle('invitee', stanza).length;
  };

  EventFilters.hasntInvitee = _.not(EventFilters.hasInvitee);

  EventFilters.isConflict = function(stanza) {
    return !!Sizzle('conflict', stanza).length;
  };

  EventFilters.hasErrorTypeCancel = function(stanza) {
    var ref;
    return ((ref = Sizzle('error', stanza)[0]) != null ? ref.getAttribute('type') : void 0) === MUCErrorType.CANCEL;
  };

  EventFilters.hasntErrorTypeCancel = _.not(EventFilters.hasErrorTypeCancel);

  EventFilters.hasErrorTypeAuth = function(stanza) {
    var ref;
    return ((ref = Sizzle('error', stanza)[0]) != null ? ref.getAttribute('type') : void 0) === MUCErrorType.AUTH;
  };

  EventFilters.hasntErrorTypeAuth = _.not(EventFilters.hasErrorTypeAuth);

  EventFilters.hasErrorTypeModify = function(stanza) {
    var ref;
    return ((ref = Sizzle('error', stanza)[0]) != null ? ref.getAttribute('type') : void 0) === MUCErrorType.MODIFY;
  };

  EventFilters.hasntErrorTypeModify = _.not(EventFilters.hasErrorTypeModify);

  EventFilters.isTypingNotice = function(stanza) {
    return !!Sizzle('composing[xmlns="' + ChatStatesNS.CHAT_STATES + '"]', stanza).length;
  };

  EventFilters.isntTypingNotice = _.not(EventFilters.isTypingNotice);

  EventFilters.isHistoryBlocked = function(stanza) {
    return !!Sizzle('error[type="modify"] policy-violation', stanza).length && !!Sizzle('compliance[code="606"]', stanza).length;
  };

  EventFilters.isntHistoryBlocked = _.not(EventFilters.isHistoryBlocked);

  EventFilters.run = function(stanza, filters, selfJID) {
    var filter, i, len, pass;
    pass = true;
    for (i = 0, len = filters.length; i < len; i++) {
      filter = filters[i];
      if (_.isFunction(filter)) {
        if (!filter.call(this, stanza, selfJID)) {
          pass = false;
          break;
        }
      } else {
        throw new Error("Attempted to invoke an invalid filter function " + filter);
      }
    }
    return pass;
  };

  EventFilters.filterByRecipient = function(func, expectedJID, bare) {
    return filterByJID('to', func, expectedJID, getMatcher(bare));
  };

  EventFilters.filterBySender = function(func, expectedJID, bare) {
    return filterByJID('from', func, expectedJID, getMatcher(bare));
  };

  EventFilters.matchBareJID = function(expectedJID, testJID) {
    return expectedJID === Strophe.getBareJidFromJid(testJID);
  };

  EventFilters.matchJID = function(expectedJID, testJID) {
    return _.isEqual(expectedJID, testJID) || this.matchBareJID(testJID);
  };

  EventFilters.hasBodyTag = function(stanza) {
    return !!Sizzle('body', stanza).length;
  };

  EventFilters.hasntBodyTag = _.not(EventFilters.hasBodyTag);

  EventFilters.hasStatusTag = function(stanza) {
    return !!Sizzle('status', stanza).length;
  };

  EventFilters.hasntStatusTag = _.not(EventFilters.hasStatusTag);

  filterByJID = function(attrName, func, expectedJID, matcherFn) {
    return function(stanza) {
      var stanzaJID;
      stanzaJID = stanza.getAttribute(attrName);
      if (matcherFn(expectedJID, stanzaJID)) {
        return func(stanza);
      }
    };
  };

  getMatcher = function(bare) {
    if (bare == null) {
      bare = false;
    }
    return (function(bare) {
      return function(expected, test) {
        if (bare) {
          return EventFilters.matchBareJID(expected, test);
        } else {
          return _.isEqual(expected, test);
        }
      };
    })(bare);
  };

  return EventFilters;

})();


},{"config":"config","enum/chat_states_ns":"enum/chat_states_ns","enum/muc_error_type":"enum/muc_error_type","sizzle":84,"strophe":"lib/strophe","underscore":85,"util/matchers":"util/matchers","util/not":"util/not","util/xmpp_utils":"util/xmpp_utils"}],"events/event_handler":[function(require,module,exports){
var EventFilters, EventHandler, ShortID, Strophe, _, dataPayload,
  hasProp = {}.hasOwnProperty;

_ = require('underscore');

ShortID = require('shortid');

Strophe = require('strophe');

EventFilters = require('events/event_filters');

dataPayload = require('adapters/data_payload');

module.exports = EventHandler = (function() {
  var onceAndRemove;

  EventHandler.prototype.path = null;

  EventHandler.prototype.selfJID = null;

  EventHandler.prototype.config = null;

  EventHandler.prototype._callbacks = null;

  EventHandler.prototype._stropheHandler = null;

  function EventHandler(config) {
    var base, base1, base2, base3, base4, base5, base6, matchBare;
    this.config = config != null ? config : {};
    if ((base = this.config).ns == null) {
      base.ns = null;
    }
    if ((base1 = this.config).name == null) {
      base1.name = null;
    }
    if ((base2 = this.config).type == null) {
      base2.type = null;
    }
    if ((base3 = this.config).id == null) {
      base3.id = null;
    }
    if ((base4 = this.config).from == null) {
      base4.from = null;
    }
    if ((base5 = this.config).filters == null) {
      base5.filters = [];
    }
    if (matchBare = this.config.matchBare) {
      this.config.options = {
        matchBare: matchBare
      };
    } else {
      if ((base6 = this.config).options == null) {
        base6.options = {
          matchBare: false
        };
      }
    }
    this._callbacks = {};
  }

  EventHandler.prototype.addCallback = function(callback, once) {
    var id;
    if (once == null) {
      once = false;
    }
    if (!_.isFunction(callback)) {
      return null;
    }
    id = ShortID.generate();
    if (once) {
      callback = onceAndRemove(callback, _.bind(this.removeCallback, this, id));
    }
    this._callbacks[id] = callback;
    return id;
  };

  EventHandler.prototype.removeCallback = function(id) {
    if (_.has(this._callbacks, id)) {
      delete this._callbacks[id];
      return id;
    } else {
      return null;
    }
  };

  EventHandler.prototype.hasCallbacks = function() {
    return !_.isEmpty(this._callbacks);
  };

  EventHandler.prototype.getStropheHandler = function() {
    return this._stropheHandler;
  };

  EventHandler.prototype.setStropheHandler = function(handler, reset) {
    if (handler == null) {
      handler = null;
    }
    if (reset == null) {
      reset = false;
    }
    if (!reset) {
      if (!(handler instanceof Strophe.Handler)) {
        return this;
      }
    }
    this._stropheHandler = handler;
    return this;
  };

  EventHandler.prototype.reset = function() {
    this.resetStropheHandler();
    return this.resetCallbacks();
  };

  EventHandler.prototype.resetStropheHandler = function() {
    this.setStropheHandler(null, true);
    return this;
  };

  EventHandler.prototype.resetCallbacks = function() {
    var ids;
    ids = _.keys(this._callbacks);
    this._callbacks = {};
    return ids;
  };

  EventHandler.prototype.getSignatureArgs = function(selfJID) {
    var selected;
    this.selfJID = selfJID;
    selected = _.pick(this.config, 'ns', 'name', 'type', 'id', 'from', 'options');
    if (selected.from === EventFilters.SELF_JID) {
      selected.from = this.selfJID;
    }
    return _.values(selected);
  };

  EventHandler.prototype.invokeCallbacks = function(stanza) {
    var callback, data, e, error, id, pass, ref;
    if (!(pass = EventFilters.run(stanza, this.config.filters, this.selfJID))) {
      return this;
    }
    ref = this._callbacks;
    for (id in ref) {
      if (!hasProp.call(ref, id)) continue;
      callback = ref[id];
      try {
        data = dataPayload.getData(stanza);
        callback(data);
      } catch (error) {
        e = error;
      }
    }
    return this;
  };

  onceAndRemove = function(func, remove) {
    return function() {
      func.apply(null, arguments);
      return remove();
    };
  };

  return EventHandler;

})();


},{"adapters/data_payload":"adapters/data_payload","events/event_filters":"events/event_filters","shortid":51,"strophe":"lib/strophe","underscore":85}],"events/event_manager":[function(require,module,exports){
var EventManager, Utils, _,
  hasProp = {}.hasOwnProperty;

_ = require('underscore');

Utils = require('util/utils');

module.exports = EventManager = (function() {
  var PrivateEventManager, instance;

  function EventManager() {}

  instance = null;

  EventManager.get = function(options) {
    var createInstance;
    if (options == null) {
      options = {};
    }
    createInstance = function() {
      return new PrivateEventManager(options);
    };
    return instance != null ? instance : instance = createInstance();
  };

  EventManager.destroy = Utils.returnBool(function() {
    return instance = null;
  });

  PrivateEventManager = (function() {
    var addHandler, addHandlerForCallback, addStropheHandler, addStropheHandlerLazily, addStropheHandlers, createEventsDictionary, deleteHandler, deleteStropheHandler, lazyStrophePolicy, removeStropheHandlers;

    addHandler = null;

    deleteHandler = null;

    addStropheHandlerLazily = null;

    PrivateEventManager.prototype._eventsDictionary = {};

    PrivateEventManager.prototype._selfJID = null;

    function PrivateEventManager(options) {
      var config, handlerClass;
      if (options == null) {
        options = {};
      }
      addHandler = options.addHandler, deleteHandler = options.deleteHandler, config = options.config, handlerClass = options.handlerClass;
      this._eventsDictionary = createEventsDictionary(config, handlerClass);
      addStropheHandlerLazily = Utils.conditional(addStropheHandler, lazyStrophePolicy);
      return this;
    }

    PrivateEventManager.prototype.toggleConnection = function(connected, selfJID) {
      if (selfJID == null) {
        selfJID = '';
      }
      this._selfJID = Strophe.unescapeNode(selfJID);
      if (connected) {
        addStropheHandlers(this._selfJID, this._eventsDictionary);
      } else {
        removeStropheHandlers(this._eventsDictionary);
      }
      return this;
    };

    PrivateEventManager.prototype.listenTo = function(path, callback, once) {
      var callbackId, eventHandler;
      if (once == null) {
        once = false;
      }
      if (eventHandler = this._eventsDictionary[path]) {
        callbackId = eventHandler.addCallback(callback, once);
        addHandlerForCallback(eventHandler, this._selfJID);
        return callbackId;
      } else {
        throw new Error("Unsupported event: " + path);
      }
    };

    PrivateEventManager.prototype.listenToOnce = function(path, callback) {
      return this.listenTo(path, callback, true);
    };

    PrivateEventManager.prototype.stopListening = function(id) {
      var removedIds;
      removedIds = _.invoke(this._eventsDictionary, 'removeCallback', id);
      removedIds = _.compact(removedIds);
      return removedIds[0];
    };

    createEventsDictionary = function(configObj, handlerClass) {
      var dictionary, eventHandler, path, signature;
      if (_.isEmpty(configObj)) {
        return null;
      }
      if (!_.isFunction(handlerClass)) {
        return null;
      }
      dictionary = _.clone(configObj);
      for (path in dictionary) {
        if (!hasProp.call(dictionary, path)) continue;
        signature = dictionary[path];
        eventHandler = new handlerClass(signature);
        eventHandler.path = path;
        dictionary[path] = eventHandler;
      }
      return dictionary;
    };

    lazyStrophePolicy = function(eventHandler) {
      return eventHandler.hasCallbacks();
    };

    addStropheHandlers = function(selfJID, eventsDictionary) {
      var eventHandler, path, results;
      results = [];
      for (path in eventsDictionary) {
        if (!hasProp.call(eventsDictionary, path)) continue;
        eventHandler = eventsDictionary[path];
        results.push(addStropheHandlerLazily(eventHandler, selfJID));
      }
      return results;
    };

    removeStropheHandlers = function(eventsDictionary) {
      var eventHandler, path, results;
      results = [];
      for (path in eventsDictionary) {
        if (!hasProp.call(eventsDictionary, path)) continue;
        eventHandler = eventsDictionary[path];
        deleteStropheHandler(eventHandler.getStropheHandler());
        results.push(eventHandler.resetStropheHandler());
      }
      return results;
    };

    addHandlerForCallback = function(eventHandler, jid) {
      if (!eventHandler.getStropheHandler()) {
        return addStropheHandlerLazily(eventHandler, jid);
      }
    };

    addStropheHandler = function(eventHandler, selfJID, filterJID) {
      var args, handler, invokeCallbacks, signatureArgs, stropheHandler;
      if (!selfJID) {
        return null;
      }
      if (eventHandler.getStropheHandler()) {
        return null;
      }
      invokeCallbacks = _.bind(eventHandler.invokeCallbacks, eventHandler);
      handler = Utils.returnBool(invokeCallbacks, true);
      signatureArgs = eventHandler.getSignatureArgs(selfJID, filterJID);
      args = [handler].concat(signatureArgs);
      stropheHandler = addHandler.apply(null, args);
      eventHandler.setStropheHandler(stropheHandler);
      return stropheHandler;
    };

    deleteStropheHandler = function(stropheHandler) {
      if (!(stropheHandler instanceof Strophe.Handler)) {
        return null;
      }
      return deleteHandler(stropheHandler);
    };

    return PrivateEventManager;

  })();

  return EventManager;

})();


},{"underscore":85,"util/utils":"util/utils"}],"events/events":[function(require,module,exports){
var ACKNS, EventFilters, Events, GatewayName, HistoryNS, MessageType, PresenceType, _, strophePresence;

_ = require('underscore');

strophePresence = require('strophe/strophe_presence');

PresenceType = require('enum/presence_type');

MessageType = require('enum/message_type');

EventFilters = require('events/event_filters');

HistoryNS = require('enum/history_ns');

ACKNS = require('enum/ack_ns');

GatewayName = require('enum/gateways');

module.exports = Events = (function() {
  function Events() {}

  Events.filterByRecipient = function() {
    return EventFilters.filterByRecipient.apply(EventFilters, arguments);
  };

  Events.filterBySender = function() {
    return EventFilters.filterBySender.apply(EventFilters, arguments);
  };

  Events.PRESENCE_USER_UPDATE = 'presence.user.update';

  Events.PRESENCE_SELF_UPDATE = 'presence.self.update';

  Events.PREFERENCES_UPDATE = 'preferences.update';

  Events.BOOKMARKS_UPDATE = 'bookmarks.update';

  Events.MESSAGE_CHAT_RECEIVED = 'message.chat.received';

  Events.MESSAGE_CHAT_HISTORY_RECEIVED = 'message.chat.history.received';

  Events.MESSAGE_CHAT_REGISTERED = 'message.chat.registered';

  Events.MESSAGE_CHAT_DELIVERED = 'message.chat.delivered';

  Events.MESSAGE_CHAT_FAILED = 'message.chat.failed';

  Events.MESSAGE_CHAT_FIN = 'message.chat.fin';

  Events.MESSAGE_GROUPCHAT_INVITE = 'message.groupchat.invite';

  Events.MESSAGE_GROUPCHAT_INVITE_REJECTED = 'message.groupchat.invite.rejected';

  Events.MESSAGE_GROUPCHAT_INVITE_BLOCKED = 'message.groupchat.invite.blocked';

  Events.MESSAGE_GROUPCHAT_INVITE_ERROR = 'message.groupchat.invite.error';

  Events.MESSAGE_GROUPCHAT_RECEIVED = 'message.groupchat.received';

  Events.MESSAGE_GROUPCHAT_HISTORY_RECEIVED = 'message.groupchat.history.received';

  Events.PRESENCE_GROUPCHAT_HISTORY_BLOCKED = 'message.groupchat.history.blocked';

  Events.MESSAGE_GROUPCHAT_REGISTERED = 'message.groupchat.registered';

  Events.MESSAGE_MANAGED_GROUPCHAT_REGISTERED = 'message.managed.groupchat.registered';

  Events.MESSAGE_GROUPCHAT_DELIVERED = 'message.groupchat.delivered';

  Events.MESSAGE_GROUPCHAT_FAILED = 'message.groupchat.failed';

  Events.MESSAGE_GROUPCHAT_SUBJECT = 'message.groupchat.subject';

  Events.ROSTER_ADDED = 'roster.added';

  Events.ROSTER_REMOVED = 'roster.removed';

  Events.ROSTER_INVITE_RECEIVED = 'roster.invite.received';

  Events.ROSTER_INVITE_CONFIRMED = 'roster.invite.confirmed';

  Events.BLOCKLIST_BLOCK = 'blocklist.blocked';

  Events.BLOCKLIST_UNBLOCK = 'blocklist.unblocked';

  Events.GROUPCHAT_SELF_JOINED = 'groupchat.self.joined';

  Events.GROUPCHAT_SELF_LEFT = 'groupchat.self.left';

  Events.GROUPCHAT_USER_JOINED = 'groupchat.user.joined';

  Events.GROUPCHAT_USER_LEFT = 'groupchat.user.left';

  Events.GROUPCHAT_CREATE_ERROR = 'groupchat.create.error';

  Events.GROUPCHAT_JOIN_ERROR = 'groupchat.join.error';

  Events.GROUPCHAT_CONFIGURATION_CHANGE = 'groupchat.config.changed';

  Events.GATEWAY_YAHOO_SUBSCRIBE = 'gateway.yahoo.subscribe';

  Events.GATEWAY_YAHOO_SELF_PRESENCE = 'gateway.yahoo.self.presence';

  Events.GATEWAY_YAHOO_UNSUBSCRIBED = 'gateway.yahoo.unsubscribed';

  Events.STREAM_ERROR = 'stream.error';

  Events.TYPING_NOTICE = 'typing.notice';

  Events.NAME_MESSAGE = 'message';

  Events.NAME_PRESENCE = strophePresence.PRESENCE;

  Events.NAME_IQ = 'iq';

  Events.TYPE_HEADLINE = 'headline';

  Events.TYPE_SET = 'set';

  Events.TYPE_CHAT = MessageType.CHAT;

  Events.TYPE_GROUPCHAT = MessageType.GROUPCHAT;

  Events.TYPE_ERROR = 'error';

  Events.getConfig = function() {
    var config;
    config = {};
    config[this.PRESENCE_USER_UPDATE] = {
      name: this.NAME_PRESENCE,
      filters: [EventFilters.isntMUC, EventFilters.isntSelf, EventFilters.isntSubscribed, EventFilters.isntUnsubscribe]
    };
    config[this.PRESENCE_SELF_UPDATE] = {
      name: this.NAME_PRESENCE,
      filters: [EventFilters.isSelf]
    };
    config[this.PREFERENCES_UPDATE] = {
      name: this.NAME_MESSAGE,
      type: this.TYPE_HEADLINE,
      ns: 'http://jabber.org/protocol/pubsub#event',
      filters: [EventFilters.isPreferences]
    };
    config[this.BOOKMARKS_UPDATE] = {
      name: this.NAME_MESSAGE,
      type: this.TYPE_HEADLINE,
      ns: 'http://jabber.org/protocol/pubsub#event',
      filters: [EventFilters.isBookmarks]
    };
    config[this.MESSAGE_CHAT_HISTORY_RECEIVED] = {
      name: this.NAME_MESSAGE,
      ns: HistoryNS.CHAT_HISTORY,
      filters: [EventFilters.isntMUC]
    };
    config[this.MESSAGE_CHAT_RECEIVED] = {
      name: this.NAME_MESSAGE,
      type: this.TYPE_CHAT,
      filters: [EventFilters.isntMUC]
    };
    config[this.MESSAGE_CHAT_REGISTERED] = {
      name: this.NAME_MESSAGE,
      ns: ACKNS.NITRO_RECEIPTS,
      filters: [EventFilters.isntMUC]
    };
    config[this.MESSAGE_CHAT_DELIVERED] = {
      name: this.NAME_MESSAGE,
      type: this.TYPE_CHAT,
      filters: [EventFilters.isClientAck, EventFilters.isntMUC]
    };
    config[this.MESSAGE_CHAT_FAILED] = {
      name: this.NAME_MESSAGE,
      type: this.TYPE_ERROR,
      filters: [EventFilters.isntMUC]
    };
    config[this.MESSAGE_GROUPCHAT_INVITE] = {
      name: this.NAME_MESSAGE,
      filters: [EventFilters.isMUCInvite, EventFilters.isntError]
    };
    config[this.MESSAGE_GROUPCHAT_INVITE_REJECTED] = {
      name: this.NAME_MESSAGE,
      filters: [EventFilters.isMUC, EventFilters.hasDecline]
    };
    config[this.MESSAGE_GROUPCHAT_INVITE_BLOCKED] = {
      name: this.NAME_MESSAGE,
      type: this.TYPE_ERROR,
      filters: [EventFilters.hasPolicyViolation, EventFilters.hasInvitee, EventFilters.hasntErrorTypeCancel]
    };
    config[this.MESSAGE_GROUPCHAT_INVITE_ERROR] = {
      name: this.NAME_MESSAGE,
      type: this.TYPE_ERROR,
      filters: [EventFilters.hasErrorTypeCancel, EventFilters.hasInvitee]
    };
    config[this.MESSAGE_GROUPCHAT_SUBJECT] = {
      name: this.NAME_MESSAGE,
      filters: [EventFilters.isMUCSubject]
    };
    config[this.MESSAGE_GROUPCHAT_RECEIVED] = {
      name: this.NAME_MESSAGE,
      type: this.TYPE_GROUPCHAT,
      filters: [EventFilters.isntMUCSelf, EventFilters.isntMUCInvite, EventFilters.isntMUCSubject, EventFilters.isntDelayed, EventFilters.hasBodyTag]
    };
    config[this.MESSAGE_MANAGED_GROUPCHAT_REGISTERED] = {
      name: this.NAME_MESSAGE,
      ns: ACKNS.STANDARD_RECEIPTS,
      filters: [EventFilters.isMUC, EventFilters.hasntErrorTypeModify]
    };
    config[this.MESSAGE_GROUPCHAT_HISTORY_RECEIVED] = {
      name: this.NAME_MESSAGE,
      type: this.TYPE_GROUPCHAT,
      ns: HistoryNS.DELAY,
      filters: [EventFilters.isDelayed]
    };
    config[this.MESSAGE_GROUPCHAT_REGISTERED] = {
      name: this.NAME_MESSAGE,
      type: this.TYPE_GROUPCHAT,
      filters: [EventFilters.isGroupchatAck]
    };
    config[this.MESSAGE_GROUPCHAT_DELIVERED] = {
      name: this.NAME_MESSAGE,
      type: this.TYPE_GROUPCHAT,
      filters: [EventFilters.isClientAck]
    };
    config[this.MESSAGE_GROUPCHAT_FAILED] = {
      name: this.NAME_MESSAGE,
      type: this.TYPE_ERROR,
      filters: [EventFilters.isMUC]
    };
    config[this.MESSAGE_CHAT_FIN] = {
      name: this.NAME_MESSAGE,
      ns: HistoryNS.CHAT_HISTORY,
      filters: [EventFilters.isHistoryFin]
    };
    config[this.ROSTER_ADDED] = {
      name: this.NAME_IQ,
      type: this.TYPE_SET,
      ns: 'jabber:iq:roster',
      filters: [EventFilters.isRosterAdded]
    };
    config[this.ROSTER_REMOVED] = {
      name: this.NAME_IQ,
      type: this.TYPE_SET,
      ns: 'jabber:iq:roster',
      filters: [EventFilters.isRosterRemoved]
    };
    config[this.ROSTER_INVITE_RECEIVED] = {
      name: this.NAME_PRESENCE,
      type: PresenceType.SUBSCRIBE,
      filters: [EventFilters.isntSelf, EventFilters.isntYahooGateway]
    };
    config[this.ROSTER_INVITE_CONFIRMED] = {
      name: this.NAME_PRESENCE,
      type: PresenceType.SUBSCRIBE,
      filters: [EventFilters.isntSelf]
    };
    config[this.BLOCKLIST_BLOCK] = {
      name: this.NAME_IQ,
      type: this.TYPE_SET,
      ns: 'urn:xmpp:blocking',
      filters: [EventFilters.isBlocklistBlocked]
    };
    config[this.BLOCKLIST_UNBLOCK] = {
      name: this.NAME_IQ,
      type: this.TYPE_SET,
      ns: 'urn:xmpp:blocking',
      filters: [EventFilters.isBlocklistUnblocked]
    };
    config[this.GROUPCHAT_SELF_JOINED] = {
      name: this.NAME_PRESENCE,
      ns: 'http://jabber.org/protocol/muc#user',
      filters: [EventFilters.isMUCSelf, EventFilters.hasntType]
    };
    config[this.GROUPCHAT_SELF_LEFT] = {
      name: this.NAME_PRESENCE,
      ns: 'http://jabber.org/protocol/muc#user',
      type: PresenceType.UNAVAILABLE,
      filters: [EventFilters.isMUCSelf]
    };
    config[this.GROUPCHAT_USER_JOINED] = {
      name: this.NAME_PRESENCE,
      ns: 'http://jabber.org/protocol/muc#user',
      filters: [EventFilters.isntMUCSelf, EventFilters.hasntType]
    };
    config[this.GROUPCHAT_USER_LEFT] = {
      name: this.NAME_PRESENCE,
      ns: 'http://jabber.org/protocol/muc#user',
      type: PresenceType.UNAVAILABLE,
      filters: [EventFilters.isntMUCSelf]
    };
    config[this.GROUPCHAT_JOIN_ERROR] = {
      name: this.NAME_PRESENCE,
      type: PresenceType.ERROR,
      filters: [EventFilters.isMUCSelf]
    };
    config[this.GROUPCHAT_CONFIGURATION_CHANGE] = {
      name: this.NAME_MESSAGE,
      type: this.TYPE_GROUPCHAT,
      filters: [EventFilters.hasStatusCode]
    };
    config[this.GATEWAY_YAHOO_SUBSCRIBE] = {
      name: this.NAME_PRESENCE,
      type: PresenceType.SUBSCRIBE,
      filters: [EventFilters.isYahooGateway]
    };
    config[this.GATEWAY_YAHOO_SELF_PRESENCE] = {
      name: this.NAME_PRESENCE,
      filters: [EventFilters.isYahooGateway, EventFilters.isntSubscribe]
    };
    config[this.GATEWAY_YAHOO_UNSUBSCRIBED] = {
      name: this.NAME_PRESENCE,
      type: PresenceType.UNSUBSCRIBED,
      filters: [EventFilters.isYahooGateway]
    };
    config[this.STREAM_ERROR] = {
      name: 'stream:error',
      filters: [EventFilters.isConflict]
    };
    config[this.TYPING_NOTICE] = {
      name: 'message',
      filters: [EventFilters.isTypingNotice]
    };
    config[this.PRESENCE_GROUPCHAT_HISTORY_BLOCKED] = {
      name: this.NAME_PRESENCE,
      type: this.TYPE_ERROR,
      filters: [EventFilters.isHistoryBlocked]
    };
    return config;
  };

  return Events;

})();


},{"enum/ack_ns":"enum/ack_ns","enum/gateways":"enum/gateways","enum/history_ns":"enum/history_ns","enum/message_type":"enum/message_type","enum/presence_type":"enum/presence_type","events/event_filters":"events/event_filters","strophe/strophe_presence":"strophe/strophe_presence","underscore":85}],"events/io_event":[function(require,module,exports){
module.exports = {
  RAW: 'IOEvent.RAW',
  XML: 'IOEvent.XML',
  INPUT: 'IOEvent.INPUT',
  OUTPUT: 'IOEvent.OUTPUT'
};


},{}],"lib/strophe":[function(require,module,exports){
(function (global){
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
/** File: strophe.js
 *  A JavaScript library for writing XMPP clients.
 *
 *  This library uses either Bidirectional-streams Over Synchronous HTTP (BOSH)
 *  to emulate a persistent, stateful, two-way connection to an XMPP server or
 *  alternatively WebSockets.
 *
 *  More information on BOSH can be found in XEP 124.
 *  For more information on XMPP-over WebSocket see this RFC:
 *  http://tools.ietf.org/html/rfc7395
 */

/* All of the Strophe globals are defined in this special function below so
 * that references to the globals become closures.  This will ensure that
 * on page reload, these references will still be available to callbacks
 * that are still executing.
 */

/* jshint ignore:start */
(function (callback) {
/* jshint ignore:end */

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-base64', function () {
            return factory();
        });
    } else {
        // Browser globals
        root.Base64 = factory();
    }
}(this, function () {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

    var obj = {
        /**
         * Encodes a string in base64
         * @param {String} input The string to encode in base64.
         */
        encode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            do {
                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);

                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if (isNaN(chr2)) {
                    enc2 = ((chr1 & 3) << 4);
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }

                output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) + keyStr.charAt(enc4);
            } while (i < input.length);

            return output;
        },

        /**
         * Decodes a base64 string.
         * @param {String} input The string to decode.
         */
        decode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

            do {
                enc1 = keyStr.indexOf(input.charAt(i++));
                enc2 = keyStr.indexOf(input.charAt(i++));
                enc3 = keyStr.indexOf(input.charAt(i++));
                enc4 = keyStr.indexOf(input.charAt(i++));

                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;

                output = output + String.fromCharCode(chr1);

                if (enc3 != 64) {
                    output = output + String.fromCharCode(chr2);
                }
                if (enc4 != 64) {
                    output = output + String.fromCharCode(chr3);
                }
            } while (i < input.length);

            return output;
        }
    };
    return obj;
}));

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/* jshint undef: true, unused: true:, noarg: true, latedef: false */
/* global define */

/* Some functions and variables have been stripped for use with Strophe */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-sha1', function () {
            return factory();
        });
    } else {
        // Browser globals
        root.SHA1 = factory();
    }
}(this, function () {

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = new Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  var i, j, t, olda, oldb, oldc, oldd, olde;
  for (i = 0; i < x.length; i += 16)
  {
    olda = a;
    oldb = b;
    oldc = c;
    oldd = d;
    olde = e;

    for (j = 0; j < 80; j++)
    {
      if (j < 16) { w[j] = x[i + j]; }
      else { w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1); }
      t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return [a, b, c, d, e];
}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if (t < 20) { return (b & c) | ((~b) & d); }
  if (t < 40) { return b ^ c ^ d; }
  if (t < 60) { return (b & c) | (b & d) | (c & d); }
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if (bkey.length > 16) { bkey = core_sha1(bkey, key.length * 8); }

  var ipad = new Array(16), opad = new Array(16);
  for (var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = [];
  var mask = 255;
  for (var i = 0; i < str.length * 8; i += 8)
  {
    bin[i>>5] |= (str.charCodeAt(i / 8) & mask) << (24 - i%32);
  }
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = 255;
  for (var i = 0; i < bin.length * 32; i += 8)
  {
    str += String.fromCharCode((bin[i>>5] >>> (24 - i%32)) & mask);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  var triplet, j;
  for (var i = 0; i < binarray.length * 4; i += 3)
  {
    triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |
              (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |
               ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for (j = 0; j < 4; j++)
    {
      if (i * 8 + j * 6 > binarray.length * 32) { str += "="; }
      else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }
    }
  }
  return str;
}

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
return {
    b64_hmac_sha1:  function (key, data){ return binb2b64(core_hmac_sha1(key, data)); },
    b64_sha1:       function (s) { return binb2b64(core_sha1(str2binb(s),s.length * 8)); },
    binb2str:       binb2str,
    core_hmac_sha1: core_hmac_sha1,
    str_hmac_sha1:  function (key, data){ return binb2str(core_hmac_sha1(key, data)); },
    str_sha1:       function (s) { return binb2str(core_sha1(str2binb(s),s.length * 8)); },
};
}));

/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Everything that isn't used by Strophe has been stripped here!
 */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-md5', function () {
            return factory();
        });
    } else {
        // Browser globals
        root.MD5 = factory();
    }
}(this, function (b) {
    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    var safe_add = function (x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    };

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    var bit_rol = function (num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    };

    /*
     * Convert a string to an array of little-endian words
     */
    var str2binl = function (str) {
        var bin = [];
        for(var i = 0; i < str.length * 8; i += 8)
        {
            bin[i>>5] |= (str.charCodeAt(i / 8) & 255) << (i%32);
        }
        return bin;
    };

    /*
     * Convert an array of little-endian words to a string
     */
    var binl2str = function (bin) {
        var str = "";
        for(var i = 0; i < bin.length * 32; i += 8)
        {
            str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & 255);
        }
        return str;
    };

    /*
     * Convert an array of little-endian words to a hex string.
     */
    var binl2hex = function (binarray) {
        var hex_tab = "0123456789abcdef";
        var str = "";
        for(var i = 0; i < binarray.length * 4; i++)
        {
            str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
                hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
        }
        return str;
    };

    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    var md5_cmn = function (q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);
    };

    var md5_ff = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    };

    var md5_gg = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    };

    var md5_hh = function (a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    };

    var md5_ii = function (a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    };

    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length
     */
    var core_md5 = function (x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var a =  1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d =  271733878;

        var olda, oldb, oldc, oldd;
        for (var i = 0; i < x.length; i += 16)
        {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
            d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
            d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
            d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
            c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
            d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
            c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
            d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
            c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
            d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
            d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
            d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
            d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    };

    var obj = {
        /*
         * These are the functions you'll usually want to call.
         * They take string arguments and return either hex or base-64 encoded
         * strings.
         */
        hexdigest: function (s) {
            return binl2hex(core_md5(str2binl(s), s.length * 8));
        },

        hash: function (s) {
            return binl2str(core_md5(str2binl(s), s.length * 8));
        }
    };
    return obj;
}));

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-utils', function () {
            return factory();
        });
    } else {
        // Browser globals
        root.stropheUtils = factory();
    }
}(this, function () {

    var utils = {

        utf16to8: function (str) {
            var i, c;
            var out = "";
            var len = str.length;
            for (i = 0; i < len; i++) {
                c = str.charCodeAt(i);
                if ((c >= 0x0000) && (c <= 0x007F)) {
                    out += str.charAt(i);
                } else if (c > 0x07FF) {
                    out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));
                    out += String.fromCharCode(0x80 | ((c >>  6) & 0x3F));
                    out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));
                } else {
                    out += String.fromCharCode(0xC0 | ((c >>  6) & 0x1F));
                    out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));
                }
            }
            return out;
        },

        addCookies: function (cookies) {
            /* Parameters:
             *  (Object) cookies - either a map of cookie names
             *    to string values or to maps of cookie values.
             *
             * For example:
             * { "myCookie": "1234" }
             *
             * or:
             * { "myCookie": {
             *      "value": "1234",
             *      "domain": ".example.org",
             *      "path": "/",
             *      "expires": expirationDate
             *      }
             *  }
             *
             *  These values get passed to Strophe.Connection via
             *   options.cookies
             */
            var cookieName, cookieObj, isObj, cookieValue, expires, domain, path;
            for (cookieName in (cookies || {})) {
                expires = '';
                domain = '';
                path = '';
                cookieObj = cookies[cookieName];
                isObj = typeof cookieObj == "object";
                cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));
                if (isObj) {
                    expires = cookieObj.expires ? ";expires="+cookieObj.expires : '';
                    domain = cookieObj.domain ? ";domain="+cookieObj.domain : '';
                    path = cookieObj.path ? ";path="+cookieObj.path : '';
                }
                document.cookie =
                    cookieName+'='+cookieValue + expires + domain + path;
            }
        }
    };
    return utils;
}));

/*
    This program is distributed under the terms of the MIT license.
    Please see the LICENSE file for details.

    Copyright 2006-2008, OGG, LLC
*/

/* jshint undef: true, unused: true:, noarg: true, latedef: true */
/* global define */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-polyfill', [], function () {
            return factory();
        });
    } else {
        // Browser globals
        return factory();
    }
}(this, function () {

/** Function: Function.prototype.bind
 *  Bind a function to an instance.
 *
 *  This Function object extension method creates a bound method similar
 *  to those in Python.  This means that the 'this' object will point
 *  to the instance you want.  See <MDC's bind() documentation at https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind>
 *  and <Bound Functions and Function Imports in JavaScript at http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/>
 *  for a complete explanation.
 *
 *  This extension already exists in some browsers (namely, Firefox 3), but
 *  we provide it to support those that don't.
 *
 *  Parameters:
 *    (Object) obj - The object that will become 'this' in the bound function.
 *    (Object) argN - An option argument that will be prepended to the
 *      arguments given for the function call
 *
 *  Returns:
 *    The bound function.
 */
if (!Function.prototype.bind) {
    Function.prototype.bind = function (obj /*, arg1, arg2, ... */) {
        var func = this;
        var _slice = Array.prototype.slice;
        var _concat = Array.prototype.concat;
        var _args = _slice.call(arguments, 1);
        return function () {
            return func.apply(obj ? obj : this, _concat.call(_args, _slice.call(arguments, 0)));
        };
    };
}

/** Function: Array.isArray
 *  This is a polyfill for the ES5 Array.isArray method.
 */
if (!Array.isArray) {
    Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}

/** Function: Array.prototype.indexOf
 *  Return the index of an object in an array.
 *
 *  This function is not supplied by some JavaScript implementations, so
 *  we provide it if it is missing.  This code is from:
 *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf
 *
 *  Parameters:
 *    (Object) elt - The object to look for.
 *    (Integer) from - The index from which to start looking. (optional).
 *
 *  Returns:
 *    The index of elt in the array or -1 if not found.
 */
if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function(elt /*, from*/) {
            var len = this.length;
            var from = Number(arguments[1]) || 0;
            from = (from < 0) ? Math.ceil(from) : Math.floor(from);
            if (from < 0) {
                from += len;
            }

            for (; from < len; from++) {
                if (from in this && this[from] === elt) {
                    return from;
                }
            }
            return -1;
        };
    }
}));


/** Function: Array.prototype.forEach
 *
 *  This function is not available in IE < 9
 *
 *  See <forEach on developer.mozilla.org at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach>
 */
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function(callback, thisArg) {
        var T, k;
        if (this === null) {
            throw new TypeError(' this is null or not defined');
        }

        // 1. Let O be the result of calling toObject() passing the
        // |this| value as the argument.
        var O = Object(this);
        // 2. Let lenValue be the result of calling the Get() internal
        // method of O with the argument "length".
        // 3. Let len be toUint32(lenValue).
        var len = O.length >>> 0;
        // 4. If isCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== "function") {
            throw new TypeError(callback + ' is not a function');
        }
        // 5. If thisArg was supplied, let T be thisArg; else let
        // T be undefined.
        if (arguments.length > 1) {
            T = thisArg;
        }
        // 6. Let k be 0
        k = 0;
        // 7. Repeat, while k < len
        while (k < len) {
            var kValue;
            // a. Let Pk be ToString(k).
            //        This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty
            //        internal method of O with argument Pk.
            //        This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal
                // method of O with argument Pk.
                kValue = O[k];
                // ii. Call the Call internal method of callback with T as
                // the this value and argument list containing kValue, k, and O.
                callback.call(T, kValue, k, O);
            }
            // d. Increase k by 1.
            k++;
        }
        // 8. return undefined
    };
}

/*
    This program is distributed under the terms of the MIT license.
    Please see the LICENSE file for details.

    Copyright 2006-2008, OGG, LLC
*/

/* jshint undef: true, unused: true:, noarg: true, latedef: true */
/*global define, document, window, setTimeout, clearTimeout, ActiveXObject, DOMParser */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-core', [
            'strophe-sha1',
            'strophe-base64',
            'strophe-md5',
            'strophe-utils',
            "strophe-polyfill"
        ], function () {
            return factory.apply(this, arguments);
        });
    } else {
        // Browser globals
        var o = factory(root.SHA1, root.Base64, root.MD5, root.stropheUtils);
        window.Strophe =        o.Strophe;
        window.$build =         o.$build;
        window.$iq =            o.$iq;
        window.$msg =           o.$msg;
        window.$pres =          o.$pres;
        window.SHA1 =           o.SHA1;
        window.Base64 =         o.Base64;
        window.MD5 =            o.MD5;
        window.b64_hmac_sha1 =  o.SHA1.b64_hmac_sha1;
        window.b64_sha1 =       o.SHA1.b64_sha1;
        window.str_hmac_sha1 =  o.SHA1.str_hmac_sha1;
        window.str_sha1 =       o.SHA1.str_sha1;
    }
}(this, function (SHA1, Base64, MD5, utils) {

var Strophe;

/** Function: $build
 *  Create a Strophe.Builder.
 *  This is an alias for 'new Strophe.Builder(name, attrs)'.
 *
 *  Parameters:
 *    (String) name - The root element name.
 *    (Object) attrs - The attributes for the root element in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $build(name, attrs) { return new Strophe.Builder(name, attrs); }

/** Function: $msg
 *  Create a Strophe.Builder with a <message/> element as the root.
 *
 *  Parameters:
 *    (Object) attrs - The <message/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $msg(attrs) { return new Strophe.Builder("message", attrs); }

/** Function: $iq
 *  Create a Strophe.Builder with an <iq/> element as the root.
 *
 *  Parameters:
 *    (Object) attrs - The <iq/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $iq(attrs) { return new Strophe.Builder("iq", attrs); }

/** Function: $pres
 *  Create a Strophe.Builder with a <presence/> element as the root.
 *
 *  Parameters:
 *    (Object) attrs - The <presence/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $pres(attrs) { return new Strophe.Builder("presence", attrs); }

/** Class: Strophe
 *  An object container for all Strophe library functions.
 *
 *  This class is just a container for all the objects and constants
 *  used in the library.  It is not meant to be instantiated, but to
 *  provide a namespace for library objects, constants, and functions.
 */
Strophe = {
    /** Constant: VERSION
     *  The version of the Strophe library. Unreleased builds will have
     *  a version of head-HASH where HASH is a partial revision.
     */
    VERSION: "1.2.10",

    /** Constants: XMPP Namespace Constants
     *  Common namespace constants from the XMPP RFCs and XEPs.
     *
     *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.
     *  NS.BOSH - BOSH namespace from XEP 206.
     *  NS.CLIENT - Main XMPP client namespace.
     *  NS.AUTH - Legacy authentication namespace.
     *  NS.ROSTER - Roster operations namespace.
     *  NS.PROFILE - Profile namespace.
     *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.
     *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.
     *  NS.MUC - Multi-User Chat namespace from XEP 45.
     *  NS.SASL - XMPP SASL namespace from RFC 3920.
     *  NS.STREAM - XMPP Streams namespace from RFC 3920.
     *  NS.BIND - XMPP Binding namespace from RFC 3920.
     *  NS.SESSION - XMPP Session namespace from RFC 3920.
     *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.
     *  NS.XHTML - XHTML body namespace from XEP 71.
     */
    NS: {
        HTTPBIND: "http://jabber.org/protocol/httpbind",
        BOSH: "urn:xmpp:xbosh",
        CLIENT: "jabber:client",
        AUTH: "jabber:iq:auth",
        ROSTER: "jabber:iq:roster",
        PROFILE: "jabber:iq:profile",
        DISCO_INFO: "http://jabber.org/protocol/disco#info",
        DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
        MUC: "http://jabber.org/protocol/muc",
        SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
        STREAM: "http://etherx.jabber.org/streams",
        FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
        BIND: "urn:ietf:params:xml:ns:xmpp-bind",
        SESSION: "urn:ietf:params:xml:ns:xmpp-session",
        VERSION: "jabber:iq:version",
        STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
        XHTML_IM: "http://jabber.org/protocol/xhtml-im",
        XHTML: "http://www.w3.org/1999/xhtml"
    },

    /** Constants: XHTML_IM Namespace
     *  contains allowed tags, tag attributes, and css properties.
     *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.
     *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended
     *  allowed tags and their attributes.
     */
    XHTML: {
        tags: ['a','blockquote','br','cite','em','img','li','ol','p','span','strong','ul','body'],
        attributes: {
            'a':          ['href'],
            'blockquote': ['style'],
            'br':         [],
            'cite':       ['style'],
            'em':         [],
            'img':        ['src', 'alt', 'style', 'height', 'width'],
            'li':         ['style'],
            'ol':         ['style'],
            'p':          ['style'],
            'span':       ['style'],
            'strong':     [],
            'ul':         ['style'],
            'body':       []
        },
        css: ['background-color','color','font-family','font-size','font-style','font-weight','margin-left','margin-right','text-align','text-decoration'],
        /** Function: XHTML.validTag
         *
         * Utility method to determine whether a tag is allowed
         * in the XHTML_IM namespace.
         *
         * XHTML tag names are case sensitive and must be lower case.
         */
        validTag: function(tag) {
            for (var i = 0; i < Strophe.XHTML.tags.length; i++) {
                if (tag == Strophe.XHTML.tags[i]) {
                    return true;
                }
            }
            return false;
        },
        /** Function: XHTML.validAttribute
         *
         * Utility method to determine whether an attribute is allowed
         * as recommended per XEP-0071
         *
         * XHTML attribute names are case sensitive and must be lower case.
         */
        validAttribute: function(tag, attribute) {
            if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {
                for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                    if (attribute == Strophe.XHTML.attributes[tag][i]) {
                        return true;
                    }
                }
            }
        return false;
        },
        validCSS: function(style) {
            for (var i = 0; i < Strophe.XHTML.css.length; i++) {
                if (style == Strophe.XHTML.css[i]) {
                    return true;
                }
            }
            return false;
        }
    },

    /** Constants: Connection Status Constants
     *  Connection status constants for use by the connection handler
     *  callback.
     *
     *  Status.ERROR - An error has occurred
     *  Status.CONNECTING - The connection is currently being made
     *  Status.CONNFAIL - The connection attempt failed
     *  Status.AUTHENTICATING - The connection is authenticating
     *  Status.AUTHFAIL - The authentication attempt failed
     *  Status.CONNECTED - The connection has succeeded
     *  Status.DISCONNECTED - The connection has been terminated
     *  Status.DISCONNECTING - The connection is currently being terminated
     *  Status.ATTACHED - The connection has been attached
     *  Status.CONNTIMEOUT - The connection has timed out
     */
    Status: {
        ERROR: 0,
        CONNECTING: 1,
        CONNFAIL: 2,
        AUTHENTICATING: 3,
        AUTHFAIL: 4,
        CONNECTED: 5,
        DISCONNECTED: 6,
        DISCONNECTING: 7,
        ATTACHED: 8,
        REDIRECT: 9,
        CONNTIMEOUT: 10
    },

    /** Constants: Log Level Constants
     *  Logging level indicators.
     *
     *  LogLevel.DEBUG - Debug output
     *  LogLevel.INFO - Informational output
     *  LogLevel.WARN - Warnings
     *  LogLevel.ERROR - Errors
     *  LogLevel.FATAL - Fatal errors
     */
    LogLevel: {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3,
        FATAL: 4
    },

    /** PrivateConstants: DOM Element Type Constants
     *  DOM element types.
     *
     *  ElementType.NORMAL - Normal element.
     *  ElementType.TEXT - Text data element.
     *  ElementType.FRAGMENT - XHTML fragment element.
     */
    ElementType: {
        NORMAL: 1,
        TEXT: 3,
        CDATA: 4,
        FRAGMENT: 11
    },

    /** PrivateConstants: Timeout Values
     *  Timeout values for error states.  These values are in seconds.
     *  These should not be changed unless you know exactly what you are
     *  doing.
     *
     *  TIMEOUT - Timeout multiplier. A waiting request will be considered
     *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.
     *      This defaults to 1.1, and with default wait, 66 seconds.
     *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where
     *      Strophe can detect early failure, it will consider the request
     *      failed if it doesn't return after
     *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.
     *      This defaults to 0.1, and with default wait, 6 seconds.
     */
    TIMEOUT: 1.1,
    SECONDARY_TIMEOUT: 0.1,

    /** Function: addNamespace
     *  This function is used to extend the current namespaces in
     *  Strophe.NS.  It takes a key and a value with the key being the
     *  name of the new namespace, with its actual value.
     *  For example:
     *  Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
     *
     *  Parameters:
     *    (String) name - The name under which the namespace will be
     *      referenced under Strophe.NS
     *    (String) value - The actual namespace.
     */
    addNamespace: function (name, value) {
        Strophe.NS[name] = value;
    },

    /** Function: forEachChild
     *  Map a function over some or all child elements of a given element.
     *
     *  This is a small convenience function for mapping a function over
     *  some or all of the children of an element.  If elemName is null, all
     *  children will be passed to the function, otherwise only children
     *  whose tag names match elemName will be passed.
     *
     *  Parameters:
     *    (XMLElement) elem - The element to operate on.
     *    (String) elemName - The child element tag name filter.
     *    (Function) func - The function to apply to each child.  This
     *      function should take a single argument, a DOM element.
     */
    forEachChild: function (elem, elemName, func) {
        var i, childNode;
        for (i = 0; i < elem.childNodes.length; i++) {
            childNode = elem.childNodes[i];
            if (childNode.nodeType == Strophe.ElementType.NORMAL &&
                (!elemName || this.isTagEqual(childNode, elemName))) {
                func(childNode);
            }
        }
    },

    /** Function: isTagEqual
     *  Compare an element's tag name with a string.
     *
     *  This function is case sensitive.
     *
     *  Parameters:
     *    (XMLElement) el - A DOM element.
     *    (String) name - The element name.
     *
     *  Returns:
     *    true if the element's tag name matches _el_, and false
     *    otherwise.
     */
    isTagEqual: function (el, name) {
        return el.tagName == name;
    },

    /** PrivateVariable: _xmlGenerator
     *  _Private_ variable that caches a DOM document to
     *  generate elements.
     */
    _xmlGenerator: null,

    /** PrivateFunction: _makeGenerator
     *  _Private_ function that creates a dummy XML DOM document to serve as
     *  an element and text node generator.
     */
    _makeGenerator: function () {
        var doc;
        // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.
        // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be
                // less than 10 in the case of IE9 and below.
        if (document.implementation.createDocument === undefined ||
                        document.implementation.createDocument && document.documentMode && document.documentMode < 10) {
            doc = this._getIEXmlDom();
            doc.appendChild(doc.createElement('strophe'));
        } else {
            doc = document.implementation
                .createDocument('jabber:client', 'strophe', null);
        }
        return doc;
    },

    /** Function: xmlGenerator
     *  Get the DOM document to generate elements.
     *
     *  Returns:
     *    The currently used DOM document.
     */
    xmlGenerator: function () {
        if (!Strophe._xmlGenerator) {
            Strophe._xmlGenerator = Strophe._makeGenerator();
        }
        return Strophe._xmlGenerator;
    },

    /** PrivateFunction: _getIEXmlDom
     *  Gets IE xml doc object
     *
     *  Returns:
     *    A Microsoft XML DOM Object
     *  See Also:
     *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx
     */
    _getIEXmlDom : function() {
        var doc = null;
        var docStrings = [
            "Msxml2.DOMDocument.6.0",
            "Msxml2.DOMDocument.5.0",
            "Msxml2.DOMDocument.4.0",
            "MSXML2.DOMDocument.3.0",
            "MSXML2.DOMDocument",
            "MSXML.DOMDocument",
            "Microsoft.XMLDOM"
        ];

        for (var d = 0; d < docStrings.length; d++) {
            if (doc === null) {
                try {
                    doc = new ActiveXObject(docStrings[d]);
                } catch (e) {
                    doc = null;
                }
            } else {
                break;
            }
        }
        return doc;
    },

    /** Function: xmlElement
     *  Create an XML DOM element.
     *
     *  This function creates an XML DOM element correctly across all
     *  implementations. Note that these are not HTML DOM elements, which
     *  aren't appropriate for XMPP stanzas.
     *
     *  Parameters:
     *    (String) name - The name for the element.
     *    (Array|Object) attrs - An optional array or object containing
     *      key/value pairs to use as element attributes. The object should
     *      be in the format {'key': 'value'} or {key: 'value'}. The array
     *      should have the format [['key1', 'value1'], ['key2', 'value2']].
     *    (String) text - The text child data for the element.
     *
     *  Returns:
     *    A new XML DOM element.
     */
    xmlElement: function (name) {
        if (!name) { return null; }

        var node = Strophe.xmlGenerator().createElement(name);
        // FIXME: this should throw errors if args are the wrong type or
        // there are more than two optional args
        var a, i, k;
        for (a = 1; a < arguments.length; a++) {
            var arg = arguments[a];
            if (!arg) { continue; }
            if (typeof(arg) == "string" ||
                typeof(arg) == "number") {
                node.appendChild(Strophe.xmlTextNode(arg));
            } else if (typeof(arg) == "object" &&
                       typeof(arg.sort) == "function") {
                for (i = 0; i < arg.length; i++) {
                    var attr = arg[i];
                    if (typeof(attr) == "object" &&
                        typeof(attr.sort) == "function" &&
                        attr[1] !== undefined &&
                        attr[1] !== null) {
                        node.setAttribute(attr[0], attr[1]);
                    }
                }
            } else if (typeof(arg) == "object") {
                for (k in arg) {
                    if (arg.hasOwnProperty(k)) {
                        if (arg[k] !== undefined &&
                            arg[k] !== null) {
                            node.setAttribute(k, arg[k]);
                        }
                    }
                }
            }
        }

        return node;
    },

    /*  Function: xmlescape
     *  Excapes invalid xml characters.
     *
     *  Parameters:
     *     (String) text - text to escape.
     *
     *  Returns:
     *      Escaped text.
     */
    xmlescape: function(text) {
        text = text.replace(/\&/g, "&amp;");
        text = text.replace(/</g,  "&lt;");
        text = text.replace(/>/g,  "&gt;");
        text = text.replace(/'/g,  "&apos;");
        text = text.replace(/"/g,  "&quot;");
        return text;
    },

    /*  Function: xmlunescape
    *  Unexcapes invalid xml characters.
    *
    *  Parameters:
    *     (String) text - text to unescape.
    *
    *  Returns:
    *      Unescaped text.
    */
    xmlunescape: function(text) {
        text = text.replace(/\&amp;/g, "&");
        text = text.replace(/&lt;/g,  "<");
        text = text.replace(/&gt;/g,  ">");
        text = text.replace(/&apos;/g,  "'");
        text = text.replace(/&quot;/g,  "\"");
        return text;
    },

    /** Function: xmlTextNode
     *  Creates an XML DOM text node.
     *
     *  Provides a cross implementation version of document.createTextNode.
     *
     *  Parameters:
     *    (String) text - The content of the text node.
     *
     *  Returns:
     *    A new XML DOM text node.
     */
    xmlTextNode: function (text) {
        return Strophe.xmlGenerator().createTextNode(text);
    },

    /** Function: xmlHtmlNode
     *  Creates an XML DOM html node.
     *
     *  Parameters:
     *    (String) html - The content of the html node.
     *
     *  Returns:
     *    A new XML DOM text node.
     */
    xmlHtmlNode: function (html) {
        var node;
        //ensure text is escaped
        if (window.DOMParser) {
            var parser = new DOMParser();
            node = parser.parseFromString(html, "text/xml");
        } else {
            node = new ActiveXObject("Microsoft.XMLDOM");
            node.async="false";
            node.loadXML(html);
        }
        return node;
    },

    /** Function: getText
     *  Get the concatenation of all text children of an element.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    A String with the concatenated text of all text element children.
     */
    getText: function (elem) {
        if (!elem) { return null; }

        var str = "";
        if (elem.childNodes.length === 0 && elem.nodeType ==
            Strophe.ElementType.TEXT) {
            str += elem.nodeValue;
        }

        for (var i = 0; i < elem.childNodes.length; i++) {
            if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
                str += elem.childNodes[i].nodeValue;
            }
        }

        return Strophe.xmlescape(str);
    },

    /** Function: copyElement
     *  Copy an XML DOM element.
     *
     *  This function copies a DOM element and all its descendants and returns
     *  the new copy.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    A new, copied DOM element tree.
     */
    copyElement: function (elem) {
        var i, el;
        if (elem.nodeType == Strophe.ElementType.NORMAL) {
            el = Strophe.xmlElement(elem.tagName);

            for (i = 0; i < elem.attributes.length; i++) {
                el.setAttribute(elem.attributes[i].nodeName,
                                elem.attributes[i].value);
            }

            for (i = 0; i < elem.childNodes.length; i++) {
                el.appendChild(Strophe.copyElement(elem.childNodes[i]));
            }
        } else if (elem.nodeType == Strophe.ElementType.TEXT) {
            el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);
        }
        return el;
    },


    /** Function: createHtml
     *  Copy an HTML DOM element into an XML DOM.
     *
     *  This function copies a DOM element and all its descendants and returns
     *  the new copy.
     *
     *  Parameters:
     *    (HTMLElement) elem - A DOM element.
     *
     *  Returns:
     *    A new, copied DOM element tree.
     */
    createHtml: function (elem) {
        var i, el, j, tag, attribute, value, css, cssAttrs, attr, cssName, cssValue;
        if (elem.nodeType == Strophe.ElementType.NORMAL) {
            tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.
            if(Strophe.XHTML.validTag(tag)) {
                try {
                    el = Strophe.xmlElement(tag);
                    for(i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                        attribute = Strophe.XHTML.attributes[tag][i];
                        value = elem.getAttribute(attribute);
                        if(typeof value == 'undefined' || value === null || value === '' || value === false || value === 0) {
                            continue;
                        }
                        if(attribute == 'style' && typeof value == 'object') {
                            if(typeof value.cssText != 'undefined') {
                                value = value.cssText; // we're dealing with IE, need to get CSS out
                            }
                        }
                        // filter out invalid css styles
                        if(attribute == 'style') {
                            css = [];
                            cssAttrs = value.split(';');
                            for(j = 0; j < cssAttrs.length; j++) {
                                attr = cssAttrs[j].split(':');
                                cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                                if(Strophe.XHTML.validCSS(cssName)) {
                                    cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                                    css.push(cssName + ': ' + cssValue);
                                }
                            }
                            if(css.length > 0) {
                                value = css.join('; ');
                                el.setAttribute(attribute, value);
                            }
                        } else {
                            el.setAttribute(attribute, value);
                        }
                    }

                    for (i = 0; i < elem.childNodes.length; i++) {
                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                    }
                } catch(e) { // invalid elements
                  el = Strophe.xmlTextNode('');
                }
            } else {
                el = Strophe.xmlGenerator().createDocumentFragment();
                for (i = 0; i < elem.childNodes.length; i++) {
                    el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                }
            }
        } else if (elem.nodeType == Strophe.ElementType.FRAGMENT) {
            el = Strophe.xmlGenerator().createDocumentFragment();
            for (i = 0; i < elem.childNodes.length; i++) {
                el.appendChild(Strophe.createHtml(elem.childNodes[i]));
            }
        } else if (elem.nodeType == Strophe.ElementType.TEXT) {
            el = Strophe.xmlTextNode(elem.nodeValue);
        }
        return el;
    },

    /** Function: escapeNode
     *  Escape the node part (also called local part) of a JID.
     *
     *  Parameters:
     *    (String) node - A node (or local part).
     *
     *  Returns:
     *    An escaped node (or local part).
     */
    escapeNode: function (node) {
        if (typeof node !== "string") { return node; }
        return node.replace(/^\s+|\s+$/g, '')
            .replace(/\\/g,  "\\5c")
            .replace(/ /g,   "\\20")
            .replace(/\"/g,  "\\22")
            .replace(/\&/g,  "\\26")
            .replace(/\'/g,  "\\27")
            .replace(/\//g,  "\\2f")
            .replace(/:/g,   "\\3a")
            .replace(/</g,   "\\3c")
            .replace(/>/g,   "\\3e")
            .replace(/@/g,   "\\40");
    },

    /** Function: unescapeNode
     *  Unescape a node part (also called local part) of a JID.
     *
     *  Parameters:
     *    (String) node - A node (or local part).
     *
     *  Returns:
     *    An unescaped node (or local part).
     */
    unescapeNode: function (node) {
        if (typeof node !== "string") { return node; }
        return node.replace(/\\20/g, " ")
            .replace(/\\22/g, '"')
            .replace(/\\26/g, "&")
            .replace(/\\27/g, "'")
            .replace(/\\2f/g, "/")
            .replace(/\\3a/g, ":")
            .replace(/\\3c/g, "<")
            .replace(/\\3e/g, ">")
            .replace(/\\40/g, "@")
            .replace(/\\5c/g, "\\");
    },

    /** Function: getNodeFromJid
     *  Get the node portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the node.
     */
    getNodeFromJid: function (jid) {
        if (jid.indexOf("@") < 0) { return null; }
        return jid.split("@")[0];
    },

    /** Function: getDomainFromJid
     *  Get the domain portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the domain.
     */
    getDomainFromJid: function (jid) {
        var bare = Strophe.getBareJidFromJid(jid);
        if (bare.indexOf("@") < 0) {
            return bare;
        } else {
            var parts = bare.split("@");
            parts.splice(0, 1);
            return parts.join('@');
        }
    },

    /** Function: getResourceFromJid
     *  Get the resource portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the resource.
     */
    getResourceFromJid: function (jid) {
        var s = jid.split("/");
        if (s.length < 2) { return null; }
        s.splice(0, 1);
        return s.join('/');
    },

    /** Function: getBareJidFromJid
     *  Get the bare JID from a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the bare JID.
     */
    getBareJidFromJid: function (jid) {
        return jid ? jid.split("/")[0] : null;
    },

    /** PrivateFunction: _handleError
     *  _Private_ function that properly logs an error to the console
     */
    _handleError: function (e) {
        if (typeof e.stack !== "undefined") {
            Strophe.fatal(e.stack);
        }
        if (e.sourceURL) {
            Strophe.fatal("error: " + this.handler + " " + e.sourceURL + ":" +
                          e.line + " - " + e.name + ": " + e.message);
        } else if (e.fileName) {
            Strophe.fatal("error: " + this.handler + " " +
                          e.fileName + ":" + e.lineNumber + " - " +
                          e.name + ": " + e.message);
        } else {
            Strophe.fatal("error: " + e.message);
        }
    },

    /** Function: log
     *  User overrideable logging function.
     *
     *  This function is called whenever the Strophe library calls any
     *  of the logging functions.  The default implementation of this
     *  function does nothing.  If client code wishes to handle the logging
     *  messages, it should override this with
     *  > Strophe.log = function (level, msg) {
     *  >   (user code here)
     *  > };
     *
     *  Please note that data sent and received over the wire is logged
     *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().
     *
     *  The different levels and their meanings are
     *
     *    DEBUG - Messages useful for debugging purposes.
     *    INFO - Informational messages.  This is mostly information like
     *      'disconnect was called' or 'SASL auth succeeded'.
     *    WARN - Warnings about potential problems.  This is mostly used
     *      to report transient connection errors like request timeouts.
     *    ERROR - Some error occurred.
     *    FATAL - A non-recoverable fatal error occurred.
     *
     *  Parameters:
     *    (Integer) level - The log level of the log message.  This will
     *      be one of the values in Strophe.LogLevel.
     *    (String) msg - The log message.
     */
    /* jshint ignore:start */
    log: function (level, msg) {
        return;
    },
    /* jshint ignore:end */

    /** Function: debug
     *  Log a message at the Strophe.LogLevel.DEBUG level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    debug: function(msg) {
        this.log(this.LogLevel.DEBUG, msg);
    },

    /** Function: info
     *  Log a message at the Strophe.LogLevel.INFO level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    info: function (msg) {
        this.log(this.LogLevel.INFO, msg);
    },

    /** Function: warn
     *  Log a message at the Strophe.LogLevel.WARN level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    warn: function (msg) {
        this.log(this.LogLevel.WARN, msg);
    },

    /** Function: error
     *  Log a message at the Strophe.LogLevel.ERROR level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    error: function (msg) {
        this.log(this.LogLevel.ERROR, msg);
    },

    /** Function: fatal
     *  Log a message at the Strophe.LogLevel.FATAL level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    fatal: function (msg) {
        this.log(this.LogLevel.FATAL, msg);
    },

    /** Function: serialize
     *  Render a DOM element and all descendants to a String.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    The serialized element tree as a String.
     */
    serialize: function (elem) {
        var result;

        if (!elem) { return null; }

        if (typeof(elem.tree) === "function") {
            elem = elem.tree();
        }

        var nodeName = elem.nodeName;
        var i, child;

        if (elem.getAttribute("_realname")) {
            nodeName = elem.getAttribute("_realname");
        }

        result = "<" + nodeName;
        for (i = 0; i < elem.attributes.length; i++) {
             if(elem.attributes[i].nodeName != "_realname") {
               result += " " + elem.attributes[i].nodeName +
                   "='" + Strophe.xmlescape(elem.attributes[i].value) + "'";
             }
        }

        if (elem.childNodes.length > 0) {
            result += ">";
            for (i = 0; i < elem.childNodes.length; i++) {
                child = elem.childNodes[i];
                switch( child.nodeType ){
                  case Strophe.ElementType.NORMAL:
                    // normal element, so recurse
                    result += Strophe.serialize(child);
                    break;
                  case Strophe.ElementType.TEXT:
                    // text element to escape values
                    result += Strophe.xmlescape(child.nodeValue);
                    break;
                  case Strophe.ElementType.CDATA:
                    // cdata section so don't escape values
                    result += "<![CDATA["+child.nodeValue+"]]>";
                }
            }
            result += "</" + nodeName + ">";
        } else {
            result += "/>";
        }

        return result;
    },

    /** PrivateVariable: _requestId
     *  _Private_ variable that keeps track of the request ids for
     *  connections.
     */
    _requestId: 0,

    /** PrivateVariable: Strophe.connectionPlugins
     *  _Private_ variable Used to store plugin names that need
     *  initialization on Strophe.Connection construction.
     */
    _connectionPlugins: {},

    /** Function: addConnectionPlugin
     *  Extends the Strophe.Connection object with the given plugin.
     *
     *  Parameters:
     *    (String) name - The name of the extension.
     *    (Object) ptype - The plugin's prototype.
     */
    addConnectionPlugin: function (name, ptype) {
        Strophe._connectionPlugins[name] = ptype;
    }
};

/** Class: Strophe.Builder
 *  XML DOM builder.
 *
 *  This object provides an interface similar to JQuery but for building
 *  DOM elements easily and rapidly.  All the functions except for toString()
 *  and tree() return the object, so calls can be chained.  Here's an
 *  example using the $iq() builder helper.
 *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})
 *  >     .c('query', {xmlns: 'strophe:example'})
 *  >     .c('example')
 *  >     .toString()
 *
 *  The above generates this XML fragment
 *  > <iq to='you' from='me' type='get' id='1'>
 *  >   <query xmlns='strophe:example'>
 *  >     <example/>
 *  >   </query>
 *  > </iq>
 *  The corresponding DOM manipulations to get a similar fragment would be
 *  a lot more tedious and probably involve several helper variables.
 *
 *  Since adding children makes new operations operate on the child, up()
 *  is provided to traverse up the tree.  To add two children, do
 *  > builder.c('child1', ...).up().c('child2', ...)
 *  The next operation on the Builder will be relative to the second child.
 */

/** Constructor: Strophe.Builder
 *  Create a Strophe.Builder object.
 *
 *  The attributes should be passed in object notation.  For example
 *  > var b = new Builder('message', {to: 'you', from: 'me'});
 *  or
 *  > var b = new Builder('messsage', {'xml:lang': 'en'});
 *
 *  Parameters:
 *    (String) name - The name of the root element.
 *    (Object) attrs - The attributes for the root element in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder.
 */
Strophe.Builder = function (name, attrs) {
    // Set correct namespace for jabber:client elements
    if (name == "presence" || name == "message" || name == "iq") {
        if (attrs && !attrs.xmlns) {
            attrs.xmlns = Strophe.NS.CLIENT;
        } else if (!attrs) {
            attrs = {xmlns: Strophe.NS.CLIENT};
        }
    }

    // Holds the tree being built.
    this.nodeTree = Strophe.xmlElement(name, attrs);

    // Points to the current operation node.
    this.node = this.nodeTree;
};

Strophe.Builder.prototype = {
    /** Function: tree
     *  Return the DOM tree.
     *
     *  This function returns the current DOM tree as an element object.  This
     *  is suitable for passing to functions like Strophe.Connection.send().
     *
     *  Returns:
     *    The DOM tree as a element object.
     */
    tree: function () {
        return this.nodeTree;
    },

    /** Function: toString
     *  Serialize the DOM tree to a String.
     *
     *  This function returns a string serialization of the current DOM
     *  tree.  It is often used internally to pass data to a
     *  Strophe.Request object.
     *
     *  Returns:
     *    The serialized DOM tree in a String.
     */
    toString: function () {
        return Strophe.serialize(this.nodeTree);
    },

    /** Function: up
     *  Make the current parent element the new current element.
     *
     *  This function is often used after c() to traverse back up the tree.
     *  For example, to add two children to the same element
     *  > builder.c('child1', {}).up().c('child2', {});
     *
     *  Returns:
     *    The Stophe.Builder object.
     */
    up: function () {
        this.node = this.node.parentNode;
        return this;
    },

    /** Function: root
     *  Make the root element the new current element.
     *
     *  When at a deeply nested element in the tree, this function can be used
     *  to jump back to the root of the tree, instead of having to repeatedly
     *  call up().
     *
     *  Returns:
     *    The Stophe.Builder object.
     */
    root: function () {
        this.node = this.nodeTree;
        return this;
    },

    /** Function: attrs
     *  Add or modify attributes of the current element.
     *
     *  The attributes should be passed in object notation.  This function
     *  does not move the current element pointer.
     *
     *  Parameters:
     *    (Object) moreattrs - The attributes to add/modify in object notation.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    attrs: function (moreattrs) {
        for (var k in moreattrs) {
            if (moreattrs.hasOwnProperty(k)) {
                if (moreattrs[k] === undefined) {
                    this.node.removeAttribute(k);
                } else {
                    this.node.setAttribute(k, moreattrs[k]);
                }
            }
        }
        return this;
    },

    /** Function: c
     *  Add a child to the current element and make it the new current
     *  element.
     *
     *  This function moves the current element pointer to the child,
     *  unless text is provided.  If you need to add another child, it
     *  is necessary to use up() to go back to the parent in the tree.
     *
     *  Parameters:
     *    (String) name - The name of the child.
     *    (Object) attrs - The attributes of the child in object notation.
     *    (String) text - The text to add to the child.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    c: function (name, attrs, text) {
        var child = Strophe.xmlElement(name, attrs, text);
        this.node.appendChild(child);
        if (typeof text !== "string" && typeof text !=="number") {
            this.node = child;
        }
        return this;
    },

    /** Function: cnode
     *  Add a child to the current element and make it the new current
     *  element.
     *
     *  This function is the same as c() except that instead of using a
     *  name and an attributes object to create the child it uses an
     *  existing DOM element object.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    cnode: function (elem) {
        var impNode;
        var xmlGen = Strophe.xmlGenerator();
        try {
            impNode = (xmlGen.importNode !== undefined);
        } catch (e) {
            impNode = false;
        }
        var newElem = impNode ?
                      xmlGen.importNode(elem, true) :
                      Strophe.copyElement(elem);
        this.node.appendChild(newElem);
        this.node = newElem;
        return this;
    },

    /** Function: t
     *  Add a child text element.
     *
     *  This *does not* make the child the new current element since there
     *  are no children of text elements.
     *
     *  Parameters:
     *    (String) text - The text data to append to the current element.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    t: function (text) {
        var child = Strophe.xmlTextNode(text);
        this.node.appendChild(child);
        return this;
    },

    /** Function: h
     *  Replace current element contents with the HTML passed in.
     *
     *  This *does not* make the child the new current element
     *
     *  Parameters:
     *    (String) html - The html to insert as contents of current element.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    h: function (html) {
        var fragment = document.createElement('body');

        // force the browser to try and fix any invalid HTML tags
        fragment.innerHTML = html;

        // copy cleaned html into an xml dom
        var xhtml = Strophe.createHtml(fragment);

        while(xhtml.childNodes.length > 0) {
            this.node.appendChild(xhtml.childNodes[0]);
        }
        return this;
    }
};

/** PrivateClass: Strophe.Handler
 *  _Private_ helper class for managing stanza handlers.
 *
 *  A Strophe.Handler encapsulates a user provided callback function to be
 *  executed when matching stanzas are received by the connection.
 *  Handlers can be either one-off or persistant depending on their
 *  return value. Returning true will cause a Handler to remain active, and
 *  returning false will remove the Handler.
 *
 *  Users will not use Strophe.Handler objects directly, but instead they
 *  will use Strophe.Connection.addHandler() and
 *  Strophe.Connection.deleteHandler().
 */

/** PrivateConstructor: Strophe.Handler
 *  Create and initialize a new Strophe.Handler.
 *
 *  Parameters:
 *    (Function) handler - A function to be executed when the handler is run.
 *    (String) ns - The namespace to match.
 *    (String) name - The element name to match.
 *    (String) type - The element type to match.
 *    (String) id - The element id attribute to match.
 *    (String) from - The element from attribute to match.
 *    (Object) options - Handler options
 *
 *  Returns:
 *    A new Strophe.Handler object.
 */
Strophe.Handler = function (handler, ns, name, type, id, from, options) {
    this.handler = handler;
    this.ns = ns;
    this.name = name;
    this.type = type;
    this.id = id;
    this.options = options || {'matchBareFromJid': false, 'ignoreNamespaceFragment': false};
    // BBB: Maintain backward compatibility with old `matchBare` option
    if (this.options.matchBare) {
        Strophe.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.');
        this.options.matchBareFromJid = this.options.matchBare;
        delete this.options.matchBare;
    }

    if (this.options.matchBareFromJid) {
        this.from = from ? Strophe.getBareJidFromJid(from) : null;
    } else {
        this.from = from;
    }
    // whether the handler is a user handler or a system handler
    this.user = true;
};

Strophe.Handler.prototype = {
    /** PrivateFunction: getNamespace
     *  Returns the XML namespace attribute on an element.
     *  If `ignoreNamespaceFragment` was passed in for this handler, then the
     *  URL fragment will be stripped.
     *
     *  Parameters:
     *    (XMLElement) elem - The XML element with the namespace.
     *
     *  Returns:
     *    The namespace, with optionally the fragment stripped.
     */
    getNamespace: function (elem) {
        var elNamespace = elem.getAttribute("xmlns");
        if (elNamespace && this.options.ignoreNamespaceFragment) {
            elNamespace = elNamespace.split('#')[0];
        }
        return elNamespace;
    },

    /** PrivateFunction: namespaceMatch
     *  Tests if a stanza matches the namespace set for this Strophe.Handler.
     *
     *  Parameters:
     *    (XMLElement) elem - The XML element to test.
     *
     *  Returns:
     *    true if the stanza matches and false otherwise.
     */
    namespaceMatch: function (elem) {
        var nsMatch = false;
        if (!this.ns) {
            return true;
        } else {
            var that = this;
            Strophe.forEachChild(elem, null, function (elem) {
                if (that.getNamespace(elem) === that.ns) {
                    nsMatch = true;
                }
            });
            nsMatch = nsMatch || this.getNamespace(elem) === this.ns;
        }
        return nsMatch;
    },

    /** PrivateFunction: isMatch
     *  Tests if a stanza matches the Strophe.Handler.
     *
     *  Parameters:
     *    (XMLElement) elem - The XML element to test.
     *
     *  Returns:
     *    true if the stanza matches and false otherwise.
     */
    isMatch: function (elem) {
        var from = elem.getAttribute('from');
        if (this.options.matchBareFromJid) {
            from = Strophe.getBareJidFromJid(from);
        }
        var elem_type = elem.getAttribute("type");
        if (this.namespaceMatch(elem) &&
            (!this.name || Strophe.isTagEqual(elem, this.name)) &&
            (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) != -1 : elem_type == this.type)) &&
            (!this.id || elem.getAttribute("id") == this.id) &&
            (!this.from || from == this.from)) {
                return true;
        }
        return false;
    },

    /** PrivateFunction: run
     *  Run the callback on a matching stanza.
     *
     *  Parameters:
     *    (XMLElement) elem - The DOM element that triggered the
     *      Strophe.Handler.
     *
     *  Returns:
     *    A boolean indicating if the handler should remain active.
     */
    run: function (elem) {
        var result = null;
        try {
            result = this.handler(elem);
        } catch (e) {
            Strophe._handleError(e);
            throw e;
        }
        return result;
    },

    /** PrivateFunction: toString
     *  Get a String representation of the Strophe.Handler object.
     *
     *  Returns:
     *    A String.
     */
    toString: function () {
        return "{Handler: " + this.handler + "(" + this.name + "," +
            this.id + "," + this.ns + ")}";
    }
};

/** PrivateClass: Strophe.TimedHandler
 *  _Private_ helper class for managing timed handlers.
 *
 *  A Strophe.TimedHandler encapsulates a user provided callback that
 *  should be called after a certain period of time or at regular
 *  intervals.  The return value of the callback determines whether the
 *  Strophe.TimedHandler will continue to fire.
 *
 *  Users will not use Strophe.TimedHandler objects directly, but instead
 *  they will use Strophe.Connection.addTimedHandler() and
 *  Strophe.Connection.deleteTimedHandler().
 */

/** PrivateConstructor: Strophe.TimedHandler
 *  Create and initialize a new Strophe.TimedHandler object.
 *
 *  Parameters:
 *    (Integer) period - The number of milliseconds to wait before the
 *      handler is called.
 *    (Function) handler - The callback to run when the handler fires.  This
 *      function should take no arguments.
 *
 *  Returns:
 *    A new Strophe.TimedHandler object.
 */
Strophe.TimedHandler = function (period, handler) {
    this.period = period;
    this.handler = handler;
    this.lastCalled = new Date().getTime();
    this.user = true;
};

Strophe.TimedHandler.prototype = {
    /** PrivateFunction: run
     *  Run the callback for the Strophe.TimedHandler.
     *
     *  Returns:
     *    true if the Strophe.TimedHandler should be called again, and false
     *      otherwise.
     */
    run: function () {
        this.lastCalled = new Date().getTime();
        return this.handler();
    },

    /** PrivateFunction: reset
     *  Reset the last called time for the Strophe.TimedHandler.
     */
    reset: function () {
        this.lastCalled = new Date().getTime();
    },

    /** PrivateFunction: toString
     *  Get a string representation of the Strophe.TimedHandler object.
     *
     *  Returns:
     *    The string representation.
     */
    toString: function () {
        return "{TimedHandler: " + this.handler + "(" + this.period +")}";
    }
};

/** Class: Strophe.Connection
 *  XMPP Connection manager.
 *
 *  This class is the main part of Strophe.  It manages a BOSH or websocket
 *  connection to an XMPP server and dispatches events to the user callbacks
 *  as data arrives. It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1
 *  and legacy authentication.
 *
 *  After creating a Strophe.Connection object, the user will typically
 *  call connect() with a user supplied callback to handle connection level
 *  events like authentication failure, disconnection, or connection
 *  complete.
 *
 *  The user will also have several event handlers defined by using
 *  addHandler() and addTimedHandler().  These will allow the user code to
 *  respond to interesting stanzas or do something periodically with the
 *  connection. These handlers will be active once authentication is
 *  finished.
 *
 *  To send data to the connection, use send().
 */

/** Constructor: Strophe.Connection
 *  Create and initialize a Strophe.Connection object.
 *
 *  The transport-protocol for this connection will be chosen automatically
 *  based on the given service parameter. URLs starting with "ws://" or
 *  "wss://" will use WebSockets, URLs starting with "http://", "https://"
 *  or without a protocol will use BOSH.
 *
 *  To make Strophe connect to the current host you can leave out the protocol
 *  and host part and just pass the path, e.g.
 *
 *  > var conn = new Strophe.Connection("/http-bind/");
 *
 *  Options common to both Websocket and BOSH:
 *  ------------------------------------------
 *
 *  cookies:
 *
 *  The *cookies* option allows you to pass in cookies to be added to the
 *  document. These cookies will then be included in the BOSH XMLHttpRequest
 *  or in the websocket connection.
 *
 *  The passed in value must be a map of cookie names and string values.
 *
 *  > { "myCookie": {
 *  >     "value": "1234",
 *  >     "domain": ".example.org",
 *  >     "path": "/",
 *  >     "expires": expirationDate
 *  >     }
 *  > }
 *
 *  Note that cookies can't be set in this way for other domains (i.e. cross-domain).
 *  Those cookies need to be set under those domains, for example they can be
 *  set server-side by making a XHR call to that domain to ask it to set any
 *  necessary cookies.
 *
 *  mechanisms:
 *
 *  The *mechanisms* option allows you to specify the SASL mechanisms that this
 *  instance of Strophe.Connection (and therefore your XMPP client) will
 *  support.
 *
 *  The value must be an array of objects with Strophe.SASLMechanism
 *  prototypes.
 *
 *  If nothing is specified, then the following mechanisms (and their
 *  priorities) are registered:
 *
 *      EXTERNAL - 60
 *      OAUTHBEARER - 50
 *      SCRAM-SHA1 - 40
 *      DIGEST-MD5 - 30
 *      PLAIN - 20
 *      ANONYMOUS - 10
 *
 *  WebSocket options:
 *  ------------------
 *
 *  If you want to connect to the current host with a WebSocket connection you
 *  can tell Strophe to use WebSockets through a "protocol" attribute in the
 *  optional options parameter. Valid values are "ws" for WebSocket and "wss"
 *  for Secure WebSocket.
 *  So to connect to "wss://CURRENT_HOSTNAME/xmpp-websocket" you would call
 *
 *  > var conn = new Strophe.Connection("/xmpp-websocket/", {protocol: "wss"});
 *
 *  Note that relative URLs _NOT_ starting with a "/" will also include the path
 *  of the current site.
 *
 *  Also because downgrading security is not permitted by browsers, when using
 *  relative URLs both BOSH and WebSocket connections will use their secure
 *  variants if the current connection to the site is also secure (https).
 *
 *  BOSH options:
 *  -------------
 *
 *  By adding "sync" to the options, you can control if requests will
 *  be made synchronously or not. The default behaviour is asynchronous.
 *  If you want to make requests synchronous, make "sync" evaluate to true.
 *  > var conn = new Strophe.Connection("/http-bind/", {sync: true});
 *
 *  You can also toggle this on an already established connection.
 *  > conn.options.sync = true;
 *
 *  The *customHeaders* option can be used to provide custom HTTP headers to be
 *  included in the XMLHttpRequests made.
 *
 *  The *keepalive* option can be used to instruct Strophe to maintain the
 *  current BOSH session across interruptions such as webpage reloads.
 *
 *  It will do this by caching the sessions tokens in sessionStorage, and when
 *  "restore" is called it will check whether there are cached tokens with
 *  which it can resume an existing session.
 *
 *  The *withCredentials* option should receive a Boolean value and is used to
 *  indicate wether cookies should be included in ajax requests (by default
 *  they're not).
 *  Set this value to true if you are connecting to a BOSH service
 *  and for some reason need to send cookies to it.
 *  In order for this to work cross-domain, the server must also enable
 *  credentials by setting the Access-Control-Allow-Credentials response header
 *  to "true". For most usecases however this setting should be false (which
 *  is the default).
 *  Additionally, when using Access-Control-Allow-Credentials, the
 *  Access-Control-Allow-Origin header can't be set to the wildcard "*", but
 *  instead must be restricted to actual domains.
 *
 *  The *contentType* option can be set to change the default Content-Type
 *  of "text/xml; charset=utf-8", which can be useful to reduce the amount of
 *  CORS preflight requests that are sent to the server.
 *
 *  Parameters:
 *    (String) service - The BOSH or WebSocket service URL.
 *    (Object) options - A hash of configuration options
 *
 *  Returns:
 *    A new Strophe.Connection object.
 */
Strophe.Connection = function (service, options) {
    // The service URL
    this.service = service;
    // Configuration options
    this.options = options || {};
    var proto = this.options.protocol || "";

    // Select protocal based on service or options
    if (service.indexOf("ws:") === 0 || service.indexOf("wss:") === 0 ||
            proto.indexOf("ws") === 0) {
        this._proto = new Strophe.Websocket(this);
    } else {
        this._proto = new Strophe.Bosh(this);
    }

    /* The connected JID. */
    this.jid = "";
    /* the JIDs domain */
    this.domain = null;
    /* stream:features */
    this.features = null;

    // SASL
    this._sasl_data = {};
    this.do_session = false;
    this.do_bind = false;

    // handler lists
    this.timedHandlers = [];
    this.handlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];
    this.protocolErrorHandlers = {
        'HTTP': {},
        'websocket': {}
    };

    this._idleTimeout = null;
    this._disconnectTimeout = null;

    this.authenticated = false;
    this.connected = false;
    this.disconnecting = false;
    this.do_authentication = true;
    this.paused = false;
    this.restored = false;

    this._data = [];
    this._uniqueId = 0;

    this._sasl_success_handler = null;
    this._sasl_failure_handler = null;
    this._sasl_challenge_handler = null;

    // Max retries before disconnecting
    this.maxRetries = 5;

    // Call onIdle callback every 1/10th of a second
    // XXX: setTimeout should be called only with function expressions (23974bc1)
    this._idleTimeout = setTimeout(function() {
        this._onIdle();
    }.bind(this), 100);

    utils.addCookies(this.options.cookies);
    this.registerSASLMechanisms(this.options.mechanisms);

    // initialize plugins
    for (var k in Strophe._connectionPlugins) {
        if (Strophe._connectionPlugins.hasOwnProperty(k)) {
            var ptype = Strophe._connectionPlugins[k];
            // jslint complaints about the below line, but this is fine
            var F = function () {}; // jshint ignore:line
            F.prototype = ptype;
            this[k] = new F();
            this[k].init(this);
        }
    }
};

Strophe.Connection.prototype = {
    /** Function: reset
     *  Reset the connection.
     *
     *  This function should be called after a connection is disconnected
     *  before that connection is reused.
     */
    reset: function () {
        this._proto._reset();

        // SASL
        this.do_session = false;
        this.do_bind = false;

        // handler lists
        this.timedHandlers = [];
        this.handlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];

        this.authenticated = false;
        this.connected = false;
        this.disconnecting = false;
        this.restored = false;

        this._data = [];
        this._requests = [];
        this._uniqueId = 0;
    },

    /** Function: pause
     *  Pause the request manager.
     *
     *  This will prevent Strophe from sending any more requests to the
     *  server.  This is very useful for temporarily pausing
     *  BOSH-Connections while a lot of send() calls are happening quickly.
     *  This causes Strophe to send the data in a single request, saving
     *  many request trips.
     */
    pause: function () {
        this.paused = true;
    },

    /** Function: resume
     *  Resume the request manager.
     *
     *  This resumes after pause() has been called.
     */
    resume: function () {
        this.paused = false;
    },

    /** Function: getUniqueId
     *  Generate a unique ID for use in <iq/> elements.
     *
     *  All <iq/> stanzas are required to have unique id attributes.  This
     *  function makes creating these easy.  Each connection instance has
     *  a counter which starts from zero, and the value of this counter
     *  plus a colon followed by the suffix becomes the unique id. If no
     *  suffix is supplied, the counter is used as the unique id.
     *
     *  Suffixes are used to make debugging easier when reading the stream
     *  data, and their use is recommended.  The counter resets to 0 for
     *  every new connection for the same reason.  For connections to the
     *  same server that authenticate the same way, all the ids should be
     *  the same, which makes it easy to see changes.  This is useful for
     *  automated testing as well.
     *
     *  Parameters:
     *    (String) suffix - A optional suffix to append to the id.
     *
     *  Returns:
     *    A unique string to be used for the id attribute.
     */
    getUniqueId: function(suffix) {
        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0,
                v = c == 'x' ? r : r & 0x3 | 0x8;
            return v.toString(16);
        });
        if (typeof(suffix) == "string" || typeof(suffix) == "number") {
            return uuid + ":" + suffix;
        } else {
            return uuid + "";
        }
    },

    /** Function: addProtocolErrorHandler
     *  Register a handler function for when a protocol (websocker or HTTP)
     *  error occurs.
     *
     *  NOTE: Currently only HTTP errors for BOSH requests are handled.
     *  Patches that handle websocket errors would be very welcome.
     *
     *  Parameters:
     *    (String) protocol - 'HTTP' or 'websocket' 
     *    (Integer) status_code - Error status code (e.g 500, 400 or 404)
     *    (Function) callback - Function that will fire on Http error
     *
     *  Example:
     *  function onError(err_code){
     *    //do stuff
     *  }
     *
     *  var conn = Strophe.connect('http://example.com/http-bind');
     *  conn.addProtocolErrorHandler('HTTP', 500, onError);
     *  // Triggers HTTP 500 error and onError handler will be called
     *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);
     */
    addProtocolErrorHandler: function(protocol, status_code, callback){
        this.protocolErrorHandlers[protocol][status_code] = callback;
    },


    /** Function: connect
     *  Starts the connection process.
     *
     *  As the connection process proceeds, the user supplied callback will
     *  be triggered multiple times with status updates.  The callback
     *  should take two arguments - the status code and the error condition.
     *
     *  The status code will be one of the values in the Strophe.Status
     *  constants.  The error condition will be one of the conditions
     *  defined in RFC 3920 or the condition 'strophe-parsererror'.
     *
     *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant
     *  for BOSH connections. Please see XEP 124 for a more detailed explanation
     *  of the optional parameters.
     *
     *  Parameters:
     *    (String) jid - The user's JID.  This may be a bare JID,
     *      or a full JID.  If a node is not supplied, SASL ANONYMOUS
     *      authentication will be attempted.
     *    (String) pass - The user's password.
     *    (Function) callback - The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (String) route - The optional route value.
     *    (String) authcid - The optional alternative authentication identity
     *      (username) if intending to impersonate another user.
     *      When using the SASL-EXTERNAL authentication mechanism, for example
     *      with client certificates, then the authcid value is used to
     *      determine whether an authorization JID (authzid) should be sent to
     *      the server. The authzid should not be sent to the server if the
     *      authzid and authcid are the same. So to prevent it from being sent
     *      (for example when the JID is already contained in the client
     *      certificate), set authcid to that same JID. See XEP-178 for more
     *      details.
     */
    connect: function (jid, pass, callback, wait, hold, route, authcid) {
        this.jid = jid;
        /** Variable: authzid
         *  Authorization identity.
         */
        this.authzid = Strophe.getBareJidFromJid(this.jid);

        /** Variable: authcid
         *  Authentication identity (User name).
         */
        this.authcid = authcid || Strophe.getNodeFromJid(this.jid);

        /** Variable: pass
         *  Authentication identity (User password).
         */
        this.pass = pass;

        /** Variable: servtype
         *  Digest MD5 compatibility.
         */
        this.servtype = "xmpp";

        this.connect_callback = callback;
        this.disconnecting = false;
        this.connected = false;
        this.authenticated = false;
        this.restored = false;

        // parse jid for domain
        this.domain = Strophe.getDomainFromJid(this.jid);

        this._changeConnectStatus(Strophe.Status.CONNECTING, null);

        this._proto._connect(wait, hold, route);
    },

    /** Function: attach
     *  Attach to an already created and authenticated BOSH session.
     *
     *  This function is provided to allow Strophe to attach to BOSH
     *  sessions which have been created externally, perhaps by a Web
     *  application.  This is often used to support auto-login type features
     *  without putting user credentials into the page.
     *
     *  Parameters:
     *    (String) jid - The full JID that is bound by the session.
     *    (String) sid - The SID of the BOSH session.
     *    (String) rid - The current RID of the BOSH session.  This RID
     *      will be used by the next request.
     *    (Function) callback The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *      Other settings will require tweaks to the Strophe.TIMEOUT value.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (Integer) wind - The optional HTTBIND window value.  This is the
     *      allowed range of request ids that are valid.  The default is 5.
     */
    attach: function (jid, sid, rid, callback, wait, hold, wind) {
        if (this._proto instanceof Strophe.Bosh) {
            this._proto._attach(jid, sid, rid, callback, wait, hold, wind);
        } else {
            throw {
                name: 'StropheSessionError',
                message: 'The "attach" method can only be used with a BOSH connection.'
            };
        }
    },

    /** Function: restore
     *  Attempt to restore a cached BOSH session.
     *
     *  This function is only useful in conjunction with providing the
     *  "keepalive":true option when instantiating a new Strophe.Connection.
     *
     *  When "keepalive" is set to true, Strophe will cache the BOSH tokens
     *  RID (Request ID) and SID (Session ID) and then when this function is
     *  called, it will attempt to restore the session from those cached
     *  tokens.
     *
     *  This function must therefore be called instead of connect or attach.
     *
     *  For an example on how to use it, please see examples/restore.js
     *
     *  Parameters:
     *    (String) jid - The user's JID.  This may be a bare JID or a full JID.
     *    (Function) callback - The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (Integer) wind - The optional HTTBIND window value.  This is the
     *      allowed range of request ids that are valid.  The default is 5.
     */
    restore: function (jid, callback, wait, hold, wind) {
        if (this._sessionCachingSupported()) {
            this._proto._restore(jid, callback, wait, hold, wind);
        } else {
            throw {
                name: 'StropheSessionError',
                message: 'The "restore" method can only be used with a BOSH connection.'
            };
        }
    },

    /** PrivateFunction: _sessionCachingSupported
     * Checks whether sessionStorage and JSON are supported and whether we're
     * using BOSH.
     */
    _sessionCachingSupported: function () {
        if (this._proto instanceof Strophe.Bosh) {
            if (!JSON) { return false; }
            try {
                window.sessionStorage.setItem('_strophe_', '_strophe_');
                window.sessionStorage.removeItem('_strophe_');
            } catch (e) {
                return false;
            }
            return true;
        }
        return false;
    },

    /** Function: xmlInput
     *  User overrideable function that receives XML data coming into the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.xmlInput = function (elem) {
     *  >   (user code)
     *  > };
     *
     *  Due to limitations of current Browsers' XML-Parsers the opening and closing
     *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
     *
     *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
     *  <Strophe.Bosh.strip> if you want to strip this tag.
     *
     *  Parameters:
     *    (XMLElement) elem - The XML data received by the connection.
     */
    /* jshint unused:false */
    xmlInput: function (elem) {
        return;
    },
    /* jshint unused:true */

    /** Function: xmlOutput
     *  User overrideable function that receives XML data sent to the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.xmlOutput = function (elem) {
     *  >   (user code)
     *  > };
     *
     *  Due to limitations of current Browsers' XML-Parsers the opening and closing
     *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
     *
     *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
     *  <Strophe.Bosh.strip> if you want to strip this tag.
     *
     *  Parameters:
     *    (XMLElement) elem - The XMLdata sent by the connection.
     */
    /* jshint unused:false */
    xmlOutput: function (elem) {
        return;
    },
    /* jshint unused:true */

    /** Function: rawInput
     *  User overrideable function that receives raw data coming into the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.rawInput = function (data) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (String) data - The data received by the connection.
     */
    /* jshint unused:false */
    rawInput: function (data) {
        return;
    },
    /* jshint unused:true */

    /** Function: rawOutput
     *  User overrideable function that receives raw data sent to the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.rawOutput = function (data) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (String) data - The data sent by the connection.
     */
    /* jshint unused:false */
    rawOutput: function (data) {
        return;
    },
    /* jshint unused:true */

    /** Function: nextValidRid
     *  User overrideable function that receives the new valid rid.
     *
     *  The default function does nothing. User code can override this with
     *  > Strophe.Connection.nextValidRid = function (rid) {
     *  >    (user code)
     *  > };
     *
     *  Parameters:
     *    (Number) rid - The next valid rid
     */
    /* jshint unused:false */
    nextValidRid: function (rid) {
        return;
    },
    /* jshint unused:true */

    /** Function: send
     *  Send a stanza.
     *
     *  This function is called to push data onto the send queue to
     *  go out over the wire.  Whenever a request is sent to the BOSH
     *  server, all pending data is sent and the queue is flushed.
     *
     *  Parameters:
     *    (XMLElement |
     *     [XMLElement] |
     *     Strophe.Builder) elem - The stanza to send.
     */
    send: function (elem) {
        if (elem === null) { return ; }
        if (typeof(elem.sort) === "function") {
            for (var i = 0; i < elem.length; i++) {
                this._queueData(elem[i]);
            }
        } else if (typeof(elem.tree) === "function") {
            this._queueData(elem.tree());
        } else {
            this._queueData(elem);
        }

        this._proto._send();
    },

    /** Function: flush
     *  Immediately send any pending outgoing data.
     *
     *  Normally send() queues outgoing data until the next idle period
     *  (100ms), which optimizes network use in the common cases when
     *  several send()s are called in succession. flush() can be used to
     *  immediately send all pending data.
     */
    flush: function () {
        // cancel the pending idle period and run the idle function
        // immediately
        clearTimeout(this._idleTimeout);
        this._onIdle();
    },

    /** Function: sendIQ
     *  Helper function to send IQ stanzas.
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza to send.
     *    (Function) callback - The callback function for a successful request.
     *    (Function) errback - The callback function for a failed or timed
     *      out request.  On timeout, the stanza will be null.
     *    (Integer) timeout - The time specified in milliseconds for a
     *      timeout to occur.
     *
     *  Returns:
     *    The id used to send the IQ.
    */
    sendIQ: function(elem, callback, errback, timeout) {
        var timeoutHandler = null;
        var that = this;

        if (typeof(elem.tree) === "function") {
            elem = elem.tree();
        }
        var id = elem.getAttribute('id');
        if (!id) { // inject id if not found
            id = this.getUniqueId("sendIQ");
            elem.setAttribute("id", id);
        }

        var handler = this.addHandler(function (stanza) {
            // remove timeout handler if there is one
            if (timeoutHandler) {
                that.deleteTimedHandler(timeoutHandler);
            }
            var iqtype = stanza.getAttribute('type');
            if (iqtype == 'result') {
                if (callback) {
                    callback(stanza);
                }
            } else if (iqtype == 'error') {
                if (errback) {
                    errback(stanza);
                }
            } else {
                throw {
                    name: "StropheError",
                    message: "Got bad IQ type of " + iqtype
                };
            }
        }, null, 'iq', ['error', 'result'], id);

        // if timeout specified, set up a timeout handler.
        if (timeout) {
            timeoutHandler = this.addTimedHandler(timeout, function () {
                // get rid of normal handler
                that.deleteHandler(handler);
                // call errback on timeout with null stanza
                if (errback) {
                    errback(null);
                }
                return false;
            });
        }
        this.send(elem);
        return id;
    },

    /** PrivateFunction: _queueData
     *  Queue outgoing data for later sending.  Also ensures that the data
     *  is a DOMElement.
     */
    _queueData: function (element) {
        if (element === null ||
            !element.tagName ||
            !element.childNodes) {
            throw {
                name: "StropheError",
                message: "Cannot queue non-DOMElement."
            };
        }
        this._data.push(element);
    },

    /** PrivateFunction: _sendRestart
     *  Send an xmpp:restart stanza.
     */
    _sendRestart: function () {
        this._data.push("restart");
        this._proto._sendRestart();
        // XXX: setTimeout should be called only with function expressions (23974bc1)
        this._idleTimeout = setTimeout(function() {
            this._onIdle();
        }.bind(this), 100);
    },

    /** Function: addTimedHandler
     *  Add a timed handler to the connection.
     *
     *  This function adds a timed handler.  The provided handler will
     *  be called every period milliseconds until it returns false,
     *  the connection is terminated, or the handler is removed.  Handlers
     *  that wish to continue being invoked should return true.
     *
     *  Because of method binding it is necessary to save the result of
     *  this function if you wish to remove a handler with
     *  deleteTimedHandler().
     *
     *  Note that user handlers are not active until authentication is
     *  successful.
     *
     *  Parameters:
     *    (Integer) period - The period of the handler.
     *    (Function) handler - The callback function.
     *
     *  Returns:
     *    A reference to the handler that can be used to remove it.
     */
    addTimedHandler: function (period, handler) {
        var thand = new Strophe.TimedHandler(period, handler);
        this.addTimeds.push(thand);
        return thand;
    },

    /** Function: deleteTimedHandler
     *  Delete a timed handler for a connection.
     *
     *  This function removes a timed handler from the connection.  The
     *  handRef parameter is *not* the function passed to addTimedHandler(),
     *  but is the reference returned from addTimedHandler().
     *
     *  Parameters:
     *    (Strophe.TimedHandler) handRef - The handler reference.
     */
    deleteTimedHandler: function (handRef) {
        // this must be done in the Idle loop so that we don't change
        // the handlers during iteration
        this.removeTimeds.push(handRef);
    },

    /** Function: addHandler
     *  Add a stanza handler for the connection.
     *
     *  This function adds a stanza handler to the connection.  The
     *  handler callback will be called for any stanza that matches
     *  the parameters.  Note that if multiple parameters are supplied,
     *  they must all match for the handler to be invoked.
     *
     *  The handler will receive the stanza that triggered it as its argument.
     *  *The handler should return true if it is to be invoked again;
     *  returning false will remove the handler after it returns.*
     *
     *  As a convenience, the ns parameters applies to the top level element
     *  and also any of its immediate children.  This is primarily to make
     *  matching /iq/query elements easy.
     *
     *  Options
     *  ~~~~~~~
     *  With the options argument, you can specify boolean flags that affect how
     *  matches are being done.
     *
     *  Currently two flags exist:
     *
     *  - matchBareFromJid:
     *      When set to true, the from parameter and the
     *      from attribute on the stanza will be matched as bare JIDs instead
     *      of full JIDs. To use this, pass {matchBareFromJid: true} as the
     *      value of options. The default value for matchBareFromJid is false.
     *
     *  - ignoreNamespaceFragment:
     *      When set to true, a fragment specified on the stanza's namespace
     *      URL will be ignored when it's matched with the one configured for
     *      the handler.
     *
     *      This means that if you register like this:
     *      >   connection.addHandler(
     *      >       handler,
     *      >       'http://jabber.org/protocol/muc',
     *      >       null, null, null, null,
     *      >       {'ignoreNamespaceFragment': true}
     *      >   );
     *
     *      Then a stanza with XML namespace of
     *      'http://jabber.org/protocol/muc#user' will also be matched. If
     *      'ignoreNamespaceFragment' is false, then only stanzas with
     *      'http://jabber.org/protocol/muc' will be matched.
     *
     *  Deleting the handler
     *  ~~~~~~~~~~~~~~~~~~~~
     *  The return value should be saved if you wish to remove the handler
     *  with deleteHandler().
     *
     *  Parameters:
     *    (Function) handler - The user callback.
     *    (String) ns - The namespace to match.
     *    (String) name - The stanza name to match.
     *    (String|Array) type - The stanza type (or types if an array) to match.
     *    (String) id - The stanza id attribute to match.
     *    (String) from - The stanza from attribute to match.
     *    (String) options - The handler options
     *
     *  Returns:
     *    A reference to the handler that can be used to remove it.
     */
    addHandler: function (handler, ns, name, type, id, from, options) {
        var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
        this.addHandlers.push(hand);
        return hand;
    },

    /** Function: deleteHandler
     *  Delete a stanza handler for a connection.
     *
     *  This function removes a stanza handler from the connection.  The
     *  handRef parameter is *not* the function passed to addHandler(),
     *  but is the reference returned from addHandler().
     *
     *  Parameters:
     *    (Strophe.Handler) handRef - The handler reference.
     */
    deleteHandler: function (handRef) {
        // this must be done in the Idle loop so that we don't change
        // the handlers during iteration
        this.removeHandlers.push(handRef);
        // If a handler is being deleted while it is being added,
        // prevent it from getting added
        var i = this.addHandlers.indexOf(handRef);
        if (i >= 0) {
            this.addHandlers.splice(i, 1);
        }
    },

    /** Function: registerSASLMechanisms
     *
     * Register the SASL mechanisms which will be supported by this instance of
     * Strophe.Connection (i.e. which this XMPP client will support).
     *
     *  Parameters:
     *    (Array) mechanisms - Array of objects with Strophe.SASLMechanism prototypes
     *
     */
    registerSASLMechanisms: function (mechanisms) {
        this.mechanisms = {};
        mechanisms = mechanisms || [
            Strophe.SASLAnonymous,
            Strophe.SASLExternal,
            Strophe.SASLMD5,
            Strophe.SASLOAuthBearer,
            Strophe.SASLPlain,
            Strophe.SASLSHA1
        ];
        mechanisms.forEach(this.registerSASLMechanism.bind(this));
    },

    /** Function: registerSASLMechanism
     *
     * Register a single SASL mechanism, to be supported by this client.
     *
     *  Parameters:
     *    (Object) mechanism - Object with a Strophe.SASLMechanism prototype
     *
     */
    registerSASLMechanism: function (mechanism) {
        this.mechanisms[mechanism.prototype.name] = mechanism;
    },

    /** Function: disconnect
     *  Start the graceful disconnection process.
     *
     *  This function starts the disconnection process.  This process starts
     *  by sending unavailable presence and sending BOSH body of type
     *  terminate.  A timeout handler makes sure that disconnection happens
     *  even if the BOSH server does not respond.
     *  If the Connection object isn't connected, at least tries to abort all pending requests
     *  so the connection object won't generate successful requests (which were already opened).
     *
     *  The user supplied connection callback will be notified of the
     *  progress as this process happens.
     *
     *  Parameters:
     *    (String) reason - The reason the disconnect is occuring.
     */
    disconnect: function (reason) {
        this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);

        Strophe.info("Disconnect was called because: " + reason);
        if (this.connected) {
            var pres = false;
            this.disconnecting = true;
            if (this.authenticated) {
                pres = $pres({
                    xmlns: Strophe.NS.CLIENT,
                    type: 'unavailable'
                });
            }
            // setup timeout handler
            this._disconnectTimeout = this._addSysTimedHandler(
                3000, this._onDisconnectTimeout.bind(this));
            this._proto._disconnect(pres);
        } else {
            Strophe.info("Disconnect was called before Strophe connected to the server");
            this._proto._abortAllRequests();
        }
    },

    /** PrivateFunction: _changeConnectStatus
     *  _Private_ helper function that makes sure plugins and the user's
     *  callback are notified of connection status changes.
     *
     *  Parameters:
     *    (Integer) status - the new connection status, one of the values
     *      in Strophe.Status
     *    (String) condition - the error condition or null
     */
    _changeConnectStatus: function (status, condition) {
        // notify all plugins listening for status changes
        for (var k in Strophe._connectionPlugins) {
            if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                var plugin = this[k];
                if (plugin.statusChanged) {
                    try {
                        plugin.statusChanged(status, condition);
                    } catch (err) {
                        Strophe.error("" + k + " plugin caused an exception " +
                                      "changing status: " + err);
                    }
                }
            }
        }

        // notify the user's callback
        if (this.connect_callback) {
            try {
                this.connect_callback(status, condition);
            } catch (e) {
                Strophe._handleError(e);
                Strophe.error(
                    "User connection callback caused an "+"exception: "+e);
            }
        }
    },

    /** PrivateFunction: _doDisconnect
     *  _Private_ function to disconnect.
     *
     *  This is the last piece of the disconnection logic.  This resets the
     *  connection and alerts the user's connection callback.
     */
    _doDisconnect: function (condition) {
        if (typeof this._idleTimeout == "number") {
            clearTimeout(this._idleTimeout);
        }

        // Cancel Disconnect Timeout
        if (this._disconnectTimeout !== null) {
            this.deleteTimedHandler(this._disconnectTimeout);
            this._disconnectTimeout = null;
        }

        Strophe.info("_doDisconnect was called");
        this._proto._doDisconnect();

        this.authenticated = false;
        this.disconnecting = false;
        this.restored = false;

        // delete handlers
        this.handlers = [];
        this.timedHandlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];

        // tell the parent we disconnected
        this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);
        this.connected = false;
    },

    /** PrivateFunction: _dataRecv
     *  _Private_ handler to processes incoming data from the the connection.
     *
     *  Except for _connect_cb handling the initial connection request,
     *  this function handles the incoming data for all requests.  This
     *  function also fires stanza handlers that match each incoming
     *  stanza.
     *
     *  Parameters:
     *    (Strophe.Request) req - The request that has data ready.
     *    (string) req - The stanza a raw string (optiona).
     */
    _dataRecv: function (req, raw) {
        Strophe.info("_dataRecv called");
        var elem = this._proto._reqToData(req);
        if (elem === null) { return; }

        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
                this.xmlInput(elem.childNodes[0]);
            } else {
                this.xmlInput(elem);
            }
        }
        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            if (raw) {
                this.rawInput(raw);
            } else {
                this.rawInput(Strophe.serialize(elem));
            }
        }

        // remove handlers scheduled for deletion
        var i, hand;
        while (this.removeHandlers.length > 0) {
            hand = this.removeHandlers.pop();
            i = this.handlers.indexOf(hand);
            if (i >= 0) {
                this.handlers.splice(i, 1);
            }
        }

        // add handlers scheduled for addition
        while (this.addHandlers.length > 0) {
            this.handlers.push(this.addHandlers.pop());
        }

        // handle graceful disconnect
        if (this.disconnecting && this._proto._emptyQueue()) {
            this._doDisconnect();
            return;
        }

        var type = elem.getAttribute("type");
        var cond, conflict;
        if (type !== null && type == "terminate") {
            // Don't process stanzas that come in after disconnect
            if (this.disconnecting) {
                return;
            }

            // an error occurred
            cond = elem.getAttribute("condition");
            conflict = elem.getElementsByTagName("conflict");
            if (cond !== null) {
                if (cond == "remote-stream-error" && conflict.length > 0) {
                    cond = "conflict";
                }
                this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
            } else {
                this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
            }
            this._doDisconnect(cond);
            return;
        }

        // send each incoming stanza through the handler chain
        var that = this;
        Strophe.forEachChild(elem, null, function (child) {
            var i, newList;
            // process handlers
            newList = that.handlers;
            that.handlers = [];
            for (i = 0; i < newList.length; i++) {
                var hand = newList[i];
                // encapsulate 'handler.run' not to lose the whole handler list if
                // one of the handlers throws an exception
                try {
                    if (hand.isMatch(child) &&
                        (that.authenticated || !hand.user)) {
                        if (hand.run(child)) {
                            that.handlers.push(hand);
                        }
                    } else {
                        that.handlers.push(hand);
                    }
                } catch(e) {
                    // if the handler throws an exception, we consider it as false
                    Strophe.warn('Removing Strophe handlers due to uncaught exception: '+e.message);
                }
            }
        });
    },


    /** Attribute: mechanisms
     *  SASL Mechanisms available for Connection.
     */
    mechanisms: {},

    /** PrivateFunction: _connect_cb
     *  _Private_ handler for initial connection request.
     *
     *  This handler is used to process the initial connection request
     *  response from the BOSH server. It is used to set up authentication
     *  handlers and start the authentication process.
     *
     *  SASL authentication will be attempted if available, otherwise
     *  the code will fall back to legacy authentication.
     *
     *  Parameters:
     *    (Strophe.Request) req - The current request.
     *    (Function) _callback - low level (xmpp) connect callback function.
     *      Useful for plugins with their own xmpp connect callback (when their)
     *      want to do something special).
     */
    _connect_cb: function (req, _callback, raw) {
        Strophe.info("_connect_cb was called");
        this.connected = true;

        var bodyWrap;
        try {
            bodyWrap = this._proto._reqToData(req);
        } catch (e) {
            if (e != "badformat") { throw e; }
            this._changeConnectStatus(Strophe.Status.CONNFAIL, 'bad-format');
            this._doDisconnect('bad-format');
        }
        if (!bodyWrap) { return; }

        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
                this.xmlInput(bodyWrap.childNodes[0]);
            } else {
                this.xmlInput(bodyWrap);
            }
        }
        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            if (raw) {
                this.rawInput(raw);
            } else {
                this.rawInput(Strophe.serialize(bodyWrap));
            }
        }

        var conncheck = this._proto._connect_cb(bodyWrap);
        if (conncheck === Strophe.Status.CONNFAIL) {
            return;
        }

        // Check for the stream:features tag
        var hasFeatures;
        if (bodyWrap.getElementsByTagNameNS) {
            hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "features").length > 0;
        } else {
            hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0 ||
                            bodyWrap.getElementsByTagName("features").length > 0;
        }
        if (!hasFeatures) {
            this._proto._no_auth_received(_callback);
            return;
        }

        var matched = [], i, mech;
        var mechanisms = bodyWrap.getElementsByTagName("mechanism");
        if (mechanisms.length > 0) {
            for (i = 0; i < mechanisms.length; i++) {
                mech = Strophe.getText(mechanisms[i]);
                if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);
            }
        }
        if (matched.length === 0) {
            if (bodyWrap.getElementsByTagName("auth").length === 0) {
                // There are no matching SASL mechanisms and also no legacy
                // auth available.
                this._proto._no_auth_received(_callback);
                return;
            }
        }
        if (this.do_authentication !== false) {
            this.authenticate(matched);
        }
    },

    /** Function: sortMechanismsByPriority
     *
     *  Sorts an array of objects with prototype SASLMechanism according to
     *  their priorities.
     *
     *  Parameters:
     *    (Array) mechanisms - Array of SASL mechanisms.
     *
     */
    sortMechanismsByPriority: function (mechanisms) {
        // Sorting mechanisms according to priority.
        var i, j, higher, swap;
        for (i = 0; i < mechanisms.length - 1; ++i) {
            higher = i;
            for (j = i + 1; j < mechanisms.length; ++j) {
                if (mechanisms[j].prototype.priority > mechanisms[higher].prototype.priority) {
                    higher = j;
                }
            }
            if (higher != i) {
                swap = mechanisms[i];
                mechanisms[i] = mechanisms[higher];
                mechanisms[higher] = swap;
            }
        }
        return mechanisms;
    },

    /** PrivateFunction: _attemptSASLAuth
     *
     *  Iterate through an array of SASL mechanisms and attempt authentication
     *  with the highest priority (enabled) mechanism.
     *
     *  Parameters:
     *    (Array) mechanisms - Array of SASL mechanisms.
     *
     *  Returns:
     *    (Boolean) mechanism_found - true or false, depending on whether a
     *          valid SASL mechanism was found with which authentication could be
     *          started.
     */
    _attemptSASLAuth: function (mechanisms) {
        mechanisms = this.sortMechanismsByPriority(mechanisms || []);
        var i = 0, mechanism_found = false;
        for (i = 0; i < mechanisms.length; ++i) {
            if (!mechanisms[i].prototype.test(this)) {
                continue;
            }
            this._sasl_success_handler = this._addSysHandler(
                this._sasl_success_cb.bind(this), null,
                "success", null, null);
            this._sasl_failure_handler = this._addSysHandler(
                this._sasl_failure_cb.bind(this), null,
                "failure", null, null);
            this._sasl_challenge_handler = this._addSysHandler(
                this._sasl_challenge_cb.bind(this), null,
                "challenge", null, null);

            this._sasl_mechanism = new mechanisms[i]();
            this._sasl_mechanism.onStart(this);

            var request_auth_exchange = $build("auth", {
                xmlns: Strophe.NS.SASL,
                mechanism: this._sasl_mechanism.name
            });
            if (this._sasl_mechanism.isClientFirst) {
                var response = this._sasl_mechanism.onChallenge(this, null);
                request_auth_exchange.t(Base64.encode(response));
            }
            this.send(request_auth_exchange.tree());
            mechanism_found = true;
            break;
        }
        return mechanism_found;
    },

    /** PrivateFunction: _attemptLegacyAuth
     *
     *  Attempt legacy (i.e. non-SASL) authentication.
     *
     */
    _attemptLegacyAuth: function () {
        if (Strophe.getNodeFromJid(this.jid) === null) {
            // we don't have a node, which is required for non-anonymous
            // client connections
            this._changeConnectStatus(
                Strophe.Status.CONNFAIL,
                'x-strophe-bad-non-anon-jid'
            );
            this.disconnect('x-strophe-bad-non-anon-jid');
        } else {
            // Fall back to legacy authentication
            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._addSysHandler(
                this._auth1_cb.bind(this),
                null, null, null, "_auth_1"
            );
            this.send($iq({
                    'type': "get",
                    'to': this.domain,
                    'id': "_auth_1"
                }).c("query", {xmlns: Strophe.NS.AUTH})
                .c("username", {}).t(Strophe.getNodeFromJid(this.jid))
                .tree());
        }
    },

    /** Function: authenticate
     * Set up authentication
     *
     *  Continues the initial connection request by setting up authentication
     *  handlers and starting the authentication process.
     *
     *  SASL authentication will be attempted if available, otherwise
     *  the code will fall back to legacy authentication.
     *
     *  Parameters:
     *    (Array) matched - Array of SASL mechanisms supported.
     *
     */
    authenticate: function (matched) {
        if (!this._attemptSASLAuth(matched)) {
            this._attemptLegacyAuth();
        }
    },

    /** PrivateFunction: _sasl_challenge_cb
     *  _Private_ handler for the SASL challenge
     *
     */
    _sasl_challenge_cb: function(elem) {
      var challenge = Base64.decode(Strophe.getText(elem));
      var response = this._sasl_mechanism.onChallenge(this, challenge);
      var stanza = $build('response', {
          'xmlns': Strophe.NS.SASL
      });
      if (response !== "") {
        stanza.t(Base64.encode(response));
      }
      this.send(stanza.tree());
      return true;
    },

    /** PrivateFunction: _auth1_cb
     *  _Private_ handler for legacy authentication.
     *
     *  This handler is called in response to the initial <iq type='get'/>
     *  for legacy authentication.  It builds an authentication <iq/> and
     *  sends it, creating a handler (calling back to _auth2_cb()) to
     *  handle the result
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza that triggered the callback.
     *
     *  Returns:
     *    false to remove the handler.
     */
    /* jshint unused:false */
    _auth1_cb: function (elem) {
        // build plaintext auth iq
        var iq = $iq({type: "set", id: "_auth_2"})
            .c('query', {xmlns: Strophe.NS.AUTH})
            .c('username', {}).t(Strophe.getNodeFromJid(this.jid))
            .up()
            .c('password').t(this.pass);

        if (!Strophe.getResourceFromJid(this.jid)) {
            // since the user has not supplied a resource, we pick
            // a default one here.  unlike other auth methods, the server
            // cannot do this for us.
            this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';
        }
        iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));

        this._addSysHandler(this._auth2_cb.bind(this), null,
                            null, null, "_auth_2");
        this.send(iq.tree());
        return false;
    },
    /* jshint unused:true */

    /** PrivateFunction: _sasl_success_cb
     *  _Private_ handler for succesful SASL authentication.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_success_cb: function (elem) {
        if (this._sasl_data["server-signature"]) {
            var serverSignature;
            var success = Base64.decode(Strophe.getText(elem));
            var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
            var matches = success.match(attribMatch);
            if (matches[1] == "v") {
                serverSignature = matches[2];
            }

            if (serverSignature != this._sasl_data["server-signature"]) {
              // remove old handlers
              this.deleteHandler(this._sasl_failure_handler);
              this._sasl_failure_handler = null;
              if (this._sasl_challenge_handler) {
                this.deleteHandler(this._sasl_challenge_handler);
                this._sasl_challenge_handler = null;
              }

              this._sasl_data = {};
              return this._sasl_failure_cb(null);
            }
        }
        Strophe.info("SASL authentication succeeded.");

        if (this._sasl_mechanism) {
          this._sasl_mechanism.onSuccess();
        }

        // remove old handlers
        this.deleteHandler(this._sasl_failure_handler);
        this._sasl_failure_handler = null;
        if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null;
        }

        var streamfeature_handlers = [];
        var wrapper = function(handlers, elem) {
            while (handlers.length) {
                this.deleteHandler(handlers.pop());
            }
            this._sasl_auth1_cb.bind(this)(elem);
            return false;
        };
        streamfeature_handlers.push(this._addSysHandler(function(elem) {
            wrapper.bind(this)(streamfeature_handlers, elem);
        }.bind(this), null, "stream:features", null, null));
        streamfeature_handlers.push(this._addSysHandler(function(elem) {
            wrapper.bind(this)(streamfeature_handlers, elem);
        }.bind(this), Strophe.NS.STREAM, "features", null, null));

        // we must send an xmpp:restart now
        this._sendRestart();

        return false;
    },

    /** PrivateFunction: _sasl_auth1_cb
     *  _Private_ handler to start stream binding.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_auth1_cb: function (elem) {
        // save stream:features for future usage
        this.features = elem;
        var i, child;
        for (i = 0; i < elem.childNodes.length; i++) {
            child = elem.childNodes[i];
            if (child.nodeName == 'bind') {
                this.do_bind = true;
            }

            if (child.nodeName == 'session') {
                this.do_session = true;
            }
        }

        if (!this.do_bind) {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        } else {
            this._addSysHandler(this._sasl_bind_cb.bind(this), null, null,
                                null, "_bind_auth_2");

            var resource = Strophe.getResourceFromJid(this.jid);
            if (resource) {
                this.send($iq({type: "set", id: "_bind_auth_2"})
                          .c('bind', {xmlns: Strophe.NS.BIND})
                          .c('resource', {}).t(resource).tree());
            } else {
                this.send($iq({type: "set", id: "_bind_auth_2"})
                          .c('bind', {xmlns: Strophe.NS.BIND})
                          .tree());
            }
        }
        return false;
    },

    /** PrivateFunction: _sasl_bind_cb
     *  _Private_ handler for binding result and session start.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_bind_cb: function (elem) {
        if (elem.getAttribute("type") == "error") {
            Strophe.info("SASL binding failed.");
            var conflict = elem.getElementsByTagName("conflict"), condition;
            if (conflict.length > 0) {
                condition = 'conflict';
            }
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);
            return false;
        }

        // TODO - need to grab errors
        var bind = elem.getElementsByTagName("bind");
        var jidNode;
        if (bind.length > 0) {
            // Grab jid
            jidNode = bind[0].getElementsByTagName("jid");
            if (jidNode.length > 0) {
                this.jid = Strophe.getText(jidNode[0]);

                if (this.do_session) {
                    this._addSysHandler(this._sasl_session_cb.bind(this),
                                        null, null, null, "_session_auth_2");

                    this.send($iq({type: "set", id: "_session_auth_2"})
                                  .c('session', {xmlns: Strophe.NS.SESSION})
                                  .tree());
                } else {
                    this.authenticated = true;
                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                }
            }
        } else {
            Strophe.info("SASL binding failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        }
    },

    /** PrivateFunction: _sasl_session_cb
     *  _Private_ handler to finish successful SASL connection.
     *
     *  This sets Connection.authenticated to true on success, which
     *  starts the processing of user handlers.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_session_cb: function (elem) {
        if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null);
        } else if (elem.getAttribute("type") == "error") {
            Strophe.info("Session creation failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        }
        return false;
    },

    /** PrivateFunction: _sasl_failure_cb
     *  _Private_ handler for SASL authentication failure.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    /* jshint unused:false */
    _sasl_failure_cb: function (elem) {
        // delete unneeded handlers
        if (this._sasl_success_handler) {
            this.deleteHandler(this._sasl_success_handler);
            this._sasl_success_handler = null;
        }
        if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null;
        }

        if(this._sasl_mechanism)
          this._sasl_mechanism.onFailure();
        this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
        return false;
    },
    /* jshint unused:true */

    /** PrivateFunction: _auth2_cb
     *  _Private_ handler to finish legacy authentication.
     *
     *  This handler is called when the result from the jabber:iq:auth
     *  <iq/> stanza is returned.
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza that triggered the callback.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _auth2_cb: function (elem) {
        if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null);
        } else if (elem.getAttribute("type") == "error") {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            this.disconnect('authentication failed');
        }
        return false;
    },

    /** PrivateFunction: _addSysTimedHandler
     *  _Private_ function to add a system level timed handler.
     *
     *  This function is used to add a Strophe.TimedHandler for the
     *  library code.  System timed handlers are allowed to run before
     *  authentication is complete.
     *
     *  Parameters:
     *    (Integer) period - The period of the handler.
     *    (Function) handler - The callback function.
     */
    _addSysTimedHandler: function (period, handler) {
        var thand = new Strophe.TimedHandler(period, handler);
        thand.user = false;
        this.addTimeds.push(thand);
        return thand;
    },

    /** PrivateFunction: _addSysHandler
     *  _Private_ function to add a system level stanza handler.
     *
     *  This function is used to add a Strophe.Handler for the
     *  library code.  System stanza handlers are allowed to run before
     *  authentication is complete.
     *
     *  Parameters:
     *    (Function) handler - The callback function.
     *    (String) ns - The namespace to match.
     *    (String) name - The stanza name to match.
     *    (String) type - The stanza type attribute to match.
     *    (String) id - The stanza id attribute to match.
     */
    _addSysHandler: function (handler, ns, name, type, id) {
        var hand = new Strophe.Handler(handler, ns, name, type, id);
        hand.user = false;
        this.addHandlers.push(hand);
        return hand;
    },

    /** PrivateFunction: _onDisconnectTimeout
     *  _Private_ timeout handler for handling non-graceful disconnection.
     *
     *  If the graceful disconnect process does not complete within the
     *  time allotted, this handler finishes the disconnect anyway.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _onDisconnectTimeout: function () {
        Strophe.info("_onDisconnectTimeout was called");
        this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);
        this._proto._onDisconnectTimeout();
        // actually disconnect
        this._doDisconnect();
        return false;
    },

    /** PrivateFunction: _onIdle
     *  _Private_ handler to process events during idle cycle.
     *
     *  This handler is called every 100ms to fire timed handlers that
     *  are ready and keep poll requests going.
     */
    _onIdle: function () {
        var i, thand, since, newList;

        // add timed handlers scheduled for addition
        // NOTE: we add before remove in the case a timed handler is
        // added and then deleted before the next _onIdle() call.
        while (this.addTimeds.length > 0) {
            this.timedHandlers.push(this.addTimeds.pop());
        }

        // remove timed handlers that have been scheduled for deletion
        while (this.removeTimeds.length > 0) {
            thand = this.removeTimeds.pop();
            i = this.timedHandlers.indexOf(thand);
            if (i >= 0) {
                this.timedHandlers.splice(i, 1);
            }
        }

        // call ready timed handlers
        var now = new Date().getTime();
        newList = [];
        for (i = 0; i < this.timedHandlers.length; i++) {
            thand = this.timedHandlers[i];
            if (this.authenticated || !thand.user) {
                since = thand.lastCalled + thand.period;
                if (since - now <= 0) {
                    if (thand.run()) {
                        newList.push(thand);
                    }
                } else {
                    newList.push(thand);
                }
            }
        }
        this.timedHandlers = newList;

        clearTimeout(this._idleTimeout);

        this._proto._onIdle();

        // reactivate the timer only if connected
        if (this.connected) {
            // XXX: setTimeout should be called only with function expressions (23974bc1)
            this._idleTimeout = setTimeout(function() {
                this._onIdle();
            }.bind(this), 100);
        }
    }
};

/** Class: Strophe.SASLMechanism
 *
 *  encapsulates SASL authentication mechanisms.
 *
 *  User code may override the priority for each mechanism or disable it completely.
 *  See <priority> for information about changing priority and <test> for informatian on
 *  how to disable a mechanism.
 *
 *  By default, all mechanisms are enabled and the priorities are
 *
 *  EXTERNAL - 60
 *  OAUTHBEARER - 50
 *  SCRAM-SHA1 - 40
 *  DIGEST-MD5 - 30
 *  PLAIN - 20
 *  ANONYMOUS - 10
 *
 *  See: Strophe.Connection.addSupportedSASLMechanisms
 */

/**
 * PrivateConstructor: Strophe.SASLMechanism
 * SASL auth mechanism abstraction.
 *
 *  Parameters:
 *    (String) name - SASL Mechanism name.
 *    (Boolean) isClientFirst - If client should send response first without challenge.
 *    (Number) priority - Priority.
 *
 *  Returns:
 *    A new Strophe.SASLMechanism object.
 */
Strophe.SASLMechanism = function(name, isClientFirst, priority) {
  /** PrivateVariable: name
   *  Mechanism name.
   */
  this.name = name;
  /** PrivateVariable: isClientFirst
   *  If client sends response without initial server challenge.
   */
  this.isClientFirst = isClientFirst;
  /** Variable: priority
   *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).
   *  Users may override this to prioritize mechanisms differently.
   *
   *  In the default configuration the priorities are
   *
   *  SCRAM-SHA1 - 40
   *  DIGEST-MD5 - 30
   *  Plain - 20
   *
   *  Example: (This will cause Strophe to choose the mechanism that the server sent first)
   *
   *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;
   *
   *  See <SASL mechanisms> for a list of available mechanisms.
   *
   */
  this.priority = priority;
};

Strophe.SASLMechanism.prototype = {
  /**
   *  Function: test
   *  Checks if mechanism able to run.
   *  To disable a mechanism, make this return false;
   *
   *  To disable plain authentication run
   *  > Strophe.SASLPlain.test = function() {
   *  >   return false;
   *  > }
   *
   *  See <SASL mechanisms> for a list of available mechanisms.
   *
   *  Parameters:
   *    (Strophe.Connection) connection - Target Connection.
   *
   *  Returns:
   *    (Boolean) If mechanism was able to run.
   */
  /* jshint unused:false */
  test: function(connection) {
    return true;
  },
  /* jshint unused:true */

  /** PrivateFunction: onStart
   *  Called before starting mechanism on some connection.
   *
   *  Parameters:
   *    (Strophe.Connection) connection - Target Connection.
   */
  onStart: function(connection) {
    this._connection = connection;
  },

  /** PrivateFunction: onChallenge
   *  Called by protocol implementation on incoming challenge. If client is
   *  first (isClientFirst == true) challenge will be null on the first call.
   *
   *  Parameters:
   *    (Strophe.Connection) connection - Target Connection.
   *    (String) challenge - current challenge to handle.
   *
   *  Returns:
   *    (String) Mechanism response.
   */
  /* jshint unused:false */
  onChallenge: function(connection, challenge) {
    throw new Error("You should implement challenge handling!");
  },
  /* jshint unused:true */

  /** PrivateFunction: onFailure
   *  Protocol informs mechanism implementation about SASL failure.
   */
  onFailure: function() {
    this._connection = null;
  },

  /** PrivateFunction: onSuccess
   *  Protocol informs mechanism implementation about SASL success.
   */
  onSuccess: function() {
    this._connection = null;
  }
};

  /** Constants: SASL mechanisms
   *  Available authentication mechanisms
   *
   *  Strophe.SASLAnonymous - SASL ANONYMOUS authentication.
   *  Strophe.SASLPlain - SASL PLAIN authentication.
   *  Strophe.SASLMD5 - SASL DIGEST-MD5 authentication
   *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication
   *  Strophe.SASLOAuthBearer - SASL OAuth Bearer authentication
   *  Strophe.SASLExternal - SASL EXTERNAL authentication
   */

// Building SASL callbacks

/** PrivateConstructor: SASLAnonymous
 *  SASL ANONYMOUS authentication.
 */
Strophe.SASLAnonymous = function() {};
Strophe.SASLAnonymous.prototype = new Strophe.SASLMechanism("ANONYMOUS", false, 10);

Strophe.SASLAnonymous.prototype.test = function(connection) {
    return connection.authcid === null;
};


/** PrivateConstructor: SASLPlain
 *  SASL PLAIN authentication.
 */
Strophe.SASLPlain = function() {};
Strophe.SASLPlain.prototype = new Strophe.SASLMechanism("PLAIN", true, 20);

Strophe.SASLPlain.prototype.test = function(connection) {
    return connection.authcid !== null;
};

Strophe.SASLPlain.prototype.onChallenge = function(connection) {
    var auth_str = connection.authzid;
    auth_str = auth_str + "\u0000";
    auth_str = auth_str + connection.authcid;
    auth_str = auth_str + "\u0000";
    auth_str = auth_str + connection.pass;
    return utils.utf16to8(auth_str);
};


/** PrivateConstructor: SASLSHA1
 *  SASL SCRAM SHA 1 authentication.
 */
Strophe.SASLSHA1 = function() {};
Strophe.SASLSHA1.prototype = new Strophe.SASLMechanism("SCRAM-SHA-1", true, 40);

Strophe.SASLSHA1.prototype.test = function(connection) {
    return connection.authcid !== null;
};

Strophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {
  var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);
  var auth_str = "n=" + utils.utf16to8(connection.authcid);
  auth_str += ",r=";
  auth_str += cnonce;
  connection._sasl_data.cnonce = cnonce;
  connection._sasl_data["client-first-message-bare"] = auth_str;

  auth_str = "n,," + auth_str;

  this.onChallenge = function (connection, challenge) {
    var nonce, salt, iter, Hi, U, U_old, i, k, pass;
    var clientKey, serverKey, clientSignature;
    var responseText = "c=biws,";
    var authMessage = connection._sasl_data["client-first-message-bare"] + "," +
      challenge + ",";
    var cnonce = connection._sasl_data.cnonce;
    var attribMatch = /([a-z]+)=([^,]+)(,|$)/;

    while (challenge.match(attribMatch)) {
      var matches = challenge.match(attribMatch);
      challenge = challenge.replace(matches[0], "");
      switch (matches[1]) {
      case "r":
        nonce = matches[2];
        break;
      case "s":
        salt = matches[2];
        break;
      case "i":
        iter = matches[2];
        break;
      }
    }

    if (nonce.substr(0, cnonce.length) !== cnonce) {
      connection._sasl_data = {};
      return connection._sasl_failure_cb();
    }

    responseText += "r=" + nonce;
    authMessage += responseText;

    salt = Base64.decode(salt);
    salt += "\x00\x00\x00\x01";

    pass = utils.utf16to8(connection.pass);
    Hi = U_old = SHA1.core_hmac_sha1(pass, salt);
    for (i = 1; i < iter; i++) {
      U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));
      for (k = 0; k < 5; k++) {
        Hi[k] ^= U[k];
      }
      U_old = U;
    }
    Hi = SHA1.binb2str(Hi);

    clientKey = SHA1.core_hmac_sha1(Hi, "Client Key");
    serverKey = SHA1.str_hmac_sha1(Hi, "Server Key");
    clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);
    connection._sasl_data["server-signature"] = SHA1.b64_hmac_sha1(serverKey, authMessage);

    for (k = 0; k < 5; k++) {
      clientKey[k] ^= clientSignature[k];
    }

    responseText += ",p=" + Base64.encode(SHA1.binb2str(clientKey));
    return responseText;
  }.bind(this);

  return auth_str;
};


/** PrivateConstructor: SASLMD5
 *  SASL DIGEST MD5 authentication.
 */
Strophe.SASLMD5 = function() {};
Strophe.SASLMD5.prototype = new Strophe.SASLMechanism("DIGEST-MD5", false, 30);

Strophe.SASLMD5.prototype.test = function(connection) {
    return connection.authcid !== null;
};

/** PrivateFunction: _quote
 *  _Private_ utility function to backslash escape and quote strings.
 *
 *  Parameters:
 *    (String) str - The string to be quoted.
 *
 *  Returns:
 *    quoted string
 */
Strophe.SASLMD5.prototype._quote = function (str) {
    return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
    //" end string workaround for emacs
};

Strophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {
  var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;
  var cnonce = test_cnonce || MD5.hexdigest("" + (Math.random() * 1234567890));
  var realm = "";
  var host = null;
  var nonce = "";
  var qop = "";
  var matches;

  while (challenge.match(attribMatch)) {
    matches = challenge.match(attribMatch);
    challenge = challenge.replace(matches[0], "");
    matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
    switch (matches[1]) {
    case "realm":
      realm = matches[2];
      break;
    case "nonce":
      nonce = matches[2];
      break;
    case "qop":
      qop = matches[2];
      break;
    case "host":
      host = matches[2];
      break;
    }
  }

  var digest_uri = connection.servtype + "/" + connection.domain;
  if (host !== null) {
    digest_uri = digest_uri + "/" + host;
  }

  var cred = utils.utf16to8(connection.authcid + ":" + realm + ":" + this._connection.pass);
  var A1 = MD5.hash(cred) + ":" + nonce + ":" + cnonce;
  var A2 = 'AUTHENTICATE:' + digest_uri;

  var responseText = "";
  responseText += 'charset=utf-8,';
  responseText += 'username=' + this._quote(utils.utf16to8(connection.authcid)) + ',';
  responseText += 'realm=' + this._quote(realm) + ',';
  responseText += 'nonce=' + this._quote(nonce) + ',';
  responseText += 'nc=00000001,';
  responseText += 'cnonce=' + this._quote(cnonce) + ',';
  responseText += 'digest-uri=' + this._quote(digest_uri) + ',';
  responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + ":" +
                                              nonce + ":00000001:" +
                                              cnonce + ":auth:" +
                                              MD5.hexdigest(A2)) + ",";
  responseText += 'qop=auth';

  this.onChallenge = function () {
      return "";
  };
  return responseText;
};


/** PrivateConstructor: SASLOAuthBearer
 *  SASL OAuth Bearer authentication.
 */
Strophe.SASLOAuthBearer = function() {};
Strophe.SASLOAuthBearer.prototype = new Strophe.SASLMechanism("OAUTHBEARER", true, 50);

Strophe.SASLOAuthBearer.prototype.test = function(connection) {
    return connection.authcid !== null;
};

Strophe.SASLOAuthBearer.prototype.onChallenge = function(connection) {
    var auth_str = 'n,a=';
    auth_str = auth_str + connection.authzid;
    auth_str = auth_str + ',';
    auth_str = auth_str + "\u0001";
    auth_str = auth_str + 'auth=Bearer ';
    auth_str = auth_str + connection.pass;
    auth_str = auth_str + "\u0001";
    auth_str = auth_str + "\u0001";
    return utils.utf16to8(auth_str);
};


/** PrivateConstructor: SASLExternal
 *  SASL EXTERNAL authentication.
 *
 *  The EXTERNAL mechanism allows a client to request the server to use
 *  credentials established by means external to the mechanism to
 *  authenticate the client. The external means may be, for instance,
 *  TLS services.
 */
Strophe.SASLExternal = function() {};
Strophe.SASLExternal.prototype = new Strophe.SASLMechanism("EXTERNAL", true, 60);

Strophe.SASLExternal.prototype.onChallenge = function(connection) {
    /** According to XEP-178, an authzid SHOULD NOT be presented when the
     * authcid contained or implied in the client certificate is the JID (i.e.
     * authzid) with which the user wants to log in as.
     *
     * To NOT send the authzid, the user should therefore set the authcid equal
     * to the JID when instantiating a new Strophe.Connection object.
     */
    return connection.authcid === connection.authzid ? '' : connection.authzid;
};

return {
    Strophe:        Strophe,
    $build:         $build,
    $msg:           $msg,
    $iq:            $iq,
    $pres:          $pres,
    SHA1:           SHA1,
    Base64:         Base64,
    MD5:            MD5,
};
}));

/*
    This program is distributed under the terms of the MIT license.
    Please see the LICENSE file for details.

    Copyright 2006-2008, OGG, LLC
*/

/* jshint undef: true, unused: true:, noarg: true, latedef: true */
/* global define, window, setTimeout, clearTimeout, XMLHttpRequest, ActiveXObject, Strophe, $build */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-bosh', ['strophe-core'], function (core) {
            return factory(
                core.Strophe,
                core.$build
            );
        });
    } else {
        // Browser globals
        return factory(Strophe, $build);
    }
}(this, function (Strophe, $build) {

/** PrivateClass: Strophe.Request
 *  _Private_ helper class that provides a cross implementation abstraction
 *  for a BOSH related XMLHttpRequest.
 *
 *  The Strophe.Request class is used internally to encapsulate BOSH request
 *  information.  It is not meant to be used from user's code.
 */

/** PrivateConstructor: Strophe.Request
 *  Create and initialize a new Strophe.Request object.
 *
 *  Parameters:
 *    (XMLElement) elem - The XML data to be sent in the request.
 *    (Function) func - The function that will be called when the
 *      XMLHttpRequest readyState changes.
 *    (Integer) rid - The BOSH rid attribute associated with this request.
 *    (Integer) sends - The number of times this same request has been sent.
 */
Strophe.Request = function (elem, func, rid, sends) {
    this.id = ++Strophe._requestId;
    this.xmlData = elem;
    this.data = Strophe.serialize(elem);
    // save original function in case we need to make a new request
    // from this one.
    this.origFunc = func;
    this.func = func;
    this.rid = rid;
    this.date = NaN;
    this.sends = sends || 0;
    this.abort = false;
    this.dead = null;

    this.age = function () {
        if (!this.date) { return 0; }
        var now = new Date();
        return (now - this.date) / 1000;
    };
    this.timeDead = function () {
        if (!this.dead) { return 0; }
        var now = new Date();
        return (now - this.dead) / 1000;
    };
    this.xhr = this._newXHR();
};

Strophe.Request.prototype = {
    /** PrivateFunction: getResponse
     *  Get a response from the underlying XMLHttpRequest.
     *
     *  This function attempts to get a response from the request and checks
     *  for errors.
     *
     *  Throws:
     *    "parsererror" - A parser error occured.
     *    "badformat" - The entity has sent XML that cannot be processed.
     *
     *  Returns:
     *    The DOM element tree of the response.
     */
    getResponse: function () {
        var node = null;
        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
            node = this.xhr.responseXML.documentElement;
            if (node.tagName == "parsererror") {
                Strophe.error("invalid response received");
                Strophe.error("responseText: " + this.xhr.responseText);
                Strophe.error("responseXML: " +
                              Strophe.serialize(this.xhr.responseXML));
                throw "parsererror";
            }
        } else if (this.xhr.responseText) {
            Strophe.error("invalid response received");
            Strophe.error("responseText: " + this.xhr.responseText);
            throw "badformat";
        }

        return node;
    },

    /** PrivateFunction: _newXHR
     *  _Private_ helper function to create XMLHttpRequests.
     *
     *  This function creates XMLHttpRequests across all implementations.
     *
     *  Returns:
     *    A new XMLHttpRequest.
     */
    _newXHR: function () {
        var xhr = null;
        if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
            if (xhr.overrideMimeType) {
                xhr.overrideMimeType("text/xml; charset=utf-8");
            }
        } else if (window.ActiveXObject) {
            xhr = new ActiveXObject("Microsoft.XMLHTTP");
        }
        // use Function.bind() to prepend ourselves as an argument
        xhr.onreadystatechange = this.func.bind(null, this);
        return xhr;
    }
};

/** Class: Strophe.Bosh
 *  _Private_ helper class that handles BOSH Connections
 *
 *  The Strophe.Bosh class is used internally by Strophe.Connection
 *  to encapsulate BOSH sessions. It is not meant to be used from user's code.
 */

/** File: bosh.js
 *  A JavaScript library to enable BOSH in Strophejs.
 *
 *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)
 *  to emulate a persistent, stateful, two-way connection to an XMPP server.
 *  More information on BOSH can be found in XEP 124.
 */

/** PrivateConstructor: Strophe.Bosh
 *  Create and initialize a Strophe.Bosh object.
 *
 *  Parameters:
 *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.
 *
 *  Returns:
 *    A new Strophe.Bosh object.
 */
Strophe.Bosh = function(connection) {
    this._conn = connection;
    /* request id for body tags */
    this.rid = Math.floor(Math.random() * 4294967295);
    /* The current session ID. */
    this.sid = null;

    // default BOSH values
    this.hold = 1;
    this.wait = 60;
    this.window = 5;
    this.errors = 0;
    this.inactivity = null;

    this._requests = [];
};

Strophe.Bosh.prototype = {
    /** Variable: strip
     *
     *  BOSH-Connections will have all stanzas wrapped in a <body> tag when
     *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.
     *  To strip this tag, User code can set <Strophe.Bosh.strip> to "body":
     *
     *  > Strophe.Bosh.prototype.strip = "body";
     *
     *  This will enable stripping of the body tag in both
     *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.
     */
    strip: null,

    /** PrivateFunction: _buildBody
     *  _Private_ helper function to generate the <body/> wrapper for BOSH.
     *
     *  Returns:
     *    A Strophe.Builder with a <body/> element.
     */
    _buildBody: function () {
        var bodyWrap = $build('body', {
            rid: this.rid++,
            xmlns: Strophe.NS.HTTPBIND
        });
        if (this.sid !== null) {
            bodyWrap.attrs({sid: this.sid});
        }
        if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {
            this._cacheSession();
        }
        return bodyWrap;
    },

    /** PrivateFunction: _reset
     *  Reset the connection.
     *
     *  This function is called by the reset function of the Strophe Connection
     */
    _reset: function () {
        this.rid = Math.floor(Math.random() * 4294967295);
        this.sid = null;
        this.errors = 0;
        if (this._conn._sessionCachingSupported()) {
            window.sessionStorage.removeItem('strophe-bosh-session');
        }

        this._conn.nextValidRid(this.rid);
    },

    /** PrivateFunction: _connect
     *  _Private_ function that initializes the BOSH connection.
     *
     *  Creates and sends the Request that initializes the BOSH connection.
     */
    _connect: function (wait, hold, route) {
        this.wait = wait || this.wait;
        this.hold = hold || this.hold;
        this.errors = 0;

        // build the body tag
        var body = this._buildBody().attrs({
            to: this._conn.domain,
            "xml:lang": "en",
            wait: this.wait,
            hold: this.hold,
            content: "text/xml; charset=utf-8",
            ver: "1.6",
            "xmpp:version": "1.0",
            "xmlns:xmpp": Strophe.NS.BOSH
        });

        if(route){
            body.attrs({
                route: route
            });
        }

        var _connect_cb = this._conn._connect_cb;

        this._requests.push(
            new Strophe.Request(body.tree(),
                                this._onRequestStateChange.bind(
                                    this, _connect_cb.bind(this._conn)),
                                body.tree().getAttribute("rid")));
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _attach
     *  Attach to an already created and authenticated BOSH session.
     *
     *  This function is provided to allow Strophe to attach to BOSH
     *  sessions which have been created externally, perhaps by a Web
     *  application.  This is often used to support auto-login type features
     *  without putting user credentials into the page.
     *
     *  Parameters:
     *    (String) jid - The full JID that is bound by the session.
     *    (String) sid - The SID of the BOSH session.
     *    (String) rid - The current RID of the BOSH session.  This RID
     *      will be used by the next request.
     *    (Function) callback The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *      Other settings will require tweaks to the Strophe.TIMEOUT value.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (Integer) wind - The optional HTTBIND window value.  This is the
     *      allowed range of request ids that are valid.  The default is 5.
     */
    _attach: function (jid, sid, rid, callback, wait, hold, wind) {
        this._conn.jid = jid;
        this.sid = sid;
        this.rid = rid;

        this._conn.connect_callback = callback;

        this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);

        this._conn.authenticated = true;
        this._conn.connected = true;

        this.wait = wait || this.wait;
        this.hold = hold || this.hold;
        this.window = wind || this.window;

        this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);
    },

    /** PrivateFunction: _restore
     *  Attempt to restore a cached BOSH session
     *
     *  Parameters:
     *    (String) jid - The full JID that is bound by the session.
     *      This parameter is optional but recommended, specifically in cases
     *      where prebinded BOSH sessions are used where it's important to know
     *      that the right session is being restored.
     *    (Function) callback The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *      Other settings will require tweaks to the Strophe.TIMEOUT value.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (Integer) wind - The optional HTTBIND window value.  This is the
     *      allowed range of request ids that are valid.  The default is 5.
     */
    _restore: function (jid, callback, wait, hold, wind) {
        var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));
        if (typeof session !== "undefined" &&
                   session !== null &&
                   session.rid &&
                   session.sid &&
                   session.jid &&
                   (    typeof jid === "undefined" ||
                        jid === null ||
                        Strophe.getBareJidFromJid(session.jid) == Strophe.getBareJidFromJid(jid) ||
                        // If authcid is null, then it's an anonymous login, so
                        // we compare only the domains:
                        ((Strophe.getNodeFromJid(jid) === null) && (Strophe.getDomainFromJid(session.jid) == jid))
                    )
        ) {
            this._conn.restored = true;
            this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);
        } else {
            throw { name: "StropheSessionError", message: "_restore: no restoreable session." };
        }
    },

    /** PrivateFunction: _cacheSession
     *  _Private_ handler for the beforeunload event.
     *
     *  This handler is used to process the Bosh-part of the initial request.
     *  Parameters:
     *    (Strophe.Request) bodyWrap - The received stanza.
     */
    _cacheSession: function () {
        if (this._conn.authenticated) {
            if (this._conn.jid && this.rid && this.sid) {
                window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({
                    'jid': this._conn.jid,
                    'rid': this.rid,
                    'sid': this.sid
                }));
            }
        } else {
            window.sessionStorage.removeItem('strophe-bosh-session');
        }
    },

    /** PrivateFunction: _connect_cb
     *  _Private_ handler for initial connection request.
     *
     *  This handler is used to process the Bosh-part of the initial request.
     *  Parameters:
     *    (Strophe.Request) bodyWrap - The received stanza.
     */
    _connect_cb: function (bodyWrap) {
        var typ = bodyWrap.getAttribute("type");
        var cond, conflict;
        if (typ !== null && typ == "terminate") {
            // an error occurred
            cond = bodyWrap.getAttribute("condition");
            Strophe.error("BOSH-Connection failed: " + cond);
            conflict = bodyWrap.getElementsByTagName("conflict");
            if (cond !== null) {
                if (cond == "remote-stream-error" && conflict.length > 0) {
                    cond = "conflict";
                }
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
            } else {
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
            }
            this._conn._doDisconnect(cond);
            return Strophe.Status.CONNFAIL;
        }

        // check to make sure we don't overwrite these if _connect_cb is
        // called multiple times in the case of missing stream:features
        if (!this.sid) {
            this.sid = bodyWrap.getAttribute("sid");
        }
        var wind = bodyWrap.getAttribute('requests');
        if (wind) { this.window = parseInt(wind, 10); }
        var hold = bodyWrap.getAttribute('hold');
        if (hold) { this.hold = parseInt(hold, 10); }
        var wait = bodyWrap.getAttribute('wait');
        if (wait) { this.wait = parseInt(wait, 10); }
        var inactivity = bodyWrap.getAttribute('inactivity');
        if (inactivity) { this.inactivity = parseInt(inactivity, 10); }
    },

    /** PrivateFunction: _disconnect
     *  _Private_ part of Connection.disconnect for Bosh
     *
     *  Parameters:
     *    (Request) pres - This stanza will be sent before disconnecting.
     */
    _disconnect: function (pres) {
        this._sendTerminate(pres);
    },

    /** PrivateFunction: _doDisconnect
     *  _Private_ function to disconnect.
     *
     *  Resets the SID and RID.
     */
    _doDisconnect: function () {
        this.sid = null;
        this.rid = Math.floor(Math.random() * 4294967295);
        if (this._conn._sessionCachingSupported()) {
            window.sessionStorage.removeItem('strophe-bosh-session');
        }

        this._conn.nextValidRid(this.rid);
    },

    /** PrivateFunction: _emptyQueue
     * _Private_ function to check if the Request queue is empty.
     *
     *  Returns:
     *    True, if there are no Requests queued, False otherwise.
     */
    _emptyQueue: function () {
        return this._requests.length === 0;
    },

    /** PrivateFunction: _callProtocolErrorHandlers
     *  _Private_ function to call error handlers registered for HTTP errors.
     *
     *  Parameters:
     *    (Strophe.Request) req - The request that is changing readyState.
     */
    _callProtocolErrorHandlers: function (req) {
        var reqStatus = this._getRequestStatus(req),
            err_callback;
        err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];
        if (err_callback) {
            err_callback.call(this, reqStatus);
        }
    },

    /** PrivateFunction: _hitError
     *  _Private_ function to handle the error count.
     *
     *  Requests are resent automatically until their error count reaches
     *  5.  Each time an error is encountered, this function is called to
     *  increment the count and disconnect if the count is too high.
     *
     *  Parameters:
     *    (Integer) reqStatus - The request status.
     */
    _hitError: function (reqStatus) {
        this.errors++;
        Strophe.warn("request errored, status: " + reqStatus +
                     ", number of errors: " + this.errors);
        if (this.errors > 4) {
            this._conn._onDisconnectTimeout();
        }
    },

    /** PrivateFunction: _no_auth_received
     *
     * Called on stream start/restart when no stream:features
     * has been received and sends a blank poll request.
     */
    _no_auth_received: function (_callback) {
        if (_callback) {
            _callback = _callback.bind(this._conn);
        } else {
            _callback = this._conn._connect_cb.bind(this._conn);
        }
        var body = this._buildBody();
        this._requests.push(
                new Strophe.Request(body.tree(),
                    this._onRequestStateChange.bind(
                        this, _callback.bind(this._conn)),
                    body.tree().getAttribute("rid")));
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _onDisconnectTimeout
     *  _Private_ timeout handler for handling non-graceful disconnection.
     *
     *  Cancels all remaining Requests and clears the queue.
     */
    _onDisconnectTimeout: function () {
        this._abortAllRequests();
    },

    /** PrivateFunction: _abortAllRequests
     *  _Private_ helper function that makes sure all pending requests are aborted.
     */
    _abortAllRequests: function _abortAllRequests() {
        var req;
        while (this._requests.length > 0) {
            req = this._requests.pop();
            req.abort = true;
            req.xhr.abort();
            // jslint complains, but this is fine. setting to empty func
            // is necessary for IE6
            req.xhr.onreadystatechange = function () {}; // jshint ignore:line
        }
    },

    /** PrivateFunction: _onIdle
     *  _Private_ handler called by Strophe.Connection._onIdle
     *
     *  Sends all queued Requests or polls with empty Request if there are none.
     */
    _onIdle: function () {
        var data = this._conn._data;
        // if no requests are in progress, poll
        if (this._conn.authenticated && this._requests.length === 0 &&
            data.length === 0 && !this._conn.disconnecting) {
            Strophe.info("no requests during idle cycle, sending " +
                         "blank request");
            data.push(null);
        }

        if (this._conn.paused) {
            return;
        }

        if (this._requests.length < 2 && data.length > 0) {
            var body = this._buildBody();
            for (var i = 0; i < data.length; i++) {
                if (data[i] !== null) {
                    if (data[i] === "restart") {
                        body.attrs({
                            to: this._conn.domain,
                            "xml:lang": "en",
                            "xmpp:restart": "true",
                            "xmlns:xmpp": Strophe.NS.BOSH
                        });
                    } else {
                        body.cnode(data[i]).up();
                    }
                }
            }
            delete this._conn._data;
            this._conn._data = [];
            this._requests.push(
                new Strophe.Request(body.tree(),
                                    this._onRequestStateChange.bind(
                                        this, this._conn._dataRecv.bind(this._conn)),
                                    body.tree().getAttribute("rid")));
            this._throttledRequestHandler();
        }

        if (this._requests.length > 0) {
            var time_elapsed = this._requests[0].age();
            if (this._requests[0].dead !== null) {
                if (this._requests[0].timeDead() >
                    Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                    this._throttledRequestHandler();
                }
            }

            if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
                Strophe.warn("Request " +
                             this._requests[0].id +
                             " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) +
                             " seconds since last activity");
                this._throttledRequestHandler();
            }
        }
    },

    /** PrivateFunction: _getRequestStatus
     *
     *  Returns the HTTP status code from a Strophe.Request
     *
     *  Parameters:
     *    (Strophe.Request) req - The Strophe.Request instance.
     *    (Integer) def - The default value that should be returned if no
     *          status value was found.
     */
    _getRequestStatus: function (req, def) {
        var reqStatus;
        if (req.xhr.readyState == 4) {
            try {
                reqStatus = req.xhr.status;
            } catch (e) {
                // ignore errors from undefined status attribute. Works
                // around a browser bug
                Strophe.error(
                    "Caught an error while retrieving a request's status, " +
                    "reqStatus: " + reqStatus);
            }
        }
        if (typeof(reqStatus) == "undefined") {
            reqStatus = typeof def === 'number' ? def : 0;
        }
        return reqStatus;
    },

    /** PrivateFunction: _onRequestStateChange
     *  _Private_ handler for Strophe.Request state changes.
     *
     *  This function is called when the XMLHttpRequest readyState changes.
     *  It contains a lot of error handling logic for the many ways that
     *  requests can fail, and calls the request callback when requests
     *  succeed.
     *
     *  Parameters:
     *    (Function) func - The handler for the request.
     *    (Strophe.Request) req - The request that is changing readyState.
     */
    _onRequestStateChange: function (func, req) {
        Strophe.debug("request id "+req.id+"."+req.sends+
                      " state changed to "+req.xhr.readyState);
        if (req.abort) {
            req.abort = false;
            return;
        }
        if (req.xhr.readyState !== 4) {
            // The request is not yet complete
            return;
        }
        var reqStatus = this._getRequestStatus(req);
        if (this.disconnecting && reqStatus >= 400) {
            this._hitError(reqStatus);
            this._callProtocolErrorHandlers(req);
            return;
        }

        if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
            // remove from internal queue
            this._removeRequest(req);
            Strophe.debug("request id "+req.id+" should now be removed");
        }

        if (reqStatus == 200) {
            // request succeeded
            var reqIs0 = (this._requests[0] == req);
            var reqIs1 = (this._requests[1] == req);
            // if request 1 finished, or request 0 finished and request
            // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to
            // restart the other - both will be in the first spot, as the
            // completed request has been removed from the queue already
            if (reqIs1 ||
                (reqIs0 && this._requests.length > 0 &&
                    this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
                this._restartRequest(0);
            }
            this._conn.nextValidRid(Number(req.rid) + 1);
            Strophe.debug("request id "+req.id+"."+req.sends+" got 200");
            func(req); // call handler
            this.errors = 0;
        } else if (reqStatus === 0 ||
                   (reqStatus >= 400 && reqStatus < 600) ||
                   reqStatus >= 12000) {
            // request failed
            Strophe.error("request id "+req.id+"."+req.sends+" error "+reqStatus+" happened");
            this._hitError(reqStatus);
            this._callProtocolErrorHandlers(req);
            if (reqStatus >= 400 && reqStatus < 500) {
                this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);
                this._conn._doDisconnect();
            }
        } else {
            Strophe.error("request id "+req.id+"."+req.sends+" error "+reqStatus+" happened");
        }
        if (!(reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
            this._throttledRequestHandler();
        }
    },

    /** PrivateFunction: _processRequest
     *  _Private_ function to process a request in the queue.
     *
     *  This function takes requests off the queue and sends them and
     *  restarts dead requests.
     *
     *  Parameters:
     *    (Integer) i - The index of the request in the queue.
     */
    _processRequest: function (i) {
        var self = this;
        var req = this._requests[i];
        var reqStatus = this._getRequestStatus(req, -1);

        // make sure we limit the number of retries
        if (req.sends > this._conn.maxRetries) {
            this._conn._onDisconnectTimeout();
            return;
        }

        var time_elapsed = req.age();
        var primaryTimeout = (!isNaN(time_elapsed) &&
                              time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
        var secondaryTimeout = (req.dead !== null &&
                                req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
        var requestCompletedWithServerError = (req.xhr.readyState == 4 &&
                                               (reqStatus < 1 || reqStatus >= 500));
        if (primaryTimeout || secondaryTimeout ||
            requestCompletedWithServerError) {
            if (secondaryTimeout) {
                Strophe.error("Request " + this._requests[i].id +
                              " timed out (secondary), restarting");
            }
            req.abort = true;
            req.xhr.abort();
            // setting to null fails on IE6, so set to empty function
            req.xhr.onreadystatechange = function () {};
            this._requests[i] = new Strophe.Request(req.xmlData,
                                                    req.origFunc,
                                                    req.rid,
                                                    req.sends);
            req = this._requests[i];
        }

        if (req.xhr.readyState === 0) {
            Strophe.debug("request id "+req.id+"."+req.sends+" posting");

            try {
                var contentType = this._conn.options.contentType || "text/xml; charset=utf-8";
                req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true);
                if (typeof req.xhr.setRequestHeader !== 'undefined') {
                    // IE9 doesn't have setRequestHeader
                    req.xhr.setRequestHeader("Content-Type", contentType);
                }
                if (this._conn.options.withCredentials) {
                    req.xhr.withCredentials = true;
                }
            } catch (e2) {
                Strophe.error("XHR open failed.");
                if (!this._conn.connected) {
                    this._conn._changeConnectStatus(
                            Strophe.Status.CONNFAIL, "bad-service");
                }
                this._conn.disconnect();
                return;
            }

            // Fires the XHR request -- may be invoked immediately
            // or on a gradually expanding retry window for reconnects
            var sendFunc = function () {
                req.date = new Date();
                if (self._conn.options.customHeaders){
                    var headers = self._conn.options.customHeaders;
                    for (var header in headers) {
                        if (headers.hasOwnProperty(header)) {
                            req.xhr.setRequestHeader(header, headers[header]);
                        }
                    }
                }
                req.xhr.send(req.data);
            };

            // Implement progressive backoff for reconnects --
            // First retry (send == 1) should also be instantaneous
            if (req.sends > 1) {
                // Using a cube of the retry number creates a nicely
                // expanding retry window
                var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),
                                       Math.pow(req.sends, 3)) * 1000;
                setTimeout(function() {
                    // XXX: setTimeout should be called only with function expressions (23974bc1)
                    sendFunc();
                }, backoff);
            } else {
                sendFunc();
            }

            req.sends++;

            if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
                if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {
                    this._conn.xmlOutput(req.xmlData.childNodes[0]);
                } else {
                    this._conn.xmlOutput(req.xmlData);
                }
            }
            if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {
                this._conn.rawOutput(req.data);
            }
        } else {
            Strophe.debug("_processRequest: " +
                          (i === 0 ? "first" : "second") +
                          " request has readyState of " +
                          req.xhr.readyState);
        }
    },

    /** PrivateFunction: _removeRequest
     *  _Private_ function to remove a request from the queue.
     *
     *  Parameters:
     *    (Strophe.Request) req - The request to remove.
     */
    _removeRequest: function (req) {
        Strophe.debug("removing request");
        var i;
        for (i = this._requests.length - 1; i >= 0; i--) {
            if (req == this._requests[i]) {
                this._requests.splice(i, 1);
            }
        }
        // IE6 fails on setting to null, so set to empty function
        req.xhr.onreadystatechange = function () {};
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _restartRequest
     *  _Private_ function to restart a request that is presumed dead.
     *
     *  Parameters:
     *    (Integer) i - The index of the request in the queue.
     */
    _restartRequest: function (i) {
        var req = this._requests[i];
        if (req.dead === null) {
            req.dead = new Date();
        }

        this._processRequest(i);
    },

    /** PrivateFunction: _reqToData
     * _Private_ function to get a stanza out of a request.
     *
     * Tries to extract a stanza out of a Request Object.
     * When this fails the current connection will be disconnected.
     *
     *  Parameters:
     *    (Object) req - The Request.
     *
     *  Returns:
     *    The stanza that was passed.
     */
    _reqToData: function (req) {
        try {
            return req.getResponse();
        } catch (e) {
            if (e != "parsererror") { throw e; }
            this._conn.disconnect("strophe-parsererror");
        }
    },

    /** PrivateFunction: _sendTerminate
     *  _Private_ function to send initial disconnect sequence.
     *
     *  This is the first step in a graceful disconnect.  It sends
     *  the BOSH server a terminate body and includes an unavailable
     *  presence if authentication has completed.
     */
    _sendTerminate: function (pres) {
        Strophe.info("_sendTerminate was called");
        var body = this._buildBody().attrs({type: "terminate"});
        if (pres) {
            body.cnode(pres.tree());
        }
        var req = new Strophe.Request(
            body.tree(),
            this._onRequestStateChange.bind(
            this, this._conn._dataRecv.bind(this._conn)),
            body.tree().getAttribute("rid")
        );
        this._requests.push(req);
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _send
     *  _Private_ part of the Connection.send function for BOSH
     *
     * Just triggers the RequestHandler to send the messages that are in the queue
     */
    _send: function () {
        clearTimeout(this._conn._idleTimeout);
        this._throttledRequestHandler();

        // XXX: setTimeout should be called only with function expressions (23974bc1)
        this._conn._idleTimeout = setTimeout(function() {
            this._onIdle();
        }.bind(this._conn), 100);
    },

    /** PrivateFunction: _sendRestart
     *
     *  Send an xmpp:restart stanza.
     */
    _sendRestart: function () {
        this._throttledRequestHandler();
        clearTimeout(this._conn._idleTimeout);
    },

    /** PrivateFunction: _throttledRequestHandler
     *  _Private_ function to throttle requests to the connection window.
     *
     *  This function makes sure we don't send requests so fast that the
     *  request ids overflow the connection window in the case that one
     *  request died.
     */
    _throttledRequestHandler: function () {
        if (!this._requests) {
            Strophe.debug("_throttledRequestHandler called with " +
                          "undefined requests");
        } else {
            Strophe.debug("_throttledRequestHandler called with " +
                          this._requests.length + " requests");
        }

        if (!this._requests || this._requests.length === 0) {
            return;
        }

        if (this._requests.length > 0) {
            this._processRequest(0);
        }

        if (this._requests.length > 1 &&
            Math.abs(this._requests[0].rid -
                     this._requests[1].rid) < this.window) {
            this._processRequest(1);
        }
    }
};
return Strophe;
}));

/*
    This program is distributed under the terms of the MIT license.
    Please see the LICENSE file for details.

    Copyright 2006-2008, OGG, LLC
*/

/* jshint undef: true, unused: true:, noarg: true, latedef: true */
/* global define, window, clearTimeout, WebSocket, DOMParser, Strophe, $build */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('strophe-websocket', ['strophe-core'], function (core) {
            return factory(
                core.Strophe,
                core.$build
            );
        });
    } else {
        // Browser globals
        return factory(Strophe, $build);
    }
}(this, function (Strophe, $build) {

/** Class: Strophe.WebSocket
 *  _Private_ helper class that handles WebSocket Connections
 *
 *  The Strophe.WebSocket class is used internally by Strophe.Connection
 *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.
 */

/** File: websocket.js
 *  A JavaScript library to enable XMPP over Websocket in Strophejs.
 *
 *  This file implements XMPP over WebSockets for Strophejs.
 *  If a Connection is established with a Websocket url (ws://...)
 *  Strophe will use WebSockets.
 *  For more information on XMPP-over-WebSocket see RFC 7395:
 *  http://tools.ietf.org/html/rfc7395
 *
 *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)
 */

/** PrivateConstructor: Strophe.Websocket
 *  Create and initialize a Strophe.WebSocket object.
 *  Currently only sets the connection Object.
 *
 *  Parameters:
 *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.
 *
 *  Returns:
 *    A new Strophe.WebSocket object.
 */
Strophe.Websocket = function(connection) {
    this._conn = connection;
    this.strip = "wrapper";

    var service = connection.service;
    if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
        // If the service is not an absolute URL, assume it is a path and put the absolute
        // URL together from options, current URL and the path.
        var new_service = "";

        if (connection.options.protocol === "ws" && window.location.protocol !== "https:") {
            new_service += "ws";
        } else {
            new_service += "wss";
        }

        new_service += "://" + window.location.host;

        if (service.indexOf("/") !== 0) {
            new_service += window.location.pathname + service;
        } else {
            new_service += service;
        }

        connection.service = new_service;
    }
};

Strophe.Websocket.prototype = {
    /** PrivateFunction: _buildStream
     *  _Private_ helper function to generate the <stream> start tag for WebSockets
     *
     *  Returns:
     *    A Strophe.Builder with a <stream> element.
     */
    _buildStream: function () {
        return $build("open", {
            "xmlns": Strophe.NS.FRAMING,
            "to": this._conn.domain,
            "version": '1.0'
        });
    },

    /** PrivateFunction: _check_streamerror
     * _Private_ checks a message for stream:error
     *
     *  Parameters:
     *    (Strophe.Request) bodyWrap - The received stanza.
     *    connectstatus - The ConnectStatus that will be set on error.
     *  Returns:
     *     true if there was a streamerror, false otherwise.
     */
    _check_streamerror: function (bodyWrap, connectstatus) {
        var errors;
        if (bodyWrap.getElementsByTagNameNS) {
            errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "error");
        } else {
            errors = bodyWrap.getElementsByTagName("stream:error");
        }
        if (errors.length === 0) {
            return false;
        }
        var error = errors[0];

        var condition = "";
        var text = "";

        var ns = "urn:ietf:params:xml:ns:xmpp-streams";
        for (var i = 0; i < error.childNodes.length; i++) {
            var e = error.childNodes[i];
            if (e.getAttribute("xmlns") !== ns) {
                break;
            } if (e.nodeName === "text") {
                text = e.textContent;
            } else {
                condition = e.nodeName;
            }
        }

        var errorString = "WebSocket stream error: ";

        if (condition) {
            errorString += condition;
        } else {
            errorString += "unknown";
        }

        if (text) {
            errorString += " - " + condition;
        }

        Strophe.error(errorString);

        // close the connection on stream_error
        this._conn._changeConnectStatus(connectstatus, condition);
        this._conn._doDisconnect();
        return true;
    },

    /** PrivateFunction: _reset
     *  Reset the connection.
     *
     *  This function is called by the reset function of the Strophe Connection.
     *  Is not needed by WebSockets.
     */
    _reset: function () {
        return;
    },

    /** PrivateFunction: _connect
     *  _Private_ function called by Strophe.Connection.connect
     *
     *  Creates a WebSocket for a connection and assigns Callbacks to it.
     *  Does nothing if there already is a WebSocket.
     */
    _connect: function () {
        // Ensure that there is no open WebSocket from a previous Connection.
        this._closeSocket();

        // Create the new WobSocket
        this.socket = new WebSocket(this._conn.service, "xmpp");
        this.socket.onopen = this._onOpen.bind(this);
        this.socket.onerror = this._onError.bind(this);
        this.socket.onclose = this._onClose.bind(this);
        this.socket.onmessage = this._connect_cb_wrapper.bind(this);
    },

    /** PrivateFunction: _connect_cb
     *  _Private_ function called by Strophe.Connection._connect_cb
     *
     * checks for stream:error
     *
     *  Parameters:
     *    (Strophe.Request) bodyWrap - The received stanza.
     */
    _connect_cb: function(bodyWrap) {
        var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);
        if (error) {
            return Strophe.Status.CONNFAIL;
        }
    },

    /** PrivateFunction: _handleStreamStart
     * _Private_ function that checks the opening <open /> tag for errors.
     *
     * Disconnects if there is an error and returns false, true otherwise.
     *
     *  Parameters:
     *    (Node) message - Stanza containing the <open /> tag.
     */
    _handleStreamStart: function(message) {
        var error = false;

        // Check for errors in the <open /> tag
        var ns = message.getAttribute("xmlns");
        if (typeof ns !== "string") {
            error = "Missing xmlns in <open />";
        } else if (ns !== Strophe.NS.FRAMING) {
            error = "Wrong xmlns in <open />: " + ns;
        }

        var ver = message.getAttribute("version");
        if (typeof ver !== "string") {
            error = "Missing version in <open />";
        } else if (ver !== "1.0") {
            error = "Wrong version in <open />: " + ver;
        }

        if (error) {
            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);
            this._conn._doDisconnect();
            return false;
        }

        return true;
    },

    /** PrivateFunction: _connect_cb_wrapper
     * _Private_ function that handles the first connection messages.
     *
     * On receiving an opening stream tag this callback replaces itself with the real
     * message handler. On receiving a stream error the connection is terminated.
     */
    _connect_cb_wrapper: function(message) {
        if (message.data.indexOf("<open ") === 0 || message.data.indexOf("<?xml") === 0) {
            // Strip the XML Declaration, if there is one
            var data = message.data.replace(/^(<\?.*?\?>\s*)*/, "");
            if (data === '') return;

            var streamStart = new DOMParser().parseFromString(data, "text/xml").documentElement;
            this._conn.xmlInput(streamStart);
            this._conn.rawInput(message.data);

            //_handleStreamSteart will check for XML errors and disconnect on error
            if (this._handleStreamStart(streamStart)) {
                //_connect_cb will check for stream:error and disconnect on error
                this._connect_cb(streamStart);
            }
        } else if (message.data.indexOf("<close ") === 0) { //'<close xmlns="urn:ietf:params:xml:ns:xmpp-framing />') {
            this._conn.rawInput(message.data);
            this._conn.xmlInput(message);
            var see_uri = message.getAttribute("see-other-uri");
            if (see_uri) {
                this._conn._changeConnectStatus(Strophe.Status.REDIRECT, "Received see-other-uri, resetting connection");
                this._conn.reset();
                this._conn.service = see_uri;
                this._connect();
            } else {
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Received closing stream");
                this._conn._doDisconnect();
            }
        } else {
            var string = this._streamWrap(message.data);
            var elem = new DOMParser().parseFromString(string, "text/xml").documentElement;
            this.socket.onmessage = this._onMessage.bind(this);
            this._conn._connect_cb(elem, null, message.data);
        }
    },

    /** PrivateFunction: _disconnect
     *  _Private_ function called by Strophe.Connection.disconnect
     *
     *  Disconnects and sends a last stanza if one is given
     *
     *  Parameters:
     *    (Request) pres - This stanza will be sent before disconnecting.
     */
    _disconnect: function (pres) {
        if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
            if (pres) {
                this._conn.send(pres);
            }
            var close = $build("close", { "xmlns": Strophe.NS.FRAMING });
            this._conn.xmlOutput(close);
            var closeString = Strophe.serialize(close);
            this._conn.rawOutput(closeString);
            try {
                this.socket.send(closeString);
            } catch (e) {
                Strophe.info("Couldn't send <close /> tag.");
            }
        }
        this._conn._doDisconnect();
    },

    /** PrivateFunction: _doDisconnect
     *  _Private_ function to disconnect.
     *
     *  Just closes the Socket for WebSockets
     */
    _doDisconnect: function () {
        Strophe.info("WebSockets _doDisconnect was called");
        this._closeSocket();
    },

    /** PrivateFunction _streamWrap
     *  _Private_ helper function to wrap a stanza in a <stream> tag.
     *  This is used so Strophe can process stanzas from WebSockets like BOSH
     */
    _streamWrap: function (stanza) {
        return "<wrapper>" + stanza + '</wrapper>';
    },


    /** PrivateFunction: _closeSocket
     *  _Private_ function to close the WebSocket.
     *
     *  Closes the socket if it is still open and deletes it
     */
    _closeSocket: function () {
        if (this.socket) { try {
            this.socket.close();
        } catch (e) {} }
        this.socket = null;
    },

    /** PrivateFunction: _emptyQueue
     * _Private_ function to check if the message queue is empty.
     *
     *  Returns:
     *    True, because WebSocket messages are send immediately after queueing.
     */
    _emptyQueue: function () {
        return true;
    },

    /** PrivateFunction: _onClose
     * _Private_ function to handle websockets closing.
     *
     * Nothing to do here for WebSockets
     */
    _onClose: function() {
        if(this._conn.connected && !this._conn.disconnecting) {
            Strophe.error("Websocket closed unexpectedly");
            this._conn._doDisconnect();
        } else {
            Strophe.info("Websocket closed");
        }
    },

    /** PrivateFunction: _no_auth_received
     *
     * Called on stream start/restart when no stream:features
     * has been received.
     */
    _no_auth_received: function (_callback) {
        Strophe.error("Server did not send any auth methods");
        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Server did not send any auth methods");
        if (_callback) {
            _callback = _callback.bind(this._conn);
            _callback();
        }
        this._conn._doDisconnect();
    },

    /** PrivateFunction: _onDisconnectTimeout
     *  _Private_ timeout handler for handling non-graceful disconnection.
     *
     *  This does nothing for WebSockets
     */
    _onDisconnectTimeout: function () {},

    /** PrivateFunction: _abortAllRequests
     *  _Private_ helper function that makes sure all pending requests are aborted.
     */
    _abortAllRequests: function () {},

    /** PrivateFunction: _onError
     * _Private_ function to handle websockets errors.
     *
     * Parameters:
     * (Object) error - The websocket error.
     */
    _onError: function(error) {
        Strophe.error("Websocket error " + error);
        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected.");
        this._disconnect();
    },

    /** PrivateFunction: _onIdle
     *  _Private_ function called by Strophe.Connection._onIdle
     *
     *  sends all queued stanzas
     */
    _onIdle: function () {
        var data = this._conn._data;
        if (data.length > 0 && !this._conn.paused) {
            for (var i = 0; i < data.length; i++) {
                if (data[i] !== null) {
                    var stanza, rawStanza;
                    if (data[i] === "restart") {
                        stanza = this._buildStream().tree();
                    } else {
                        stanza = data[i];
                    }
                    rawStanza = Strophe.serialize(stanza);
                    this._conn.xmlOutput(stanza);
                    this._conn.rawOutput(rawStanza);
                    this.socket.send(rawStanza);
                }
            }
            this._conn._data = [];
        }
    },

    /** PrivateFunction: _onMessage
     * _Private_ function to handle websockets messages.
     *
     * This function parses each of the messages as if they are full documents.
     * [TODO : We may actually want to use a SAX Push parser].
     *
     * Since all XMPP traffic starts with
     *  <stream:stream version='1.0'
     *                 xml:lang='en'
     *                 xmlns='jabber:client'
     *                 xmlns:stream='http://etherx.jabber.org/streams'
     *                 id='3697395463'
     *                 from='SERVER'>
     *
     * The first stanza will always fail to be parsed.
     *
     * Additionally, the seconds stanza will always be <stream:features> with
     * the stream NS defined in the previous stanza, so we need to 'force'
     * the inclusion of the NS in this stanza.
     *
     * Parameters:
     * (string) message - The websocket message.
     */
    _onMessage: function(message) {
        var elem, data;
        // check for closing stream
        var close = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
        if (message.data === close) {
            this._conn.rawInput(close);
            this._conn.xmlInput(message);
            if (!this._conn.disconnecting) {
                this._conn._doDisconnect();
            }
            return;
        } else if (message.data.search("<open ") === 0) {
            // This handles stream restarts
            elem = new DOMParser().parseFromString(message.data, "text/xml").documentElement;
            if (!this._handleStreamStart(elem)) {
                return;
            }
        } else {
            data = this._streamWrap(message.data);
            elem = new DOMParser().parseFromString(data, "text/xml").documentElement;
        }

        if (this._check_streamerror(elem, Strophe.Status.ERROR)) {
            return;
        }

        //handle unavailable presence stanza before disconnecting
        if (this._conn.disconnecting &&
                elem.firstChild.nodeName === "presence" &&
                elem.firstChild.getAttribute("type") === "unavailable") {
            this._conn.xmlInput(elem);
            this._conn.rawInput(Strophe.serialize(elem));
            // if we are already disconnecting we will ignore the unavailable stanza and
            // wait for the </stream:stream> tag before we close the connection
            return;
        }
        this._conn._dataRecv(elem, message.data);
    },

    /** PrivateFunction: _onOpen
     * _Private_ function to handle websockets connection setup.
     *
     * The opening stream tag is sent here.
     */
    _onOpen: function() {
        Strophe.info("Websocket open");
        var start = this._buildStream();
        this._conn.xmlOutput(start.tree());

        var startString = Strophe.serialize(start);
        this._conn.rawOutput(startString);
        this.socket.send(startString);
    },

    /** PrivateFunction: _reqToData
     * _Private_ function to get a stanza out of a request.
     *
     * WebSockets don't use requests, so the passed argument is just returned.
     *
     *  Parameters:
     *    (Object) stanza - The stanza.
     *
     *  Returns:
     *    The stanza that was passed.
     */
    _reqToData: function (stanza) {
        return stanza;
    },

    /** PrivateFunction: _send
     *  _Private_ part of the Connection.send function for WebSocket
     *
     * Just flushes the messages that are in the queue
     */
    _send: function () {
        this._conn.flush();
    },

    /** PrivateFunction: _sendRestart
     *
     *  Send an xmpp:restart stanza.
     */
    _sendRestart: function () {
        clearTimeout(this._conn._idleTimeout);
        this._conn._onIdle.bind(this._conn)();
    }
};
return Strophe;
}));

(function(root){
    if(typeof define === 'function' && define.amd){
        define("strophe", [
            "strophe-core",
            "strophe-bosh",
            "strophe-websocket"
        ], function (wrapper) {
            return wrapper;
        });
    }
})(this);

/* jshint ignore:start */
if (callback) {
    if(typeof define === 'function' && define.amd){
        //For backwards compatability
        var n_callback = callback;
        if (typeof requirejs === 'function') {
            requirejs(["strophe"], function(o){
                n_callback(o.Strophe,o.$build,o.$msg,o.$iq,o.$pres);
            });
        } else {
            __browserify_shim_require__(["strophe"], function(o){
                n_callback(o.Strophe,o.$build,o.$msg,o.$iq,o.$pres);
            });
        }
    }else{
        return callback(Strophe, $build, $msg, $iq, $pres);
    }
}


})(function (Strophe, build, msg, iq, pres) {
    window.Strophe = Strophe;
    window.$build = build;
    window.$msg = msg;
    window.$iq = iq;
    window.$pres = pres;
});
/* jshint ignore:end */

; browserify_shim__define__module__export__(typeof Strophe != "undefined" ? Strophe : window.Strophe);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"nitro":[function(require,module,exports){
var Connection, Utils, _, getStropheAPI;

_ = require('underscore');

Connection = require('connection');

Utils = require('util/utils');

module.exports = window.Nitro = {
  ROSTER: require('components/roster').NAME,
  MESSAGING: require('components/messaging').NAME,
  STORAGE: require('components/storage').NAME,
  BLOCKLIST: require('components/blocklist').NAME,
  MUC: require('components/muc').NAME,
  YAHOO: require('enum/gateways').YAHOO,
  Status: require('enum/status'),
  PresenceShow: require('enum/presence_show'),
  XMPPPresence: require('enum/xmpp_presence'),
  PresenceType: require('enum/presence_type'),
  MessageType: require('enum/message_type'),
  MUCNode: require('enum/muc_node'),
  MUCRole: require('enum/muc_role'),
  MUCError: require('enum/muc_error'),
  MUCErrorType: require('enum/muc_error_type'),
  SubscriptionStatus: require('enum/subscription_status'),
  ComplianceError: require('enum/compliance_error'),
  YahooError: require('enum/yahoo_error'),
  Events: require('events/events'),
  IOEvent: require('events/io_event'),
  getConnection: Connection.get,
  getComponent: function() {
    var connection, error, error1;
    try {
      connection = Connection.get();
      return connection.getComponent.apply(connection, arguments);
    } catch (error1) {
      error = error1;
      return null;
    }
  }
};

Object.defineProperty(Nitro, 'connection', {
  get: function() {
    return Utils.tryCatch(function() {
      return Connection.get();
    })();
  }
});

Object.defineProperty(Nitro, 'eventManager', {
  get: function() {
    return Utils.tryCatch(function() {
      var ref;
      return (ref = Connection.get()) != null ? ref.eventManager : void 0;
    })();
  }
});

Object.defineProperty(Nitro, 'utils', {
  get: _.once(function() {
    var Matchers, XMPPUtils, retryer, stropheAPI;
    XMPPUtils = require('util/xmpp_utils');
    Matchers = require('util/matchers');
    retryer = require('util/retryer');
    stropheAPI = getStropheAPI(Strophe);
    return _.extend({}, Utils, XMPPUtils, Matchers, retryer, stropheAPI);
  })
});

getStropheAPI = function(strophe) {
  return {
    getBareJID: strophe.getBareJidFromJid,
    getResource: strophe.getResourceFromJid,
    serialize: strophe.serialize
  };
};


},{"components/blocklist":"components/blocklist","components/messaging":"components/messaging","components/muc":"components/muc","components/roster":"components/roster","components/storage":"components/storage","connection":"connection","enum/compliance_error":"enum/compliance_error","enum/gateways":"enum/gateways","enum/message_type":"enum/message_type","enum/muc_error":"enum/muc_error","enum/muc_error_type":"enum/muc_error_type","enum/muc_node":"enum/muc_node","enum/muc_role":"enum/muc_role","enum/presence_show":"enum/presence_show","enum/presence_type":"enum/presence_type","enum/status":"enum/status","enum/subscription_status":"enum/subscription_status","enum/xmpp_presence":"enum/xmpp_presence","enum/yahoo_error":"enum/yahoo_error","events/events":"events/events","events/io_event":"events/io_event","underscore":85,"util/matchers":"util/matchers","util/retryer":"util/retryer","util/utils":"util/utils","util/xmpp_utils":"util/xmpp_utils"}],"spec/adapters/adapters_spec":[function(require,module,exports){
var adapters, assert, expect, ref, sinon;

ref = require('spec/spec_helper'), sinon = ref.sinon, expect = ref.expect, assert = ref.assert;

adapters = require('adapters/adapters');

describe('Adapters', function() {
  describe('xmlToJSON', function() {
    return it('should convert XML to JSON', function() {
      return assert(true);
    });
  });
  return describe('jsonAttrs', function() {
    var expected, object;
    object = null;
    expected = null;
    afterEach(function() {
      object = null;
      return expected = null;
    });
    it('should group attributes under `attributes` object', function() {
      var newObj;
      object = {
        _attr1: 'attr1Val',
        _attr2: 'attr2Val'
      };
      newObj = adapters.jsonAttrs(object);
      newObj.should.have.a.property('attributes').that.eqls({
        attr1: 'attr1Val',
        attr2: 'attr2Val'
      });
      newObj.should.not.have.a.property('_attr1');
      return newObj.should.not.have.a.property('_attr2');
    });
    it('should process an object that is an array', function() {
      var newObj;
      object = ["element1", "element2"];
      newObj = adapters.jsonAttrs(object);
      return newObj.should.eql(["element1", "element2"]);
    });
    it('should process an object with an array', function() {
      var newObj;
      object = {
        prop1: ["one", "two"]
      };
      newObj = adapters.jsonAttrs(object);
      return newObj.should.eql({
        prop1: ["one", "two"]
      });
    });
    it('should process an object with an array of objects', function() {
      var newObj;
      object = {
        prop1: [
          {
            el1Prop1: "el1Prop1",
            el1Prop2: "el1Prop2"
          }, {
            el2Prop1: "el2Prop1",
            el2Prop2: "el2Prop2"
          }
        ]
      };
      newObj = adapters.jsonAttrs(object);
      expected = {
        prop1: [
          {
            el1Prop1: "el1Prop1",
            el1Prop2: "el1Prop2"
          }, {
            el2Prop1: "el2Prop1",
            el2Prop2: "el2Prop2"
          }
        ]
      };
      return newObj.should.eql(expected);
    });
    it('should recurse to group attributes for each object property', function() {
      var newObj;
      object = {
        prop1: 'prop1Val',
        prop2: {
          prop2_prop1: 'prop2_prop1Val',
          prop2_prop2: 'prop2_prop2Val',
          _prop2_attr1: 'prop2_attr1Val',
          _prop2_attr2: 'prop2_attr2Val'
        },
        _attr1: 'attr1Val',
        _attr2: 'attr2Val'
      };
      newObj = adapters.jsonAttrs(object);
      expected = {
        attributes: {
          attr1: 'attr1Val',
          attr2: 'attr2Val'
        },
        prop1: 'prop1Val',
        prop2: {
          attributes: {
            prop2_attr1: 'prop2_attr1Val',
            prop2_attr2: 'prop2_attr2Val'
          },
          prop2_prop1: 'prop2_prop1Val',
          prop2_prop2: 'prop2_prop2Val'
        }
      };
      return newObj.should.eql(expected);
    });
    it('should handle an object with an array of objects containing attributes', function() {
      var newObj;
      object = {
        prop1: [
          {
            element1: 'element1Val',
            element2: {
              _el1Attr1: 'el1Attr1',
              _el1Attr2: 'el1Attr2'
            }
          }
        ]
      };
      newObj = adapters.jsonAttrs(object);
      expected = {
        prop1: [
          {
            element1: 'element1Val',
            element2: {
              attributes: {
                el1Attr1: 'el1Attr1',
                el1Attr2: 'el1Attr2'
              }
            }
          }
        ]
      };
      return newObj.should.eql(expected);
    });
    it('should handle arrays of objects', function() {
      var newObj;
      object = [
        {
          element1: {
            e1Prop1: 'e1Prop1Val',
            e1Prop2: 'e1Prop2Val',
            _e1Attr1: 'e1Attr1Val',
            _e1Attr2: 'e1Attr2Val'
          }
        }
      ];
      newObj = adapters.jsonAttrs(object);
      expected = [
        {
          element1: {
            e1Prop1: 'e1Prop1Val',
            e1Prop2: 'e1Prop2Val',
            attributes: {
              e1Attr1: 'e1Attr1Val',
              e1Attr2: 'e1Attr2Val'
            }
          }
        }
      ];
      return newObj.should.eql(expected);
    });
    it('should handle arrays of objects with attributes', function() {
      var newObj;
      object = [
        {
          element1: {
            e1Prop1: 'e1Prop1Val',
            e1Prop2: 'e1Prop2Val',
            _e1Attr1: 'e1Attr1Val',
            _e1Attr2: 'e1Attr2Val'
          },
          element2: {
            e2Prop1: 'e2Prop1Val',
            e2Prop2: 'e2Prop2Val',
            _e2Attr1: 'e2Attr1Val',
            _e2Attr2: 'e2Attr2Val'
          }
        }
      ];
      newObj = adapters.jsonAttrs(object);
      expected = [
        {
          element1: {
            e1Prop1: 'e1Prop1Val',
            e1Prop2: 'e1Prop2Val',
            attributes: {
              e1Attr1: 'e1Attr1Val',
              e1Attr2: 'e1Attr2Val'
            }
          },
          element2: {
            e2Prop1: 'e2Prop1Val',
            e2Prop2: 'e2Prop2Val',
            attributes: {
              e2Attr1: 'e2Attr1Val',
              e2Attr2: 'e2Attr2Val'
            }
          }
        }
      ];
      return newObj.should.eql(expected);
    });
    it('should handle a mix of object with arrays and without', function() {
      var newObj;
      object = {
        prop1: 'prop1Val',
        prop2: 'prop2Val',
        items: [
          "element1", "element2", {
            elementObj1: {
              elObjProp1: 'elObjProp1Val',
              elObjProp2: 'elObjProp2Val',
              _elObjAttr1: 'elObjAttr1Val',
              _elObjAttr2: 'elObjAttr2Val'
            }
          }
        ],
        _attr1: 'attr1Val',
        _attr2: 'attr2Val'
      };
      newObj = adapters.jsonAttrs(object);
      expected = {
        prop1: 'prop1Val',
        prop2: 'prop2Val',
        items: [
          "element1", "element2", {
            elementObj1: {
              elObjProp1: 'elObjProp1Val',
              elObjProp2: 'elObjProp2Val',
              attributes: {
                elObjAttr1: 'elObjAttr1Val',
                elObjAttr2: 'elObjAttr2Val'
              }
            }
          }
        ],
        attributes: {
          attr1: 'attr1Val',
          attr2: 'attr2Val'
        }
      };
      return newObj.should.eql(expected);
    });
    it('should allow a custom `attribute` object name', function() {
      var newObj;
      object = {
        _attr1: 'attr1Val',
        _attr2: 'attr2Val'
      };
      newObj = adapters.jsonAttrs(object, {
        attrObjectName: "myAttributes"
      });
      expected = {
        myAttributes: {
          attr1: 'attr1Val',
          attr2: 'attr2Val'
        }
      };
      return newObj.should.eql(expected);
    });
    it('should allow a custom regexp to identify potential attributes', function() {
      var newObj;
      object = {
        _attribute_attr1: 'attr1Val',
        _attribute_attr2: 'attr2Val'
      };
      newObj = adapters.jsonAttrs(object, {
        regexp: /^_attribute_/
      });
      expected = {
        attributes: {
          attribute_attr1: 'attr1Val',
          attribute_attr2: 'attr2Val'
        }
      };
      return newObj.should.eql(expected);
    });
    it('should allow a custom function to transform attribute property names', function() {
      var newObj;
      object = {
        _attr1: 'attr1Val',
        _attr2: 'attr2Val'
      };
      newObj = adapters.jsonAttrs(object, {
        nameTransform: function(name) {
          return "attr" + name;
        }
      });
      expected = {
        attributes: {
          attr_attr1: 'attr1Val',
          attr_attr2: 'attr2Val'
        }
      };
      return newObj.should.eql(expected);
    });
    it('should convert a \'__text\' property to a text property', function() {
      var newObj;
      object = {
        _attr1: 'attr1Val',
        _attr2: 'attr2Val',
        __text: 'some text value'
      };
      newObj = adapters.jsonAttrs(object);
      expected = {
        attributes: {
          attr1: 'attr1Val',
          attr2: 'attr2Val'
        },
        text: 'some text value'
      };
      return newObj.should.eql(expected);
    });
    return it('should convert nested \'__text\' properties to text properties', function() {
      var newObj;
      object = {
        _attr1: 'attr1Val',
        _attr2: 'attr2Val',
        __text: 'some text value',
        child: {
          _child_attr1: 'childAttr1Val',
          _child_attr2: 'childAttr2Val',
          __text: 'some child text value'
        }
      };
      newObj = adapters.jsonAttrs(object);
      expected = {
        attributes: {
          attr1: 'attr1Val',
          attr2: 'attr2Val'
        },
        text: 'some text value',
        child: {
          attributes: {
            child_attr1: 'childAttr1Val',
            child_attr2: 'childAttr2Val'
          },
          text: 'some child text value'
        }
      };
      return newObj.should.eql(expected);
    });
  });
});


},{"adapters/adapters":"adapters/adapters","spec/spec_helper":"spec/spec_helper"}],"spec/closure_spec":[function(require,module,exports){
var assert, ref, sinon;

ref = require('spec/spec_helper'), sinon = ref.sinon, assert = ref.assert;

describe('closures', function() {
  return describe('private variables', function() {
    describe('declared in a function outside of a closure', function() {
      var func;
      func = null;
      beforeEach(function() {
        return func = function() {
          var variable;
          variable = 0;
          return function() {
            return variable += 1;
          };
        };
      });
      afterEach(function() {
        return func = null;
      });
      it('should return 1 when created once', function() {
        var f;
        f = func();
        return f().should.equal(1);
      });
      return it('should maintain separate function environments when created twice', function() {
        var f1, f2;
        f1 = func();
        f1().should.equal(1);
        f1().should.equal(2);
        f1().should.equal(3);
        f2 = func();
        return f2().should.equal(1);
      });
    });
    return describe('defined by args passed into a function outside of a closure', function() {
      var func;
      func = null;
      beforeEach(function() {
        return func = function(arg) {
          return function() {
            return arg += 1;
          };
        };
      });
      afterEach(function() {
        return func = null;
      });
      it('should return 1 when created once', function() {
        var f;
        f = func(1);
        return f().should.equal(2);
      });
      return it('should maintain separate function environments when created twice', function() {
        var f1, f2;
        f1 = func(1);
        f1().should.equal(2);
        f1().should.equal(3);
        f1().should.equal(4);
        f2 = func(1);
        return f2().should.equal(2);
      });
    });
  });
});


},{"spec/spec_helper":"spec/spec_helper"}],"spec/components/blocklist_spec":[function(require,module,exports){
var Blocklist, Strophe, X2JS, assert, fixtures, ref, sinon, trimFixture;

ref = require('spec/spec_helper'), sinon = ref.sinon, assert = ref.assert, X2JS = ref.X2JS, fixtures = ref.fixtures, trimFixture = ref.trimFixture;

Strophe = require('strophe');

Blocklist = require('components/blocklist');

describe('Blocklist', function() {
  var blocklist, sendIQ, stropheHelper;
  blocklist = null;
  sendIQ = null;
  stropheHelper = {
    getBlocklistStanza: sinon.stub().returns(new Strophe.Builder()),
    getBlockStanza: sinon.stub().returns(new Strophe.Builder()),
    getUnblockStanza: sinon.stub().returns(new Strophe.Builder())
  };
  afterEach(function() {
    var helper;
    stropheHelper.getBlocklistStanza.reset();
    stropheHelper.getBlockStanza.reset();
    stropheHelper.getUnblockStanza.reset();
    Blocklist.destroy();
    blocklist = null;
    sendIQ = null;
    return helper = null;
  });
  describe('#getBlocklist()', function() {
    var reject, resolve;
    resolve = null;
    reject = null;
    beforeEach(function() {
      sendIQ = sinon.spy(function(options) {
        if (options == null) {
          options = {};
        }
        return resolve = options.resolve, reject = options.reject, options;
      });
      return blocklist = Blocklist.get({
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    afterEach(function() {
      sendIQ.reset();
      resolve = null;
      return reject = null;
    });
    it('should retrieve a blocklist by calling #sendIQ() with a stanza', function() {
      blocklist.getBlocklist();
      stropheHelper.getBlocklistStanza.should.have.been.calledOnce;
      return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
        element: sinon.match.instanceOf(Strophe.Builder),
        resolve: sinon.match.func,
        reject: sinon.match.func
      }));
    });
    return describe('when failure', function() {
      var errorMsg;
      errorMsg = null;
      beforeEach(function() {
        sinon.stub(console, 'error');
        return errorMsg = "You are not connected to Nitro!";
      });
      afterEach(function() {
        errorMsg = null;
        return console.error.restore();
      });
      it('should log an error to the console', function(done) {
        var promise;
        promise = blocklist.getBlocklist();
        promise.should.eventually.be.rejected.notify(done);
        promise.should.eventually.be.rejectedWith(errorMsg);
        return reject(errorMsg);
      });
      return it('should not affect the previously stored list of blocked contact JIDs', function(done) {
        blocklist._blockedJIDs = ['previousJID1', 'previousJID2'];
        blocklist.getBlocklist().should.eventually.be.rejected.then(function() {
          blocklist._blockedJIDs.should.eql(['previousJID1', 'previousJID2']);
          return done();
        });
        return reject(errorMsg);
      });
    });
  });
  describe('#block()', function() {
    beforeEach(function() {
      sendIQ = sinon.stub();
      return blocklist = Blocklist.get({
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    afterEach(function() {
      return sendIQ.reset();
    });
    it('should accept a single plain jid', function() {
      var jid;
      jid = 'jid1';
      blocklist.block(jid);
      stropheHelper.getBlockStanza.should.have.been.calledOnce;
      return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
        element: sinon.match.instanceOf(Strophe.Builder),
        resolve: sinon.match.func,
        reject: sinon.match.func
      }));
    });
    return it('should block users by calling #sendIQ() with a stanza', function() {
      var jids;
      jids = ['jid1', 'jid2'];
      blocklist.block(jids);
      stropheHelper.getBlockStanza.should.have.been.calledOnce;
      return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
        element: sinon.match.instanceOf(Strophe.Builder),
        resolve: sinon.match.func,
        reject: sinon.match.func
      }));
    });
  });
  return describe('#unblock()', function() {
    beforeEach(function() {
      sendIQ = sinon.stub();
      return blocklist = Blocklist.get({
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    afterEach(function() {
      return sendIQ.reset();
    });
    it('should accept a single plain jid', function() {
      var jid;
      jid = 'jid1';
      blocklist.unblock(jid);
      stropheHelper.getUnblockStanza.should.have.been.calledOnce;
      return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
        element: sinon.match.instanceOf(Strophe.Builder),
        resolve: sinon.match.func,
        reject: sinon.match.func
      }));
    });
    return it('should unblock users by calling #sendIQ() with a stanza', function() {
      var jids;
      jids = ['jid1', 'jid2'];
      blocklist.unblock(jids);
      stropheHelper.getUnblockStanza.should.have.been.calledOnce;
      return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
        element: sinon.match.instanceOf(Strophe.Builder),
        resolve: sinon.match.func,
        reject: sinon.match.func
      }));
    });
  });
});


},{"components/blocklist":"components/blocklist","spec/spec_helper":"spec/spec_helper","strophe":"lib/strophe"}],"spec/components/gateway_spec":[function(require,module,exports){
var Gateway, Strophe, _, assert, expect, ref, sinon;

ref = require('spec/spec_helper'), _ = ref._, sinon = ref.sinon, assert = ref.assert, expect = ref.expect;

Strophe = require('strophe');

Gateway = require('components/gateway');

describe('Gateway', function() {
  var gateway, getPassword, getUsername, send, sendIQ, stropheHelper;
  gateway = null;
  send = null;
  sendIQ = null;
  stropheHelper = null;
  getUsername = function(name) {
    if (name == null) {
      name = 'a';
    }
    return "user." + name + ".thomsonreuters.com@reuters.net";
  };
  getPassword = function() {
    return (new Date().getTime()).toString();
  };
  before(function() {
    return stropheHelper = {
      getRegisterStanza: sinon.stub().returns($iq()),
      getUnregisterStanza: sinon.stub().returns($iq()),
      getSubscriptionStanza: sinon.stub().returns($pres()),
      getPresenceStanza: sinon.stub().returns($pres()),
      getRosterStanza: sinon.stub().returns($iq())
    };
  });
  afterEach(function() {
    stropheHelper.getRegisterStanza.reset();
    stropheHelper.getUnregisterStanza.reset();
    stropheHelper.getSubscriptionStanza.reset();
    stropheHelper.getPresenceStanza.reset();
    return stropheHelper.getRosterStanza.reset();
  });
  describe('#register()', function() {
    var registerOptions;
    registerOptions = null;
    beforeEach(function() {
      sendIQ = sinon.stub();
      gateway = new Gateway({
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
      gateway.nitroConnected = true;
      gateway.jid = getUsername('self');
      return registerOptions = {
        username: getUsername('self-yahoo'),
        password: getPassword()
      };
    });
    it('should return a Q promise', function() {
      return gateway.register(registerOptions).__proto__.toString().should.equal("[object Promise]");
    });
    it('should call sendIQ with proper args', function() {
      gateway.register(registerOptions);
      return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
        element: Strophe.Builder.prototype,
        resolve: sinon.match.func,
        reject: sinon.match.func
      }));
    });
    it('should should return null when username is unspecified', function() {
      var promise;
      promise = gateway.register({
        password: getPassword()
      });
      return promise === null;
    });
    return it('should should return null when password is unspecified', function() {
      var promise;
      promise = gateway.register({
        username: getUsername()
      });
      return promise === null;
    });
  });
  describe('#unregister()', function() {
    beforeEach(function() {
      sendIQ = sinon.stub();
      return gateway = new Gateway({
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    it('should return a Q promise', function() {
      return gateway.unregister().__proto__.toString().should.equal("[object Promise]");
    });
    return it('should call sendIQ with proper args', function() {
      gateway.unregister();
      return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
        element: Strophe.Builder.prototype,
        resolve: sinon.match.func,
        reject: sinon.match.func
      }));
    });
  });
  return describe('#setPresence()', function() {});
});


},{"components/gateway":"components/gateway","spec/spec_helper":"spec/spec_helper","strophe":"lib/strophe"}],"spec/components/messaging_spec":[function(require,module,exports){
var Messaging, Strophe, assert, ref, sinon;

ref = require('spec/spec_helper'), sinon = ref.sinon, assert = ref.assert;

Strophe = require('strophe');

Messaging = require('components/messaging');

describe('Messaging', function() {
  var messages;
  messages = null;
  afterEach(function() {
    return messages = null;
  });
  return it('true', function() {
    return assert(true);
  });
});


},{"components/messaging":"components/messaging","spec/spec_helper":"spec/spec_helper","strophe":"lib/strophe"}],"spec/components/muc_spec":[function(require,module,exports){
var MUC, Q, Strophe, assert, ref, sinon;

ref = require('spec/spec_helper'), sinon = ref.sinon, assert = ref.assert;

Strophe = require('strophe');

MUC = require('components/muc');

Q = require('Q');

describe('MUC', function() {
  var eventManager, getJID, muc, send, sendIQ, stropheHelper;
  muc = null;
  stropheHelper = null;
  before(function() {
    return stropheHelper = {
      getJoinStanza: sinon.stub().returns($pres()),
      getLeaveStanza: sinon.stub().returns($pres()),
      getDestroyGroupchatStanza: sinon.stub().returns($iq()),
      getGroupchatConfigForm: sinon.stub(),
      addGroupchatConfigField: sinon.stub(),
      getRoomDiscoStanza: sinon.stub().returns($iq()),
      getMemberListStanza: sinon.stub().returns($iq()),
      getMediatedInviteStanza: sinon.stub().returns($msg())
    };
  });
  afterEach(function() {
    stropheHelper.getJoinStanza.reset();
    stropheHelper.getLeaveStanza.reset();
    stropheHelper.getDestroyGroupchatStanza.reset();
    stropheHelper.getGroupchatConfigForm.reset();
    stropheHelper.addGroupchatConfigField.reset();
    stropheHelper.getRoomDiscoStanza.reset();
    stropheHelper.getMemberListStanza.reset();
    stropheHelper.getMediatedInviteStanza.reset();
    MUC.destroy();
    return muc = null;
  });
  getJID = sinon.spy(function() {
    return 'my.jid.thomsonreuters.com@reuters.net';
  });
  send = sinon.stub();
  sendIQ = sinon.spy(function(options) {
    console.log('resolving', options);
    return options.resolve(true);
  });
  eventManager = {
    listen: sinon.spy(function(path) {
      return path;
    }),
    stopListening: sinon.stub()
  };
  describe('#create()', function() {
    var invalidJID, name, validJID;
    validJID = 'foo.bar@conference.reuters.net';
    invalidJID = 'invalid';
    name = 'FooBar Chatroom';
    beforeEach(function() {
      var promise;
      muc = MUC.get({
        getJID: getJID,
        eventManager: eventManager,
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
      promise = Q();
      sinon.stub(muc, 'join').returns(promise);
      return sinon.stub(muc, 'acceptDefaultConfiguration').returns(promise);
    });
    afterEach(function() {
      sendIQ.reset();
      send.reset();
      eventManager.listen.reset();
      eventManager.stopListening.reset();
      muc.join.restore();
      return muc.acceptDefaultConfiguration.restore();
    });
    it('should return a Q promise', function() {
      return muc.create().__proto__.toString().should.equal("[object Promise]");
    });
    it('should reject returned promise when given an invalid JID', function(done) {
      var promise;
      promise = muc.create({
        jid: invalidJID
      });
      promise.should.eventually.be.rejected.notify(done);
      return promise.should.eventually.be.rejectedWith("invalid groupchat jid " + invalidJID);
    });
    it('should call #join() with jid to create', function(done) {
      return muc.create({
        jid: validJID,
        name: name
      }).should.eventually.be.fulfilled.then(function() {
        return muc.join.should.have.been.calledOnce.calledWith(validJID);
      }).should.notify(done);
    });
    return it('should call #acceptDefaultConfiguration() with proper args', function(done) {
      return muc.create({
        jid: validJID,
        name: name
      }).should.eventually.be.fulfilled.then(function() {
        return muc.acceptDefaultConfiguration.should.have.been.calledOnce;
      }).should.notify(done);
    });
  });
  describe('#join()', function() {
    var invalidJID, validJID;
    validJID = 'foo.bar@conference.reuters.net';
    invalidJID = 'invalid';
    beforeEach(function() {
      return muc = MUC.get({
        getJID: getJID,
        eventManager: eventManager,
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    afterEach(function() {
      sendIQ.reset();
      send.reset();
      eventManager.listen.reset();
      return eventManager.stopListening.reset();
    });
    it('should return a Q promise', function() {
      return muc.join().__proto__.toString().should.equal("[object Promise]");
    });
    return it('should reject returned promise when given an invalid JID', function(done) {
      var promise;
      promise = muc.join(invalidJID);
      promise.should.eventually.be.rejected.notify(done);
      return promise.should.eventually.be.rejectedWith("invalid groupchat jid " + invalidJID);
    });
  });
  describe('#leave()', function() {
    var invalidJID, validJID;
    validJID = 'foo.bar@conference.reuters.net';
    invalidJID = 'invalid';
    beforeEach(function() {
      return muc = MUC.get({
        getJID: getJID,
        eventManager: eventManager,
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    afterEach(function() {
      sendIQ.reset();
      send.reset();
      eventManager.listen.reset();
      return eventManager.stopListening.reset();
    });
    it('should return a Q promise', function() {
      return muc.leave().__proto__.toString().should.equal("[object Promise]");
    });
    return it('should reject returned promise when given an invalid JID', function(done) {
      var promise;
      promise = muc.leave(invalidJID);
      promise.should.eventually.be.rejected.notify(done);
      return promise.should.eventually.be.rejectedWith("invalid groupchat jid " + invalidJID);
    });
  });
  describe('#destroy()', function() {
    var invalidJID, validJID;
    validJID = 'foo.bar@conference.reuters.net';
    invalidJID = 'invalid';
    beforeEach(function() {
      return muc = MUC.get({
        getJID: getJID,
        eventManager: eventManager,
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    afterEach(function() {
      sendIQ.reset();
      send.reset();
      eventManager.listen.reset();
      return eventManager.stopListening.reset();
    });
    it('should return a Q promise', function() {
      return muc.destroy().__proto__.toString().should.equal("[object Promise]");
    });
    return it('should reject returned promise when given an invalid JID', function(done) {
      var promise;
      promise = muc.destroy(invalidJID);
      promise.should.eventually.be.rejected.notify(done);
      return promise.should.eventually.be.rejectedWith("invalid groupchat jid " + invalidJID);
    });
  });
  return describe('#acceptDefaultConfiguration()', function() {
    var invalidJID, validJID;
    validJID = 'foo.bar@conference.reuters.net';
    invalidJID = 'invalid';
    beforeEach(function() {
      return muc = MUC.get({
        getJID: getJID,
        eventManager: eventManager,
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    afterEach(function() {
      sendIQ.reset();
      send.reset();
      eventManager.listen.reset();
      return eventManager.stopListening.reset();
    });
    it('should return a Q promise', function() {
      return muc.acceptDefaultConfiguration({
        jid: validJID,
        name: name
      }).__proto__.toString().should.equal("[object Promise]");
    });
    return it('should reject returned promise when given an invalid JID', function(done) {
      var promise;
      promise = muc.acceptDefaultConfiguration({
        jid: invalidJID,
        name: name
      });
      promise.should.eventually.be.rejected.notify(done);
      return promise.should.eventually.be.rejectedWith("invalid groupchat jid " + invalidJID);
    });
  });
});


},{"Q":1,"components/muc":"components/muc","spec/spec_helper":"spec/spec_helper","strophe":"lib/strophe"}],"spec/components/roster_spec":[function(require,module,exports){
var PresenceType, Q, Roster, Strophe, _, assert, expect, ref, sinon;

ref = require('spec/spec_helper'), _ = ref._, sinon = ref.sinon, assert = ref.assert, expect = ref.expect, Q = ref.Q;

Strophe = require('strophe');

Roster = require('components/roster');

PresenceType = require('enum/presence_type');

describe('Roster', function() {
  var getUser, roster, send, sendIQ, stropheHelper;
  roster = null;
  send = null;
  sendIQ = null;
  getUser = function(name) {
    return {
      jid: "user." + name + ".thomsonreuters.com@reuters.net",
      name: name
    };
  };
  stropheHelper = null;
  before(function() {
    return stropheHelper = {
      getRosterStanza: sinon.stub().returns($iq()),
      getAddStanza: sinon.stub().returns($iq()),
      getRemoveStanza: sinon.stub().returns($iq()),
      getPresenceSubscriptionStanza: sinon.stub().returns($pres())
    };
  });
  afterEach(function() {
    stropheHelper.getRosterStanza.reset();
    stropheHelper.getAddStanza.reset();
    stropheHelper.getRemoveStanza.reset();
    stropheHelper.getPresenceSubscriptionStanza.reset();
    Roster.destroy();
    return roster = null;
  });
  describe('#getRoster()', function() {
    beforeEach(function() {
      sendIQ = sinon.stub();
      return roster = Roster.get({
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    afterEach(function() {
      return sendIQ.reset();
    });
    it('should return a Q promise', function() {
      return roster.getRoster().__proto__.toString().should.equal("[object Promise]");
    });
    return it('should call sendIQ with proper args', function() {
      roster.getRoster();
      return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
        element: Strophe.Builder.prototype,
        resolve: sinon.match.func,
        reject: sinon.match.func
      }));
    });
  });
  describe('#addContact()', function() {
    var reject, resolve, user1, user2;
    user1 = null;
    user2 = null;
    resolve = null;
    reject = null;
    beforeEach(function() {
      user1 = getUser(1);
      user2 = getUser(2);
      sinon.stub(console, 'warn');
      sendIQ = sinon.spy(function(options) {
        if (options == null) {
          options = {};
        }
        return resolve = options.resolve, reject = options.reject, options;
      });
      return roster = Roster.get({
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    afterEach(function() {
      sendIQ.reset();
      console.warn.restore();
      user1 = null;
      user2 = null;
      resolve = null;
      return reject = null;
    });
    it('should return a Q promise', function() {
      return roster.addContact(user1.jid).__proto__.toString().should.equal("[object Promise]");
    });
    describe('adding a single contact', function() {
      it('should require a valid contact', function(done) {
        return roster.addContact(null).should.eventually.be.rejected.notify(done);
      });
      it('should require a valid contact with at least a jid property', function(done) {
        return roster.addContact({}).should.eventually.be.rejected.notify(done);
      });
      it('should call #getAddStanza() on the stropheHelper', function() {
        roster.addContact(user1);
        return stropheHelper.getAddStanza.should.have.been.calledOnce;
      });
      it('should accept single string-based item', function() {
        roster.addContact(user1.jid);
        return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
          element: sinon.match.instanceOf(Strophe.Builder),
          resolve: sinon.match.func,
          reject: sinon.match.func
        }));
      });
      return it('should accept a single hash-based item', function() {
        roster.addContact(user1);
        return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
          element: sinon.match.instanceOf(Strophe.Builder),
          resolve: sinon.match.func,
          reject: sinon.match.func
        }));
      });
    });
    return describe('for contacts with groups', function() {
      return it('should call #getAddStanza() on stropheRoster', function() {
        user1.groups = ["GroupA", "GroupB"];
        roster.addContact(user1);
        return stropheHelper.getAddStanza.should.have.been.calledOnce.calledWith(user1.jid, user1.name, user1.groups);
      });
    });
  });
  describe('#removeContact()', function() {
    var reject, resolve, user1, user2;
    user1 = null;
    user2 = null;
    resolve = null;
    reject = null;
    beforeEach(function() {
      user1 = getUser(1);
      user2 = getUser(2);
      sendIQ = sinon.spy(function(options) {
        if (options == null) {
          options = {};
        }
        return resolve = options.resolve, reject = options.reject, options;
      });
      return roster = Roster.get({
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    afterEach(function() {
      user1 = null;
      user2 = null;
      resolve = null;
      reject = null;
      return sendIQ.reset();
    });
    it('should return a Q promise', function() {
      return roster.removeContact(user1.jid).__proto__.toString().should.equal("[object Promise]");
    });
    return describe('removing a single contact', function() {
      it('should require a valid contact', function(done) {
        return roster.removeContact(null).should.eventually.be.rejected.notify(done);
      });
      it('should require a valid contact with at least a jidl property', function(done) {
        return roster.removeContact({}).should.eventually.be.rejected.notify(done);
      });
      it('should call #getRemoveStanza() on the stropheHelper', function() {
        roster.removeContact(user1);
        return stropheHelper.getRemoveStanza.should.have.been.calledOnce;
      });
      it('should accept single string-based item', function() {
        roster.removeContact(user1.jid);
        return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
          element: sinon.match.instanceOf(Strophe.Builder),
          resolve: sinon.match.func,
          reject: sinon.match.func
        }));
      });
      return it('should accept a single hash-based item', function() {
        roster.removeContact(user1);
        return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
          element: sinon.match.instanceOf(Strophe.Builder),
          resolve: sinon.match.func,
          reject: sinon.match.func
        }));
      });
    });
  });
  describe('#invite()', function() {
    var user1;
    user1 = null;
    beforeEach(function() {
      user1 = getUser(1);
      roster = Roster.get({
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
      return sinon.stub(roster, 'subscribe').returns(Q());
    });
    afterEach(function() {
      user1 = null;
      return roster.subscribe.restore();
    });
    it('should return a Q.Promise', function() {
      var subject;
      subject = roster.invite();
      return subject.__proto__.toString().should.equal("[object Promise]");
    });
    return it('should invoke #subscribe()', function() {
      roster.invite(user1);
      return roster.subscribe.should.have.been.calledOnce.calledWithExactly(user1);
    });
  });
  describe('#subscribe()', function() {
    var user1;
    user1 = null;
    beforeEach(function() {
      user1 = getUser(1);
      send = sinon.stub();
      return roster = Roster.get({
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    afterEach(function() {
      user1 = null;
      return send.reset();
    });
    it('should return a Q promise', function() {
      return roster.subscribe(user1).__proto__.toString().should.equal("[object Promise]");
    });
    it('should require a valid contact', function(done) {
      return roster.subscribe(null).should.eventually.be.rejected.notify(done);
    });
    it('should call #getPresenceSubscriptionStanza() on the rosterHelper', function() {
      roster.subscribe(user1.jid);
      return stropheHelper.getPresenceSubscriptionStanza.should.have.been.calledOnce.calledWithExactly(user1.jid, PresenceType.SUBSCRIBE);
    });
    return it('should call send with proper args', function() {
      roster.subscribe(user1.jid);
      return send.should.have.been.calledOnce.calledWith(sinon.match({
        element: sinon.match.instanceOf(Strophe.Builder)
      }));
    });
  });
  describe('#subscribed()', function() {
    var user1;
    user1 = null;
    beforeEach(function() {
      user1 = getUser(1);
      send = sinon.stub();
      return roster = Roster.get({
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    afterEach(function() {
      user1 = null;
      return send.reset();
    });
    it('should return a Q promise', function() {
      return roster.subscribed(user1).__proto__.toString().should.equal("[object Promise]");
    });
    it('should require a valid contact', function(done) {
      return roster.subscribed(null).should.eventually.be.rejected.notify(done);
    });
    it('should call #getPresenceSubscriptionStanza() on the rosterHelper', function() {
      roster.subscribed(user1.jid);
      return stropheHelper.getPresenceSubscriptionStanza.should.have.been.calledOnce.calledWithExactly(user1.jid, PresenceType.SUBSCRIBED);
    });
    return it('should call send with proper args', function() {
      roster.subscribed(user1.jid);
      return send.should.have.been.calledOnce.calledWith(sinon.match({
        element: sinon.match.instanceOf(Strophe.Builder)
      }));
    });
  });
  describe('#unsubscribe()', function() {
    var user1;
    user1 = null;
    beforeEach(function() {
      user1 = getUser(1);
      send = sinon.stub();
      return roster = Roster.get({
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
    });
    afterEach(function() {
      user1 = null;
      return send.reset();
    });
    it('should return a Q promise', function() {
      return roster.unsubscribe().__proto__.toString().should.equal("[object Promise]");
    });
    it('should require a valid contact', function(done) {
      return roster.unsubscribe(null).should.eventually.be.rejected.notify(done);
    });
    it('should call #getPresenceSubscriptionStanza() on the rosterHelper', function() {
      roster.unsubscribe(user1.jid);
      return stropheHelper.getPresenceSubscriptionStanza.should.have.been.calledOnce.calledWithExactly(user1.jid, PresenceType.UNSUBSCRIBE);
    });
    return it('should call send with proper args', function() {
      roster.unsubscribe(user1.jid);
      return send.should.have.been.calledOnce.calledWith(sinon.match({
        element: sinon.match.instanceOf(Strophe.Builder)
      }));
    });
  });
  return describe('#update() - alias for #addContact()', function() {
    beforeEach(function() {
      roster = Roster.get({
        send: send,
        sendIQ: sendIQ,
        helper: stropheHelper
      });
      return sinon.stub(roster, 'addContact');
    });
    afterEach(function() {
      return roster.addContact.restore();
    });
    return it('should call #addContact() with the same arguments passed to it', function() {
      var user;
      user = getUser(1);
      roster.updateContact(user);
      return roster.addContact.should.have.been.calledOnce.calledWithExactly(user);
    });
  });
});


},{"components/roster":"components/roster","enum/presence_type":"enum/presence_type","spec/spec_helper":"spec/spec_helper","strophe":"lib/strophe"}],"spec/components/storage_spec":[function(require,module,exports){
var Storage, Strophe, assert, ref, sinon;

ref = require('spec/spec_helper'), sinon = ref.sinon, assert = ref.assert;

Strophe = require('strophe');

Storage = require('components/storage');

describe('Storage', function() {
  var sendIQ, stanza, storage, stropheHelper;
  storage = null;
  sendIQ = null;
  stanza = null;
  stropheHelper = null;
  stropheHelper = {
    getPreferencesStanza: sinon.stub().returns(new Strophe.Builder()),
    setPreferencesStanza: sinon.stub().returns(new Strophe.Builder()),
    getBookmarksStanza: sinon.stub().returns(new Strophe.Builder()),
    setBookmarksStanza: sinon.stub().returns(new Strophe.Builder())
  };
  beforeEach(function() {
    sendIQ = sinon.stub();
    stanza = new Strophe.Builder();
    return stropheHelper = {
      getPreferencesStanza: sinon.stub(),
      setPreferencesStanza: sinon.stub(),
      getBookmarksStanza: sinon.stub(),
      setBookmarksStanza: sinon.stub()
    };
  });
  afterEach(function() {
    Storage.destroy();
    sendIQ.reset();
    stropheHelper.getPreferencesStanza.reset();
    stropheHelper.setPreferencesStanza.reset();
    stropheHelper.getBookmarksStanza.reset();
    stropheHelper.setBookmarksStanza.reset();
    stropheHelper = null;
    return storage = null;
  });
  describe('#getPreferences()', function() {
    beforeEach(function() {
      storage = Storage.get({
        sendIQ: sendIQ,
        helper: stropheHelper
      });
      return stropheHelper.getPreferencesStanza.returns(stanza);
    });
    return it('should call sendIQ()', function() {
      storage.getPreferences();
      stropheHelper.getPreferencesStanza.should.have.been.calledOnce;
      return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
        element: sinon.match.instanceOf(Strophe.Builder),
        resolve: sinon.match.func,
        reject: sinon.match.func
      }));
    });
  });
  describe('#setPreferences()', function() {
    beforeEach(function() {
      storage = Storage.get({
        sendIQ: sendIQ,
        helper: stropheHelper
      });
      return stropheHelper.setPreferencesStanza.returns(stanza);
    });
    return it('should call sendIQ()', function() {
      var preferences;
      preferences = {};
      storage.setPreferences(preferences);
      stropheHelper.setPreferencesStanza.should.have.been.calledOnce.calledWith(preferences);
      return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
        element: sinon.match.instanceOf(Strophe.Builder),
        resolve: sinon.match.func,
        reject: sinon.match.func
      }));
    });
  });
  describe('#getBookmarks()', function() {
    beforeEach(function() {
      storage = Storage.get({
        sendIQ: sendIQ,
        helper: stropheHelper
      });
      return stropheHelper.getBookmarksStanza.returns(stanza);
    });
    return it('should call sendIQ()', function() {
      storage.getBookmarks();
      stropheHelper.getBookmarksStanza.should.have.been.calledOnce;
      return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
        element: sinon.match.instanceOf(Strophe.Builder),
        resolve: sinon.match.func,
        reject: sinon.match.func
      }));
    });
  });
  return describe('#setBookmarks()', function() {
    beforeEach(function() {
      storage = Storage.get({
        sendIQ: sendIQ,
        helper: stropheHelper
      });
      return stropheHelper.setBookmarksStanza.returns(stanza);
    });
    return it('should call sendIQ()', function() {
      var bookmarks;
      bookmarks = {};
      storage.setBookmarks(bookmarks);
      stropheHelper.setBookmarksStanza.should.have.been.calledOnce.calledWith(bookmarks);
      return sendIQ.should.have.been.calledOnce.calledWith(sinon.match({
        element: sinon.match.instanceOf(Strophe.Builder),
        resolve: sinon.match.func,
        reject: sinon.match.func
      }));
    });
  });
});


},{"components/storage":"components/storage","spec/spec_helper":"spec/spec_helper","strophe":"lib/strophe"}],"spec/connection_spec":[function(require,module,exports){
var Blocklist, Connection, EventManager, IOEvent, RateLimiter, Roster, Status, Storage, Strophe, StropheIO, XMPPPresence, _, assert, expect, ref, sinon;

ref = require('spec/spec_helper'), _ = ref._, sinon = ref.sinon, assert = ref.assert, expect = ref.expect;

Strophe = require('strophe');

Connection = require('connection');

XMPPPresence = require('enum/xmpp_presence');

Roster = require('components/roster');

Storage = require('components/storage');

Blocklist = require('components/blocklist');

RateLimiter = require('util/rate_limiter');

EventManager = require('events/event_manager');

Status = require('enum/status');

StropheIO = require('strophe/strophe_io');

IOEvent = require('events/io_event');

describe('Connection', function() {
  var BlocklistStub, EventManagerStub, RosterStub, StorageStub, StropheConnectionStub, connection, specOptions;
  connection = null;
  specOptions = null;
  RosterStub = (function() {
    function RosterStub() {}

    return RosterStub;

  })();
  StorageStub = (function() {
    function StorageStub() {}

    return StorageStub;

  })();
  BlocklistStub = (function() {
    function BlocklistStub() {}

    return BlocklistStub;

  })();
  EventManagerStub = (function() {
    function EventManagerStub() {}

    EventManagerStub.prototype.toggleConnection = sinon.stub();

    return EventManagerStub;

  })();
  StropheConnectionStub = (function() {
    function StropheConnectionStub() {}

    StropheConnectionStub.prototype.connect = sinon.stub();

    StropheConnectionStub.prototype.send = sinon.stub();

    StropheConnectionStub.prototype.sendIQ = sinon.stub();

    StropheConnectionStub.prototype.reset = sinon.stub();

    StropheConnectionStub.prototype.addHandler = sinon.stub();

    StropheConnectionStub.prototype.deleteHandler = sinon.stub();

    return StropheConnectionStub;

  })();
  before(function() {
    Strophe.Connection = StropheConnectionStub;
    sinon.stub(EventManager, 'get').returns(new EventManagerStub());
    sinon.stub(Roster, 'get').returns(new RosterStub());
    sinon.stub(Storage, 'get').returns(new StorageStub());
    return sinon.stub(Blocklist, 'get').returns(new BlocklistStub());
  });
  after(function() {
    Strophe.Connection = null;
    Roster.get.restore();
    EventManager.get.restore();
    Storage.get.restore();
    return Blocklist.get.restore();
  });
  beforeEach(function() {
    specOptions = {
      appName: Connection.TEST_KEY,
      appVersion: "1.0"
    };
    return sinon.spy(_, 'bind');
  });
  afterEach(function() {
    _.bind.restore();
    if (connection != null) {
      connection._connection.send.reset();
    }
    if (connection != null) {
      connection._connection.sendIQ.reset();
    }
    Connection.destroy();
    connection = null;
    specOptions = null;
    return Roster.get.reset();
  });
  it('Connection class should be available on the window object', function() {
    return window.Connection.should.exist;
  });
  it('should return an empty object when directly instantiated', function() {
    return new Connection().should.be.empty;
  });
  describe('instantiating dependencies', function() {
    it('should retrieve the Roster singleton and inject dependencies', function() {
      connection = Connection.get(specOptions);
      return Roster.get.should.have.been.calledOnce.calledWith(sinon.match({
        send: sinon.match.func,
        sendIQ: sinon.match.func
      }));
    });
    it('should retrieve the Storage singleton and inject dependencies', function() {
      connection = Connection.get(specOptions);
      return Roster.get.should.have.been.calledOnce.calledWith(sinon.match({
        sendIQ: sinon.match.func
      }));
    });
    it('should bind send and sendIQ and addHandler and deleteHandler on Strophe.Connection', function() {
      connection = Connection.get(specOptions);
      _.bind.callCount.should.equal(4);
      _.bind.firstCall.should.have.been.calledWith(sinon.match.func, connection);
      _.bind.secondCall.should.have.been.calledWith(sinon.match.func, connection);
      return _.bind.thirdCall.should.have.been.calledWith(sinon.match.func, connection._connection);
    });
    return it('should connect Strophe with potential event listeners', function() {
      sinon.stub(StropheIO, 'connectIOListeners');
      connection = Connection.get(specOptions);
      StropheIO.connectIOListeners.should.have.been.calledOnce.calledWith({
        connection: connection._connection,
        getRawInputListeners: sinon.match.func,
        getRawOutputListeners: sinon.match.func,
        getXMLInputListeners: sinon.match.func,
        getXMLOutputListeners: sinon.match.func
      });
      return StropheIO.connectIOListeners.restore();
    });
  });
  describe('#addStropheListener()', function() {
    describe('adding a single listener', function() {
      beforeEach(function() {
        connection = Connection.get(specOptions);
        return sinon.stub(StropheIO, 'addIOListener');
      });
      afterEach(function() {
        return StropheIO.addIOListener.restore();
      });
      it('should register a single listener with StropheIO for raw input/output by default', function() {
        var listener, options;
        listener = sinon.stub();
        options = {
          listener: listener
        };
        connection.addStropheListener(options);
        return StropheIO.addIOListener.should.have.been.calledTwice.calledWith(listener, StropheIO.rawInputListeners).calledWith(listener, StropheIO.rawOutputListeners);
      });
      it('should register a single listener with StropheIO for raw input', function() {
        var listener, options;
        listener = sinon.stub();
        options = {
          listener: listener,
          type: IOEvent.RAW,
          ioType: IOEvent.INPUT
        };
        connection.addStropheListener(options);
        return StropheIO.addIOListener.should.have.been.calledOnce.calledWithExactly(listener, StropheIO.rawInputListeners);
      });
      it('should register a single listener with StropheIO for raw output', function() {
        var listener, options;
        listener = sinon.stub();
        options = {
          listener: listener,
          type: IOEvent.RAW,
          ioType: IOEvent.OUTPUT
        };
        connection.addStropheListener(options);
        return StropheIO.addIOListener.should.have.been.calledOnce.calledWithExactly(listener, StropheIO.rawOutputListeners);
      });
      it('should register a single listener with StropheIO for XML input', function() {
        var listener, options;
        listener = sinon.stub();
        options = {
          listener: listener,
          type: IOEvent.XML,
          ioType: IOEvent.INPUT
        };
        connection.addStropheListener(options);
        return StropheIO.addIOListener.should.have.been.calledOnce.calledWithExactly(listener, StropheIO.xmlInputListeners);
      });
      return it('should register a single listener with StropheIO for XML output', function() {
        var listener, options;
        listener = sinon.stub();
        options = {
          listener: listener,
          type: IOEvent.XML,
          ioType: IOEvent.OUTPUT
        };
        connection.addStropheListener(options);
        return StropheIO.addIOListener.should.have.been.calledOnce.calledWithExactly(listener, StropheIO.xmlOutputListeners);
      });
    });
    return describe('adding multiple listeners', function() {
      beforeEach(function() {
        connection = Connection.get(specOptions);
        return sinon.stub(StropheIO, 'addIOListener');
      });
      afterEach(function() {
        return StropheIO.addIOListener.restore();
      });
      it('should register a multiple listeners with StropheIO for raw input/output by default', function() {
        var listener1, listener2, listeners, options;
        listener1 = sinon.stub();
        listener2 = sinon.stub();
        listeners = [listener1, listener2];
        options = {
          listener: listeners
        };
        connection.addStropheListener(options);
        return StropheIO.addIOListener.should.have.been.calledTwice.calledWith(listeners, StropheIO.rawInputListeners).calledWith(listeners, StropheIO.rawOutputListeners);
      });
      it('should register a single listener with StropheIO for raw input', function() {
        var listener1, listener2, listeners, options;
        listener1 = sinon.stub();
        listener2 = sinon.stub();
        listeners = [listener1, listener2];
        options = {
          listener: listeners,
          type: IOEvent.RAW,
          ioType: IOEvent.INPUT
        };
        connection.addStropheListener(options);
        return StropheIO.addIOListener.should.have.been.calledOnce.calledWithExactly(listeners, StropheIO.rawInputListeners);
      });
      it('should register a single listener with StropheIO for raw output', function() {
        var listener1, listener2, listeners, options;
        listener1 = sinon.stub();
        listener2 = sinon.stub();
        listeners = [listener1, listener2];
        options = {
          listener: listeners,
          type: IOEvent.RAW,
          ioType: IOEvent.OUTPUT
        };
        connection.addStropheListener(options);
        return StropheIO.addIOListener.should.have.been.calledOnce.calledWithExactly(listeners, StropheIO.rawOutputListeners);
      });
      it('should register a single listener with StropheIO for XML input', function() {
        var listener1, listener2, listeners, options;
        listener1 = sinon.stub();
        listener2 = sinon.stub();
        listeners = [listener1, listener2];
        options = {
          listener: listeners,
          type: IOEvent.XML,
          ioType: IOEvent.INPUT
        };
        connection.addStropheListener(options);
        return StropheIO.addIOListener.should.have.been.calledOnce.calledWithExactly(listeners, StropheIO.xmlInputListeners);
      });
      return it('should register a single listener with StropheIO for XML output', function() {
        var listener1, listener2, listeners, options;
        listener1 = sinon.stub();
        listener2 = sinon.stub();
        listeners = [listener1, listener2];
        options = {
          listener: listeners,
          type: IOEvent.XML,
          ioType: IOEvent.OUTPUT
        };
        connection.addStropheListener(options);
        return StropheIO.addIOListener.should.have.been.calledOnce.calledWithExactly(listeners, StropheIO.xmlOutputListeners);
      });
    });
  });
  describe('#status()', function() {
    beforeEach(function() {
      return connection = Connection.get(specOptions);
    });
    it('should have a default status of `disconnected`', function() {
      return connection.status().should.equal(Status.DISCONNECTED);
    });
    return it('should retrieve the current status of the connection', function() {
      connection._connectionStatus = Status.CONNECTED;
      return connection.status().should.equal(Status.CONNECTED);
    });
  });
  describe('#isConnected()', function() {
    beforeEach(function() {
      return connection = Connection.get(specOptions);
    });
    it('should return true if the connection status is `CONNECTED`', function() {
      connection._connectionStatus = Status.CONNECTED;
      return connection.isConnected().should.be["true"];
    });
    return it('should return true if the connection status is `CONNECTED`', function() {
      connection._connectionStatus = Status.DISCONNECTED;
      return connection.isConnected().should.be["false"];
    });
  });
  describe('getAppName', function() {
    beforeEach(function() {
      return connection = Connection.get(specOptions);
    });
    return it('should return an `appName` String', function() {
      return connection.getAppName().should.equal(Connection.TEST_KEY);
    });
  });
  describe('getAppVersion', function() {
    beforeEach(function() {
      return connection = Connection.get(specOptions);
    });
    return it('should return an `appVersion` String', function() {
      return connection.getAppVersion().should.equal("1.0");
    });
  });
  describe('getAppService', function() {
    beforeEach(function() {
      specOptions = _.extend({}, specOptions, {
        service: "test-service"
      });
      return connection = Connection.get(specOptions);
    });
    return it('should return an `appVersion` String', function() {
      return connection.getService().should.equal("/test-service/");
    });
  });
  describe('#get()', function() {
    it('should return a singleton of Connection', function() {
      var connection2;
      connection = Connection.get(specOptions);
      connection2 = Connection.get(specOptions);
      return connection.should.equal(connection2);
    });
    it('should have a `connection` property that is a `Strophe.Connection`', function() {
      return Connection.get(specOptions).should.have.a.property('_connection').that.is.an["instanceof"](Strophe.Connection);
    });
    it('should rate limit the `#connect()` method of its Strophe Connection with aliases', function() {
      connection = Connection.get(specOptions);
      connection.should.have.a.property('_connectToServer').that.is.an["instanceof"](RateLimiter);
      connection._connectToServer.should.have.a.property('afterServerFailure').that.is.a('function');
      return connection._connectToServer.should.have.a.property('afterLongPollFailure').that.is.a('function');
    });
    it('should require an `appName` be passed in', function() {
      return expect(function() {
        return Connection.get({
          appName: null
        });
      }).to["throw"](Error);
    });
    return it('should require an `appVersion` be passed in', function() {
      var options;
      options = {
        appName: Connection.TEST_KEY,
        appVersion: null
      };
      return expect(function() {
        return Connection.get(options);
      }).to["throw"](Error);
    });
  });
  describe('#getComponent()', function() {
    beforeEach(function() {
      return connection = Connection.get(specOptions);
    });
    it('should throw an exception when passed a non-existent component', function() {
      var invalid;
      invalid = "invalidComponent";
      expect(function() {
        return connection.getComponent(invalid);
      }).to["throw"](Error);
      return expect(function() {
        return connection.getComponent(invalid);
      }).to["throw"]("Component '" + invalid + "' does not exist.");
    });
    it('should thow an exception if passed an invalid value', function() {
      expect(function() {
        return connection.getComponent();
      }).to["throw"](Error);
      expect(function() {
        return connection.getComponent(null);
      }).to["throw"](Error);
      expect(function() {
        return connection.getComponent(void 0);
      }).to["throw"](Error);
      expect(function() {
        return connection.getComponent({});
      }).to["throw"](Error);
      expect(function() {
        return connection.getComponent(false);
      }).to["throw"](Error);
      return expect(function() {
        return connection.getComponent(1);
      }).to["throw"](Error);
    });
    return it('should return an instance of the roster component when available', function() {
      return connection.getComponent(Roster.NAME).should.equal(connection._roster);
    });
  });
  return describe('#connect()', function() {
    var options, stropheConnectStub;
    options = null;
    stropheConnectStub = null;
    beforeEach(function() {
      stropheConnectStub = sinon.stub();
      sinon.stub(_, 'limit').returns(stropheConnectStub);
      connection = Connection.get(specOptions);
      options = {
        jid: "test@test.com",
        password: "password"
      };
      return _.bind.reset();
    });
    afterEach(function() {
      stropheConnectStub.reset();
      connection._connection.reset.reset();
      _.limit.restore();
      return options = null;
    });
    it('should return a promise', function() {
      return connection.connect(options).__proto__.toString().should.equal("[object Promise]");
    });
    describe('when a connection is already in progress', function() {
      var promise;
      promise = null;
      beforeEach(function(done) {
        promise = connection.connect(options);
        return done();
      });
      afterEach(function() {
        return promise = null;
      });
      it('should return a previous promise for a `pending` deferred', function() {
        var promise2;
        promise2 = connection.connect(options);
        promise2.should.equal(promise);
        promise2.isPending().should.be["true"];
        return stropheConnectStub.should.have.been.calledOnce;
      });
      it('should return a previous promise when the status is CONNECTING', function() {
        sinon.spy(connection._connectionDfd, 'notify');
        connection._connectionStatus = Status.CONNECTING;
        connection.connect(options);
        return connection._connectionDfd.notify.should.have.been.calledWith(Status.CONNECTING, "Aleady connecting to the Nitro server");
      });
      it('should return a previous promise when the status is AUTHENTICATING', function() {
        sinon.spy(connection._connectionDfd, 'notify');
        connection._connectionStatus = Status.AUTHENTICATING;
        connection.connect(options);
        return connection._connectionDfd.notify.should.have.been.calledWith(Status.AUTHENTICATING, "Already authenticating with the Nitro server");
      });
      return it('should return a previous promise when the status is DISCONNECTING', function() {
        sinon.spy(connection._connectionDfd, 'notify');
        connection._connectionStatus = Status.DISCONNECTED;
        connection.connect(options);
        return connection._connectionDfd.notify.should.have.been.calledWith(Status.DISCONNECTED, "Already disconnecting from the Nitro server");
      });
    });
    it('should immediately return a resolved promise if status is already CONNECTED', function() {
      connection._connectionStatus = Status.CONNECTED;
      connection.connect(options).should.be.fulfilled;
      return stropheConnectStub.should.not.have.been.called;
    });
    it('should call `connect()` on the Strophe connection object', function() {
      connection.connect(options);
      stropheConnectStub.should.have.been.calledOnce.calledWith(options.jid, options.password);
      return _.bind.should.have.been.calledOnce;
    });
    it('should return a failed promise if credentials are invalid', function(done) {
      options = {
        jid: null,
        password: null
      };
      connection.connect(options).should.eventually.be.rejectedWith("Can not connect due to missing credentials");
      return connection.connect(options).should.eventually.be.rejected.notify(done);
    });
    describe('handling status updates with `onConnectionStatus()`', function() {
      beforeEach(function() {
        return sinon.stub(connection, 'getJID');
      });
      afterEach(function() {
        connection.getJID.restore();
        connection.eventManager.toggleConnection.reset();
        return connection._connection.reset.reset();
      });
      it('should handle the CONNECTED status', function(done) {
        var handlerFunction, jid;
        connection.getJID.returns(jid = "selfJID");
        connection.connect(options).should.eventually.be.fulfilled.notify(done);
        handlerFunction = _.bind.firstCall.args[0];
        handlerFunction.call(connection, connection._connectionDfd, null, Status.CONNECTED);
        connection.status().should.equal(Status.CONNECTED);
        return connection.eventManager.toggleConnection.should.have.been.calledOnce.calledWith(true);
      });
      it('should handle the CONNECTING status', function(done) {
        var handlerFunction;
        connection.connect(options).progress(function() {
          return done();
        });
        handlerFunction = _.bind.firstCall.args[0];
        handlerFunction.call(connection, connection._connectionDfd, null, Status.CONNECTING);
        connection.status().should.equal(Status.CONNECTING);
        return connection.eventManager.toggleConnection.should.not.have.been.called;
      });
      it('should handle the AUTHENTICATING status', function(done) {
        var handlerFunction;
        connection.connect(options).progress(function() {
          return done();
        });
        handlerFunction = _.bind.firstCall.args[0];
        handlerFunction.call(connection, connection._connectionDfd, null, Status.AUTHENTICATING);
        connection.status().should.equal(Status.AUTHENTICATING);
        return connection.eventManager.toggleConnection.should.not.have.been.called;
      });
      it('should handle the CONNFAIL status', function(done) {
        var handlerFunction;
        connection.connect(options).should.eventually.be.rejected.notify(done);
        handlerFunction = _.bind.firstCall.args[0];
        handlerFunction.call(connection, connection._connectionDfd, null, Status.CONNFAIL);
        connection.status().should.equal(Status.CONNFAIL);
        return connection.eventManager.toggleConnection.should.have.been.calledOnce.calledWith(false);
      });
      it('should handle the AUTHFAIL status', function(done) {
        var handlerFunction;
        connection.connect(options).should.eventually.be.rejected.notify(done);
        handlerFunction = _.bind.firstCall.args[0];
        handlerFunction.call(connection, connection._connectionDfd, null, Status.AUTHFAIL);
        connection.status().should.equal(Status.AUTHFAIL);
        return connection.eventManager.toggleConnection.should.not.have.been.called;
      });
      it('should handle the DISCONNECTING status', function() {
        var handlerFunction;
        connection.connect(options);
        handlerFunction = _.bind.firstCall.args[0];
        handlerFunction.call(connection, connection._connectionDfd, null, Status.DISCONNECTING);
        connection.status().should.equal(Status.DISCONNECTING);
        return connection.eventManager.toggleConnection.should.not.have.been.called;
      });
      it('should handle the DISCONNECTED status', function() {
        var handlerFunction;
        connection.connect(options);
        handlerFunction = _.bind.firstCall.args[0];
        handlerFunction.call(connection, connection._connectionDfd, null, Status.DISCONNECTED);
        connection.status().should.equal(Status.DISCONNECTED);
        return connection.eventManager.toggleConnection.should.have.been.calledOnce.calledWith(false);
      });
      it('should reset the Strophe connection on DISCONNECTED status', function() {
        var handlerFunction;
        connection.connect(options);
        handlerFunction = _.bind.firstCall.args[0];
        handlerFunction.call(connection, connection._connectionDfd, null, Status.DISCONNECTED);
        return connection._connection.reset.should.have.been.calledOnce;
      });
      it('should handle the FATAL_FAILURE status', function() {
        var handlerFunction;
        connection.connect(options);
        handlerFunction = _.bind.firstCall.args[0];
        handlerFunction.call(connection, connection._connectionDfd, null, Status.FATAL_FAILURE);
        connection.status().should.equal(Status.FATAL_FAILURE);
        return connection.eventManager.toggleConnection.should.not.have.been.called;
      });
      return it('should reject any unknown status', function() {
        var handlerFunction;
        connection.connect(options);
        handlerFunction = _.bind.firstCall.args[0];
        handlerFunction.call(connection, connection._connectionDfd, "InvalidStatus");
        connection.status().should.equal(Status.DISCONNECTED);
        return connection.eventManager.toggleConnection.should.have.been.calledOnce.calledWith(false);
      });
    });
    return describe('#setPresence()', function() {
      var status;
      status = null;
      beforeEach(function() {
        return sinon.stub(connection, 'isConnected').returns(true);
      });
      afterEach(function() {
        return connection.isConnected.restore();
      });
      return it('should send AVAILABLE presence and return a fulfilled promise', function() {
        status = XMPPPresence.AVAILABLE;
        connection.setPresence(status).should.be.fulfilled;
        connection._connection.sendIQ.should.have.been.calledOnce;
        return connection._connection.sendIQ.firstCall.args[0].should.be instanceof Strophe.Builder;
      });
    });
  });
});


},{"components/blocklist":"components/blocklist","components/roster":"components/roster","components/storage":"components/storage","connection":"connection","enum/status":"enum/status","enum/xmpp_presence":"enum/xmpp_presence","events/event_manager":"events/event_manager","events/io_event":"events/io_event","spec/spec_helper":"spec/spec_helper","strophe":"lib/strophe","strophe/strophe_io":"strophe/strophe_io","util/rate_limiter":"util/rate_limiter"}],"spec/events/event_filters_spec":[function(require,module,exports){
var ChatStatesNS, EventFilters, convertXMLToStanza, expect, ref, sinon;

ref = require('spec/spec_helper'), sinon = ref.sinon, expect = ref.expect, convertXMLToStanza = ref.convertXMLToStanza;

ChatStatesNS = require('enum/chat_states_ns');

EventFilters = require('events/event_filters');

describe('EventFilters', function() {
  describe('#isMUC()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true when the stanza contains a MUC namespace', function() {
      var stanza;
      xml = '<something><x xmlns="http://jabber.org/protocol/muc#user"></x></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isMUC(stanza).should.be["true"];
    });
    it('should return false when the stanza contains a non MUC namespace', function() {
      var stanza;
      xml = '<something><x xmlns="http://jabber.org/protocol/"></x></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isMUC(stanza).should.be["false"];
    });
    return it('should return false when the stanza contains no MUC namespace', function() {
      var stanza;
      xml = '<something></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isMUC(stanza).should.be["false"];
    });
  });
  describe('#isntMUC()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return false when the stanza contains a MUC namespace', function() {
      var stanza;
      xml = '<something><x xmlns="http://jabber.org/protocol/muc#user"></x></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isntMUC(stanza).should.be["false"];
    });
    it('should return true when the stanza contains a non MUC namespace', function() {
      var stanza;
      xml = '<something><x xmlns="http://jabber.org/protocol/"></x></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isntMUC(stanza).should.be["true"];
    });
    return it('should return true when the stanza contains no MUC namespace', function() {
      var stanza;
      xml = '<something></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isntMUC(stanza).should.be["true"];
    });
  });
  describe('#isMUCInvite()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true when the stanza contains a MUC namespace and also an invite element', function() {
      var stanza;
      xml = '<something> <x xmlns="http://jabber.org/protocol/muc#user"> <invite from="rm-qa_8.thomsonreuters.com@reuasmb.net" name="RM QA8 - Pioneer Investment Management SGRpA" email="rm-qa_8@thomsonreuters.com"> <reason>%7B%22id%22%3A%22groupchat-6ae8140conference.reuasmb.net%22%2C%</reason> </invite> </x> </something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isMUCInvite(stanza).should.be["true"];
    });
    it('should return false when the stanza contains a MUC namespace but no invite element', function() {
      var stanza;
      xml = '<something> <x xmlns="http://jabber.org/protocol/muc#user"></x> </something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isMUCInvite(stanza).should.be["false"];
    });
    it('should return false when the stanza contains a non MUC namespace', function() {
      var stanza;
      xml = '<something> <x xmlns="http://jabber.org/protocol"> <invite from="rm-qa_8.thomsonreuters.com@reuasmb.net" name="RM QA8 - Pioneer Investment Management SGRpA" email="rm-qa_8@thomsonreuters.com"> <reason>%7B%22id%22%3A%22groupchat-6ae8140conference.reuasmb.net%22%2C%</reason> </invite> </x> </something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isMUCInvite(stanza).should.be["false"];
    });
    return it('should return false when the stanza contains no MUC namespace', function() {
      var stanza;
      xml = '<something> <invite from="rm-qa_8.thomsonreuters.com@reuasmb.net" name="RM QA8 - Pioneer Investment Management SGRpA" email="rm-qa_8@thomsonreuters.com"> <reason>%7B%22id%22%3A%22groupchat-6ae8140conference.reuasmb.net%22%2C%</reason> </invite> </something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isMUCInvite(stanza).should.be["false"];
    });
  });
  describe('#hasType()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true when the stanza contains a `type` attribute', function() {
      var stanza;
      xml = '<something type="sometype"></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.hasType(stanza).should.be["true"];
    });
    return it('should return false when the stanza contains no `type` attribute', function() {
      var stanza;
      xml = '<something></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.hasType(stanza).should.be["false"];
    });
  });
  describe('#isSelf()', function() {
    var selfID, xml;
    xml = null;
    selfID = null;
    beforeEach(function() {
      return selfID = "selfid";
    });
    afterEach(function() {
      xml = null;
      return selfID = null;
    });
    it('should return true when the stanza contains a `from` attribute that is the selfID', function() {
      var stanza;
      xml = '<something from="selfid"></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isSelf(stanza, selfID).should.be["true"];
    });
    it('should return false when the stanza contains a `from` atrribute that is not the selfID', function() {
      var stanza;
      xml = '<something from="anotherid"></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isSelf(stanza, selfID).should.be["false"];
    });
    return it('should return false when the stanza contains no `from` atrribute', function() {
      var stanza;
      xml = '<something></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isSelf(stanza, selfID).should.be["false"];
    });
  });
  describe('#isntSelf()', function() {
    var selfID, xml;
    xml = null;
    selfID = null;
    beforeEach(function() {
      return selfID = "selfid";
    });
    afterEach(function() {
      xml = null;
      return selfID = null;
    });
    it('should return false when the stanza contains a `from` attribute that is the selfID', function() {
      var stanza;
      xml = '<something from="selfid"></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isntSelf(stanza, selfID).should.be["false"];
    });
    it('should return true when the stanza contains a `from` atrribute that is not the selfID', function() {
      var stanza;
      xml = '<something from="anotherid"></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isntSelf(stanza, selfID).should.be["true"];
    });
    return it('should return true when the stanza contains no `from` atrribute', function() {
      var stanza;
      xml = '<something></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isntSelf(stanza, selfID).should.be["true"];
    });
  });
  describe('#isRecipientUnavailable()', function() {
    var xml;
    xml = null;
    beforeEach(function() {});
    afterEach(function() {
      return xml = null;
    });
    it('should return true when the stanza contains a `recipient-unavailable` stanza.', function() {
      var stanza;
      xml = '<message from="anotherid"><error><recipient-unavailable/></error></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isRecipientUnavailable(stanza).should.be["true"];
    });
    return it('should return false when the stanza does not contain a `recipient-unavailable` stanza.', function() {
      var stanza;
      xml = '<something></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isRecipientUnavailable(stanza).should.be["false"];
    });
  });
  describe('#isPreferences()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true for a preferences stanza', function() {
      var stanza;
      xml = "<iq type='set' xmlns='jabber:client'> <query xmlns='jabber:iq:private'> <storage xmlns='storage:preferences' /> </query> </iq>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isPreferences(stanza).should.be["true"];
    });
    it('should return false for a bookmarks stanza', function() {
      var stanza;
      xml = "<iq type='set' xmlns='jabber:client'> <query xmlns='jabber:iq:private'> <storage xmlns='storage:bookmarks' /> </query> </iq>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isPreferences(stanza).should.be["false"];
    });
    return it('should return false for a stanza missing the preferences xmlns', function() {
      var stanza;
      xml = "<iq type='set' xmlns='jabber:client'> <query xmlns='jabber:iq:private'> <storage /> </query> </iq>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isPreferences(stanza).should.be["false"];
    });
  });
  describe('#isBookmarks()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true for a bookmarks stanza', function() {
      var stanza;
      xml = "<iq type='set' xmlns='jabber:client'> <query xmlns='jabber:iq:private'> <storage xmlns='storage:bookmarks' /> </query> </iq>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isBookmarks(stanza).should.be["true"];
    });
    it('should return true for a preferences stanza', function() {
      var stanza;
      xml = "<iq type='set' xmlns='jabber:client'> <query xmlns='jabber:iq:private'> <storage xmlns='storage:preferences' /> </query> </iq>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isBookmarks(stanza).should.be["false"];
    });
    return it('should return false for a stanza missing the bookmarks xmlns', function() {
      var stanza;
      xml = "<iq type='set' xmlns='jabber:client'> <query xmlns='jabber:iq:private'> <storage /> </query> </iq>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isBookmarks(stanza).should.be["false"];
    });
  });
  describe('#isRosterAdded()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true for a subscription of `none` stanza', function() {
      var stanza;
      xml = "<iq from='rm-qa_6.thomsonreuters.com@reuasmb.net' to='rm-qa_6.thomsonreuters.com@reuasmb.net/nitro7b203ebee5fd8387' id='5811079' type='set'> <query xmlns='jabber:iq:roster'> <item jid='test.user.thomsonreuters.com@reuasmb.net' subscription='none' /> </query>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isRosterAdded(stanza).should.be["true"];
    });
    it('should return true for a subscription of `from` stanza', function() {
      var stanza;
      xml = "<iq from='rm-qa_6.thomsonreuters.com@reuasmb.net' to='rm-qa_6.thomsonreuters.com@reuasmb.net/nitro7b203ebee5fd8387' id='5811079' type='set'> <query xmlns='jabber:iq:roster'> <item jid='test.user.thomsonreuters.com@reuasmb.net' subscription='from' /> </query>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isRosterAdded(stanza).should.be["true"];
    });
    return it('should return false for a subscription of `remove` stanza', function() {
      var stanza;
      xml = "<iq from='rm-qa_6.thomsonreuters.com@reuasmb.net' to='rm-qa_6.thomsonreuters.com@reuasmb.net/nitro7b203ebee5fd8387' id='5811079' type='set'> <query xmlns='jabber:iq:roster'> <item jid='test.user.thomsonreuters.com@reuasmb.net' subscription='remove' /> </query>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isRosterAdded(stanza).should.be["false"];
    });
  });
  describe('#isRosterRemoved()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true for a subscription of `remove` stanza', function() {
      var stanza;
      xml = "<iq from='rm-qa_6.thomsonreuters.com@reuasmb.net' to='rm-qa_6.thomsonreuters.com@reuasmb.net/nitro7b203ebee5fd8387' id='5811079' type='set'> <query xmlns='jabber:iq:roster'> <item jid='test.user.thomsonreuters.com@reuasmb.net' subscription='remove' /> </query>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isRosterRemoved(stanza).should.be["true"];
    });
    it('should return false for a subscription of `none` stanza', function() {
      var stanza;
      xml = "<iq from='rm-qa_6.thomsonreuters.com@reuasmb.net' to='rm-qa_6.thomsonreuters.com@reuasmb.net/nitro7b203ebee5fd8387' id='5811079' type='set'> <query xmlns='jabber:iq:roster'> <item jid='test.user.thomsonreuters.com@reuasmb.net' subscription='none' /> </query>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isRosterRemoved(stanza).should.be["false"];
    });
    return it('should return false for a subscription of `from` stanza', function() {
      var stanza;
      xml = "<iq from='rm-qa_6.thomsonreuters.com@reuasmb.net' to='rm-qa_6.thomsonreuters.com@reuasmb.net/nitro7b203ebee5fd8387' id='5811079' type='set'> <query xmlns='jabber:iq:roster'> <item jid='test.user.thomsonreuters.com@reuasmb.net' subscription='from' /> </query>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isRosterRemoved(stanza).should.be["false"];
    });
  });
  describe('#isBlocklistBlocked()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true if the stanza includes a `block` element', function() {
      var stanza;
      xml = "<iq from='rm-qa_6.thomsonreuters.com@reuasmb.net' to='rm-qa_6.thomsonreuters.com@reuasmb.net/nitro68f46db05f00dd78' id='10:sendIQ' type='set'> <block xmlns='urn:xmpp:blocking'> <item jid='kevin.maes1.qa-test.com@reuasmb.net' /> </block> </iq>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isBlocklistBlocked(stanza).should.be["true"];
    });
    return it('should return false if the stanza includes an `unblock` element', function() {
      var stanza;
      xml = "<iq from='rm-qa_6.thomsonreuters.com@reuasmb.net' to='rm-qa_6.thomsonreuters.com@reuasmb.net/nitro68f46db05f00dd78' id='10:sendIQ' type='set'> <unblock xmlns='urn:xmpp:blocking'> <item jid='kevin.maes1.qa-test.com@reuasmb.net' /> </unblock> </iq>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isBlocklistBlocked(stanza).should.be["false"];
    });
  });
  describe('#isBlocklistUnblocked()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true if the stanza includes a `block` element', function() {
      var stanza;
      xml = "<iq from='rm-qa_6.thomsonreuters.com@reuasmb.net' to='rm-qa_6.thomsonreuters.com@reuasmb.net/nitro68f46db05f00dd78' id='10:sendIQ' type='set'> <unblock xmlns='urn:xmpp:blocking'> <item jid='kevin.maes1.qa-test.com@reuasmb.net' /> </unblock> </iq>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isBlocklistUnblocked(stanza).should.be["true"];
    });
    return it('should return false if the stanza includes an `unblock` element', function() {
      var stanza;
      xml = "<iq from='rm-qa_6.thomsonreuters.com@reuasmb.net' to='rm-qa_6.thomsonreuters.com@reuasmb.net/nitro68f46db05f00dd78' id='10:sendIQ' type='set'> <block xmlns='urn:xmpp:blocking'> <item jid='kevin.maes1.qa-test.com@reuasmb.net' /> </block> </iq>";
      stanza = convertXMLToStanza(xml);
      return EventFilters.isBlocklistUnblocked(stanza).should.be["false"];
    });
  });
  describe('.isConflict()', function() {
    it('should return true if a `conflict` stanza is included', function() {
      var result, stanza, xml;
      xml = "<body xmlns='http://jabber.org/protocol/httpbind' xmlns:stream='http://etherx.jabber.org/streams' ack='1429706565'> <stream:error> <conflict xmlns='urn:ietf:params:xml:ns:xmpp-streams'/> </stream:error> </body>";
      stanza = convertXMLToStanza(xml);
      result = EventFilters.isConflict(stanza);
      return result.should.be["true"];
    });
    return it('should return false if a `conflict` stanza is not included', function() {
      var result, stanza, xml;
      xml = "<body xmlns='http://jabber.org/protocol/httpbind' xmlns:stream='http://etherx.jabber.org/streams' ack='1429706565'> <stream:error /> </body>";
      stanza = convertXMLToStanza(xml);
      result = EventFilters.isConflict(stanza);
      return result.should.be["false"];
    });
  });
  describe('#run()', function() {
    var filter1, filter2, filters, selfID, stanza;
    stanza = null;
    filters = null;
    selfID = null;
    filter1 = null;
    filter2 = null;
    before(function() {
      filter1 = sinon.stub();
      return filter2 = sinon.stub();
    });
    after(function() {
      filter1 = null;
      return filter2 = null;
    });
    beforeEach(function() {
      return stanza = "<xml/>";
    });
    afterEach(function() {
      filter1.reset();
      filter2.reset();
      filters = null;
      stanza = null;
      return selfID = null;
    });
    it('should run all filters and return true if they all pass', function() {
      filter1.returns(true);
      filter2.returns(true);
      filters = [filter1, filter2];
      EventFilters.run(stanza, filters, selfID).should.be["true"];
      filter1.should.have.been.calledOnce.calledWithExactly(stanza, selfID);
      return filter2.should.have.been.calledOnce.calledWithExactly(stanza, selfID);
    });
    it('should run all filters and return false if any one fails', function() {
      filter1.returns(true);
      filter2.returns(false);
      filters = [filter1, filter2];
      EventFilters.run(stanza, filters, selfID).should.be["false"];
      filter1.should.have.been.calledOnce.calledWithExactly(stanza, selfID);
      return filter2.should.have.been.calledOnce.calledWithExactly(stanza, selfID);
    });
    return it('should run all filters and throw an exception if filter not found', function() {
      expect(function() {
        return EventFilters.run(stanza, [null], selfID);
      }).to["throw"].Error;
      expect(function() {
        return EventFilters.run(stanza, [void 0], selfID);
      }).to["throw"].Error;
      return expect(function() {
        return EventFilters.run(stanza, ['notAFunction'], selfID);
      }).to["throw"].Error;
    });
  });
  describe('.filterByRecipient()', function() {
    var callback, stanza;
    stanza = null;
    callback = null;
    beforeEach(function() {
      stanza = {
        getAttribute: sinon.stub()
      };
      callback = sinon.stub();
      return sinon.stub(EventFilters, 'matchBareJID');
    });
    afterEach(function() {
      EventFilters.matchBareJID.restore();
      stanza = null;
      return callback = null;
    });
    it('should return a function', function() {
      return EventFilters.filterByRecipient(callback, "stanzaJID").should.be.a('function');
    });
    it('should invoke the callback if attribute matches exact jid', function() {
      var filteredCallback;
      filteredCallback = EventFilters.filterByRecipient(callback, "stanzaJID");
      stanza.getAttribute.withArgs('to').returns("stanzaJID");
      filteredCallback(stanza);
      return callback.should.have.been.calledOnce.calledWith(stanza);
    });
    it('should not invoke the callback if attribute does not match the exact jid', function() {
      var filteredCallback;
      filteredCallback = EventFilters.filterByRecipient(callback, "somejid");
      stanza.getAttribute.withArgs('to').returns("stanzaJID");
      filteredCallback(stanza);
      return callback.should.not.have.been.called;
    });
    it('should invoke the callback if attribute at least matches the bare jid', function() {
      var filteredCallback;
      filteredCallback = EventFilters.filterByRecipient(callback, "expectedJID", true);
      stanza.getAttribute.withArgs('to').returns("stanzaJID");
      EventFilters.matchBareJID.withArgs("expectedJID", "stanzaJID").returns(true);
      filteredCallback(stanza);
      return callback.should.have.been.calledOnce.calledWith(stanza);
    });
    return it('should not invoke the callback if attribute does not even match the bare jid', function() {
      var filteredCallback;
      filteredCallback = EventFilters.filterByRecipient(callback, "expectedJID", true);
      stanza.getAttribute.withArgs('to').returns("stanzaJID");
      EventFilters.matchBareJID.withArgs("expectedJID", "stanzaJID").returns(false);
      filteredCallback(stanza);
      return callback.should.not.have.been.called;
    });
  });
  describe('.filterBySender()', function() {
    var callback, stanza;
    stanza = null;
    callback = null;
    beforeEach(function() {
      stanza = {
        getAttribute: sinon.stub()
      };
      callback = sinon.stub();
      return sinon.stub(EventFilters, 'matchBareJID');
    });
    afterEach(function() {
      EventFilters.matchBareJID.restore();
      stanza = null;
      return callback = null;
    });
    it('should return a function', function() {
      return EventFilters.filterBySender(callback, "stanzaJID").should.be.a('function');
    });
    it('should invoke the callback if attribute matches exact jid', function() {
      var filteredCallback;
      filteredCallback = EventFilters.filterBySender(callback, "stanzaJID");
      stanza.getAttribute.withArgs('from').returns("stanzaJID");
      filteredCallback(stanza);
      return callback.should.have.been.calledOnce.calledWith(stanza);
    });
    it('should not invoke the callback if attribute does not match the exact jid', function() {
      var filteredCallback;
      filteredCallback = EventFilters.filterBySender(callback, "somejid");
      stanza.getAttribute.withArgs('from').returns("stanzaJID");
      filteredCallback(stanza);
      return callback.should.not.have.been.called;
    });
    it('should invoke the callback if attribute at least matches the bare jid', function() {
      var filteredCallback;
      filteredCallback = EventFilters.filterBySender(callback, "expectedJID", true);
      stanza.getAttribute.withArgs('from').returns("stanzaJID");
      EventFilters.matchBareJID.withArgs("expectedJID", "stanzaJID").returns(true);
      filteredCallback(stanza);
      return callback.should.have.been.calledOnce.calledWith(stanza);
    });
    return it('should not invoke the callback if attribute does not even match the bare jid', function() {
      var filteredCallback;
      filteredCallback = EventFilters.filterBySender(callback, "expectedJID", true);
      stanza.getAttribute.withArgs('from').returns("stanzaJID");
      EventFilters.matchBareJID.withArgs("expectedJID", "stanzaJID").returns(false);
      filteredCallback(stanza);
      return callback.should.not.have.been.called;
    });
  });
  describe('#isHistoryFin()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true when the stanza contains a fin stanza', function() {
      var stanza;
      xml = '<something><fin xmlns="urn:xmpp:mam:tmp"></fin></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isHistoryFin(stanza).should.be["true"];
    });
    return it('should return false when the stanza does not contain a fin stanza', function() {
      var stanza;
      xml = '<something><x xmlns="http://jabber.org/protocol/"></x></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isHistoryFin(stanza).should.be["false"];
    });
  });
  describe('#isntHistoryFin()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true when the stanza does not contain a fin stanza', function() {
      var stanza;
      xml = '<something><x xmlns="http://jabber.org/protocol/"></x></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isntHistoryFin(stanza).should.be["true"];
    });
    return it('should return false when the stanza contains a fin stanza', function() {
      var stanza;
      xml = '<something><fin xmlns="urn:xmpp:mam:tmp"></fin></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isntHistoryFin(stanza).should.be["false"];
    });
  });
  describe('#isMUCSubject()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true when the stanza contains a subject stanza', function() {
      var stanza;
      xml = '<message type="groupchat"><subject>the subject</subject></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isMUCSubject(stanza).should.be["true"];
    });
    return it('should return false when the stanza does not contain a subject stanza', function() {
      var stanza;
      xml = '<something><x xmlns="http://jabber.org/protocol/"></x></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isMUCSubject(stanza).should.be["false"];
    });
  });
  describe('#isntMUCSubject()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true when the stanza does not contain a subject stanza', function() {
      var stanza;
      xml = '<something><x xmlns="http://jabber.org/protocol/"></x></something>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isntMUCSubject(stanza).should.be["true"];
    });
    return it('should return false when the stanza contains a fin stanza', function() {
      var stanza;
      xml = '<message type="groupchat"><subject>the subject</subject></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isntMUCSubject(stanza).should.be["false"];
    });
  });
  describe('#isTypingNotice()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true when the stanza contains a composing stanza', function() {
      var stanza;
      xml = '<message><composing xmlns="' + ChatStatesNS.CHAT_STATES + '"/></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isTypingNotice(stanza).should.be["true"];
    });
    return it('should return false when the stanza does not contain a composing stanza', function() {
      var stanza;
      xml = '<message type="groupchat"><body>foo</body></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isTypingNotice(stanza).should.be["false"];
    });
  });
  describe('#isntTypingNotice()', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return false when the stanza contains a composing stanza', function() {
      var stanza;
      xml = '<message><composing xmlns="' + ChatStatesNS.CHAT_STATES + '"/></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isntTypingNotice(stanza).should.be["false"];
    });
    return it('should return true when the stanza does not contain a composing stanza', function() {
      var stanza;
      xml = '<message type="groupchat"><body>foo</body></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.isntTypingNotice(stanza).should.be["true"];
    });
  });
  describe('#hasBodyTag', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true if the stanza has a body tag', function() {
      var stanza;
      xml = '<message type="groupchat"><body>foo</body></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.hasBodyTag(stanza).should.be["true"];
    });
    return it('should return false if the stanza does not have a body tag', function() {
      var stanza;
      xml = '<message type="groupchat"></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.hasBodyTag(stanza).should.be["false"];
    });
  });
  describe('#hasntBodyTag', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true if the stanza does not have a body tag', function() {
      var stanza;
      xml = '<message type="groupchat"></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.hasntBodyTag(stanza).should.be["true"];
    });
    return it('should return false if the stanza has a body tag', function() {
      var stanza;
      xml = '<message type="groupchat"><body>foo</body></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.hasntBodyTag(stanza).should.be["false"];
    });
  });
  describe('#hasStatusTag', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true if the stanza has a status tag', function() {
      var stanza;
      xml = '<message type="groupchat"><status code="104"/></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.hasStatusTag(stanza).should.be["true"];
    });
    return it('should return false if the stanza does not have a status tag', function() {
      var stanza;
      xml = '<message type="groupchat"><body>foo</body></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.hasStatusTag(stanza).should.be["false"];
    });
  });
  return describe('#hasntStatusTag', function() {
    var xml;
    xml = null;
    afterEach(function() {
      return xml = null;
    });
    it('should return true if the stanza does not have a status tag', function() {
      var stanza;
      xml = '<message type="groupchat"><body>foo</body></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.hasntStatusTag(stanza).should.be["true"];
    });
    return it('should return false if the stanza has a status tag', function() {
      var stanza;
      xml = '<message type="groupchat"><status code="104"/></message>';
      stanza = convertXMLToStanza(xml);
      return EventFilters.hasntStatusTag(stanza).should.be["false"];
    });
  });
});


},{"enum/chat_states_ns":"enum/chat_states_ns","events/event_filters":"events/event_filters","spec/spec_helper":"spec/spec_helper"}],"spec/events/event_handler_spec":[function(require,module,exports){
var EventFilters, EventHandler, Strophe, _, convertXMLToStanza, expect, ref, sinon;

ref = require('spec/spec_helper'), sinon = ref.sinon, expect = ref.expect, _ = ref._, convertXMLToStanza = ref.convertXMLToStanza;

EventHandler = require('events/event_handler');

EventFilters = require('events/event_filters');

Strophe = require('strophe');

describe('EventHandler', function() {
  var eventHandler, path;
  eventHandler = null;
  path = null;
  beforeEach(function() {
    return path = 'path.to.event';
  });
  afterEach(function() {
    eventHandler = null;
    return path = null;
  });
  describe('#constructor()', function() {
    var config;
    config = null;
    beforeEach(function() {
      return config = {
        ns: 'ns',
        name: 'name',
        type: 'type',
        id: 'id',
        from: 'from',
        filters: ["a", "b"]
      };
    });
    afterEach(function() {
      return config = null;
    });
    it('should accept a config object', function() {
      eventHandler = new EventHandler(config);
      eventHandler.config.ns.should.equal(config.ns);
      eventHandler.config.name.should.equal(config.name);
      eventHandler.config.type.should.equal(config.type);
      eventHandler.config.id.should.equal(config.id);
      eventHandler.config.from.should.equal(config.from);
      return eventHandler.config.filters.should.equal(config.filters);
    });
    it('should accept a `matchBare` property', function() {
      config = _.extend(config, {
        matchBare: true
      });
      eventHandler = new EventHandler(config);
      eventHandler.config.matchBare.should.be["true"];
      return eventHandler.config.options.matchBare.should.be["true"];
    });
    it('should accept a `matchBare` property', function() {
      eventHandler = new EventHandler(config);
      expect(eventHandler.config.matchBare).to.not.exist;
      return eventHandler.config.options.matchBare.should.be["false"];
    });
    return it('should have an empty callbacks object', function() {
      return new EventHandler(config).should.have.a.property('_callbacks').that.eqls({});
    });
  });
  describe('#addCallback()', function() {
    var callback;
    callback = null;
    beforeEach(function() {
      return eventHandler = new EventHandler();
    });
    afterEach(function() {
      return callback = null;
    });
    it('should return an id', function() {
      var id;
      callback = sinon.stub();
      id = eventHandler.addCallback(callback);
      return id.should.be.a('string');
    });
    it('should add a callback', function() {
      var id;
      callback = sinon.stub();
      id = eventHandler.addCallback(callback);
      return eventHandler._callbacks[id].should.equal(callback);
    });
    return it('should return null if not passed a callback function', function() {
      expect(eventHandler.addCallback()).to.be["null"];
      expect(eventHandler.addCallback(null)).to.be["null"];
      expect(eventHandler.addCallback(1)).to.be["null"];
      expect(eventHandler.addCallback("function")).to.be["null"];
      expect(eventHandler.addCallback(true)).to.be["null"];
      return expect(eventHandler.addCallback([])).to.be["null"];
    });
  });
  describe('#hasCallbacks()', function() {
    beforeEach(function() {
      return eventHandler = new EventHandler();
    });
    it('should return true if there are callbacks', function() {
      eventHandler._callbacks = {
        'abcd': sinon.stub(),
        'efgh': sinon.stub()
      };
      return eventHandler.hasCallbacks().should.be["true"];
    });
    return it('should return false if there are no callbacks', function() {
      return eventHandler.hasCallbacks().should.be["false"];
    });
  });
  describe('#getStropheHandler()', function() {
    beforeEach(function() {
      return eventHandler = new EventHandler();
    });
    it('should return the Strophe.Handler instance if there is one', function() {
      var stropheHandler;
      stropheHandler = new Strophe.Handler();
      eventHandler._stropheHandler = stropheHandler;
      return eventHandler.getStropheHandler().should.equal(stropheHandler);
    });
    return it('should return null if there is no Strophe.Handler instance', function() {
      return expect(eventHandler.getStropheHandler()).to.be["null"];
    });
  });
  describe('#setStropheHandler()', function() {
    beforeEach(function() {
      return eventHandler = new EventHandler();
    });
    it('should set a Strophe.Handler instance', function() {
      var stropheHandler;
      stropheHandler = new Strophe.Handler();
      eventHandler.setStropheHandler(stropheHandler);
      return eventHandler._stropheHandler.should.equal(stropheHandler);
    });
    it('should not set anything that is not a Strophe.Handler instance', function() {
      var nonStropheHandler;
      nonStropheHandler = {};
      eventHandler.setStropheHandler(nonStropheHandler).should.equal(eventHandler);
      return expect(eventHandler._stropheHandler).to.be["null"];
    });
    it('should set the Strophe handler to null when the `reset` flag is true', function() {
      var stropheHandler;
      stropheHandler = new Strophe.Handler();
      eventHandler._stropheHandler = stropheHandler;
      eventHandler.setStropheHandler(null, true);
      return expect(eventHandler._stropheHandler).to.be["null"];
    });
    return it('should be a fluent method returning this', function() {
      var stropheHandler;
      stropheHandler = new Strophe.Handler();
      return eventHandler.setStropheHandler(stropheHandler).should.equal(eventHandler);
    });
  });
  describe('#reset()', function() {
    beforeEach(function() {
      eventHandler = new EventHandler();
      sinon.stub(eventHandler, 'setStropheHandler');
      return sinon.stub(eventHandler, 'resetCallbacks');
    });
    afterEach(function() {
      eventHandler.setStropheHandler.restore();
      return eventHandler.resetCallbacks.restore();
    });
    it('should reset the Strophe.Handler by calling #setStropheHandler()', function() {
      eventHandler.reset();
      return eventHandler.setStropheHandler.should.have.been.calledOnce.calledWithExactly(null, true);
    });
    return it('should reset the callbacks calling #resetCallbacks()', function() {
      eventHandler.reset();
      return eventHandler.resetCallbacks.should.have.been.calledOnce;
    });
  });
  describe('#resetCallbacks()', function() {
    beforeEach(function() {
      return eventHandler = new EventHandler();
    });
    it('should delete all callbacks', function() {
      var callbacks, deletedIds;
      callbacks = {
        abcd: sinon.stub(),
        efgh: sinon.stub()
      };
      eventHandler._callbacks = callbacks;
      deletedIds = eventHandler.resetCallbacks();
      return eventHandler._callbacks.should.be.empty;
    });
    return it('should return an array of deleted callback ids', function() {
      var callbacks, deletedIds;
      callbacks = {
        abcd: sinon.stub(),
        efgh: sinon.stub()
      };
      eventHandler._callbacks = callbacks;
      deletedIds = eventHandler.resetCallbacks();
      _.contains(deletedIds, 'abcd').should.be["true"];
      return _.contains(deletedIds, 'abcd').should.be["true"];
    });
  });
  describe('#getSignatureArgs()', function() {
    var selfJID;
    selfJID = null;
    beforeEach(function() {
      eventHandler = new EventHandler();
      return selfJID = 'selfJID';
    });
    afterEach(function() {
      return selfJID = null;
    });
    it('should store the selfJID passed into it', function() {
      eventHandler.getSignatureArgs(selfJID);
      return eventHandler.should.have.a.property('selfJID').that.equals(selfJID);
    });
    it('should return an array of selected values', function() {
      var config;
      config = {
        ns: 'ns',
        name: 'name',
        type: 'type',
        id: 'id',
        from: 'from',
        options: {}
      };
      eventHandler.config = config;
      return eventHandler.getSignatureArgs(selfJID).should.eql(['ns', 'name', 'type', 'id', 'from', {}]);
    });
    return it('should use selfJID when specified by the `from` field', function() {
      var config;
      config = {
        ns: 'ns',
        name: 'name',
        type: 'type',
        id: 'id',
        from: EventFilters.SELF_JID,
        options: {}
      };
      eventHandler.config = config;
      return eventHandler.getSignatureArgs(selfJID).should.eql(['ns', 'name', 'type', 'id', selfJID, {}]);
    });
  });
  return describe('#invokeCallbacks()', function() {
    var callback1, callback2, stanza;
    callback1 = null;
    callback2 = null;
    stanza = null;
    beforeEach(function() {
      eventHandler = new EventHandler();
      eventHandler.config.filters = [];
      eventHandler.selfJID = 'selfJID';
      callback1 = sinon.stub();
      callback2 = sinon.stub();
      eventHandler._callbacks = {
        abcd: callback1,
        efgh: callback2
      };
      stanza = convertXMLToStanza('<something><x xmlns="http://jabber.org/"></x></something>');
      return sinon.stub(EventFilters, 'run').returns(true);
    });
    afterEach(function() {
      EventFilters.run.restore();
      callback1 = null;
      callback2 = null;
      return stanza = null;
    });
    it('should run event filters', function() {
      eventHandler.invokeCallbacks(stanza);
      return EventFilters.run.should.have.been.calledOnce.calledWithExactly(stanza, eventHandler.config.filters, eventHandler.selfJID);
    });
    it('should exit early if it does not pass the filters', function() {
      EventFilters.run.returns(false);
      eventHandler.invokeCallbacks(stanza).should.equal(eventHandler);
      callback1.should.not.have.been.called;
      return callback2.should.not.have.been.called;
    });
    it('should invoke all callbacks', function() {
      eventHandler.invokeCallbacks(stanza);
      callback1.should.have.been.calledOnce.calledWithExactly(sinon.match.object);
      return callback2.should.have.been.calledOnce.calledWithExactly(sinon.match.object);
    });
    it('should catch any callback errors', function() {
      callback1.throws(new Error("callback error1"));
      return expect(function() {
        return eventHandler.invokeCallbacks(stanza);
      }).to.not["throw"].Error;
    });
    return it('should be a fluent method returning this', function() {
      return eventHandler.invokeCallbacks(stanza).should.equal(eventHandler);
    });
  });
});


},{"events/event_filters":"events/event_filters","events/event_handler":"events/event_handler","spec/spec_helper":"spec/spec_helper","strophe":"lib/strophe"}],"spec/events/event_manager_spec":[function(require,module,exports){
var EventHandler, EventManager, Strophe, Utils, _, assert, expect, ref, sinon;

ref = require('spec/spec_helper'), sinon = ref.sinon, assert = ref.assert, expect = ref.expect, _ = ref._;

Strophe = require('strophe');

EventManager = require('events/event_manager');

EventHandler = require('events/event_handler');

Utils = require('util/utils');

describe('EventManager', function() {
  var EventHandlerStub, addHandlerStub, deleteHandlerStub, eventManager, eventsConfig, lazyStub, options, selfJID;
  EventHandlerStub = (function() {
    function EventHandlerStub() {}

    EventHandlerStub.prototype.getStropheHandler = sinon.stub().returns(new Strophe.Handler());

    EventHandlerStub.prototype.setStropheHandler = sinon.stub();

    EventHandlerStub.prototype.addCallback = sinon.stub();

    EventHandlerStub.prototype.removeCallback = sinon.stub();

    EventHandlerStub.prototype.hasCallbacks = sinon.stub();

    EventHandlerStub.prototype.resetCallbacks = sinon.stub();

    EventHandlerStub.prototype.getSignatureArgs = sinon.stub();

    EventHandlerStub.prototype.invokeCallbacks = sinon.stub();

    EventHandlerStub.prototype.resetStropheHandler = sinon.stub();

    return EventHandlerStub;

  })();
  eventManager = null;
  addHandlerStub = null;
  deleteHandlerStub = null;
  eventsConfig = null;
  options = null;
  selfJID = null;
  lazyStub = null;
  before(function() {
    return sinon.stub(Utils, 'conditional');
  });
  after(function() {
    return Utils.conditional.restore();
  });
  beforeEach(function() {
    lazyStub = sinon.stub();
    Utils.conditional.returns(lazyStub);
    selfJID = "selfjid";
    addHandlerStub = sinon.stub();
    deleteHandlerStub = sinon.stub();
    eventsConfig = {
      'path.to.event1': {},
      'path.to.event2': {}
    };
    return options = {
      addHandler: addHandlerStub,
      deleteHandler: deleteHandlerStub,
      config: eventsConfig,
      handlerClass: EventHandlerStub
    };
  });
  afterEach(function() {
    lazyStub.reset();
    Utils.conditional.reset();
    eventManager = null;
    addHandlerStub.reset();
    deleteHandlerStub.reset();
    eventsConfig = null;
    options = null;
    selfJID = null;
    return EventManager.destroy();
  });
  describe('creating a singleton instance', function() {
    return it('should build an events dictionary', function() {
      var i, keys, len, results, value, values;
      eventManager = EventManager.get(options);
      eventManager.should.have.a.property('_eventsDictionary');
      keys = _.keys(eventManager._eventsDictionary);
      values = _.values(eventManager._eventsDictionary);
      keys.should.eql(_.keys(eventsConfig));
      results = [];
      for (i = 0, len = values.length; i < len; i++) {
        value = values[i];
        results.push(value.should.be.an["instanceof"](EventHandlerStub));
      }
      return results;
    });
  });
  describe('#toggleConnection()', function() {
    beforeEach(function() {
      return eventManager = EventManager.get(options);
    });
    it('should store the selfJID when connected', function() {
      eventManager.toggleConnection(true, selfJID);
      return eventManager._selfJID.should.equal(selfJID);
    });
    it('should add strophe handlers lazily, when connected', function() {
      Utils.conditional.returns(lazyStub);
      eventManager.toggleConnection(true, selfJID);
      return lazyStub.should.have.been.calledTwice.calledWith(sinon.match.instanceOf(EventHandlerStub), selfJID);
    });
    return it('should call #removeStropheHandlers when disconnected', function() {
      eventManager.toggleConnection(false);
      return deleteHandlerStub.should.have.been.calledTwice;
    });
  });
  describe('#listenTo()', function() {
    var callback1, callback2, path1, path2;
    path1 = null;
    path2 = null;
    callback1 = null;
    callback2 = null;
    beforeEach(function() {
      eventManager = EventManager.get(options);
      eventManager._selfJID = 'selfJID';
      path1 = 'path.to.event1';
      path2 = 'path.to.event2';
      callback1 = sinon.stub();
      return callback2 = sinon.stub();
    });
    afterEach(function() {
      path1 = null;
      path1 = null;
      callback1 = null;
      return callback2 = null;
    });
    it('should add a callback for a specified event path', function() {
      eventManager.listenTo(path1, callback1);
      return eventManager._eventsDictionary[path1].addCallback.should.have.been.calledOnce.calledWithExactly(callback1, false);
    });
    it('should return an id string', function() {
      var callback, callbackId, path1Handler;
      callback = sinon.stub();
      path1Handler = eventManager._eventsDictionary[path1];
      path1Handler.getStropheHandler.returns(null);
      path1Handler.addCallback.returns("abcd");
      callbackId = eventManager.listenTo(path1, callback1);
      return callback1.should.be.a.string;
    });
    it('should add a Strophe Handler for an event path that has not yet been listend to', function() {
      var callback, path1Handler;
      callback = sinon.stub();
      path1Handler = eventManager._eventsDictionary[path1];
      path1Handler.getStropheHandler.returns(null);
      path1Handler.addCallback.returns("abcd");
      eventManager.listenTo(path1, callback1);
      return lazyStub.should.have.been.calledOnce.calledWith(path1Handler, eventManager._selfJID);
    });
    it('should not instantiate a Strophe Handler for an event path that already has one', function() {
      var callback, path1Handler;
      callback = sinon.stub();
      path1Handler = eventManager._eventsDictionary[path1];
      path1Handler.getStropheHandler.returns(new Strophe.Handler());
      path1Handler.addCallback.returns("abcd");
      eventManager.listenTo(path1, callback1);
      return lazyStub.should.not.have.been.called;
    });
    return it('should throw an exception when trying to add a callback for an unsupported event', function() {
      var pathCallbacks;
      expect(function() {
        return listenTo('path.does.not.exist', callback1);
      }).to["throw"](Error);
      pathCallbacks = {
        'path.does.not.exist': callback1,
        'another.path.does.not.exist': callback2
      };
      return expect(function() {
        return listenTo(pathCallbacks);
      }).to["throw"](Error);
    });
  });
  describe('#listenToOnce()', function() {
    beforeEach(function() {
      eventManager = EventManager.get(options);
      return sinon.stub(eventManager, 'listenTo');
    });
    afterEach(function() {
      return eventManager.listenTo.restore();
    });
    return it('should call #listenTo() with the same arguments and an additional true flag', function() {
      var callback, path;
      path = "some.event.path";
      callback = sinon.stub();
      eventManager.listenToOnce(path, callback);
      return eventManager.listenTo.should.have.been.calledOnce.calledWithExactly(path, callback, true);
    });
  });
  return describe('#stopListening()', function() {
    var path1, path2;
    path1 = null;
    path2 = null;
    beforeEach(function() {
      eventManager = EventManager.get(options);
      path1 = 'path.to.event1';
      return path2 = 'path.to.event2';
    });
    afterEach(function() {
      path1 = null;
      return path2 = null;
    });
    it('should return the id of the callback being deleted', function() {
      var callbackId, path1Handler, result;
      callbackId = "abcd";
      path1Handler = eventManager._eventsDictionary[path1];
      path1Handler.removeCallback.withArgs(callbackId).returns('abcd');
      result = eventManager.stopListening(callbackId);
      return result.should.equal('abcd');
    });
    it('should return undefined if no callback exists with the specified id', function() {
      var callbackId, path1Handler, result;
      callbackId = "abcd";
      path1Handler = eventManager._eventsDictionary[path1];
      path1Handler.removeCallback.withArgs(callbackId).returns(null);
      result = eventManager.stopListening(callbackId);
      return expect(result).to.not.exist;
    });
    return it('should call #removeCallback() on each EventHandler instance', function() {
      var callbackId, path1Handler, path2Handler;
      callbackId = "abcd";
      eventManager._eventsDictionary = {
        'path1': path1Handler = {
          removeCallback: sinon.stub()
        },
        'path2': path2Handler = {
          removeCallback: sinon.stub()
        }
      };
      eventManager.stopListening(callbackId);
      path1Handler.removeCallback.should.have.been.calledOnce.calledWithExactly(callbackId);
      return path2Handler.removeCallback.should.have.been.calledOnce.calledWithExactly(callbackId);
    });
  });
});


},{"events/event_handler":"events/event_handler","events/event_manager":"events/event_manager","spec/spec_helper":"spec/spec_helper","strophe":"lib/strophe","util/utils":"util/utils"}],"spec/events/events_spec":[function(require,module,exports){
var EventFilters, Events, _, assert, expect, ref, sinon;

ref = require('spec/spec_helper'), _ = ref._, assert = ref.assert, expect = ref.expect, sinon = ref.sinon;

Events = require('events/events');

EventFilters = require('events/event_filters');

describe('Events', function() {
  describe('.filterByRecipient()', function() {
    beforeEach(function() {
      return sinon.stub(EventFilters, 'filterByRecipient');
    });
    afterEach(function() {
      return EventFilters.filterByRecipient.restore();
    });
    return it('should call #filterByRecipient() on EventFilters with the same arguments', function() {
      Events.filterByRecipient((function() {}), "jid");
      return EventFilters.filterByRecipient.should.have.been.calledOnce.calledWith(sinon.match.func, "jid");
    });
  });
  return describe('.filterBySender()', function() {
    before(function() {
      return sinon.stub(EventFilters, 'filterBySender');
    });
    afterEach(function() {
      return EventFilters.filterBySender.restore();
    });
    return it('should call #filterBySender() on EventFilters with the same arguments', function() {
      Events.filterBySender((function() {}), "jid");
      return EventFilters.filterBySender.should.have.been.calledOnce.calledWith(sinon.match.func, "jid");
    });
  });
});


},{"events/event_filters":"events/event_filters","events/events":"events/events","spec/spec_helper":"spec/spec_helper"}],"spec/framework_spec":[function(require,module,exports){
var Q, X2JS, _, assert, expect, fixtures, ref, sinon;

ref = require('spec/spec_helper'), _ = ref._, fixtures = ref.fixtures, X2JS = ref.X2JS, Q = ref.Q, assert = ref.assert, expect = ref.expect, sinon = ref.sinon;

describe('framework', function() {
  var x2js;
  x2js = null;
  before(function() {
    return x2js = new X2JS();
  });
  after(function() {
    return x2js = null;
  });
  describe('loading fixtures', function() {
    it('should load a file', function() {
      var body, json;
      fixtures.load('fixture1.html');
      body = fixtures.body();
      json = x2js.xml2json(x2js.parseXmlString(fixtures.body()));
      return json.testing.toString().should.equal("This is some content");
    });
    return it('should not access a previously loaded fixture', function() {
      return expect(fixtures.body()).to.not.exist;
    });
  });
  describe('unit test assertions', function() {
    it('should assert', function() {
      return assert(true);
    });
    return it('should expect', function() {
      return expect(null).to.be["null"];
    });
  });
  describe('underscore', function() {
    return it('should use underscore', function() {
      return _.isEmpty({}).should.be["true"];
    });
  });
  xdescribe('promises', function() {
    it('should call a done handler asynchronously', function(done) {
      var dfd, handler;
      handler = sinon.spy(function(data) {
        handler.should.have.been.calledOnce.calledWith("data");
        return done();
      });
      dfd = Q.defer();
      dfd.promise.then(handler);
      return dfd.resolve("data");
    });
    it('should immediately resolve a deferred and assert using chai-as-promised', function(done) {
      var dfd;
      dfd = Q.defer();
      dfd.resolve("data");
      return dfd.promise.should.eventually.equal("data").notify(done);
    });
    return it('should eventually resolve a deferred and assert using chai-as-promised', function(done) {
      var dfd;
      dfd = Q.defer();
      dfd.promise.should.eventually.equal("data").notify(done);
      return dfd.resolve("data");
    });
  });
  return describe('sinon useFakeTimers', function() {
    var clock;
    clock = null;
    beforeEach(function() {
      return clock = sinon.useFakeTimers();
    });
    afterEach(function() {
      return clock.restore();
    });
    it('should wait for a delay', function() {
      var a, time1, time2;
      a = 1;
      time1 = new Date().getTime();
      _.delay(function() {
        return a = 2;
      }, 1000);
      clock.tick(2000);
      time2 = new Date().getTime();
      a.should.equal(2);
      return (time2 - time1).should.equal(2000);
    });
    it('true', function() {
      return assert(true);
    });
    return it('should wait for setTimeout', function() {
      var a, time1, time2;
      a = 1;
      time1 = new Date().getTime();
      setTimeout(function() {
        return a = 2;
      }, 1000);
      clock.tick(2000);
      time2 = new Date().getTime();
      a.should.equal(2);
      return (time2 - time1).should.equal(2000);
    });
  });
});


},{"spec/spec_helper":"spec/spec_helper"}],"spec/spec_helper":[function(require,module,exports){
var chai;

chai = require('chai');

module.exports = {
  fixtures: require('js-fixtures'),
  X2JS: require('xml-json-parser'),
  _: require('underscore'),
  Q: require('q'),
  chai: chai,
  sinon: require('sinon'),
  sinonChai: require('sinon-chai'),
  chaiAsPromised: require('chai-as-promised'),
  assert: chai.assert,
  expect: chai.expect,
  trimFixture: function(str) {
    return str.trim().replace(/(>(\s+|\n+|\r+| )<)/gm, "><");
  },
  convertXMLToStanza: function(xml) {
    var dom, parser;
    parser = new DOMParser();
    dom = parser.parseFromString(xml, "text/xml");
    return dom.firstChild;
  }
};


},{"chai":11,"chai-as-promised":10,"js-fixtures":46,"q":47,"sinon":57,"sinon-chai":56,"underscore":85,"xml-json-parser":90}],"spec/spec_runner":[function(require,module,exports){
var Q, X2JS, chai, chaiAsPromised, fixtures, ref, sinon, sinonChai;

ref = require('spec/spec_helper'), X2JS = ref.X2JS, sinon = ref.sinon, chai = ref.chai, fixtures = ref.fixtures, sinonChai = ref.sinonChai, chaiAsPromised = ref.chaiAsPromised;

Q = require('q');

require('spec/framework_spec');

require('spec/suites/util_suite_spec');

require('spec/suites/connection_suite_spec');

require('spec/suites/events_suite_spec');

require('spec/adapters/adapters_spec');

before(function() {
  var base;
  fixtures.path = 'fixtures';
  chai.use(sinonChai);
  chai.use(chaiAsPromised);
  chai.should();
  return (base = Function.prototype).bind != null ? base.bind : base.bind = function(thisp) {
    var fn;
    fn = this;
    return function() {
      return fn.apply(thisp, arguments);
    };
  };
});

afterEach(function() {
  return fixtures.cleanUp();
});


},{"q":47,"spec/adapters/adapters_spec":"spec/adapters/adapters_spec","spec/framework_spec":"spec/framework_spec","spec/spec_helper":"spec/spec_helper","spec/suites/connection_suite_spec":"spec/suites/connection_suite_spec","spec/suites/events_suite_spec":"spec/suites/events_suite_spec","spec/suites/util_suite_spec":"spec/suites/util_suite_spec"}],"spec/strophe/strophe_blocklist_spec":[function(require,module,exports){
var _, expect, fixtures, ref, sinon, stropheBlocklist, trimFixture;

ref = require('spec/spec_helper'), expect = ref.expect, sinon = ref.sinon, _ = ref._, fixtures = ref.fixtures, trimFixture = ref.trimFixture;

stropheBlocklist = require('strophe/strophe_blocklist');

describe('stropheBlocklist', function() {
  var jids, stanza;
  stanza = null;
  jids = null;
  afterEach(function() {
    stanza = null;
    return jids = null;
  });
  describe('#getBlocklistStanza()', function() {
    return it('should return a stanza for getting the blocklist', function() {
      var fixture;
      fixture = fixtures.read('blocklist/get.xml');
      stanza = stropheBlocklist.getBlocklistStanza();
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getBlockStanza()', function() {
    return it('should return a stanza for getting the block stanza', function() {
      var fixture;
      fixture = fixtures.read('blocklist/block.xml');
      jids = ['jid1', 'jid2'];
      stanza = stropheBlocklist.getBlockStanza(jids);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  return describe('#getUnblockStanza()', function() {
    return it('should return a stanza for getting the unblock stanza', function() {
      var fixture;
      fixture = fixtures.read('blocklist/unblock.xml');
      jids = ['jid1', 'jid2'];
      stanza = stropheBlocklist.getUnblockStanza(jids);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
});


},{"spec/spec_helper":"spec/spec_helper","strophe/strophe_blocklist":"strophe/strophe_blocklist"}],"spec/strophe/strophe_disco_spec":[function(require,module,exports){
var MUCNS, X2JS, _, expect, fixtures, ref, sinon, stropheDisco, trimFixture;

ref = require('spec/spec_helper'), expect = ref.expect, sinon = ref.sinon, _ = ref._, fixtures = ref.fixtures, X2JS = ref.X2JS, trimFixture = ref.trimFixture;

stropheDisco = require('strophe/strophe_disco');

MUCNS = require('enum/muc_ns');

describe('stropheDisco', function() {
  var domain;
  domain = 'reuters.net';
  it('contstructs an <iq/> element', function() {
    var element;
    element = stropheDisco.getDiscoStanza(domain);
    return element.nodeName === 'IQ';
  });
  it('adds a <query/> child with the correct ns', function() {
    var element;
    element = stropheDisco.getDiscoStanza(domain);
    return element.tree().firstChild.nodeName === 'QUERY' && element.tree().firstChild.getAttribute('xmlns' === MUCNS.DISCO_INFO);
  });
  it('constructs a disco#info element with the provided domain', function() {
    var element;
    element = stropheDisco.getDiscoStanza(domain);
    return element.tree().getAttribute('to') === domain;
  });
  return it('matches a known fixture', function() {
    var fixture, stanza;
    fixture = fixtures.read('disco/info.xml');
    stanza = stropheDisco.getDiscoStanza(domain);
    return stanza.toString().should.equal(trimFixture(fixture));
  });
});


},{"enum/muc_ns":"enum/muc_ns","spec/spec_helper":"spec/spec_helper","strophe/strophe_disco":"strophe/strophe_disco"}],"spec/strophe/strophe_io_spec":[function(require,module,exports){
var StropheIO, assert, ref, should, sinon;

ref = require('spec/spec_helper'), sinon = ref.sinon, assert = ref.assert, should = ref.should;

StropheIO = require('strophe/strophe_io');

describe('StropheIO', function() {
  describe('Strophe event listeners', function() {
    it('should have an empty array of listeners for raw input by default', function() {
      var result;
      result = StropheIO.rawInputListeners;
      result.should.be.an.array;
      return result.length.should.equal(0);
    });
    it('should have an empty array of listeners for raw output by default', function() {
      var result;
      result = StropheIO.rawOutputListeners;
      result.should.be.an.array;
      return result.length.should.equal(0);
    });
    it('should have an empty array of listeners for XML input by default', function() {
      var result;
      result = StropheIO.xmlInputListeners;
      result.should.be.an.array;
      return result.length.should.equal(0);
    });
    return it('should have an empty array of listeners for XML output by default', function() {
      var result;
      result = StropheIO.xmlOutputListeners;
      result.should.be.an.array;
      return result.length.should.equal(0);
    });
  });
  describe('#addIOListener()', function() {
    it('should push a single callback function onto a list', function() {
      var cb, list;
      cb = sinon.stub();
      list = [];
      StropheIO.addIOListener(cb, list);
      list.length.should.equal(1);
      return list[0].should.equal(cb);
    });
    it('should push an array of callbacks function onto a list', function() {
      var cb1, cb2, list;
      cb1 = sinon.stub();
      cb2 = sinon.stub();
      list = [];
      StropheIO.addIOListener([cb1, cb2], list);
      list.length.should.equal(2);
      list[0].should.equal(cb1);
      return list[1].should.equal(cb2);
    });
    it('should return a function to remove a single callback from the list', function() {
      var cb, list, subject;
      cb = sinon.stub();
      list = [];
      subject = StropheIO.addIOListener(cb, list);
      subject();
      return list.length.should.equal(0);
    });
    return it('should return a function to remove multiple callbacks from the list', function() {
      var cb1, cb2, list, subject;
      cb1 = sinon.stub();
      cb2 = sinon.stub();
      list = [];
      subject = StropheIO.addIOListener([cb1, cb2], list);
      subject();
      return list.length.should.equal(0);
    });
  });
  return describe('#connectIOListeners()', function() {
    it('should connect rawInput listeners', function() {
      var callback, connection, options;
      callback = sinon.stub();
      connection = {};
      options = {
        connection: connection,
        getRawInputListeners: function() {
          return [callback];
        }
      };
      StropheIO.connectIOListeners(options);
      connection.rawInput(1, 2, 3);
      return callback.should.have.been.calledOnce.calledWithExactly(1, 2, 3);
    });
    it('should connect rawOutput listeners', function() {
      var callback, connection, options;
      callback = sinon.stub();
      connection = {};
      options = {
        connection: connection,
        getRawOutputListeners: function() {
          return [callback];
        }
      };
      StropheIO.connectIOListeners(options);
      connection.rawOutput(1, 2, 3);
      return callback.should.have.been.calledOnce.calledWithExactly(1, 2, 3);
    });
    it('should connect xmlInput listeners', function() {
      var callback, connection, options;
      callback = sinon.stub();
      connection = {};
      options = {
        connection: connection,
        getXMLInputListeners: function() {
          return [callback];
        }
      };
      StropheIO.connectIOListeners(options);
      connection.xmlInput(1, 2, 3);
      return callback.should.have.been.calledOnce.calledWithExactly(1, 2, 3);
    });
    return it('should connect xmlOutput listeners', function() {
      var callback, connection, options;
      callback = sinon.stub();
      connection = {};
      options = {
        connection: connection,
        getXMLOutputListeners: function() {
          return [callback];
        }
      };
      StropheIO.connectIOListeners(options);
      connection.xmlOutput(1, 2, 3);
      return callback.should.have.been.calledOnce.calledWithExactly(1, 2, 3);
    });
  });
});


},{"spec/spec_helper":"spec/spec_helper","strophe/strophe_io":"strophe/strophe_io"}],"spec/strophe/strophe_messaging_spec":[function(require,module,exports){
var X2JS, _, convertXMLToStanza, expect, fixtures, ref, sinon, stropheMessaging, trimFixture;

ref = require('spec/spec_helper'), expect = ref.expect, sinon = ref.sinon, _ = ref._, fixtures = ref.fixtures, X2JS = ref.X2JS, trimFixture = ref.trimFixture, convertXMLToStanza = ref.convertXMLToStanza;

stropheMessaging = require('strophe/strophe_messaging');

describe('stropheMessaging', function() {
  describe('#getSendStanza()', function() {
    it('should return a stanza for sending a message with default type of \'chat\'', function() {
      var body, fixture, id, jid, stanza;
      fixture = "<message to='my.groupchat@conference.reuters.net' type='chat' id='12345' xmlns='jabber:client'> <body>This is the message body</body> <active xmlns='http://jabber.org/protocol/chatstates'/> </message>";
      id = '12345';
      jid = "my.groupchat@conference.reuters.net";
      body = "This is the message body";
      stanza = stropheMessaging.getSendStanza(jid, body, null, id);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a stanza for sending a message with a specified type', function() {
      var body, fixture, id, jid, stanza, type;
      fixture = "<message to='my.groupchat@conference.reuters.net' type='someType' id='12345' xmlns='jabber:client'> <body>This is the message body</body> <active xmlns='http://jabber.org/protocol/chatstates'/> </message>";
      id = '12345';
      jid = "my.groupchat@conference.reuters.net";
      body = "This is the message body";
      type = "someType";
      stanza = stropheMessaging.getSendStanza(jid, body, type, id);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a stanza with delivery receipt for TR jids', function() {
      var body, fixture, id, jid, stanza;
      fixture = "<message to='first.last.company@reuters.net' type='chat' id='12345' xmlns='jabber:client'> <body>This is the message body</body> <request xmlns='nitro:xmpp:receipts'/> <active xmlns='http://jabber.org/protocol/chatstates'/> </message>";
      id = '12345';
      jid = "first.last.company@reuters.net";
      body = "This is the message body";
      stanza = stropheMessaging.getSendStanza(jid, body, null, id);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    return xit('should not request a delivery receipt for non-TR jids', function() {
      var body, fixture, id, jid, stanza;
      fixture = "<message to='first.last.company@federated.net' type='chat' id='12345' xmlns='jabber:client'> <body>This is the message body</body> <active xmlns='http://jabber.org/protocol/chatstates'/> </message>";
      id = '12345';
      jid = "first.last.company@federated.net";
      body = "This is the message body";
      stanza = stropheMessaging.getSendStanza(jid, body, null, id);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  it('should request a delivery receipt with correct ns for managed chatrooms', function() {
    var body, fixture, id, jid, stanza;
    fixture = "<message to='room.name@legacychat.reuters.net' type='chat' id='12345' xmlns='jabber:client'> <body>This is the message body</body> <request xmlns='urn:xmpp:receipts'/> <active xmlns='http://jabber.org/protocol/chatstates'/> </message>";
    id = '12345';
    jid = "room.name@legacychat.reuters.net";
    body = "This is the message body";
    stanza = stropheMessaging.getSendStanza(jid, body, null, id);
    stanza.should.be.an["instanceof"](Strophe.Builder);
    return stanza.toString().should.equal(trimFixture(fixture));
  });
  it('should not request a delivery receipt for groupchat/bilaterals', function() {
    var body, fixture, id, jid, stanza;
    fixture = "<message to='room.name@conference.reuters.net' type='chat' id='12345' xmlns='jabber:client'> <body>This is the message body</body> <active xmlns='http://jabber.org/protocol/chatstates'/> </message>";
    id = '12345';
    jid = "room.name@conference.reuters.net";
    body = "This is the message body";
    stanza = stropheMessaging.getSendStanza(jid, body, null, id);
    stanza.should.be.an["instanceof"](Strophe.Builder);
    return stanza.toString().should.equal(trimFixture(fixture));
  });
  describe('#getChatHistoryStanza()', function() {
    var alternateMax, beforeID, jid;
    jid = 'some.jid.thomsonreuters.com@reuters.net';
    beforeID = '123456';
    alternateMax = '20';
    it('should return a stanza for retreiving message history (default max)', function() {
      var fixture, stanza;
      fixture = fixtures.read('messaging/chat/history_request.xml');
      stanza = stropheMessaging.getChatHistoryStanza(jid);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a stanza for retreiving more message history (default max)', function() {
      var fixture, stanza;
      fixture = fixtures.read('messaging/chat/more_history_request.xml');
      stanza = stropheMessaging.getChatHistoryStanza(jid, beforeID);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a stanza for retreiving message history (alt max)', function() {
      var fixture, stanza;
      fixture = fixtures.read('messaging/chat/alt_max_history_request.xml');
      stanza = stropheMessaging.getChatHistoryStanza(jid, null, 20);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    return it('should return a stanza for retreiving more message history (alt max)', function() {
      var fixture, stanza;
      fixture = fixtures.read('messaging/chat/alt_max_more_history_request.xml');
      stanza = stropheMessaging.getChatHistoryStanza(jid, beforeID, 20);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getGroupchatHistoryStanza()', function() {
    var alternateMax, beforeID, jid;
    jid = 'some_chatroom.reuters.com@legacychat.reuters.net';
    beforeID = '123456';
    alternateMax = '20';
    it('should return a stanza for retreiving message history (default max)', function() {
      var fixture, stanza;
      fixture = fixtures.read('messaging/groupchat/history_request.xml');
      stanza = stropheMessaging.getGroupchatHistoryStanza(jid);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a stanza for retreiving more message history (default max)', function() {
      var fixture, stanza;
      fixture = fixtures.read('messaging/groupchat/more_history_request.xml');
      stanza = stropheMessaging.getGroupchatHistoryStanza(jid, beforeID);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a stanza for retreiving message history (alt max)', function() {
      var fixture, stanza;
      fixture = fixtures.read('messaging/groupchat/alt_max_history_request.xml');
      stanza = stropheMessaging.getGroupchatHistoryStanza(jid, null, 20);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    return it('should return a stanza for retreiving more message history (alt max)', function() {
      var fixture, stanza;
      fixture = fixtures.read('messaging/groupchat/alt_max_more_history_request.xml');
      stanza = stropheMessaging.getGroupchatHistoryStanza(jid, beforeID, 20);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getManagedHistoryStanza()', function() {
    var alternateMax, beforeID, jid;
    jid = 'some_chatroom.reuters.com@legacychat.reuters.net';
    beforeID = '123456';
    alternateMax = '20';
    it('should return a stanza for retreiving message history (default max)', function() {
      var fixture, stanza;
      fixture = fixtures.read('messaging/managed/history_request.xml');
      stanza = stropheMessaging.getManagedHistoryStanza(jid);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a stanza for retreiving more message history (default max)', function() {
      var fixture, stanza;
      fixture = fixtures.read('messaging/managed/more_history_request.xml');
      stanza = stropheMessaging.getManagedHistoryStanza(jid, beforeID);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a stanza for retreiving message history (alt max)', function() {
      var fixture, stanza;
      fixture = fixtures.read('messaging/managed/alt_max_history_request.xml');
      stanza = stropheMessaging.getManagedHistoryStanza(jid, null, 20);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    return it('should return a stanza for retreiving more message history (alt max)', function() {
      var fixture, stanza;
      fixture = fixtures.read('messaging/managed/alt_max_more_history_request.xml');
      stanza = stropheMessaging.getManagedHistoryStanza(jid, beforeID, 20);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  return describe('#getTypingStanza()', function() {
    var jid;
    jid = 'some.user.thomsonreuters.com@reuters.net';
    return it('should return a stanza for notifying piers about "chatstates" event', function() {
      var fixture, stanza;
      fixture = fixtures.read('messaging/chat/chatstates.xml');
      stanza = stropheMessaging.getTypingStanza(jid);
      stanza.should.be.and.instanceOf(Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
});


},{"spec/spec_helper":"spec/spec_helper","strophe/strophe_messaging":"strophe/strophe_messaging"}],"spec/strophe/strophe_muc_spec":[function(require,module,exports){
var MUCField, MUCRole, X2JS, _, expect, fixtures, ref, sinon, stropheMUC, trimFixture;

ref = require('spec/spec_helper'), expect = ref.expect, sinon = ref.sinon, _ = ref._, fixtures = ref.fixtures, X2JS = ref.X2JS, trimFixture = ref.trimFixture;

stropheMUC = require('strophe/strophe_muc');

MUCField = require('enum/muc_field');

MUCRole = require('enum/muc_role');

describe('stropheMUC', function() {
  var groupchatJID, groupchatName, groupchatRID, selfJID, userJID;
  selfJID = 'self.jid.thomsonreuters.com@reuters.net';
  userJID = 'user.jid.thomsonreuters.com@reuters.net';
  groupchatJID = 'my.groupchat@conference.reuters.net';
  groupchatRID = 'some.user.thomsonreuters.com__reuters.net';
  groupchatName = 'My Groupchat';
  describe('#getJoinStanza()', function() {
    return it('should return a stanza for joining a groupchat', function() {
      var fixture, stanza;
      fixture = fixtures.read('muc/join.xml');
      stanza = stropheMUC.getJoinStanza(groupchatJID, groupchatRID);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getLeaveStanza()', function() {
    return it('should return the base form stanza to leave a groupchat', function() {
      var fixture, stanza;
      fixture = fixtures.read('muc/leave.xml');
      stanza = stropheMUC.getLeaveStanza(groupchatJID);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getDestroyGroupchatStanza()', function() {
    return it('should return a stanza for destroying a groupchat', function() {
      var fixture, stanza;
      fixture = fixtures.read('muc/destroy.xml');
      stanza = stropheMUC.getDestroyGroupchatStanza(groupchatJID);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getGroupchatConfigForm()', function() {
    return it('should return the base form stanza to configure a groupchat', function() {
      var fixture, stanza;
      fixture = fixtures.read('muc/form.xml');
      stanza = stropheMUC.getGroupchatConfigForm(groupchatJID, MUCField.ROOM_NAME, groupchatName);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getRoomDiscoStanza()', function() {
    return it('should return the base form stanza to perform groupchat disco', function() {
      var fixture, stanza;
      fixture = fixtures.read('muc/disco.xml');
      stanza = stropheMUC.getRoomDiscoStanza(groupchatJID);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getMemberListStanza()', function() {
    return it('should return the base form stanza to request groupchat member list', function() {
      var affiliations, fixture, stanza;
      fixture = fixtures.read('muc/members.xml');
      affiliations = [MUCRole.OWNER, MUCRole.ADMIN];
      stanza = stropheMUC.getMemberListStanza(groupchatJID, affiliations);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getMediatedInviteStanza()', function() {
    return it('should return the base form stanza to request groupchat member list', function() {
      var fixture, invitees, stanza;
      fixture = fixtures.read('muc/mediated_invite.xml');
      invitees = [userJID];
      stanza = stropheMUC.getMediatedInviteStanza(groupchatJID, selfJID, invitees);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getSearchStanza()', function() {
    return it('should return the search stanza to query for groupchats', function() {
      var fixture, searchString, stanza;
      fixture = fixtures.read('muc/search.xml');
      searchString = 'some search';
      stanza = stropheMUC.getSearchStanza('legacychat.reuters.net', searchString);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  return describe('#getKickStanza()', function() {
    return it('should return the base form stanza to request groupchat member list', function() {
      var fixture, invitees, stanza;
      fixture = fixtures.read('muc/mediated_invite.xml');
      invitees = [userJID];
      stanza = stropheMUC.getMediatedInviteStanza(groupchatJID, selfJID, invitees);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
});


},{"enum/muc_field":"enum/muc_field","enum/muc_role":"enum/muc_role","spec/spec_helper":"spec/spec_helper","strophe/strophe_muc":"strophe/strophe_muc"}],"spec/strophe/strophe_presence_spec":[function(require,module,exports){
var PresenceShow, PresenceType, X2JS, _, expect, fixtures, ref, sinon, strophePresence, trimFixture;

ref = require('spec/spec_helper'), expect = ref.expect, sinon = ref.sinon, _ = ref._, fixtures = ref.fixtures, X2JS = ref.X2JS, trimFixture = ref.trimFixture;

PresenceType = require('enum/presence_type');

PresenceShow = require('enum/presence_show');

strophePresence = require('strophe/strophe_presence');

describe('strophePresence', function() {
  describe('#getPresenceStanza()', function() {
    it('should return an instance of Strophe.Builder', function() {
      return strophePresence.getPresenceStanza().should.be.an["instanceof"](Strophe.Builder);
    });
    it('should return a plain presence stanza', function() {
      var fixture, stanza;
      fixture = "<presence xmlns='jabber:client'/>";
      stanza = strophePresence.getPresenceStanza();
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a presence stanza addressed to a contact jid', function() {
      var fixture, stanza;
      fixture = "<presence xmlns='jabber:client' to='fakejid'/>";
      stanza = strophePresence.getPresenceStanza("fakejid");
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a presence stanza to a contact with a subscription type', function() {
      var fixture, jid, stanza;
      fixture = "<presence xmlns='jabber:client' to='fakejid' type='subscribe'/>";
      jid = "fakejid";
      stanza = strophePresence.getPresenceStanza(jid, PresenceType.SUBSCRIBE);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    return it('should return a presence stanza with a show type', function() {
      var fixture, stanza;
      fixture = "<presence xmlns='jabber:client'><show>away</show></presence>";
      stanza = strophePresence.getPresenceStanza("", "", PresenceShow.AWAY);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  return describe('#getVisibleStanza()', function() {
    it('should return a stanza for \'visible\'', function() {
      var fixture, stanza;
      fixture = fixtures.read('presence/visible.xml');
      stanza = strophePresence.getVisibleStanza();
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    return it('should return a stanza for \'invisible\'', function() {
      var fixture, stanza;
      fixture = fixtures.read('presence/invisible.xml');
      stanza = strophePresence.getVisibleStanza(false);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
});


},{"enum/presence_show":"enum/presence_show","enum/presence_type":"enum/presence_type","spec/spec_helper":"spec/spec_helper","strophe/strophe_presence":"strophe/strophe_presence"}],"spec/strophe/strophe_roster_spec":[function(require,module,exports){
var PresenceType, X2JS, _, expect, fixtures, ref, sinon, stropheRoster, trimFixture;

ref = require('spec/spec_helper'), expect = ref.expect, sinon = ref.sinon, _ = ref._, fixtures = ref.fixtures, X2JS = ref.X2JS, trimFixture = ref.trimFixture;

PresenceType = require('enum/presence_type');

stropheRoster = require('strophe/strophe_roster');

describe('stropheRoster', function() {
  describe('#getRosterStanza()', function() {
    return it('should return a stanza for getting the roster', function() {
      var fixture, stanza;
      fixture = fixtures.read('roster/get.xml');
      stanza = stropheRoster.getRosterStanza();
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getAddStanza()', function() {
    return it('should return a stanza for adding a contact to the roster', function() {
      var fixture, groups, jid, name, stanza;
      jid = "myjid";
      name = "My Name";
      fixture = fixtures.read('roster/add.xml');
      groups = ['Group One', 'Group Two'];
      stanza = stropheRoster.getAddStanza(jid, name, groups);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getRemoveStanza()', function() {
    return it('should return a stanza for removinig a contact from the roster', function() {
      var fixture, jid, stanza;
      fixture = fixtures.read('roster/remove.xml');
      jid = 'contacttoremovejid';
      stanza = stropheRoster.getRemoveStanza(jid);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  return describe('#getPresenceSubscriptionStanza()', function() {
    it('should return a stanza for presence \'subscribe\' to a user', function() {
      var fixture, jid, stanza;
      fixture = "<presence xmlns='jabber:client' to='fakejid' type='subscribe'/>";
      jid = "fakejid";
      stanza = stropheRoster.getPresenceSubscriptionStanza(jid, PresenceType.SUBSCRIBE);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a stanza for presence \'subscribed\' to a user', function() {
      var fixture, jid, stanza;
      fixture = "<presence xmlns='jabber:client' to='fakejid' type='subscribed'/>";
      jid = "fakejid";
      stanza = stropheRoster.getPresenceSubscriptionStanza(jid, PresenceType.SUBSCRIBED);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a stanza for presence \'unsubscribe\' to a user', function() {
      var fixture, jid, stanza;
      fixture = "<presence xmlns='jabber:client' to='fakejid' type='unsubscribe'/>";
      jid = "fakejid";
      stanza = stropheRoster.getPresenceSubscriptionStanza(jid, PresenceType.UNSUBSCRIBE);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    return it('should return a stanza for presence \'unsubscribed\' to a user', function() {
      var fixture, jid, stanza;
      fixture = "<presence xmlns='jabber:client' to='fakejid' type='unsubscribed'/>";
      jid = "fakejid";
      stanza = stropheRoster.getPresenceSubscriptionStanza(jid, PresenceType.UNSUBSCRIBED);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
});


},{"enum/presence_type":"enum/presence_type","spec/spec_helper":"spec/spec_helper","strophe/strophe_roster":"strophe/strophe_roster"}],"spec/strophe/strophe_storage_spec":[function(require,module,exports){
var X2JS, _, expect, fixtures, ref, sinon, stropheStorage, trimFixture;

ref = require('spec/spec_helper'), expect = ref.expect, sinon = ref.sinon, _ = ref._, fixtures = ref.fixtures, X2JS = ref.X2JS, trimFixture = ref.trimFixture;

stropheStorage = require('strophe/strophe_storage');

describe('stropheStorage', function() {
  describe('#getPreferencesStanza()', function() {
    it('should return a Strophe.Builder instance', function() {
      var result;
      result = stropheStorage.getPreferencesStanza();
      return result.should.be.an["instanceof"](Strophe.Builder);
    });
    return it('should return a stanza for getting preferences', function() {
      var fixture, result;
      fixture = fixtures.read('preferences/get.xml');
      result = stropheStorage.getPreferencesStanza();
      return result.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#setPreferencesStanza()', function() {
    it('should return null if no preferences are passed', function() {
      return expect(stropheStorage.setPreferencesStanza()).to.be["null"];
    });
    it('should return a Strophe.Builder instance', function() {
      var preferences, result;
      preferences = {
        prop1: "val1",
        prop2: "val2"
      };
      result = stropheStorage.setPreferencesStanza(preferences);
      return result.should.be.an["instanceof"](Strophe.Builder);
    });
    return it('should return a stanza for setting preferences', function() {
      var fixture, preferences, result;
      preferences = {
        prop1: "val1",
        prop2: "val2"
      };
      fixture = fixtures.read('preferences/set.xml');
      result = stropheStorage.setPreferencesStanza(preferences);
      return _.unescape(result.toString()).should.equal(trimFixture(fixture));
    });
  });
  describe('#getBookmarksStanza()', function() {
    it('should return a Strophe.Builder instance', function() {
      var result;
      result = stropheStorage.getBookmarksStanza();
      return result.should.be.an["instanceof"](Strophe.Builder);
    });
    return it('should return a stanza for getting bookmarks', function() {
      var fixture, result;
      fixture = fixtures.read('bookmarks/get.xml');
      result = stropheStorage.getBookmarksStanza();
      return result.toString().should.equal(trimFixture(fixture));
    });
  });
  return describe('#setBookmarksStanza()', function() {
    it('should return a Strophe.Builder instance', function() {
      var chatrooms, result;
      chatrooms = [
        {
          jid: "jidofchatroom1",
          type: 'conference'
        }, {
          jid: "jidofchatroom2",
          type: 'conference'
        }
      ];
      result = stropheStorage.setBookmarksStanza(chatrooms);
      return result.should.be.an["instanceof"](Strophe.Builder);
    });
    return it('should return a stanza for setting bookmarks', function() {
      var chatrooms, fixture, result;
      chatrooms = [
        {
          jid: "jidofchatroom1",
          type: 'conference'
        }, {
          jid: "jidofchatroom2",
          type: 'conference'
        }
      ];
      fixture = fixtures.read('bookmarks/set.xml');
      result = stropheStorage.setBookmarksStanza(chatrooms);
      return result.toString().should.equal(trimFixture(fixture));
    });
  });
});


},{"spec/spec_helper":"spec/spec_helper","strophe/strophe_storage":"strophe/strophe_storage"}],"spec/strophe/strophe_yahoo_gateway_spec":[function(require,module,exports){
var PresenceType, X2JS, _, expect, fixtures, ref, sinon, stropheYahooGateway, trimFixture;

ref = require('spec/spec_helper'), expect = ref.expect, sinon = ref.sinon, _ = ref._, fixtures = ref.fixtures, X2JS = ref.X2JS, trimFixture = ref.trimFixture;

PresenceType = require('enum/presence_type');

stropheYahooGateway = require('strophe/strophe_yahoo_gateway');

describe('stropheYahooGateway', function() {
  describe('#getRosterStanza()', function() {
    return it('should return a stanza for getting the roster', function() {
      var fixture, stanza;
      fixture = fixtures.read('roster/get.xml');
      stanza = stropheYahooGateway.getRosterStanza();
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getAddStanza()', function() {
    return it('should return a stanza for adding a contact to the roster', function() {
      var fixture, groups, jid, name, stanza;
      jid = "myjid";
      name = "My Name";
      fixture = fixtures.read('roster/add.xml');
      groups = ['Group One', 'Group Two'];
      stanza = stropheYahooGateway.getAddStanza(jid, name, groups);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  describe('#getRemoveStanza()', function() {
    return it('should return a stanza for removinig a contact from the roster', function() {
      var fixture, jid, stanza;
      fixture = fixtures.read('roster/remove.xml');
      jid = 'contacttoremovejid';
      stanza = stropheYahooGateway.getRemoveStanza(jid);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
  return describe('#getPresenceSubscriptionStanza()', function() {
    it('should return a stanza for presence \'subscribe\' to a user', function() {
      var fixture, jid, stanza;
      fixture = "<presence xmlns='jabber:client' to='fakejid' type='subscribe'/>";
      jid = "fakejid";
      stanza = stropheYahooGateway.getPresenceSubscriptionStanza(jid, PresenceType.SUBSCRIBE);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a stanza for presence \'subscribed\' to a user', function() {
      var fixture, jid, stanza;
      fixture = "<presence xmlns='jabber:client' to='fakejid' type='subscribed'/>";
      jid = "fakejid";
      stanza = stropheYahooGateway.getPresenceSubscriptionStanza(jid, PresenceType.SUBSCRIBED);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    it('should return a stanza for presence \'unsubscribe\' to a user', function() {
      var fixture, jid, stanza;
      fixture = "<presence xmlns='jabber:client' to='fakejid' type='unsubscribe'/>";
      jid = "fakejid";
      stanza = stropheYahooGateway.getPresenceSubscriptionStanza(jid, PresenceType.UNSUBSCRIBE);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
    return it('should return a stanza for presence \'unsubscribed\' to a user', function() {
      var fixture, jid, stanza;
      fixture = "<presence xmlns='jabber:client' to='fakejid' type='unsubscribed'/>";
      jid = "fakejid";
      stanza = stropheYahooGateway.getPresenceSubscriptionStanza(jid, PresenceType.UNSUBSCRIBED);
      stanza.should.be.an["instanceof"](Strophe.Builder);
      return stanza.toString().should.equal(trimFixture(fixture));
    });
  });
});


},{"enum/presence_type":"enum/presence_type","spec/spec_helper":"spec/spec_helper","strophe/strophe_yahoo_gateway":"strophe/strophe_yahoo_gateway"}],"spec/suites/connection_suite_spec":[function(require,module,exports){
require('spec/spec_helper');

describe('Connection Suite', function() {
  require('spec/connection_spec');
  require('spec/components/roster_spec');
  require('spec/components/storage_spec');
  require('spec/components/muc_spec');
  require('spec/components/blocklist_spec');
  require('spec/components/messaging_spec');
  require('spec/components/gateway_spec');
  require('spec/strophe/strophe_disco_spec');
  require('spec/strophe/strophe_roster_spec');
  require('spec/strophe/strophe_muc_spec');
  require('spec/strophe/strophe_storage_spec');
  require('spec/strophe/strophe_blocklist_spec');
  require('spec/strophe/strophe_messaging_spec');
  require('spec/strophe/strophe_presence_spec');
  return require('spec/strophe/strophe_io_spec');
});


},{"spec/components/blocklist_spec":"spec/components/blocklist_spec","spec/components/gateway_spec":"spec/components/gateway_spec","spec/components/messaging_spec":"spec/components/messaging_spec","spec/components/muc_spec":"spec/components/muc_spec","spec/components/roster_spec":"spec/components/roster_spec","spec/components/storage_spec":"spec/components/storage_spec","spec/connection_spec":"spec/connection_spec","spec/spec_helper":"spec/spec_helper","spec/strophe/strophe_blocklist_spec":"spec/strophe/strophe_blocklist_spec","spec/strophe/strophe_disco_spec":"spec/strophe/strophe_disco_spec","spec/strophe/strophe_io_spec":"spec/strophe/strophe_io_spec","spec/strophe/strophe_messaging_spec":"spec/strophe/strophe_messaging_spec","spec/strophe/strophe_muc_spec":"spec/strophe/strophe_muc_spec","spec/strophe/strophe_presence_spec":"spec/strophe/strophe_presence_spec","spec/strophe/strophe_roster_spec":"spec/strophe/strophe_roster_spec","spec/strophe/strophe_storage_spec":"spec/strophe/strophe_storage_spec"}],"spec/suites/events_suite_spec":[function(require,module,exports){
require('spec/spec_helper');

describe('Events Suite', function() {
  require('spec/events/events_spec');
  require('spec/events/event_manager_spec');
  require('spec/events/event_handler_spec');
  return require('spec/events/event_filters_spec');
});


},{"spec/events/event_filters_spec":"spec/events/event_filters_spec","spec/events/event_handler_spec":"spec/events/event_handler_spec","spec/events/event_manager_spec":"spec/events/event_manager_spec","spec/events/events_spec":"spec/events/events_spec","spec/spec_helper":"spec/spec_helper"}],"spec/suites/util_suite_spec":[function(require,module,exports){
require('spec/spec_helper');

describe('Util', function() {
  require('spec/util/utils_spec');
  require('spec/util/limit_spec');
  require('spec/util/rate_limiter_spec');
  require('spec/util/retryer_spec');
  return require('spec/util/matchers_spec');
});


},{"spec/spec_helper":"spec/spec_helper","spec/util/limit_spec":"spec/util/limit_spec","spec/util/matchers_spec":"spec/util/matchers_spec","spec/util/rate_limiter_spec":"spec/util/rate_limiter_spec","spec/util/retryer_spec":"spec/util/retryer_spec","spec/util/utils_spec":"spec/util/utils_spec"}],"spec/util/limit_spec":[function(require,module,exports){
var _, ref, sinon;

ref = require('spec/spec_helper'), _ = ref._, sinon = ref.sinon;

_.mixin(require('util/limit'));

describe('_.limit()', function() {
  var ERROR_CALL_MAX_INDEFINITE, ERROR_DEFAULT, ERROR_MAX_0, assertCalls, clock, errorMsg, func;
  ERROR_DEFAULT = null;
  ERROR_MAX_0 = null;
  ERROR_CALL_MAX_INDEFINITE = null;
  func = null;
  errorMsg = null;
  clock = null;
  assertCalls = function(func, limitedFunc, calls, customErrorMsg) {
    var call, i, j, len, moment, next, pass, results;
    if (customErrorMsg == null) {
      customErrorMsg = errorMsg;
    }
    results = [];
    for (i = j = 0, len = calls.length; j < len; i = ++j) {
      call = calls[i];
      moment = call[0], pass = call[1];
      if (pass) {
        limitedFunc(moment).should.equal(moment);
        func.withArgs(moment).should.have.been.calledOnce;
      } else {
        limitedFunc(moment).should.eql(new Error(customErrorMsg));
        func.withArgs(moment).should.not.have.been.called;
      }
      if (next = calls[i + 1]) {
        results.push(clock.tick(next[0] - moment));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  before(function() {
    ERROR_DEFAULT = "You have exceeded the number of allowable function calls for this time period";
    ERROR_MAX_0 = "The allowable number of function calls is 0";
    return ERROR_CALL_MAX_INDEFINITE = "You have exceeded the number of allowable function calls";
  });
  after(function() {
    ERROR_DEFAULT = null;
    ERROR_MAX_0 = null;
    return ERROR_CALL_MAX_INDEFINITE = null;
  });
  beforeEach(function() {
    func = sinon.spy(function(arg) {
      return arg;
    });
    errorMsg = ERROR_DEFAULT;
    return clock = sinon.useFakeTimers();
  });
  afterEach(function() {
    func.reset();
    clock.restore();
    return errorMsg = null;
  });
  it('should prevent all calls if `max` is 0', function() {
    var limitedFunc;
    limitedFunc = _.limit(func, {
      max: 0
    });
    errorMsg = ERROR_MAX_0;
    limitedFunc(1).should.eql(new Error(errorMsg));
    return func.should.not.have.been.calledOnce;
  });
  it('should allow a limited number of calls to a function within a specified time', function() {
    var limitedFunc;
    limitedFunc = _.limit(func);
    limitedFunc(1).should.equal(1);
    return func.should.have.been.calledOnce;
  });
  it('should limit the number of function calls within a specified time', function() {
    var limitedFunc;
    limitedFunc = _.limit(func);
    limitedFunc(1).should.equal(1);
    limitedFunc(2).should.eql(new Error(errorMsg));
    return func.should.have.been.calledOnce;
  });
  it('should allow a limited number of calls to a function within a specified time', function() {
    var limitedFunc;
    limitedFunc = _.limit(func, {
      max: 2,
      time: 1000
    });
    limitedFunc(1).should.equal(1);
    limitedFunc(2).should.equal(2);
    return func.should.have.been.calledTwice;
  });
  it('should limit the function calls within a specified time', function() {
    var limitedFunc;
    limitedFunc = _.limit(func, {
      max: 2,
      time: 1000
    });
    limitedFunc(1).should.equal(1);
    limitedFunc(2).should.equal(2);
    limitedFunc(3).should.eql(new Error(errorMsg));
    func.should.have.been.calledTwice;
    func.firstCall.should.have.been.calledWith(1);
    return func.secondCall.should.have.been.calledWith(2);
  });
  it('should allow multiple calls after the time period has elapsed', function() {
    var limitedFunc;
    limitedFunc = _.limit(func, {
      max: 1,
      time: 1000
    });
    limitedFunc(1).should.equal(1);
    clock.tick(1500);
    limitedFunc(2).should.equal(2);
    return func.should.have.been.calledTwice;
  });
  it('should rate limit calls over time', function() {
    var calls, limitedFunc;
    calls = [[0, true], [500, true], [600, false], [800, false], [1100, true], [1300, true], [1500, false], [2200, true], [3500, true], [5000, true], [5300, true], [5500, false]];
    limitedFunc = _.limit(func, {
      max: 2,
      time: 1000
    });
    return assertCalls(func, limitedFunc, calls);
  });
  it('should rate limit a function precisely', function() {
    var calls, limitedFunc;
    calls = [[0, true], [1000, true], [3000, true]];
    limitedFunc = _.limit(func, {
      max: 1,
      time: 1000
    });
    return assertCalls(func, limitedFunc, calls);
  });
  describe('return values', function() {
    it('should return a function', function() {
      return _.limit(func).should.be.a('function');
    });
    return it('should return a wrapped version of the same func passed in', function() {
      var limitedFunc;
      limitedFunc = _.limit(func);
      limitedFunc(1, 2);
      return func.should.have.been.calledOnce.calledWith(1, 2);
    });
  });
  describe('specifying option properties', function() {
    it('should accept context that is passed in', function() {
      var limitedFunc, obj, spy;
      obj = {
        prop: 'val'
      };
      spy = sinon.spy(function(arg) {
        this.should.equal(obj);
        return arg;
      });
      limitedFunc = _.limit(spy, {
        context: obj
      });
      return limitedFunc(1).should.equal(1);
    });
    return it('should return a custom error message', function() {
      var limitedFunc, message;
      message = "You called it too many times!";
      limitedFunc = _.limit(func, {
        errorMessage: message
      });
      limitedFunc(1).should.equal(1);
      limitedFunc(2).should.eql(new Error(message));
      return func.should.have.been.calledOnce.calledWith(1);
    });
  });
  describe('invalid options', function() {
    it('should default to `max: 1` when receiving a negative value', function() {
      var limitedFunc;
      limitedFunc = _.limit(func, {
        max: -1,
        time: 1000
      });
      limitedFunc(1).should.equal(1);
      limitedFunc(2).should.eql(Error(errorMsg));
      return func.should.have.been.callOnce;
    });
    it('should drop float values for max time', function() {
      var limitedFunc;
      limitedFunc = _.limit(func, {
        max: 2.8,
        time: 1000
      });
      limitedFunc(1).should.equal(1);
      limitedFunc(2).should.equal(2);
      limitedFunc(3).should.eql(Error(errorMsg));
      return func.should.have.been.callOnce;
    });
    it('should default to `time: 1000` when receiving a negative value', function() {
      var calls, limitedFunc;
      calls = [[0, true], [500, false], [1000, true], [3000, true]];
      limitedFunc = _.limit(func, {
        max: 1,
        time: -5000
      });
      return assertCalls(func, limitedFunc, calls);
    });
    return it('should drop float values for time', function() {
      var calls, limitedFunc;
      calls = [[0, true], [1000, false], [2000, true], [4000, true]];
      limitedFunc = _.limit(func, {
        max: 1,
        time: 2000.5
      });
      return assertCalls(func, limitedFunc, calls);
    });
  });
  describe('multiple instances of rate limited functions', function() {
    var func2;
    func2 = null;
    beforeEach(function() {
      return func2 = sinon.spy(function(arg) {
        return arg;
      });
    });
    afterEach(function() {
      return func2.reset();
    });
    return it('should rate limit separately for different functions', function() {
      var calls1, calls2, limitedFunc1, limitedFunc2;
      calls1 = [[0, true], [1000, true], [1500, false], [2000, true]];
      limitedFunc1 = _.limit(func, {
        max: 1,
        time: 1000
      });
      assertCalls(func, limitedFunc1, calls1);
      calls2 = [[0, true], [300, true], [600, true], [900, false], [1000, true]];
      limitedFunc2 = _.limit(func2, {
        max: 3,
        time: 1000
      });
      return assertCalls(func2, limitedFunc2, calls2);
    });
  });
  describe('limiting a function indefinitely', function() {
    return it('should never reset the timer once the max calls are reached', function() {
      var calls, limitedFunc;
      calls = [[0, true], [500, true], [1000, false], [3000, false], [10000, false]];
      limitedFunc = _.limit(func, {
        max: 2,
        time: 0
      });
      errorMsg = ERROR_CALL_MAX_INDEFINITE;
      return assertCalls(func, limitedFunc, calls, errorMsg);
    });
  });
  describe('reusing _.limit ', function() {
    return it('should allow for rate limiting of the same function multiple times', function() {
      var limitedFunc1, limitedFunc2;
      limitedFunc1 = _.limit(func, {
        max: 1
      });
      return limitedFunc2 = _.limit(func, {
        max: 3
      });
    });
  });
  return describe('nesting (further limiting) already limited functions', function() {
    it('should allow for limiting an already limited function', function() {
      var limitedFunc1, limitedFunc2;
      limitedFunc1 = _.limit(func, {
        max: 1,
        errorMessage: "Error1"
      });
      limitedFunc2 = _.limit(limitedFunc1, {
        max: 1,
        errorMessage: "Error2"
      });
      limitedFunc2(1).should.equal(1);
      return limitedFunc2(2).should.eql(new Error("Error2"));
    });
    it('should use nested limiting and honor the stricter limit when first', function() {
      var limitedFunc1, limitedFunc2;
      limitedFunc1 = _.limit(func, {
        max: 1,
        errorMessage: "Error1"
      });
      limitedFunc2 = _.limit(limitedFunc1, {
        max: 2,
        errorMessage: "Error2"
      });
      limitedFunc2(1).should.equal(1);
      return limitedFunc2(2).should.eql(new Error("Error1"));
    });
    return it('should use nested limiting and honor the stricter limit when second', function() {
      var limitedFunc1, limitedFunc2;
      limitedFunc1 = _.limit(func, {
        max: 2,
        errorMessage: "Error1"
      });
      limitedFunc2 = _.limit(limitedFunc1, {
        max: 1,
        errorMessage: "Error2"
      });
      limitedFunc2(1).should.equal(1);
      return limitedFunc2(2).should.eql(new Error("Error2"));
    });
  });
});


},{"spec/spec_helper":"spec/spec_helper","util/limit":"util/limit"}],"spec/util/matchers_spec":[function(require,module,exports){
var Matchers, _, ref, sinon;

ref = require('spec/spec_helper'), _ = ref._, sinon = ref.sinon;

Matchers = require('util/matchers');

describe('Matchers', function() {
  describe('.isGroupchat()', function() {
    it('should return false if passed nothing', function() {
      return Matchers.isGroupchat().should.be["false"];
    });
    it('should return false for an empty string', function() {
      return Matchers.isGroupchat('').should.be["false"];
    });
    it('should return false for null', function() {
      return Matchers.isGroupchat(null).should.be["false"];
    });
    it('should detect return false for non-chatroom text values', function() {
      var result;
      result = Matchers.isGroupchat('adsfasdf');
      return result.should.be["false"];
    });
    it('should detect return false for non-chatroom numeric values', function() {
      var result;
      result = Matchers.isGroupchat('123456');
      return result.should.be["false"];
    });
    it('should return true if passed an id for a managed chatroom id (WCP)', function() {
      var result;
      result = Matchers.isGroupchat('@legacychat.roomasdfasdfas');
      return result.should.be["true"];
    });
    return it('should return true if passed an id for a XMPP groupchat id', function() {
      var result;
      result = Matchers.isGroupchat('@conference.asdfasdfas');
      return result.should.be["true"];
    });
  });
  describe('.isManagedGroupchat()', function() {
    it('should return false if passed nothing', function() {
      return Matchers.isManagedGroupchat().should.be["false"];
    });
    it('should return false for an empty string', function() {
      return Matchers.isManagedGroupchat('').should.be["false"];
    });
    it('should return false for null', function() {
      return Matchers.isManagedGroupchat(null).should.be["false"];
    });
    it('should detect return false for non-chatroom text values', function() {
      var result;
      result = Matchers.isManagedGroupchat('adsfasdf');
      return result.should.be["false"];
    });
    it('should detect return false for non-chatroom numeric values', function() {
      var result;
      result = Matchers.isManagedGroupchat('123456');
      return result.should.be["false"];
    });
    it('should return true if passed an id for a managed groupchat id (WCP)', function() {
      var result;
      result = Matchers.isManagedGroupchat('something@legacychat.roomasdfasdfas');
      return result.should.be["true"];
    });
    return it('should return false if passed any other id', function() {
      var result;
      result = Matchers.isManagedGroupchat('@anythingelse.asdfasdfas');
      return result.should.be["false"];
    });
  });
  describe('.isBilateralGroupchat()', function() {
    it('should return false if passed nothing', function() {
      return Matchers.isBilateralGroupchat().should.be["false"];
    });
    it('should return false for an empty string', function() {
      return Matchers.isBilateralGroupchat('').should.be["false"];
    });
    it('should return false for null', function() {
      return Matchers.isBilateralGroupchat(null).should.be["false"];
    });
    it('should detect return false for non-chatroom text values', function() {
      var result;
      result = Matchers.isBilateralGroupchat('adsfasdf');
      return result.should.be["false"];
    });
    it('should detect return false for non-chatroom numeric values', function() {
      var result;
      result = Matchers.isBilateralGroupchat('123456');
      return result.should.be["false"];
    });
    it('should return true if passed an id for a bilateral groupchat', function() {
      var result;
      result = Matchers.isBilateralGroupchat('something@conference.roomasdfasdfas');
      return result.should.be["true"];
    });
    return it('should return false if passed any other id', function() {
      var result;
      result = Matchers.isBilateralGroupchat('@anythingelse.asdfasdfas');
      return result.should.be["false"];
    });
  });
  describe('.isYahoo()', function() {
    it('should return false if passed nothing', function() {
      return Matchers.isYahoo().should.be["false"];
    });
    it('should return false for an empty string', function() {
      return Matchers.isYahoo('').should.be["false"];
    });
    it('should return false for null', function() {
      return Matchers.isYahoo(null).should.be["false"];
    });
    it('should detect return false for non-chatroom text values', function() {
      var result;
      result = Matchers.isYahoo('adsfasdf');
      return result.should.be["false"];
    });
    it('should detect return false for non-chatroom numeric values', function() {
      var result;
      result = Matchers.isYahoo('123456');
      return result.should.be["false"];
    });
    it('should return true if passed a Yahoo email address', function() {
      var result;
      result = Matchers.isYahoo('something@yahoo.com');
      return result.should.be["true"];
    });
    it('should return true if passed a Rocketmail email address', function() {
      var result;
      result = Matchers.isYahoo('something@rocketmail.com');
      return result.should.be["true"];
    });
    it('should return true if passed a Ymail email address', function() {
      var result;
      result = Matchers.isYahoo('something@ymail.com');
      return result.should.be["true"];
    });
    it('should return true if passed a non .com Yahoo email address', function() {
      var result;
      result = Matchers.isYahoo('something@yahoo.co.il');
      return result.should.be["true"];
    });
    it('should return true if passed a Yahoo subdomain email address', function() {
      var result;
      result = Matchers.isYahoo('something@yahoo.reuasmb.net');
      return result.should.be["true"];
    });
    return it('should return false if passed any other id', function() {
      var result;
      result = Matchers.isYahoo('@anythingelse.asdfasdfas');
      return result.should.be["false"];
    });
  });
  return describe('.isNitroContact()', function() {
    it('should return false if passed nothing', function() {
      return Matchers.isNitroContact().should.be["false"];
    });
    it('should return false for an empty string', function() {
      return Matchers.isNitroContact('').should.be["false"];
    });
    it('should return false for null', function() {
      return Matchers.isNitroContact(null).should.be["false"];
    });
    it('should detect return false for non-tr jid text values', function() {
      var result;
      result = Matchers.isNitroContact('adsfasdf');
      return result.should.be["false"];
    });
    it('should detect return false for non-tr jid numeric values', function() {
      var result;
      result = Matchers.isNitroContact('123456');
      return result.should.be["false"];
    });
    it('should return true if passed an jid for a TR contact in Beta/Alpha', function() {
      var result;
      result = Matchers.isNitroContact('first.last.whatever.com@reuasmb.net');
      return result.should.be["true"];
    });
    it('should return true if passed an jid with resource for a TR contact in Beta/Alpha', function() {
      var result;
      result = Matchers.isNitroContact('first.last.whatever.com@reuasmb.net/em');
      return result.should.be["true"];
    });
    it('should return true if passed an jid for a TR contact in Prod', function() {
      var result;
      result = Matchers.isNitroContact('first.last.whatever.com@reuters.net');
      return result.should.be["true"];
    });
    it('should return true if passed an jid with resource for a TR contact in Prod', function() {
      var result;
      result = Matchers.isNitroContact('first.last.whatever.com@reuters.net/em');
      return result.should.be["true"];
    });
    it('should return false if passed an jid for a managed groupchat jid Beta/Alpha', function() {
      var result;
      result = Matchers.isNitroContact('something@legacychat.reuasmb.net');
      return result.should.be["false"];
    });
    it('should return false if passed an jid for a XMPP groupchat jid Beta/Alpha', function() {
      var result;
      result = Matchers.isNitroContact('something@conference.reuasmb.net');
      return result.should.be["false"];
    });
    it('should return false if passed an jid for a managed groupchat jid Prod', function() {
      var result;
      result = Matchers.isNitroContact('something@legacychat.reuters.net');
      return result.should.be["false"];
    });
    return it('should return false if passed an jid for a XMPP groupchat jid Prod', function() {
      var result;
      result = Matchers.isNitroContact('something@conference.reuters.net');
      return result.should.be["false"];
    });
  });
});


},{"spec/spec_helper":"spec/spec_helper","util/matchers":"util/matchers"}],"spec/util/rate_limiter_spec":[function(require,module,exports){
var RateLimiter, _, expect, ref, sinon;

ref = require('spec/spec_helper'), _ = ref._, sinon = ref.sinon, expect = ref.expect;

RateLimiter = require('util/rate_limiter');

describe('RateLimiter', function() {
  var func, options, rateLimiter;
  rateLimiter = null;
  func = null;
  options = null;
  beforeEach(function() {
    func = sinon.spy(function(arg) {
      return arg;
    });
    return options = {
      max: 1,
      time: 1000,
      context: window,
      errorMessage: "Error"
    };
  });
  afterEach(function() {
    func.reset();
    return options = null;
  });
  describe('#constructor()', function() {
    beforeEach(function() {
      return sinon.stub(RateLimiter.prototype, 'addAlias');
    });
    afterEach(function() {
      return RateLimiter.prototype.addAlias.restore();
    });
    it('should add an alias called `invoke`', function() {
      rateLimiter = new RateLimiter(func, options);
      return rateLimiter.addAlias.should.have.been.calledOnce.calledWithExactly('invoke', options);
    });
    it('should throw an error if the function passed in is null', function() {
      expect(function() {
        return new RateLimiter(null, options);
      }).to["throw"](Error);
      expect(function() {
        return new RateLimiter(null, options);
      }).to["throw"](RateLimiter.ERROR_FUNCTION_MISSING);
      return rateLimiter.addAlias.should.not.have.been.called;
    });
    it('should throw an error if the function passed in is undefined', function() {
      expect(function() {
        return new RateLimiter(void 0, options);
      }).to["throw"](Error);
      expect(function() {
        return new RateLimiter(void 0, options);
      }).to["throw"](RateLimiter.ERROR_FUNCTION_MISSING);
      return rateLimiter.addAlias.should.not.have.been.called;
    });
    return it('should throw an error if the function passed in is not a real function', function() {
      expect(function() {
        return new RateLimiter({}, options);
      }).to["throw"](Error);
      expect(function() {
        return new RateLimiter({}, options);
      }).to["throw"](RateLimiter.ERROR_FUNCTION_MISSING);
      expect(function() {
        return new RateLimiter(1, options);
      }).to["throw"](Error);
      expect(function() {
        return new RateLimiter(1, options);
      }).to["throw"](RateLimiter.ERROR_FUNCTION_MISSING);
      expect(function() {
        return new RateLimiter("1", options);
      }).to["throw"](Error);
      expect(function() {
        return new RateLimiter("1", options);
      }).to["throw"](RateLimiter.ERROR_FUNCTION_MISSING);
      return rateLimiter.addAlias.should.not.have.been.called;
    });
  });
  describe('#addAlias()', function() {
    beforeEach(function() {
      sinon.spy(_, 'limit');
      return rateLimiter = new RateLimiter(func, options);
    });
    afterEach(function() {
      _.limit.restore();
      return rateLimiter = null;
    });
    it('should return a rate limited version of the function', function() {
      var alias;
      alias = rateLimiter.addAlias('alias1');
      return _.isFunction(alias).should.be["true"];
    });
    it('should rate limit a function passed in, using default options', function() {
      rateLimiter.addAlias('alias1');
      return _.limit.should.have.been.calledTwice.calledWithExactly(rateLimiter.invoke, sinon.match({
        max: 1,
        time: 1000,
        context: window,
        errorMessage: "Error"
      }));
    });
    it('should override default values if passing in new options', function() {
      var newOptions;
      newOptions = {
        max: 2,
        time: 2000,
        context: this,
        errorMessage: "New Error"
      };
      rateLimiter.addAlias('alias1', newOptions);
      return _.limit.should.have.been.calledTwice.calledWithExactly(rateLimiter.invoke, sinon.match({
        max: 2,
        time: 2000,
        errorMessage: "New Error"
      }));
    });
    return it('should add a public method with a rate limited version of the function', function() {
      rateLimiter.addAlias('alias1');
      rateLimiter.alias1(1).should.equal(1);
      return rateLimiter.alias1(2).should.eql(new Error(options.errorMessage));
    });
  });
  return describe('multiple aliases and rate limiting', function() {
    var aliasErrorMsg, originalErrorMsg;
    originalErrorMsg = null;
    aliasErrorMsg = null;
    beforeEach(function() {
      originalErrorMsg = "Original Error";
      aliasErrorMsg = "Alias Error";
      return rateLimiter = new RateLimiter(func, {
        max: 2,
        time: 1000,
        errorMessage: originalErrorMsg
      });
    });
    afterEach(function() {
      originalErrorMsg = null;
      return aliasErrorMsg = null;
    });
    it('should limit the calls to the stricter limiter when stricter is default', function() {
      var alias1, alias1Options;
      alias1Options = {
        max: 3,
        time: 1000,
        errorMessage: aliasErrorMsg
      };
      alias1 = rateLimiter.addAlias('alias1', alias1Options);
      alias1(1).should.equal(1);
      alias1(2).should.equal(2);
      return alias1(3).should.eql(new Error(originalErrorMsg));
    });
    it('should limit the calls to the stricter limiter when stricter is an alias', function() {
      var alias1, alias1Options;
      alias1Options = {
        max: 1,
        time: 1000,
        errorMessage: aliasErrorMsg
      };
      alias1 = rateLimiter.addAlias('alias1', alias1Options);
      alias1(1).should.equal(1);
      return alias1(1).should.eql(new Error(aliasErrorMsg));
    });
    return it('should limit the calls from multiple aliases to strictest of limits', function() {
      var alias1, alias2, aliasOptions;
      aliasOptions = {
        max: 2,
        time: 1000,
        errorMessage: aliasErrorMsg
      };
      alias1 = rateLimiter.addAlias('alias1', aliasOptions);
      alias2 = rateLimiter.addAlias('alias2', aliasOptions);
      alias1(1).should.equal(1);
      alias2(2).should.equal(2);
      return alias1(3).should.eql(new Error(originalErrorMsg));
    });
  });
});


},{"spec/spec_helper":"spec/spec_helper","util/rate_limiter":"util/rate_limiter"}],"spec/util/retryer_spec":[function(require,module,exports){
var Q, _, assert, expect, ref, sinon;

ref = require('spec/spec_helper'), _ = ref._, sinon = ref.sinon, assert = ref.assert, expect = ref.expect;

Q = require('q');

_.mixin(require('util/retryer'));

describe('_.retry()', function() {
  it('should accept a context for the function call', function(done) {
    var context, func, subject;
    context = {};
    func = sinon.spy(function(obj) {
      if (obj == null) {
        obj = {};
      }
      this.should.equal(context);
      return Q();
    });
    subject = _.retry(func, {
      context: context
    });
    return subject().should.eventually.be.fulfilled.notify(done);
  });
  describe('retrying synchonous functions', function() {
    var getPromiseSpyReturnsTrueOnThirdCall;
    getPromiseSpyReturnsTrueOnThirdCall = function() {
      var funcCalls;
      funcCalls = 0;
      return sinon.spy(function() {
        return ++funcCalls === 3;
      });
    };
    it('should fulfill a promise once its function call succeeds on the first attempt', function(done) {
      var func, subject;
      func = sinon.stub().returns(true);
      subject = _.retry(func);
      return subject().should.eventually.be.fulfilled.then(function() {
        return func.should.have.been.calledOnce;
      }).should.notify(done);
    });
    it('should fail a promise once its function call fails on the first attempt', function(done) {
      var func, subject;
      func = sinon.stub().returns(false);
      subject = _.retry(func);
      return subject().should.eventually.be.rejected.then(function() {
        return func.should.have.been.calledOnce;
      }).should.notify(done);
    });
    it('should reject a promise once function fails a max of 3 times', function(done) {
      var func, subject;
      func = sinon.stub().returns(false);
      subject = _.retry(func, {
        max: 3
      });
      return subject().should.eventually.be.rejected.then(function() {
        return func.should.have.been.calledThrice;
      }).should.notify(done);
    });
    return it('should fulfill a promise once its function call succeeds on the third attempt', function(done) {
      var func, subject;
      func = getPromiseSpyReturnsTrueOnThirdCall();
      subject = _.retry(func, {
        max: 3
      });
      return subject().should.eventually.be.fulfilled.then(function() {
        return func.should.have.been.calledThrice;
      }).should.notify(done);
    });
  });
  return describe('retrying asynchonous functions', function() {
    var getPromiseSpyFulfilledOnThirdCall;
    getPromiseSpyFulfilledOnThirdCall = function() {
      var funcCalls;
      funcCalls = 0;
      return sinon.spy(function() {
        if (++funcCalls === 3) {
          return Q();
        } else {
          return Q.reject();
        }
      });
    };
    it('should fulfill a promise once its functional call succeeds on the first attempt', function(done) {
      var func, subject;
      func = sinon.stub().returns(Q());
      subject = _.retry(func);
      return subject().should.eventually.be.fulfilled.then(function() {
        return func.should.have.been.calledOnce;
      }).should.notify(done);
    });
    it('should fail a promise once its functional call fails on the first attempt', function(done) {
      var func, subject;
      func = sinon.stub().returns(Q.reject());
      subject = _.retry(func);
      return subject().should.eventually.be.rejected.then(function() {
        return func.should.have.been.calledOnce;
      }).should.notify(done);
    });
    it('should reject a promise once failed calls reaches the max of 3', function(done) {
      var func, subject;
      func = sinon.stub().returns(Q.reject());
      subject = _.retry(func, {
        max: 3
      });
      return subject().should.eventually.be.rejected.then(function() {
        return func.should.have.been.calledThrice;
      }).should.notify(done);
    });
    it('should accept a max number of attempts', function(done) {
      var func, subject;
      func = getPromiseSpyFulfilledOnThirdCall();
      subject = _.retry(func, {
        max: 3
      });
      return subject().should.eventually.be.fulfilled.then(function() {
        return func.should.have.been.calledThrice;
      }).should.notify(done);
    });
    it('should accept a function returning a wait interval', function(done) {
      var func, getWait, subject;
      func = getPromiseSpyFulfilledOnThirdCall();
      getWait = sinon.spy(function() {
        return 200;
      });
      subject = _.retry(func, {
        max: 3,
        wait: getWait
      });
      return subject().should.eventually.be.fulfilled.then(function() {
        func.should.have.been.calledThrice;
        return getWait.should.have.been.calledTwice;
      }).should.notify(done);
    });
    it('should accept a wait function and invoke it at each interval', function(done) {
      var func, getWait, subject;
      func = getPromiseSpyFulfilledOnThirdCall();
      getWait = sinon.spy();
      subject = _.retry(func, {
        max: 3,
        wait: getWait
      });
      return subject().should.eventually.be.fulfilled.then(function() {
        func.should.have.been.calledThrice;
        getWait.should.have.been.calledTwice;
        getWait.withArgs(1).should.have.been.calledOnce;
        return getWait.withArgs(2).should.have.been.calledOnce;
      }).should.notify(done);
    });
    it('it should report incremental progress with each attempt number', function(done) {
      var func, progressStub, subject;
      func = getPromiseSpyFulfilledOnThirdCall();
      progressStub = sinon.stub();
      subject = _.retry(func, {
        max: 3,
        wait: 100,
        progress: progressStub
      });
      return subject().should.eventually.be.fulfilled.then(function() {
        return progressStub.should.have.been.calledTwice.calledWith(sinon.match.object, 1, 3, 100).calledWith(sinon.match.object, 2, 3, 100);
      }).should.notify(done);
    });
    return it('should be able to pass arguments through the retryer to the function call', function(done) {
      var func, subject;
      func = sinon.stub().returns(Q());
      subject = _.retry(func);
      return subject("a", "b", "c").should.eventually.be.fulfilled.then(function() {
        return func.should.have.been.calledOnce.calledWith("a", "b", "c", {
          attempt: 1
        });
      }).should.notify(done);
    });
  });
});


},{"q":47,"spec/spec_helper":"spec/spec_helper","util/retryer":"util/retryer"}],"spec/util/utils_spec":[function(require,module,exports){
var Utils, _, expect, ref, sinon;

ref = require('spec/spec_helper'), sinon = ref.sinon, expect = ref.expect, _ = ref._;

Utils = require('util/utils');

describe('Utils', function() {
  describe('#conditional()', function() {
    var func;
    func = null;
    before(function() {
      return func = sinon.stub();
    });
    after(function() {
      return func = null;
    });
    afterEach(function() {
      return func.reset();
    });
    it('should return a function', function() {
      var condition;
      condition = function() {
        return true;
      };
      return Utils.conditional(func, condition).should.be.a.Function;
    });
    it('should allow the original function to be called when condition is met', function() {
      var condition, conditionalFunc;
      condition = function() {
        return true;
      };
      conditionalFunc = Utils.conditional(func, condition);
      conditionalFunc();
      return func.should.have.been.calledOnce;
    });
    it('should allow the original function to be called with args when condition is met', function() {
      var condition, conditionalFunc;
      condition = function() {
        return true;
      };
      conditionalFunc = Utils.conditional(func, condition);
      conditionalFunc('test');
      return func.should.have.been.calledOnce.calledWithExactly('test');
    });
    it('should allow the original function to return its own value when condition is met', function() {
      var condition, conditionalFunc;
      func.returns('return value');
      condition = function() {
        return true;
      };
      conditionalFunc = Utils.conditional(func, condition);
      return conditionalFunc().should.equal('return value');
    });
    return it('should return make the original function return null if condition is not met', function() {
      var condition, conditionalFunc;
      condition = function() {
        return false;
      };
      conditionalFunc = Utils.conditional(func, condition);
      expect(conditionalFunc()).to.be["null"];
      return func.should.not.have.been.called;
    });
  });
  describe('#returnBoolean()', function() {
    var func;
    func = null;
    beforeEach(function() {
      return func = sinon.stub();
    });
    afterEach(function() {
      return func.reset();
    });
    it('should decorate a function that returns true by default', function() {
      Utils.returnBoolean(func)().should.be["true"];
      Utils.returnBoolean(func, null)().should.be["true"];
      Utils.returnBoolean(func, void 0)().should.be["true"];
      return func.should.have.been.calledThrice;
    });
    it('should decorate a function that returns true when specified', function() {
      var boolFunc;
      boolFunc = Utils.returnBoolean(func, true);
      boolFunc().should.be["true"];
      return func.should.have.been.calledOnce;
    });
    it('should decorate a function that returns false when specified', function() {
      var boolFunc;
      boolFunc = Utils.returnBoolean(func, false);
      boolFunc().should.be["false"];
      return func.should.have.been.calledOnce;
    });
    it('should decorate a function that accepts the args of the original function', function() {
      var boolFunc;
      boolFunc = Utils.returnBoolean(func);
      boolFunc("a", "b");
      return func.should.have.been.calledOnce.calledWithExactly("a", "b");
    });
    it('should coerce a value to true', function() {
      Utils.returnBoolean(func, 1)().should.be["true"];
      Utils.returnBoolean(func, 10)().should.be["true"];
      Utils.returnBoolean(func, {})().should.be["true"];
      Utils.returnBoolean(func, "a")().should.be["true"];
      return Utils.returnBoolean(func, ["a"].length)().should.be["true"];
    });
    return it('should coerce a value to false', function() {
      Utils.returnBoolean(func, 0)().should.be["false"];
      Utils.returnBoolean(func, "")().should.be["false"];
      return Utils.returnBoolean(func, [].length)().should.be["false"];
    });
  });
  return describe('#array', function() {
    it('should return an array if passed one', function() {
      var array;
      array = [];
      return Utils.array(array).should.equal(array);
    });
    it('should return an array if passed an object', function() {
      var array, obj;
      obj = "value";
      array = Utils.array(obj);
      array.should.be.an["instanceof"](Array);
      return array[0].should.equal("value");
    });
    it('should return the same array if passed an array', function() {
      var array;
      array = ["a", "b"];
      return Utils.array(array).should.equal(array);
    });
    return it('should convert multiple strings to multiple arrays', function() {
      var a, args, b, c, ref1;
      args = ["a", "b", "c"];
      ref1 = Utils.array.apply(this, args), a = ref1[0], b = ref1[1], c = ref1[2];
      a.should.be.an["instanceof"](Array);
      a[0].should.equal("a");
      b.should.be.an["instanceof"](Array);
      b[0].should.equal("b");
      c.should.be.an["instanceof"](Array);
      return c[0].should.equal("c");
    });
  });
});


},{"spec/spec_helper":"spec/spec_helper","util/utils":"util/utils"}],"spec/util/xmpp_utils_spec":[function(require,module,exports){
var _, ref, sinon;

ref = require('spec/spec_helper'), _ = ref._, sinon = ref.sinon;

require('util/xmpp_utils');


},{"spec/spec_helper":"spec/spec_helper","util/xmpp_utils":"util/xmpp_utils"}],"strophe/strophe_blocklist":[function(require,module,exports){
var Strophe, _, getIQStanza;

_ = require('underscore');

Strophe = require('strophe');

exports.getBlocklistStanza = function() {
  return getIQStanza('blocklist');
};

exports.getBlockStanza = function(jids) {
  return getIQStanza('block', 'set', jids);
};

exports.getUnblockStanza = function(jids) {
  return getIQStanza('unblock', 'set', jids);
};

getIQStanza = function(name, type, jids) {
  var i, jid, len, stanza;
  if (type == null) {
    type = 'get';
  }
  if (jids == null) {
    jids = [];
  }
  stanza = $iq({
    type: type
  }).c(name, {
    xmlns: 'urn:xmpp:blocking'
  });
  for (i = 0, len = jids.length; i < len; i++) {
    jid = jids[i];
    stanza.c('item', {
      jid: jid
    }).up();
  }
  return stanza;
};


},{"strophe":"lib/strophe","underscore":85}],"strophe/strophe_disco":[function(require,module,exports){
var MUCNS;

MUCNS = require('enum/muc_ns');

exports.getDiscoStanza = function(jid) {
  return $iq({
    to: jid,
    type: 'get'
  }).c('query', {
    xmlns: MUCNS.DISCO_INFO
  }).up();
};


},{"enum/muc_ns":"enum/muc_ns"}],"strophe/strophe_io":[function(require,module,exports){
var Utils, _, getListenerInvoker,
  slice = [].slice;

Utils = require('util/utils');

_ = require('underscore');

getListenerInvoker = function(getListenersFn) {
  return function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return getListenersFn().forEach(function(f) {
      return f.apply(null, args);
    });
  };
};

module.exports = {
  rawInputListeners: [],
  rawOutputListeners: [],
  xmlInputListeners: [],
  xmlOutputListeners: [],
  connectIOListeners: function(options) {
    var connection, getRawInputListeners, getRawOutputListeners, getXMLInputListeners, getXMLOutputListeners;
    if (options == null) {
      options = {};
    }
    connection = options.connection;
    getRawInputListeners = options.getRawInputListeners, getRawOutputListeners = options.getRawOutputListeners;
    getXMLInputListeners = options.getXMLInputListeners, getXMLOutputListeners = options.getXMLOutputListeners;
    connection.rawInput = getListenerInvoker(getRawInputListeners);
    connection.rawOutput = getListenerInvoker(getRawOutputListeners);
    connection.xmlInput = getListenerInvoker(getXMLInputListeners);
    return connection.xmlOutput = getListenerInvoker(getXMLOutputListeners);
  },
  addIOListener: function(callback, list) {
    var listeners;
    listeners = Utils.array(callback);
    listeners.forEach(function(cb) {
      return list.push(cb);
    });
    return function() {
      var firstCallback, index;
      firstCallback = _.isArray(callback) ? callback[0] : callback;
      index = list.indexOf(firstCallback);
      return list.splice(index, listeners.length);
    };
  }
};


},{"underscore":85,"util/utils":"util/utils"}],"strophe/strophe_messaging":[function(require,module,exports){
var ACKNS, ChatStatesNS, HISTORY_MAX, HistoryNS, Matchers, MessageType, Strophe, getBeforeStanza, getMaxStanza;

Strophe = require('strophe');

MessageType = require('enum/message_type');

HistoryNS = require('enum/history_ns');

ACKNS = require('enum/ack_ns');

Matchers = require('util/matchers');

ChatStatesNS = require('enum/chat_states_ns');

HISTORY_MAX = 50;

exports.getSendStanza = function(jid, body, type, id) {
  var message;
  if (type == null) {
    type = MessageType.CHAT;
  }
  if (!(jid && body)) {
    return null;
  }
  message = $msg({
    to: jid,
    type: type,
    id: id
  }).c('body', {}, body);
  if (!Matchers.isGroupchat(jid)) {
    message.c('request', {
      xmlns: ACKNS.NITRO_RECEIPTS
    }).up();
  }
  if (Matchers.isManagedGroupchat(jid)) {
    message.c('request', {
      xmlns: ACKNS.STANDARD_RECEIPTS
    }).up();
  }
  message.c('active', {
    xmlns: ChatStatesNS.CHAT_STATES
  }).up();
  if (type === MessageType.GROUPCHAT) {
    message.c('x', {
      xmlns: 'http://jabber.org/protocol/muc'
    });
  }
  return message;
};

exports.getChatHistoryStanza = function(jid, before, max) {
  var beforeStanza, stanza;
  if (max == null) {
    max = HISTORY_MAX;
  }
  stanza = $iq({
    xmlns: Strophe.NS.CLIENT,
    type: 'set'
  }).c('query', {
    xmlns: HistoryNS.CHAT_HISTORY
  }).c('with').t(jid).up().c('set', {
    xmlns: HistoryNS.RSM
  });
  stanza.cnode(getMaxStanza(max).tree());
  stanza.up();
  if (beforeStanza = getBeforeStanza(before)) {
    stanza.cnode(beforeStanza.tree());
    stanza.up();
  }
  return stanza;
};

exports.getGroupchatHistoryStanza = function(jid, before, max) {
  var beforeStanza, stanza;
  if (max == null) {
    max = HISTORY_MAX;
  }
  stanza = $iq({
    xmlns: Strophe.NS.CLIENT,
    type: 'set',
    to: jid
  }).c('query', {
    xmlns: HistoryNS.CHAT_HISTORY
  }).c('set', {
    xmlns: HistoryNS.RSM
  });
  stanza.cnode(getMaxStanza(max).tree());
  stanza.up();
  if (beforeStanza = getBeforeStanza(before)) {
    stanza.cnode(beforeStanza.tree());
    stanza.up();
  }
  return stanza;
};

exports.getManagedHistoryStanza = function(jid, before, max) {
  var beforeStanza, stanza;
  if (max == null) {
    max = HISTORY_MAX;
  }
  stanza = $iq({
    xmlns: Strophe.NS.CLIENT,
    to: jid,
    type: 'set'
  }).c('query', {
    xmlns: HistoryNS.SEARCH
  }).c('set', {
    xmlns: HistoryNS.RSM
  });
  stanza.cnode(getMaxStanza(max).tree());
  stanza.up();
  if (beforeStanza = getBeforeStanza(before)) {
    stanza.cnode(beforeStanza.tree());
    stanza.up();
  }
  return stanza;
};

exports.getTypingStanza = function(jid) {
  return $msg({
    to: jid
  }).c('composing', {
    xmlns: 'http://jabber.org/protocol/chatstates'
  });
};

getMaxStanza = function(max) {
  if (max == null) {
    max = HISTORY_MAX;
  }
  return new Strophe.Builder('max', {}).t(max);
};

getBeforeStanza = function(before) {
  var stanza;
  stanza = new Strophe.Builder('before', {});
  if (before) {
    stanza.t(before);
  }
  return stanza;
};


},{"enum/ack_ns":"enum/ack_ns","enum/chat_states_ns":"enum/chat_states_ns","enum/history_ns":"enum/history_ns","enum/message_type":"enum/message_type","strophe":"lib/strophe","util/matchers":"util/matchers"}],"strophe/strophe_muc":[function(require,module,exports){
var MUCField, MUCNS, MUCRole, Strophe, _;

_ = require('underscore');

Strophe = require('strophe');

MUCField = require('enum/muc_field');

MUCNS = require('enum/muc_ns');

MUCRole = require('enum/muc_role');

exports.getJoinStanza = function(jid, resourceId) {
  return $pres({
    to: jid + "/" + resourceId
  }).c('x', {
    xmlns: MUCNS.ROOT
  });
};

exports.getLeaveStanza = function(jid) {
  return $pres({
    to: jid,
    type: 'unavailable'
  }).c('x', {
    xmlns: MUCNS.ROOT
  });
};

exports.getDestroyGroupchatStanza = function(jid) {
  return $iq({
    to: jid,
    type: 'set'
  }).c('query', {
    xmlns: MUCNS.OWNER
  }).c('destroy');
};

exports.getGroupchatConfigForm = function(jid, fieldName, fieldValue) {
  var stanza;
  stanza = $iq({
    to: jid,
    type: 'set'
  }).c('query', {
    xmlns: MUCNS.OWNER
  }).c('x', {
    xmlns: 'jabber:x:data',
    type: 'submit'
  }).c('field', {
    "var": MUCField.FORM_TYPE
  }).c('value').t(MUCNS.ROOT + "#roomconfig").up().up();
  return stanza.c('field', {
    "var": fieldName
  }).c('value').t(fieldValue).up().up();
};

exports.getRoomDiscoStanza = function(jid) {
  return $iq({
    to: jid,
    type: 'get'
  }).c('query', {
    xmlns: MUCNS.DISCO_INFO
  }).up();
};

exports.getManagedRoomDiscoStanza = function(jid) {
  return $iq({
    to: jid,
    type: 'get'
  }).c('query', {
    xmlns: MUCNS.OWNER
  }).up();
};

exports.getMemberListStanza = function(jid, affiliations) {
  var affiliation, i, len, stanza;
  if (affiliations == null) {
    affiliations = [];
  }
  stanza = $iq({
    to: jid,
    type: 'get'
  });
  stanza.c('query', {
    xmlns: MUCNS.ADMIN
  });
  for (i = 0, len = affiliations.length; i < len; i++) {
    affiliation = affiliations[i];
    stanza.c('item', {
      affiliation: affiliation
    }).up();
  }
  return stanza;
};

exports.getMediatedInviteStanza = function(jid, selfJID, invitees, type) {
  var i, invitee, len, stanza;
  if (invitees == null) {
    invitees = [];
  }
  if (type == null) {
    type = '';
  }
  stanza = $msg({
    to: jid
  }).c('x', {
    xmlns: MUCNS.USER
  });
  for (i = 0, len = invitees.length; i < len; i++) {
    invitee = invitees[i];
    stanza.c('invite', {
      to: invitee,
      from: selfJID
    });
    if (type) {
      stanza.c('reason', {}, JSON.stringify({
        type: type
      }));
    }
    stanza.up();
  }
  return stanza;
};

exports.getDeclineMediatedInviteStanza = function(jid, inviter, reason) {
  var $rejectInviteMessage;
  if (reason == null) {
    reason = '';
  }
  $rejectInviteMessage = $msg({
    to: jid
  }).c('x', {
    xmlns: 'http://jabber.org/protocol/muc#user'
  }).c("decline", {
    to: inviter
  });
  if (!_.isEmpty(reason)) {
    $rejectInviteMessage.c('reason', {}, reason);
  }
  return $rejectInviteMessage;
};

exports.getSearchStanza = function(jid, match, max) {
  if (match == null) {
    match = '';
  }
  if (max == null) {
    max = 5;
  }
  return $iq({
    xmlns: 'jabber:client',
    to: jid,
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:search'
  }).c('set', {
    xmlns: 'http://jabber.org/protocol/rsm'
  }).c('max', {}, max.toString()).up().c('name', {}, match);
};

exports.getKickStanza = function(jid, users, reason) {
  var i, len, stanza, user;
  if (users == null) {
    users = [];
  }
  stanza = $iq({
    to: jid,
    type: 'set'
  }).c('query', {
    xmlns: MUCNS.ADMIN
  });
  for (i = 0, len = users.length; i < len; i++) {
    user = users[i];
    stanza.c('item', {
      jid: user,
      affiliation: MUCRole.NONE
    });
    if (!_.isEmpty(reason)) {
      stanza.c('reason', {}, reason).up();
    }
    stanza.up();
  }
  return stanza;
};


},{"enum/muc_field":"enum/muc_field","enum/muc_ns":"enum/muc_ns","enum/muc_role":"enum/muc_role","strophe":"lib/strophe","underscore":85}],"strophe/strophe_presence":[function(require,module,exports){
var Strophe, XMPPPresence, _;

_ = require('underscore');

Strophe = require('strophe');

XMPPPresence = require('enum/xmpp_presence');

exports.PRESENCE = 'presence';

exports.VISIBLE = 'visible';

exports.INVISIBLE = 'invisible';

exports.getPresenceStanza = function(jid, type, show) {
  var stanza;
  if (jid == null) {
    jid = '';
  }
  if (type == null) {
    type = '';
  }
  if (show == null) {
    show = '';
  }
  stanza = $pres();
  if (jid && _.isString(jid)) {
    stanza.attrs({
      to: jid
    });
  }
  if (type && _.isString(type)) {
    stanza.attrs({
      type: type
    });
  }
  if (show && _.isString(show)) {
    stanza.c('show').t(show);
  }
  return stanza;
};

exports.getVisibleStanza = function(visible) {
  var nodeName;
  if (visible == null) {
    visible = true;
  }
  nodeName = visible ? this.VISIBLE : this.INVISIBLE;
  return $iq({
    type: 'set'
  }).c(nodeName, {
    xmlns: 'urn:xmpp:invisible:0'
  });
};


},{"enum/xmpp_presence":"enum/xmpp_presence","strophe":"lib/strophe","underscore":85}],"strophe/strophe_roster":[function(require,module,exports){
var Strophe, _, strophePresence;

_ = require('underscore');

Strophe = require('strophe');

strophePresence = require('strophe/strophe_presence');

exports.getRosterStanza = function(address) {
  var stanza;
  if (address == null) {
    address = '';
  }
  stanza = $iq({
    type: 'get'
  });
  if (address && _.isString(address)) {
    stanza.attrs({
      to: address
    });
  }
  stanza.c('query', {
    xmlns: 'jabber:iq:roster'
  });
  return stanza;
};

exports.getAddStanza = function(jid, name, groups) {
  var group, i, itemData, len, stanza;
  if (groups == null) {
    groups = [];
  }
  stanza = $iq({
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:roster'
  });
  itemData = {
    jid: jid
  };
  if (typeof name === 'string' && name.length) {
    itemData.name = name;
  }
  stanza.c('item', itemData);
  for (i = 0, len = groups.length; i < len; i++) {
    group = groups[i];
    stanza.c('group').t(group).up();
  }
  return stanza;
};

exports.getRemoveStanza = function(jid) {
  if (!jid) {
    return null;
  }
  return $iq({
    type: 'set'
  }).c('query', {
    xmlns: Strophe.NS.ROSTER
  }).c('item', {
    jid: jid,
    subscription: 'remove'
  });
};

exports.getPresenceSubscriptionStanza = function(jid, type) {
  return strophePresence.getPresenceStanza(jid, type);
};


},{"strophe":"lib/strophe","strophe/strophe_presence":"strophe/strophe_presence","underscore":85}],"strophe/strophe_storage":[function(require,module,exports){
var Strophe, _;

_ = require('underscore');

Strophe = require('strophe');

exports.getPreferencesStanza = function() {
  return new Strophe.Builder('iq', {
    type: 'get'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'storage:preferences'
  }).c('preferences', {
    xmlns: 'trm:desktop'
  });
};

exports.setPreferencesStanza = function(preferences) {
  var preferencesStr;
  if (preferences == null) {
    preferences = {};
  }
  if (_.isEmpty(preferences)) {
    return null;
  }
  preferencesStr = JSON.stringify(preferences);
  return new Strophe.Builder('iq', {
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'storage:preferences'
  }).c('preferences', {
    xmlns: 'trm:desktop'
  }).t(preferencesStr).up();
};

exports.setGlobalPreferencesStanza = function(xml) {
  if (!xml) {
    return null;
  }
  return new Strophe.Builder('iq', {
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'storage:preferences'
  }).cnode(xml).up();
};

exports.setEMPreferencesStanza = function(xml) {
  if (!xml) {
    return null;
  }
  return new Strophe.Builder('iq', {
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'https://collab.thomsonreuters.com/storage/em'
  }).cnode(xml).up();
};

exports.setBlastPreferencesStanza = function(xml) {
  if (!xml) {
    return null;
  }
  return new Strophe.Builder('iq', {
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'https://collab.thomsonreuters.com/storage/blasts'
  }).cnode(xml).up();
};

exports.setConversationPreferencesStanza = function(xml) {
  if (!xml) {
    return null;
  }
  return new Strophe.Builder('iq', {
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'https://collab.thomsonreuters.com/storage/conversations'
  }).cnode(xml).up();
};

exports.setAlertPreferencesStanza = function(xml) {
  if (!xml) {
    return null;
  }
  return new Strophe.Builder('iq', {
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'https://collab.thomsonreuters.com/storage/alerts'
  }).cnode(xml).up();
};

exports.getGlobalPreferencesStanza = function() {
  return new Strophe.Builder('iq', {
    type: 'get'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'storage:preferences'
  });
};

exports.getEMPreferencesStanza = function() {
  return new Strophe.Builder('iq', {
    type: 'get'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'https://collab.thomsonreuters.com/storage/em'
  });
};

exports.getBlastsPreferencesStanza = function() {
  return new Strophe.Builder('iq', {
    type: 'get'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'https://collab.thomsonreuters.com/storage/blasts'
  });
};

exports.getConversationPreferencesStanza = function() {
  return new Strophe.Builder('iq', {
    type: 'get'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'https://collab.thomsonreuters.com/storage/conversations'
  });
};

exports.getAlertsPreferencesStanza = function() {
  return new Strophe.Builder('iq', {
    type: 'get'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'https://collab.thomsonreuters.com/storage/alerts'
  });
};

exports.clearPreferencesStanza = function() {
  return new Strophe.Builder('iq', {
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'storage:preferences'
  }).c('preferences', {
    xmlns: 'trm:desktop'
  }).t('').up();
};

exports.clearGlobalPreferencesStanza = function() {
  return new Strophe.Builder('iq', {
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'storage:preferences'
  }).t('').up();
};

exports.clearEMPreferencesStanza = function() {
  return new Strophe.Builder('iq', {
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'https://collab.thomsonreuters.com/storage/em'
  }).t('').up();
};

exports.clearBlastsPreferencesStanza = function() {
  return new Strophe.Builder('iq', {
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'https://collab.thomsonreuters.com/storage/blasts'
  }).t('').up();
};

exports.clearConversationsPreferencesStanza = function() {
  return new Strophe.Builder('iq', {
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'https://collab.thomsonreuters.com/storage/conversations'
  }).t('').up();
};

exports.clearAlertsPreferencesStanza = function() {
  return new Strophe.Builder('iq', {
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'https://collab.thomsonreuters.com/storage/alerts'
  }).t('').up();
};

exports.getBookmarksStanza = function() {
  return new Strophe.Builder('iq', {
    type: 'get'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'storage:bookmarks'
  });
};

exports.setBookmarksStanza = function(chatrooms) {
  var chatroom, i, len, sb;
  sb = new Strophe.Builder('iq', {
    type: 'set'
  }).c('query', {
    xmlns: 'jabber:iq:private'
  }).c('storage', {
    xmlns: 'storage:bookmarks'
  });
  for (i = 0, len = chatrooms.length; i < len; i++) {
    chatroom = chatrooms[i];
    sb.c(chatroom.type, chatroom).up();
  }
  return sb;
};


},{"strophe":"lib/strophe","underscore":85}],"strophe/strophe_yahoo_gateway":[function(require,module,exports){
var Strophe, _, strophePresence, stropheRoster;

_ = require('underscore');

Strophe = require('strophe');

stropheRoster = require('strophe/strophe_roster');

strophePresence = require('strophe/strophe_presence');

exports.getRegisterStanza = function(address, username, password, autoLogin) {
  var info, iq;
  if (autoLogin == null) {
    autoLogin = false;
  }
  info = {
    to: address,
    type: 'set'
  };
  iq = $iq(info).c('query', {
    xmlns: 'jabber:iq:register'
  }).c('x', {
    xmlns: 'jabber:x:data',
    type: 'submit'
  }).c('field', {
    "var": 'FORM_TYPE'
  }).c('value').t('jabber:iq:register').up().up();
  iq.c('field', {
    "var": 'username'
  }).c('value').t(username).up().up().c('field', {
    "var": 'password'
  }).c('value').t(password).up().up();
  if (autoLogin) {
    iq.c('field', {
      "var": 'autologin'
    }).c('value').t('1').up().up();
  }
  return iq;
};

exports.getUnregisterStanza = function(address) {
  var info;
  info = {
    to: address,
    type: 'set'
  };
  return $iq(info).c('query', {
    xmlns: 'jabber:iq:register'
  }).c('remove');
};

exports.getRosterStanza = function(address) {
  if (!address) {
    return null;
  }
  return stropheRoster.getRosterStanza(address);
};

exports.getSubscriptionStanza = function(address, type, show) {
  if (!(address && type)) {
    return null;
  }
  return strophePresence.getPresenceStanza(address, type, show);
};

exports.getAddContactStanza = function(jid) {
  if (!jid) {
    return null;
  }
  return strophePresence.getPresenceStanza(jid, 'subscribe');
};

exports.getAllowContactStanza = function(jid) {
  if (!jid) {
    return null;
  }
  return strophePresence.getPresenceStanza(jid, 'subscribed');
};

exports.getRemoveContactStanza = function(jid) {
  if (!jid) {
    return null;
  }
  return strophePresence.getPresenceStanza(jid, 'unsubscribe');
};


},{"strophe":"lib/strophe","strophe/strophe_presence":"strophe/strophe_presence","strophe/strophe_roster":"strophe/strophe_roster","underscore":85}],"util/limit":[function(require,module,exports){
var ERROR_CALL_MAX_INDEFINITE, ERROR_DEFAULT, ERROR_MAX_0, _, positiveInt;

_ = require('underscore');

ERROR_DEFAULT = "You have exceeded the number of allowable function calls for this time period";

ERROR_MAX_0 = "The allowable number of function calls is 0";

ERROR_CALL_MAX_INDEFINITE = "You have exceeded the number of allowable function calls";

exports.limit = function(func, options) {
  var calls, context, errorMessage, max, noReset, ref, time;
  if (options == null) {
    options = {};
  }
  ref = _.defaults(options, {
    context: window,
    errorMessage: ERROR_DEFAULT
  }), max = ref.max, time = ref.time, context = ref.context, errorMessage = ref.errorMessage;
  max = positiveInt(max, 1);
  time = positiveInt(time, 1000);
  calls = [];
  noReset = time ? false : true;
  return function() {
    var now, refIndex, refTime;
    now = new Date().getTime();
    if (max === 0) {
      return new Error(ERROR_MAX_0);
    }
    if ((calls.length >= max) && noReset) {
      return new Error(ERROR_CALL_MAX_INDEFINITE);
    }
    if ((refIndex = calls.length - max) >= 0) {
      if ((refTime = calls[refIndex]) >= 0) {
        if (now - refTime < time) {
          return new Error(errorMessage);
        } else {
          calls = [];
        }
      }
    }
    calls.push(now);
    return func.apply(context, arguments);
  };
};

positiveInt = function(n, defaultVal) {
  var num;
  num = Number(n);
  if (num >= 0) {
    return ~~num;
  } else {
    return defaultVal;
  }
};

module.exports = exports;


},{"underscore":85}],"util/matchers":[function(require,module,exports){
exports.isGroupchat = function(jid) {
  return /@(conference|legacychat)\./i.test(jid);
};

exports.isManagedGroupchat = function(jid) {
  return /@legacychat\./i.test(jid);
};

exports.isBilateralGroupchat = function(jid) {
  return /@conference\./i.test(jid);
};

exports.isYahoo = function(jid) {
  return /.*@(yahoo|rocketmail|ymail)\./.test(jid);
};

exports.isNitroContact = function(jid) {
  return /.*@(reuasmb|reuters)\.net/.test(jid);
};


},{}],"util/not":[function(require,module,exports){
module.exports.not = function(func) {
  return function() {
    return !func.apply(this, arguments);
  };
};


},{}],"util/promise":[function(require,module,exports){
var Q;

Q = require('q');

module.exports = function(fn) {
  return Q.Promise(fn).fail(function(data) {
    var error;
    if (data == null) {
      data = {};
    }
    error = data instanceof Error ? data : new Error();
    error.data = data;
    throw error;
  });
};


},{"q":47}],"util/rate_limiter":[function(require,module,exports){
var RateLimiter, _;

_ = require('underscore');

_.mixin(require('util/limit'));

RateLimiter = (function() {
  RateLimiter.ERROR_FUNCTION_MISSING = "Function is missing or invalid";

  RateLimiter.prototype._func = null;

  RateLimiter.prototype._max = null;

  RateLimiter.prototype._time = null;

  RateLimiter.prototype._context = null;

  RateLimiter.prototype._errorMessage = null;

  function RateLimiter(func, options) {
    var context, errorMessage, max, time;
    if (options == null) {
      options = {};
    }
    max = options.max, time = options.time, context = options.context, errorMessage = options.errorMessage;
    this._func = func;
    this._max = max;
    this._time = time;
    this._context = context;
    this._errorMessage = errorMessage;
    if (!_.isFunction(this._func)) {
      throw new Error(this.constructor.ERROR_FUNCTION_MISSING);
    }
    this.addAlias('invoke', options);
    return this;
  }

  RateLimiter.prototype.addAlias = function(name, options) {
    var opts;
    if (options == null) {
      options = {};
    }
    opts = _.defaults(options, {
      max: this._max,
      time: this._time,
      context: this._context,
      errorMessage: this._errorMessage
    });
    if (!name) {
      return null;
    }
    return this[name] = _.limit(this.invoke || this._func, opts);
  };

  return RateLimiter;

})();

module.exports = RateLimiter;


},{"underscore":85,"util/limit":"util/limit"}],"util/retryer":[function(require,module,exports){
var ALL_ATTEMPTS_FAILED, ATTEMPT_FAILED, Q, TIMED_OUT, _, validateMaxRetries,
  slice = [].slice;

_ = require('underscore');

Q = require('q');

_.mixin(require('util/utils'));

ATTEMPT_FAILED = "Attempt failed:";

ALL_ATTEMPTS_FAILED = "All attempts have failed.";

TIMED_OUT = "The retryer has timed out.";

exports.retry = function(func, options) {
  var attempt, context, dfd, intervalTimeout, invoke, max, progress, ref, timeout, timeoutId, wait;
  if (options == null) {
    options = {};
  }
  ref = _.defaults(options, {
    timeout: 2 * 60 * 1000,
    context: null
  }), max = ref.max, wait = ref.wait, timeout = ref.timeout, context = ref.context, progress = ref.progress;
  max = validateMaxRetries(max, 1);
  wait = _.toFunction(wait || 0);
  attempt = 0;
  dfd = Q.defer();
  timeoutId = null;
  intervalTimeout = null;
  return invoke = function() {
    var args, funcArgs, onFail, retVal;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    timeoutId = setTimeout(function() {
      var msg;
      msg = TIMED_OUT;
      dfd.reject(new Error(msg));
      return clearTimeout(intervalTimeout);
    }, timeout);
    funcArgs = args.concat([
      {
        attempt: ++attempt
      }
    ]);
    retVal = func.apply(context, funcArgs);
    onFail = function(error) {
      var waitInterval;
      if (attempt < max) {
        console.log(ATTEMPT_FAILED + " " + attempt + " of " + max);
        waitInterval = wait(attempt, max);
        if (_.isFunction(progress)) {
          progress(retVal, attempt, max, waitInterval);
        }
        return intervalTimeout = setTimeout((function() {
          return invoke.apply(context, args);
        }), waitInterval);
      } else {
        console.log(ALL_ATTEMPTS_FAILED);
        return dfd.reject(new Error(ALL_ATTEMPTS_FAILED));
      }
    };
    Q(retVal).then(function(data) {
      if (data === retVal) {
        if (!data) {
          throw new Error("Syncronous return value is falsy");
        }
      }
      clearTimeout(timeoutId);
      return data;
    }).then(dfd.resolve)["catch"](onFail);
    return dfd.promise;
  };
};

validateMaxRetries = function(n, defaultValue) {
  if (typeof n === 'number' && Math.round(n) === n && n >= 1) {
    return n;
  } else {
    console.warn("[Retryer] max retries value is an invalid number, using default value of " + defaultValue + ".");
    return defaultValue;
  }
};


},{"q":47,"underscore":85,"util/utils":"util/utils"}],"util/utils":[function(require,module,exports){
var _;

_ = require('underscore');

exports.conditional = function(func, condition) {
  if (typeof condition !== 'function') {
    return func;
  }
  return function() {
    if (condition.apply(null, arguments)) {
      return func.apply(null, arguments);
    } else {
      return null;
    }
  };
};

exports.returnBoolean = function(func, bool) {
  if (bool == null) {
    bool = true;
  }
  return function() {
    func.apply(null, arguments);
    return !!bool;
  };
};

exports.array = function() {
  var args, convertToArray, i, len, obj, results;
  args = Array.prototype.slice.call(arguments, 0);
  convertToArray = function(obj) {
    if (_.isArray(obj)) {
      return obj;
    } else {
      return _.compact([obj]);
    }
  };
  if (args.length === 1) {
    return convertToArray(args[0]);
  } else {
    results = [];
    for (i = 0, len = args.length; i < len; i++) {
      obj = args[i];
      results.push(convertToArray(obj));
    }
    return results;
  }
};

exports.returnBool = this.returnBoolean;

exports.tryCatch = function(func, level) {
  if (level == null) {
    level = 'warn';
  }
  return function() {
    var error, error1;
    try {
      return func();
    } catch (error1) {
      error = error1;
      console[level](error.message);
      return null;
    }
  };
};

exports.toFunction = function(obj) {
  var theObj;
  theObj = obj;
  if (_.isFunction(theObj)) {
    return theObj;
  } else {
    return function() {
      return theObj;
    };
  }
};


},{"underscore":85}],"util/xmpp_utils":[function(require,module,exports){
var PresenceShow, Strophe, XMPPPresence, _;

_ = require('underscore');

XMPPPresence = require('enum/xmpp_presence');

PresenceShow = require('enum/presence_show');

Strophe = require('strophe');

exports.getXMPPDomain = function(jid) {
  var xmppDomain;
  jid = Strophe.getBareJidFromJid(jid);
  if (xmppDomain = /@.+$/.exec(jid)) {
    return xmppDomain[0].substr(1);
  } else {
    return "";
  }
};

exports.xmppPresenceToShow = function(presence) {
  switch (presence) {
    case XMPPPresence.AWAY:
      return PresenceShow.AWAY;
    case XMPPPresence.EXTENDED_AWAY:
      return PresenceShow.EXTENDED_AWAY;
    case XMPPPresence.DND:
      return PresenceShow.DND;
    default:
      return '';
  }
};

exports.xmppPresenceToType = function(presence) {
  if (presence === XMPPPresence.UNAVAILABLE) {
    return XMPPPresence.UNAVAILABLE;
  } else {
    return null;
  }
};

exports.emailToJID = function(email, xmppDomain) {
  if (email == null) {
    email = '';
  }
  if (!(xmppDomain && /@/.test(email))) {
    return email;
  }
  return (email.replace('@', '.')) + "@" + xmppDomain;
};


},{"enum/presence_show":"enum/presence_show","enum/xmpp_presence":"enum/xmpp_presence","strophe":"lib/strophe","underscore":85}]},{},["nitro"])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvUS9xLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2NoYWktYXMtcHJvbWlzZWQvbGliL2NoYWktYXMtcHJvbWlzZWQuanMiLCJub2RlX21vZHVsZXMvY2hhaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvYXNzZXJ0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29yZS9hc3NlcnRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvaW50ZXJmYWNlL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9leHBlY3QuanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9pbnRlcmZhY2Uvc2hvdWxkLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkQ2hhaW5hYmxlTWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkTWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9mbGFnLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0QWN0dWFsLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRNZXNzYWdlLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0TmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldFBhdGhJbmZvLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0UGF0aFZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0UHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2hhc1Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pbnNwZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb2JqRGlzcGxheS5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZU1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdGVzdC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3RyYW5zZmVyRmxhZ3MuanMiLCJub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvYXNzZXJ0aW9uLWVycm9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL2xpYi9lcWwuanMiLCJub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvZGVlcC1lcWwvbm9kZV9tb2R1bGVzL3R5cGUtZGV0ZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL25vZGVfbW9kdWxlcy90eXBlLWRldGVjdC9saWIvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL25vZGVfbW9kdWxlcy90eXBlLWRldGVjdC9saWIvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9qcy1maXh0dXJlcy9maXh0dXJlcy5qcyIsIm5vZGVfbW9kdWxlcy9xL3EuanMiLCJub2RlX21vZHVsZXMvc2hvcnRpZC9saWIvYWxwaGFiZXQuanMiLCJub2RlX21vZHVsZXMvc2hvcnRpZC9saWIvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3Nob3J0aWQvbGliL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9zaG9ydGlkL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaG9ydGlkL2xpYi9pcy12YWxpZC5qcyIsIm5vZGVfbW9kdWxlcy9zaG9ydGlkL2xpYi9yYW5kb20vcmFuZG9tLWJ5dGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zaG9ydGlkL2xpYi9yYW5kb20vcmFuZG9tLWZyb20tc2VlZC5qcyIsIm5vZGVfbW9kdWxlcy9zaG9ydGlkL2xpYi91dGlsL2NsdXN0ZXItd29ya2VyLWlkLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2lub24tY2hhaS9saWIvc2lub24tY2hhaS5qcyIsIm5vZGVfbW9kdWxlcy9zaW5vbi9saWIvc2lub24uanMiLCJub2RlX21vZHVsZXMvc2lub24vbGliL3Npbm9uL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9zaW5vbi9saWIvc2lub24vYmVoYXZpb3IuanMiLCJub2RlX21vZHVsZXMvc2lub24vbGliL3Npbm9uL2NhbGwuanMiLCJub2RlX21vZHVsZXMvc2lub24vbGliL3Npbm9uL2NvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvc2lub24vbGliL3Npbm9uL2V4dGVuZC5qcyIsIm5vZGVfbW9kdWxlcy9zaW5vbi9saWIvc2lub24vZm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL3Npbm9uL2xpYi9zaW5vbi9sb2dfZXJyb3IuanMiLCJub2RlX21vZHVsZXMvc2lub24vbGliL3Npbm9uL21hdGNoLmpzIiwibm9kZV9tb2R1bGVzL3Npbm9uL2xpYi9zaW5vbi9tb2NrLmpzIiwibm9kZV9tb2R1bGVzL3Npbm9uL2xpYi9zaW5vbi9zYW5kYm94LmpzIiwibm9kZV9tb2R1bGVzL3Npbm9uL2xpYi9zaW5vbi9zcHkuanMiLCJub2RlX21vZHVsZXMvc2lub24vbGliL3Npbm9uL3N0dWIuanMiLCJub2RlX21vZHVsZXMvc2lub24vbGliL3Npbm9uL3Rlc3QuanMiLCJub2RlX21vZHVsZXMvc2lub24vbGliL3Npbm9uL3Rlc3RfY2FzZS5qcyIsIm5vZGVfbW9kdWxlcy9zaW5vbi9saWIvc2lub24vdGltZXNfaW5fd29yZHMuanMiLCJub2RlX21vZHVsZXMvc2lub24vbGliL3Npbm9uL3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9zaW5vbi9saWIvc2lub24vdXRpbC9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL3Npbm9uL2xpYi9zaW5vbi91dGlsL2V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3Npbm9uL2xpYi9zaW5vbi91dGlsL2Zha2Vfc2VydmVyLmpzIiwibm9kZV9tb2R1bGVzL3Npbm9uL2xpYi9zaW5vbi91dGlsL2Zha2Vfc2VydmVyX3dpdGhfY2xvY2suanMiLCJub2RlX21vZHVsZXMvc2lub24vbGliL3Npbm9uL3V0aWwvZmFrZV90aW1lcnMuanMiLCJub2RlX21vZHVsZXMvc2lub24vbGliL3Npbm9uL3V0aWwvZmFrZV94ZG9tYWluX3JlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvc2lub24vbGliL3Npbm9uL3V0aWwvZmFrZV94bWxfaHR0cF9yZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzL3Npbm9uL25vZGVfbW9kdWxlcy9mb3JtYXRpby9saWIvZm9ybWF0aW8uanMiLCJub2RlX21vZHVsZXMvc2lub24vbm9kZV9tb2R1bGVzL2xvbGV4L3NyYy9sb2xleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW5vbi9ub2RlX21vZHVsZXMvc2Ftc2FtL2xpYi9zYW1zYW0uanMiLCJub2RlX21vZHVsZXMvc2l6emxlL2Rpc3Qvc2l6emxlLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsIm5vZGVfbW9kdWxlcy92b29tL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Zvb20vcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL3Zvb20vc3JjL2xpYi5qcyIsIm5vZGVfbW9kdWxlcy92b29tL3NyYy92b29tLmpzIiwibm9kZV9tb2R1bGVzL3htbC1qc29uLXBhcnNlci94bWwtanNvbi1wYXJzZXIuanMiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvYWRhcHRlcnMvYWRhcHRlcnMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL2FkYXB0ZXJzL2RhdGFfcGF5bG9hZC5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvYWRhcHRlcnMvcHJlZmVyZW5jZXMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL2NvbXBvbmVudHMvYmxvY2tsaXN0LmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC9jb21wb25lbnRzL2dhdGV3YXkuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL2NvbXBvbmVudHMvbWVzc2FnaW5nLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC9jb21wb25lbnRzL211Yy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvY29tcG9uZW50cy9yb3N0ZXIuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL2NvbXBvbmVudHMvc3RvcmFnZS5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvY29uZmlnLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC9jb25uZWN0aW9uLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC9lbnVtL2Fja19ucy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvZW51bS9jaGF0X3N0YXRlc19ucy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvZW51bS9jb21wbGlhbmNlX2Vycm9yLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC9lbnVtL2dhdGV3YXlfZXJyb3IuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL2VudW0vZ2F0ZXdheV9zdGF0ZS5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvZW51bS9nYXRld2F5cy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvZW51bS9oaXN0b3J5X25zLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC9lbnVtL21lc3NhZ2VfdHlwZS5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvZW51bS9tdWNfZXJyb3JfdHlwZS5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvZW51bS9tdWNfZXJyb3IuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL2VudW0vbXVjX2ZpZWxkLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC9lbnVtL211Y19ub2RlLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC9lbnVtL211Y19ucy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvZW51bS9tdWNfcm9sZS5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvZW51bS9tdWNfdHlwZXMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL2VudW0vcHJlc2VuY2Vfc2hvdy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvZW51bS9wcmVzZW5jZV90eXBlLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC9lbnVtL3N0YXR1c19sYWJlbHMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL2VudW0vc3RhdHVzLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC9lbnVtL3N1YnNjcmlwdGlvbl9zdGF0dXMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL2VudW0veG1wcF9wcmVzZW5jZS5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvZW51bS95YWhvb19lcnJvci5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvZXZlbnRzL2V2ZW50X2ZpbHRlcnMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL2V2ZW50cy9ldmVudF9oYW5kbGVyLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC9ldmVudHMvZXZlbnRfbWFuYWdlci5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvZXZlbnRzL2V2ZW50cy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvZXZlbnRzL2lvX2V2ZW50LmNvZmZlZSIsInNyYy9saWIvc3Ryb3BoZS5qcyIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC9uaXRyby5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9zcGVjL2FkYXB0ZXJzL2FkYXB0ZXJzX3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy9jbG9zdXJlX3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy9jb21wb25lbnRzL2Jsb2NrbGlzdF9zcGVjLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL3NwZWMvY29tcG9uZW50cy9nYXRld2F5X3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy9jb21wb25lbnRzL21lc3NhZ2luZ19zcGVjLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL3NwZWMvY29tcG9uZW50cy9tdWNfc3BlYy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9zcGVjL2NvbXBvbmVudHMvcm9zdGVyX3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy9jb21wb25lbnRzL3N0b3JhZ2Vfc3BlYy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9zcGVjL2Nvbm5lY3Rpb25fc3BlYy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9zcGVjL2V2ZW50cy9ldmVudF9maWx0ZXJzX3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy9ldmVudHMvZXZlbnRfaGFuZGxlcl9zcGVjLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL3NwZWMvZXZlbnRzL2V2ZW50X21hbmFnZXJfc3BlYy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9zcGVjL2V2ZW50cy9ldmVudHNfc3BlYy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9zcGVjL2ZyYW1ld29ya19zcGVjLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL3NwZWMvc3BlY19oZWxwZXIuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy9zcGVjX3J1bm5lci5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9zcGVjL3N0cm9waGUvc3Ryb3BoZV9ibG9ja2xpc3Rfc3BlYy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9zcGVjL3N0cm9waGUvc3Ryb3BoZV9kaXNjb19zcGVjLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL3NwZWMvc3Ryb3BoZS9zdHJvcGhlX2lvX3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy9zdHJvcGhlL3N0cm9waGVfbWVzc2FnaW5nX3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy9zdHJvcGhlL3N0cm9waGVfbXVjX3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy9zdHJvcGhlL3N0cm9waGVfcHJlc2VuY2Vfc3BlYy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9zcGVjL3N0cm9waGUvc3Ryb3BoZV9yb3N0ZXJfc3BlYy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9zcGVjL3N0cm9waGUvc3Ryb3BoZV9zdG9yYWdlX3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy9zdHJvcGhlL3N0cm9waGVfeWFob29fZ2F0ZXdheV9zcGVjLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL3NwZWMvc3VpdGVzL2Nvbm5lY3Rpb25fc3VpdGVfc3BlYy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9zcGVjL3N1aXRlcy9ldmVudHNfc3VpdGVfc3BlYy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9zcGVjL3N1aXRlcy91dGlsX3N1aXRlX3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy91dGlsL2xpbWl0X3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy91dGlsL21hdGNoZXJzX3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy91dGlsL3JhdGVfbGltaXRlcl9zcGVjLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL3NwZWMvdXRpbC9yZXRyeWVyX3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy91dGlsL3V0aWxzX3NwZWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvc3BlYy91dGlsL3htcHBfdXRpbHNfc3BlYy5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvc3Ryb3BoZS9zdHJvcGhlX2Jsb2NrbGlzdC5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvc3Ryb3BoZS9zdHJvcGhlX2Rpc2NvLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC9zdHJvcGhlL3N0cm9waGVfaW8uY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL3N0cm9waGUvc3Ryb3BoZV9tZXNzYWdpbmcuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL3N0cm9waGUvc3Ryb3BoZV9tdWMuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL3N0cm9waGUvc3Ryb3BoZV9wcmVzZW5jZS5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvc3Ryb3BoZS9zdHJvcGhlX3Jvc3Rlci5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvc3Ryb3BoZS9zdHJvcGhlX3N0b3JhZ2UuY29mZmVlIiwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvbi9zcmMvYXBwL3N0cm9waGUvc3Ryb3BoZV95YWhvb19nYXRld2F5LmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC91dGlsL2xpbWl0LmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC91dGlsL21hdGNoZXJzLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC91dGlsL25vdC5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvdXRpbC9wcm9taXNlLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC91dGlsL3JhdGVfbGltaXRlci5jb2ZmZWUiLCIvVXNlcnMvUnVzcy9TaXRlcy9uaXRyby14bXBwLWNsaWVudC1jb25uZWN0aW9uL3NyYy9hcHAvdXRpbC9yZXRyeWVyLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC91dGlsL3V0aWxzLmNvZmZlZSIsIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb24vc3JjL2FwcC91dGlsL3htcHBfdXRpbHMuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hnRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblhBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqc0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOTVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hnRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNocEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVnREE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUEsRUFBTyxlQUxQO0VBT0EsTUFBQSxFQUFRLGdCQVBSOzs7Ozs7QUNYRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QVFJO0FBUko7QUFEMkI7O0FBa0I3QixPQUFPLENBQUMsa0JBQVIsR0FBNkIsU0FBQyxRQUFEO0VBQzNCLElBQUcsUUFBQSxLQUFZLFlBQVksQ0FBQyxXQUE1QjtXQUNFLFlBQVksQ0FBQyxZQURmO0dBQUEsTUFBQTtXQUdFLEtBSEY7O0FBRDJCOztBQVk3QixPQUFPLENBQUMsVUFBUixHQUFxQixTQUFDLEtBQUQsRUFBYSxVQUFiOztJQUFDLFFBQVE7O0VBQzVCLElBQUEsQ0FBQSxDQUFvQixVQUFBLElBQWUsR0FBRyxDQUFDLElBQUosQ0FBUyxLQUFULENBQW5DLENBQUE7QUFBQSxXQUFPLE1BQVA7O1NBQ0UsQ0FBQyxLQUFLLENBQUMsT0FBTixDQUFjLEdBQWQsRUFBbUIsR0FBbkIsQ0FBRCxDQUFBLEdBQXdCLEdBQXhCLEdBQTJCO0FBRlYiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gdmltOnRzPTQ6c3RzPTQ6c3c9NDpcbi8qIVxuICpcbiAqIENvcHlyaWdodCAyMDA5LTIwMTIgS3JpcyBLb3dhbCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVFxuICogbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9yYXcvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBXaXRoIHBhcnRzIGJ5IFR5bGVyIENsb3NlXG4gKiBDb3B5cmlnaHQgMjAwNy0yMDA5IFR5bGVyIENsb3NlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIFggbGljZW5zZSBmb3VuZFxuICogYXQgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5odG1sXG4gKiBGb3JrZWQgYXQgcmVmX3NlbmQuanMgdmVyc2lvbjogMjAwOS0wNS0xMVxuICpcbiAqIFdpdGggcGFydHMgYnkgTWFyayBNaWxsZXJcbiAqIENvcHlyaWdodCAoQykgMjAxMSBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFRoaXMgZmlsZSB3aWxsIGZ1bmN0aW9uIHByb3Blcmx5IGFzIGEgPHNjcmlwdD4gdGFnLCBvciBhIG1vZHVsZVxuICAgIC8vIHVzaW5nIENvbW1vbkpTIGFuZCBOb2RlSlMgb3IgUmVxdWlyZUpTIG1vZHVsZSBmb3JtYXRzLiAgSW5cbiAgICAvLyBDb21tb24vTm9kZS9SZXF1aXJlSlMsIHRoZSBtb2R1bGUgZXhwb3J0cyB0aGUgUSBBUEkgYW5kIHdoZW5cbiAgICAvLyBleGVjdXRlZCBhcyBhIHNpbXBsZSA8c2NyaXB0PiwgaXQgY3JlYXRlcyBhIFEgZ2xvYmFsIGluc3RlYWQuXG5cbiAgICAvLyBNb250YWdlIFJlcXVpcmVcbiAgICBpZiAodHlwZW9mIGJvb3RzdHJhcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGJvb3RzdHJhcChcInByb21pc2VcIiwgZGVmaW5pdGlvbik7XG5cbiAgICAvLyBDb21tb25KU1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcblxuICAgIC8vIFJlcXVpcmVKU1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuXG4gICAgLy8gU0VTIChTZWN1cmUgRWNtYVNjcmlwdClcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKCFzZXMub2soKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VzLm1ha2VRID0gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuXG4gICAgLy8gPHNjcmlwdD5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gUHJlZmVyIHdpbmRvdyBvdmVyIHNlbGYgZm9yIGFkZC1vbiBzY3JpcHRzLiBVc2Ugc2VsZiBmb3JcbiAgICAgICAgLy8gbm9uLXdpbmRvd2VkIGNvbnRleHRzLlxuICAgICAgICB2YXIgZ2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBgd2luZG93YCBvYmplY3QsIHNhdmUgdGhlIHByZXZpb3VzIFEgZ2xvYmFsXG4gICAgICAgIC8vIGFuZCBpbml0aWFsaXplIFEgYXMgYSBnbG9iYWwuXG4gICAgICAgIHZhciBwcmV2aW91c1EgPSBnbG9iYWwuUTtcbiAgICAgICAgZ2xvYmFsLlEgPSBkZWZpbml0aW9uKCk7XG5cbiAgICAgICAgLy8gQWRkIGEgbm9Db25mbGljdCBmdW5jdGlvbiBzbyBRIGNhbiBiZSByZW1vdmVkIGZyb20gdGhlXG4gICAgICAgIC8vIGdsb2JhbCBuYW1lc3BhY2UuXG4gICAgICAgIGdsb2JhbC5RLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnbG9iYWwuUSA9IHByZXZpb3VzUTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBlbnZpcm9ubWVudCB3YXMgbm90IGFudGljaXBhdGVkIGJ5IFEuIFBsZWFzZSBmaWxlIGEgYnVnLlwiKTtcbiAgICB9XG5cbn0pKGZ1bmN0aW9uICgpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaGFzU3RhY2tzID0gZmFsc2U7XG50cnkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xufSBjYXRjaCAoZSkge1xuICAgIGhhc1N0YWNrcyA9ICEhZS5zdGFjaztcbn1cblxuLy8gQWxsIGNvZGUgYWZ0ZXIgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzIHJlcG9ydGVkXG4vLyBieSBRLlxudmFyIHFTdGFydGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xudmFyIHFGaWxlTmFtZTtcblxuLy8gc2hpbXNcblxuLy8gdXNlZCBmb3IgZmFsbGJhY2sgaW4gXCJhbGxSZXNvbHZlZFwiXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgcG9zc2libGUgbWVhbnMgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gYSBmdXR1cmUgdHVyblxuLy8gb2YgdGhlIGV2ZW50IGxvb3AuXG52YXIgbmV4dFRpY2sgPShmdW5jdGlvbiAoKSB7XG4gICAgLy8gbGlua2VkIGxpc3Qgb2YgdGFza3MgKHNpbmdsZSwgd2l0aCBoZWFkIG5vZGUpXG4gICAgdmFyIGhlYWQgPSB7dGFzazogdm9pZCAwLCBuZXh0OiBudWxsfTtcbiAgICB2YXIgdGFpbCA9IGhlYWQ7XG4gICAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgdmFyIHJlcXVlc3RUaWNrID0gdm9pZCAwO1xuICAgIHZhciBpc05vZGVKUyA9IGZhbHNlO1xuICAgIC8vIHF1ZXVlIGZvciBsYXRlIHRhc2tzLCB1c2VkIGJ5IHVuaGFuZGxlZCByZWplY3Rpb24gdHJhY2tpbmdcbiAgICB2YXIgbGF0ZXJRdWV1ZSA9IFtdO1xuXG4gICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgICAgICB2YXIgdGFzaywgZG9tYWluO1xuXG4gICAgICAgIHdoaWxlIChoZWFkLm5leHQpIHtcbiAgICAgICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICAgICAgICB0YXNrID0gaGVhZC50YXNrO1xuICAgICAgICAgICAgaGVhZC50YXNrID0gdm9pZCAwO1xuICAgICAgICAgICAgZG9tYWluID0gaGVhZC5kb21haW47XG5cbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkLmRvbWFpbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1blNpbmdsZSh0YXNrLCBkb21haW4pO1xuXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxhdGVyUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXNrID0gbGF0ZXJRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIHJ1blNpbmdsZSh0YXNrKTtcbiAgICAgICAgfVxuICAgICAgICBmbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBydW5zIGEgc2luZ2xlIGZ1bmN0aW9uIGluIHRoZSBhc3luYyBxdWV1ZVxuICAgIGZ1bmN0aW9uIHJ1blNpbmdsZSh0YXNrLCBkb21haW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRhc2soKTtcblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBub2RlLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBjb25zaWRlcmVkIGZhdGFsIGVycm9ycy5cbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIHN5bmNocm9ub3VzbHkgdG8gaW50ZXJydXB0IGZsdXNoaW5nIVxuXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNvbnRpbnVhdGlvbiBpZiB0aGUgdW5jYXVnaHQgZXhjZXB0aW9uIGlzIHN1cHByZXNzZWRcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW5pbmcgXCJ1bmNhdWdodEV4Y2VwdGlvblwiIGV2ZW50cyAoYXMgZG9tYWlucyBkb2VzKS5cbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBpbiBuZXh0IGV2ZW50IHRvIGF2b2lkIHRpY2sgcmVjdXJzaW9uLlxuICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIGJyb3dzZXJzLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBub3QgZmF0YWwuXG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBhc3luY2hyb25vdXNseSB0byBhdm9pZCBzbG93LWRvd25zLlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5leHRUaWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgdGFpbCA9IHRhaWwubmV4dCA9IHtcbiAgICAgICAgICAgIHRhc2s6IHRhc2ssXG4gICAgICAgICAgICBkb21haW46IGlzTm9kZUpTICYmIHByb2Nlc3MuZG9tYWluLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHByb2Nlc3MudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgcHJvY2Vzcy5uZXh0VGljaykge1xuICAgICAgICAvLyBFbnN1cmUgUSBpcyBpbiBhIHJlYWwgTm9kZSBlbnZpcm9ubWVudCwgd2l0aCBhIGBwcm9jZXNzLm5leHRUaWNrYC5cbiAgICAgICAgLy8gVG8gc2VlIHRocm91Z2ggZmFrZSBOb2RlIGVudmlyb25tZW50czpcbiAgICAgICAgLy8gKiBNb2NoYSB0ZXN0IHJ1bm5lciAtIGV4cG9zZXMgYSBgcHJvY2Vzc2AgZ2xvYmFsIHdpdGhvdXQgYSBgbmV4dFRpY2tgXG4gICAgICAgIC8vICogQnJvd3NlcmlmeSAtIGV4cG9zZXMgYSBgcHJvY2Vzcy5uZXhUaWNrYCBmdW5jdGlvbiB0aGF0IHVzZXNcbiAgICAgICAgLy8gICBgc2V0VGltZW91dGAuIEluIHRoaXMgY2FzZSBgc2V0SW1tZWRpYXRlYCBpcyBwcmVmZXJyZWQgYmVjYXVzZVxuICAgICAgICAvLyAgICBpdCBpcyBmYXN0ZXIuIEJyb3dzZXJpZnkncyBgcHJvY2Vzcy50b1N0cmluZygpYCB5aWVsZHNcbiAgICAgICAgLy8gICBcIltvYmplY3QgT2JqZWN0XVwiLCB3aGlsZSBpbiBhIHJlYWwgTm9kZSBlbnZpcm9ubWVudFxuICAgICAgICAvLyAgIGBwcm9jZXNzLm5leHRUaWNrKClgIHlpZWxkcyBcIltvYmplY3QgcHJvY2Vzc11cIi5cbiAgICAgICAgaXNOb2RlSlMgPSB0cnVlO1xuXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBJbiBJRTEwLCBOb2RlLmpzIDAuOSssIG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9Ob2JsZUpTL3NldEltbWVkaWF0ZVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBzZXRJbW1lZGlhdGUuYmluZCh3aW5kb3csIGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbHVzaCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgLy8gQXQgbGVhc3QgU2FmYXJpIFZlcnNpb24gNi4wLjUgKDg1MzYuMzAuMSkgaW50ZXJtaXR0ZW50bHkgY2Fubm90IGNyZWF0ZVxuICAgICAgICAvLyB3b3JraW5nIG1lc3NhZ2UgcG9ydHMgdGhlIGZpcnN0IHRpbWUgYSBwYWdlIGxvYWRzLlxuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gcmVxdWVzdFBvcnRUaWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXF1ZXN0UG9ydFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPcGVyYSByZXF1aXJlcyB1cyB0byBwcm92aWRlIGEgbWVzc2FnZSBwYXlsb2FkLCByZWdhcmRsZXNzIG9mXG4gICAgICAgICAgICAvLyB3aGV0aGVyIHdlIHVzZSBpdC5cbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICByZXF1ZXN0UG9ydFRpY2soKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9sZCBicm93c2Vyc1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBydW5zIGEgdGFzayBhZnRlciBhbGwgb3RoZXIgdGFza3MgaGF2ZSBiZWVuIHJ1blxuICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciB1bmhhbmRsZWQgcmVqZWN0aW9uIHRyYWNraW5nIHRoYXQgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgYWxsIGB0aGVuYGQgdGFza3MgaGF2ZSBiZWVuIHJ1bi5cbiAgICBuZXh0VGljay5ydW5BZnRlciA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIGxhdGVyUXVldWUucHVzaCh0YXNrKTtcbiAgICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdFRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG5leHRUaWNrO1xufSkoKTtcblxuLy8gQXR0ZW1wdCB0byBtYWtlIGdlbmVyaWNzIHNhZmUgaW4gdGhlIGZhY2Ugb2YgZG93bnN0cmVhbVxuLy8gbW9kaWZpY2F0aW9ucy5cbi8vIFRoZXJlIGlzIG5vIHNpdHVhdGlvbiB3aGVyZSB0aGlzIGlzIG5lY2Vzc2FyeS5cbi8vIElmIHlvdSBuZWVkIGEgc2VjdXJpdHkgZ3VhcmFudGVlLCB0aGVzZSBwcmltb3JkaWFscyBuZWVkIHRvIGJlXG4vLyBkZWVwbHkgZnJvemVuIGFueXdheSwgYW5kIGlmIHlvdSBkb27igJl0IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsXG4vLyB0aGlzIGlzIGp1c3QgcGxhaW4gcGFyYW5vaWQuXG4vLyBIb3dldmVyLCB0aGlzICoqbWlnaHQqKiBoYXZlIHRoZSBuaWNlIHNpZGUtZWZmZWN0IG9mIHJlZHVjaW5nIHRoZSBzaXplIG9mXG4vLyB0aGUgbWluaWZpZWQgY29kZSBieSByZWR1Y2luZyB4LmNhbGwoKSB0byBtZXJlbHkgeCgpXG4vLyBTZWUgTWFyayBNaWxsZXLigJlzIGV4cGxhbmF0aW9uIG9mIHdoYXQgdGhpcyBkb2VzLlxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9Y29udmVudGlvbnM6c2FmZV9tZXRhX3Byb2dyYW1taW5nXG52YXIgY2FsbCA9IEZ1bmN0aW9uLmNhbGw7XG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGwuYXBwbHkoZiwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuLy8gVGhpcyBpcyBlcXVpdmFsZW50LCBidXQgc2xvd2VyOlxuLy8gdW5jdXJyeVRoaXMgPSBGdW5jdGlvbl9iaW5kLmJpbmQoRnVuY3Rpb25fYmluZC5jYWxsKTtcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3VuY3Vycnl0aGlzXG5cbnZhciBhcnJheV9zbGljZSA9IHVuY3VycnlUaGlzKEFycmF5LnByb3RvdHlwZS5zbGljZSk7XG5cbnZhciBhcnJheV9yZWR1Y2UgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgYmFzaXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAvLyBjb25jZXJuaW5nIHRoZSBpbml0aWFsIHZhbHVlLCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBzZWVrIHRvIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgYXJyYXksIGFjY291bnRpbmdcbiAgICAgICAgICAgIC8vIGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCBpcyBpcyBhIHNwYXJzZSBhcnJheVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2lzID0gdGhpc1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgrK2luZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVkdWNlXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHBvc3NpYmlsaXR5IHRoYXQgdGhlIGFycmF5IGlzIHNwYXJzZVxuICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICBiYXNpcyA9IGNhbGxiYWNrKGJhc2lzLCB0aGlzW2luZGV4XSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNpcztcbiAgICB9XG4pO1xuXG52YXIgYXJyYXlfaW5kZXhPZiA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBub3QgYSB2ZXJ5IGdvb2Qgc2hpbSwgYnV0IGdvb2QgZW5vdWdoIGZvciBvdXIgb25lIHVzZSBvZiBpdFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4pO1xuXG52YXIgYXJyYXlfbWFwID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLm1hcCB8fCBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGNvbGxlY3QgPSBbXTtcbiAgICAgICAgYXJyYXlfcmVkdWNlKHNlbGYsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgY29sbGVjdC5wdXNoKGNhbGxiYWNrLmNhbGwodGhpc3AsIHZhbHVlLCBpbmRleCwgc2VsZikpO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICByZXR1cm4gY29sbGVjdDtcbiAgICB9XG4pO1xuXG52YXIgb2JqZWN0X2NyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHByb3RvdHlwZSkge1xuICAgIGZ1bmN0aW9uIFR5cGUoKSB7IH1cbiAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICByZXR1cm4gbmV3IFR5cGUoKTtcbn07XG5cbnZhciBvYmplY3RfaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxudmFyIG9iamVjdF9rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0X2hhc093blByb3BlcnR5KG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgb2JqZWN0X3RvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBPYmplY3QodmFsdWUpO1xufVxuXG4vLyBnZW5lcmF0b3IgcmVsYXRlZCBzaGltc1xuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgZnVuY3Rpb24gb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW4gU3BpZGVyTW9ua2V5LlxuZnVuY3Rpb24gaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikge1xuICAgIHJldHVybiAoXG4gICAgICAgIG9iamVjdF90b1N0cmluZyhleGNlcHRpb24pID09PSBcIltvYmplY3QgU3RvcEl0ZXJhdGlvbl1cIiB8fFxuICAgICAgICBleGNlcHRpb24gaW5zdGFuY2VvZiBRUmV0dXJuVmFsdWVcbiAgICApO1xufVxuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgaGVscGVyIGFuZCBRLnJldHVybiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpblxuLy8gU3BpZGVyTW9ua2V5LlxudmFyIFFSZXR1cm5WYWx1ZTtcbmlmICh0eXBlb2YgUmV0dXJuVmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBSZXR1cm5WYWx1ZTtcbn0gZWxzZSB7XG4gICAgUVJldHVyblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xufVxuXG4vLyBsb25nIHN0YWNrIHRyYWNlc1xuXG52YXIgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgPSBcIkZyb20gcHJldmlvdXMgZXZlbnQ6XCI7XG5cbmZ1bmN0aW9uIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSkge1xuICAgIC8vIElmIHBvc3NpYmxlLCB0cmFuc2Zvcm0gdGhlIGVycm9yIHN0YWNrIHRyYWNlIGJ5IHJlbW92aW5nIE5vZGUgYW5kIFFcbiAgICAvLyBjcnVmdCwgdGhlbiBjb25jYXRlbmF0aW5nIHdpdGggdGhlIHN0YWNrIHRyYWNlIG9mIGBwcm9taXNlYC4gU2VlICM1Ny5cbiAgICBpZiAoaGFzU3RhY2tzICYmXG4gICAgICAgIHByb21pc2Uuc3RhY2sgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgICAgIGVycm9yLnN0YWNrICYmXG4gICAgICAgIGVycm9yLnN0YWNrLmluZGV4T2YoU1RBQ0tfSlVNUF9TRVBBUkFUT1IpID09PSAtMVxuICAgICkge1xuICAgICAgICB2YXIgc3RhY2tzID0gW107XG4gICAgICAgIGZvciAodmFyIHAgPSBwcm9taXNlOyAhIXA7IHAgPSBwLnNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHAuc3RhY2spIHtcbiAgICAgICAgICAgICAgICBzdGFja3MudW5zaGlmdChwLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja3MudW5zaGlmdChlcnJvci5zdGFjayk7XG5cbiAgICAgICAgdmFyIGNvbmNhdGVkU3RhY2tzID0gc3RhY2tzLmpvaW4oXCJcXG5cIiArIFNUQUNLX0pVTVBfU0VQQVJBVE9SICsgXCJcXG5cIik7XG4gICAgICAgIGVycm9yLnN0YWNrID0gZmlsdGVyU3RhY2tTdHJpbmcoY29uY2F0ZWRTdGFja3MpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyU3RhY2tTdHJpbmcoc3RhY2tTdHJpbmcpIHtcbiAgICB2YXIgbGluZXMgPSBzdGFja1N0cmluZy5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgZGVzaXJlZExpbmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICAgIGlmICghaXNJbnRlcm5hbEZyYW1lKGxpbmUpICYmICFpc05vZGVGcmFtZShsaW5lKSAmJiBsaW5lKSB7XG4gICAgICAgICAgICBkZXNpcmVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzaXJlZExpbmVzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZUZyYW1lKHN0YWNrTGluZSkge1xuICAgIHJldHVybiBzdGFja0xpbmUuaW5kZXhPZihcIihtb2R1bGUuanM6XCIpICE9PSAtMSB8fFxuICAgICAgICAgICBzdGFja0xpbmUuaW5kZXhPZihcIihub2RlLmpzOlwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihzdGFja0xpbmUpIHtcbiAgICAvLyBOYW1lZCBmdW5jdGlvbnM6IFwiYXQgZnVuY3Rpb25OYW1lIChmaWxlbmFtZTpsaW5lTnVtYmVyOmNvbHVtbk51bWJlcilcIlxuICAgIC8vIEluIElFMTAgZnVuY3Rpb24gbmFtZSBjYW4gaGF2ZSBzcGFjZXMgKFwiQW5vbnltb3VzIGZ1bmN0aW9uXCIpIE9fb1xuICAgIHZhciBhdHRlbXB0MSA9IC9hdCAuKyBcXCgoLispOihcXGQrKTooPzpcXGQrKVxcKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDEpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0MVsxXSwgTnVtYmVyKGF0dGVtcHQxWzJdKV07XG4gICAgfVxuXG4gICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uczogXCJhdCBmaWxlbmFtZTpsaW5lTnVtYmVyOmNvbHVtbk51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQyID0gL2F0IChbXiBdKyk6KFxcZCspOig/OlxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mikge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQyWzFdLCBOdW1iZXIoYXR0ZW1wdDJbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBGaXJlZm94IHN0eWxlOiBcImZ1bmN0aW9uQGZpbGVuYW1lOmxpbmVOdW1iZXIgb3IgQGZpbGVuYW1lOmxpbmVOdW1iZXJcIlxuICAgIHZhciBhdHRlbXB0MyA9IC8uKkAoLispOihcXGQrKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDMpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0M1sxXSwgTnVtYmVyKGF0dGVtcHQzWzJdKV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVybmFsRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgdmFyIGZpbGVOYW1lQW5kTGluZU51bWJlciA9IGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihzdGFja0xpbmUpO1xuXG4gICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICB2YXIgbGluZU51bWJlciA9IGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcblxuICAgIHJldHVybiBmaWxlTmFtZSA9PT0gcUZpbGVOYW1lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPj0gcVN0YXJ0aW5nTGluZSAmJlxuICAgICAgICBsaW5lTnVtYmVyIDw9IHFFbmRpbmdMaW5lO1xufVxuXG4vLyBkaXNjb3ZlciBvd24gZmlsZSBuYW1lIGFuZCBsaW5lIG51bWJlciByYW5nZSBmb3IgZmlsdGVyaW5nIHN0YWNrXG4vLyB0cmFjZXNcbmZ1bmN0aW9uIGNhcHR1cmVMaW5lKCkge1xuICAgIGlmICghaGFzU3RhY2tzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGUuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIHZhciBmaXJzdExpbmUgPSBsaW5lc1swXS5pbmRleE9mKFwiQFwiKSA+IDAgPyBsaW5lc1sxXSA6IGxpbmVzWzJdO1xuICAgICAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKGZpcnN0TGluZSk7XG4gICAgICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBxRmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF07XG4gICAgICAgIHJldHVybiBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXByZWNhdGUoY2FsbGJhY2ssIG5hbWUsIGFsdGVybmF0aXZlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS53YXJuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihuYW1lICsgXCIgaXMgZGVwcmVjYXRlZCwgdXNlIFwiICsgYWx0ZXJuYXRpdmUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGluc3RlYWQuXCIsIG5ldyBFcnJvcihcIlwiKS5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8vIGVuZCBvZiBzaGltc1xuLy8gYmVnaW5uaW5nIG9mIHJlYWwgd29ya1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBwcm9taXNlIGZvciBhbiBpbW1lZGlhdGUgcmVmZXJlbmNlLCBwYXNzZXMgcHJvbWlzZXMgdGhyb3VnaCwgb3JcbiAqIGNvZXJjZXMgcHJvbWlzZXMgZnJvbSBkaWZmZXJlbnQgc3lzdGVtcy5cbiAqIEBwYXJhbSB2YWx1ZSBpbW1lZGlhdGUgcmVmZXJlbmNlIG9yIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gUSh2YWx1ZSkge1xuICAgIC8vIElmIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBhIFByb21pc2UsIHJldHVybiBpdCBkaXJlY3RseS4gIFRoaXMgZW5hYmxlc1xuICAgIC8vIHRoZSByZXNvbHZlIGZ1bmN0aW9uIHRvIGJvdGggYmUgdXNlZCB0byBjcmVhdGVkIHJlZmVyZW5jZXMgZnJvbSBvYmplY3RzLFxuICAgIC8vIGJ1dCB0byB0b2xlcmFibHkgY29lcmNlIG5vbi1wcm9taXNlcyB0byBwcm9taXNlcy5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBhc3NpbWlsYXRlIHRoZW5hYmxlc1xuICAgIGlmIChpc1Byb21pc2VBbGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGwodmFsdWUpO1xuICAgIH1cbn1cblEucmVzb2x2ZSA9IFE7XG5cbi8qKlxuICogUGVyZm9ybXMgYSB0YXNrIGluIGEgZnV0dXJlIHR1cm4gb2YgdGhlIGV2ZW50IGxvb3AuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0YXNrXG4gKi9cblEubmV4dFRpY2sgPSBuZXh0VGljaztcblxuLyoqXG4gKiBDb250cm9scyB3aGV0aGVyIG9yIG5vdCBsb25nIHN0YWNrIHRyYWNlcyB3aWxsIGJlIG9uXG4gKi9cblEubG9uZ1N0YWNrU3VwcG9ydCA9IGZhbHNlO1xuXG4vLyBlbmFibGUgbG9uZyBzdGFja3MgaWYgUV9ERUJVRyBpcyBzZXRcbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52LlFfREVCVUcpIHtcbiAgICBRLmxvbmdTdGFja1N1cHBvcnQgPSB0cnVlO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSB7cHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0fSBvYmplY3QuXG4gKlxuICogYHJlc29sdmVgIGlzIGEgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggYSBtb3JlIHJlc29sdmVkIHZhbHVlIGZvciB0aGVcbiAqIHByb21pc2UuIFRvIGZ1bGZpbGwgdGhlIHByb21pc2UsIGludm9rZSBgcmVzb2x2ZWAgd2l0aCBhbnkgdmFsdWUgdGhhdCBpc1xuICogbm90IGEgdGhlbmFibGUuIFRvIHJlamVjdCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGEgcmVqZWN0ZWRcbiAqIHRoZW5hYmxlLCBvciBpbnZva2UgYHJlamVjdGAgd2l0aCB0aGUgcmVhc29uIGRpcmVjdGx5LiBUbyByZXNvbHZlIHRoZVxuICogcHJvbWlzZSB0byBhbm90aGVyIHRoZW5hYmxlLCB0aHVzIHB1dHRpbmcgaXQgaW4gdGhlIHNhbWUgc3RhdGUsIGludm9rZVxuICogYHJlc29sdmVgIHdpdGggdGhhdCBvdGhlciB0aGVuYWJsZS5cbiAqL1xuUS5kZWZlciA9IGRlZmVyO1xuZnVuY3Rpb24gZGVmZXIoKSB7XG4gICAgLy8gaWYgXCJtZXNzYWdlc1wiIGlzIGFuIFwiQXJyYXlcIiwgdGhhdCBpbmRpY2F0ZXMgdGhhdCB0aGUgcHJvbWlzZSBoYXMgbm90IHlldFxuICAgIC8vIGJlZW4gcmVzb2x2ZWQuICBJZiBpdCBpcyBcInVuZGVmaW5lZFwiLCBpdCBoYXMgYmVlbiByZXNvbHZlZC4gIEVhY2hcbiAgICAvLyBlbGVtZW50IG9mIHRoZSBtZXNzYWdlcyBhcnJheSBpcyBpdHNlbGYgYW4gYXJyYXkgb2YgY29tcGxldGUgYXJndW1lbnRzIHRvXG4gICAgLy8gZm9yd2FyZCB0byB0aGUgcmVzb2x2ZWQgcHJvbWlzZS4gIFdlIGNvZXJjZSB0aGUgcmVzb2x1dGlvbiB2YWx1ZSB0byBhXG4gICAgLy8gcHJvbWlzZSB1c2luZyB0aGUgYHJlc29sdmVgIGZ1bmN0aW9uIGJlY2F1c2UgaXQgaGFuZGxlcyBib3RoIGZ1bGx5XG4gICAgLy8gbm9uLXRoZW5hYmxlIHZhbHVlcyBhbmQgb3RoZXIgdGhlbmFibGVzIGdyYWNlZnVsbHkuXG4gICAgdmFyIG1lc3NhZ2VzID0gW10sIHByb2dyZXNzTGlzdGVuZXJzID0gW10sIHJlc29sdmVkUHJvbWlzZTtcblxuICAgIHZhciBkZWZlcnJlZCA9IG9iamVjdF9jcmVhdGUoZGVmZXIucHJvdG90eXBlKTtcbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIG9wZXJhbmRzKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKGFyZ3MpO1xuICAgICAgICAgICAgaWYgKG9wID09PSBcIndoZW5cIiAmJiBvcGVyYW5kc1sxXSkgeyAvLyBwcm9ncmVzcyBvcGVyYW5kXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMucHVzaChvcGVyYW5kc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFByb21pc2UucHJvbWlzZURpc3BhdGNoLmFwcGx5KHJlc29sdmVkUHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZFxuICAgIHByb21pc2UudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmVhcmVyVmFsdWUgPSBuZWFyZXIocmVzb2x2ZWRQcm9taXNlKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShuZWFyZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZSA9IG5lYXJlclZhbHVlOyAvLyBzaG9ydGVuIGNoYWluXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lYXJlclZhbHVlO1xuICAgIH07XG5cbiAgICBwcm9taXNlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJwZW5kaW5nXCIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRQcm9taXNlLmluc3BlY3QoKTtcbiAgICB9O1xuXG4gICAgaWYgKFEubG9uZ1N0YWNrU3VwcG9ydCAmJiBoYXNTdGFja3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBkb24ndCB0cnkgdG8gdXNlIGBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZWAgb3IgdHJhbnNmZXIgdGhlXG4gICAgICAgICAgICAvLyBhY2Nlc3NvciBhcm91bmQ7IHRoYXQgY2F1c2VzIG1lbW9yeSBsZWFrcyBhcyBwZXIgR0gtMTExLiBKdXN0XG4gICAgICAgICAgICAvLyByZWlmeSB0aGUgc3RhY2sgdHJhY2UgYXMgYSBzdHJpbmcgQVNBUC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBdCB0aGUgc2FtZSB0aW1lLCBjdXQgb2ZmIHRoZSBmaXJzdCBsaW5lOyBpdCdzIGFsd2F5cyBqdXN0XG4gICAgICAgICAgICAvLyBcIltvYmplY3QgUHJvbWlzZV1cXG5cIiwgYXMgcGVyIHRoZSBgdG9TdHJpbmdgLlxuICAgICAgICAgICAgcHJvbWlzZS5zdGFjayA9IGUuc3RhY2suc3Vic3RyaW5nKGUuc3RhY2suaW5kZXhPZihcIlxcblwiKSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTk9URTogd2UgZG8gdGhlIGNoZWNrcyBmb3IgYHJlc29sdmVkUHJvbWlzZWAgaW4gZWFjaCBtZXRob2QsIGluc3RlYWQgb2ZcbiAgICAvLyBjb25zb2xpZGF0aW5nIHRoZW0gaW50byBgYmVjb21lYCwgc2luY2Ugb3RoZXJ3aXNlIHdlJ2QgY3JlYXRlIG5ld1xuICAgIC8vIHByb21pc2VzIHdpdGggdGhlIGxpbmVzIGBiZWNvbWUod2hhdGV2ZXIodmFsdWUpKWAuIFNlZSBlLmcuIEdILTI1Mi5cblxuICAgIGZ1bmN0aW9uIGJlY29tZShuZXdQcm9taXNlKSB7XG4gICAgICAgIHJlc29sdmVkUHJvbWlzZSA9IG5ld1Byb21pc2U7XG4gICAgICAgIHByb21pc2Uuc291cmNlID0gbmV3UHJvbWlzZTtcblxuICAgICAgICBhcnJheV9yZWR1Y2UobWVzc2FnZXMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5ld1Byb21pc2UucHJvbWlzZURpc3BhdGNoLmFwcGx5KG5ld1Byb21pc2UsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG5cbiAgICAgICAgbWVzc2FnZXMgPSB2b2lkIDA7XG4gICAgICAgIHByb2dyZXNzTGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIH1cblxuICAgIGRlZmVycmVkLnByb21pc2UgPSBwcm9taXNlO1xuICAgIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKFEodmFsdWUpKTtcbiAgICB9O1xuXG4gICAgZGVmZXJyZWQuZnVsZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUoZnVsZmlsbCh2YWx1ZSkpO1xuICAgIH07XG4gICAgZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUocmVqZWN0KHJlYXNvbikpO1xuICAgIH07XG4gICAgZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5X3JlZHVjZShwcm9ncmVzc0xpc3RlbmVycywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgcHJvZ3Jlc3NMaXN0ZW5lcikge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcihwcm9ncmVzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmVycmVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBOb2RlLXN0eWxlIGNhbGxiYWNrIHRoYXQgd2lsbCByZXNvbHZlIG9yIHJlamVjdCB0aGUgZGVmZXJyZWRcbiAqIHByb21pc2UuXG4gKiBAcmV0dXJucyBhIG5vZGViYWNrXG4gKi9cbmRlZmVyLnByb3RvdHlwZS5tYWtlTm9kZVJlc29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycm9yLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgc2VsZi5yZXNvbHZlKGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSByZXNvbHZlciB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5vdGhpbmcgYW5kIGFjY2VwdHNcbiAqIHRoZSByZXNvbHZlLCByZWplY3QsIGFuZCBub3RpZnkgZnVuY3Rpb25zIGZvciBhIGRlZmVycmVkLlxuICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgbWF5IGJlIHJlc29sdmVkIHdpdGggdGhlIGdpdmVuIHJlc29sdmUgYW5kIHJlamVjdFxuICogZnVuY3Rpb25zLCBvciByZWplY3RlZCBieSBhIHRocm93biBleGNlcHRpb24gaW4gcmVzb2x2ZXJcbiAqL1xuUS5Qcm9taXNlID0gcHJvbWlzZTsgLy8gRVM2XG5RLnByb21pc2UgPSBwcm9taXNlO1xuZnVuY3Rpb24gcHJvbWlzZShyZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVzb2x2ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB0cnkge1xuICAgICAgICByZXNvbHZlcihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLm5vdGlmeSk7XG4gICAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxucHJvbWlzZS5yYWNlID0gcmFjZTsgLy8gRVM2XG5wcm9taXNlLmFsbCA9IGFsbDsgLy8gRVM2XG5wcm9taXNlLnJlamVjdCA9IHJlamVjdDsgLy8gRVM2XG5wcm9taXNlLnJlc29sdmUgPSBROyAvLyBFUzZcblxuLy8gWFhYIGV4cGVyaW1lbnRhbC4gIFRoaXMgbWV0aG9kIGlzIGEgd2F5IHRvIGRlbm90ZSB0aGF0IGEgbG9jYWwgdmFsdWUgaXNcbi8vIHNlcmlhbGl6YWJsZSBhbmQgc2hvdWxkIGJlIGltbWVkaWF0ZWx5IGRpc3BhdGNoZWQgdG8gYSByZW1vdGUgdXBvbiByZXF1ZXN0LFxuLy8gaW5zdGVhZCBvZiBwYXNzaW5nIGEgcmVmZXJlbmNlLlxuUS5wYXNzQnlDb3B5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIC8vZnJlZXplKG9iamVjdCk7XG4gICAgLy9wYXNzQnlDb3BpZXMuc2V0KG9iamVjdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnBhc3NCeUNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy9mcmVlemUob2JqZWN0KTtcbiAgICAvL3Bhc3NCeUNvcGllcy5zZXQob2JqZWN0LCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSWYgdHdvIHByb21pc2VzIGV2ZW50dWFsbHkgZnVsZmlsbCB0byB0aGUgc2FtZSB2YWx1ZSwgcHJvbWlzZXMgdGhhdCB2YWx1ZSxcbiAqIGJ1dCBvdGhlcndpc2UgcmVqZWN0cy5cbiAqIEBwYXJhbSB4IHtBbnkqfVxuICogQHBhcmFtIHkge0FueSp9XG4gKiBAcmV0dXJucyB7QW55Kn0gYSBwcm9taXNlIGZvciB4IGFuZCB5IGlmIHRoZXkgYXJlIHRoZSBzYW1lLCBidXQgYSByZWplY3Rpb25cbiAqIG90aGVyd2lzZS5cbiAqXG4gKi9cblEuam9pbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIFEoeCkuam9pbih5KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAodGhhdCkge1xuICAgIHJldHVybiBRKFt0aGlzLCB0aGF0XSkuc3ByZWFkKGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBcIj09PVwiIHNob3VsZCBiZSBPYmplY3QuaXMgb3IgZXF1aXZcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgam9pbjogbm90IHRoZSBzYW1lOiBcIiArIHggKyBcIiBcIiArIHkpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZmlyc3Qgb2YgYW4gYXJyYXkgb2YgcHJvbWlzZXMgdG8gYmVjb21lIHNldHRsZWQuXG4gKiBAcGFyYW0gYW5zd2VycyB7QXJyYXlbQW55Kl19IHByb21pc2VzIHRvIHJhY2VcbiAqIEByZXR1cm5zIHtBbnkqfSB0aGUgZmlyc3QgcHJvbWlzZSB0byBiZSBzZXR0bGVkXG4gKi9cblEucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGFuc3dlclBzKSB7XG4gICAgcmV0dXJuIHByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdGhpcyBvbmNlIHdlIGNhbiBhc3N1bWUgYXQgbGVhc3QgRVM1XG4gICAgICAgIC8vIGFuc3dlclBzLmZvckVhY2goZnVuY3Rpb24gKGFuc3dlclApIHtcbiAgICAgICAgLy8gICAgIFEoYW5zd2VyUCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gVXNlIHRoaXMgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhbnN3ZXJQcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgUShhbnN3ZXJQc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihRLnJhY2UpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgUHJvbWlzZSB3aXRoIGEgcHJvbWlzZSBkZXNjcmlwdG9yIG9iamVjdCBhbmQgb3B0aW9uYWwgZmFsbGJhY2tcbiAqIGZ1bmN0aW9uLiAgVGhlIGRlc2NyaXB0b3IgY29udGFpbnMgbWV0aG9kcyBsaWtlIHdoZW4ocmVqZWN0ZWQpLCBnZXQobmFtZSksXG4gKiBzZXQobmFtZSwgdmFsdWUpLCBwb3N0KG5hbWUsIGFyZ3MpLCBhbmQgZGVsZXRlKG5hbWUpLCB3aGljaCBhbGxcbiAqIHJldHVybiBlaXRoZXIgYSB2YWx1ZSwgYSBwcm9taXNlIGZvciBhIHZhbHVlLCBvciBhIHJlamVjdGlvbi4gIFRoZSBmYWxsYmFja1xuICogYWNjZXB0cyB0aGUgb3BlcmF0aW9uIG5hbWUsIGEgcmVzb2x2ZXIsIGFuZCBhbnkgZnVydGhlciBhcmd1bWVudHMgdGhhdCB3b3VsZFxuICogaGF2ZSBiZWVuIGZvcndhcmRlZCB0byB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIGFib3ZlIGhhZCBhIG1ldGhvZCBiZWVuXG4gKiBwcm92aWRlZCB3aXRoIHRoZSBwcm9wZXIgbmFtZS4gIFRoZSBBUEkgbWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCB0aGUgbmF0dXJlXG4gKiBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0LCBhcGFydCBmcm9tIHRoYXQgaXQgaXMgdXNhYmxlIHdoZXJlZXZlciBwcm9taXNlcyBhcmVcbiAqIGJvdWdodCBhbmQgc29sZC5cbiAqL1xuUS5tYWtlUHJvbWlzZSA9IFByb21pc2U7XG5mdW5jdGlvbiBQcm9taXNlKGRlc2NyaXB0b3IsIGZhbGxiYWNrLCBpbnNwZWN0KSB7XG4gICAgaWYgKGZhbGxiYWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgZmFsbGJhY2sgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiUHJvbWlzZSBkb2VzIG5vdCBzdXBwb3J0IG9wZXJhdGlvbjogXCIgKyBvcFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnNwZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdGU6IFwidW5rbm93blwifTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yW29wXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlc2NyaXB0b3Jbb3BdLmFwcGx5KHByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxsYmFjay5jYWxsKHByb21pc2UsIG9wLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGluc3BlY3Q7XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZCBgdmFsdWVPZmAgYW5kIGBleGNlcHRpb25gIHN1cHBvcnRcbiAgICBpZiAoaW5zcGVjdCkge1xuICAgICAgICB2YXIgaW5zcGVjdGVkID0gaW5zcGVjdCgpO1xuICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgIHByb21pc2UuZXhjZXB0aW9uID0gaW5zcGVjdGVkLnJlYXNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInBlbmRpbmdcIiB8fFxuICAgICAgICAgICAgICAgIGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdGVkLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgZG9uZSA9IGZhbHNlOyAgIC8vIGVuc3VyZSB0aGUgdW50cnVzdGVkIHByb21pc2UgbWFrZXMgYXQgbW9zdCBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2FsbCB0byBvbmUgb2YgdGhlIGNhbGxiYWNrc1xuXG4gICAgZnVuY3Rpb24gX2Z1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmdWxmaWxsZWQgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bGZpbGxlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVqZWN0ZWQoZXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGV4Y2VwdGlvbiwgc2VsZik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RlZChleGNlcHRpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAobmV3RXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXdFeGNlcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcHJvZ3Jlc3NlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2dyZXNzZWQgPT09IFwiZnVuY3Rpb25cIiA/IHByb2dyZXNzZWQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfZnVsZmlsbGVkKHZhbHVlKSk7XG4gICAgICAgIH0sIFwid2hlblwiLCBbZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfcmVqZWN0ZWQoZXhjZXB0aW9uKSk7XG4gICAgICAgIH1dKTtcbiAgICB9KTtcblxuICAgIC8vIFByb2dyZXNzIHByb3BhZ2F0b3IgbmVlZCB0byBiZSBhdHRhY2hlZCBpbiB0aGUgY3VycmVudCB0aWNrLlxuICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKHZvaWQgMCwgXCJ3aGVuXCIsIFt2b2lkIDAsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG4gICAgICAgIHZhciB0aHJldyA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBfcHJvZ3Jlc3NlZCh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRocmV3KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5RLnRhcCA9IGZ1bmN0aW9uIChwcm9taXNlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRhcChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFdvcmtzIGFsbW9zdCBsaWtlIFwiZmluYWxseVwiLCBidXQgbm90IGNhbGxlZCBmb3IgcmVqZWN0aW9ucy5cbiAqIE9yaWdpbmFsIHJlc29sdXRpb24gdmFsdWUgaXMgcGFzc2VkIHRocm91Z2ggY2FsbGJhY2sgdW5hZmZlY3RlZC5cbiAqIENhbGxiYWNrIG1heSByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBhd2FpdGVkIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7US5Qcm9taXNlfVxuICogQGV4YW1wbGVcbiAqIGRvU29tZXRoaW5nKClcbiAqICAgLnRoZW4oLi4uKVxuICogICAudGFwKGNvbnNvbGUubG9nKVxuICogICAudGhlbiguLi4pO1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKHZhbHVlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBvYnNlcnZlciBvbiBhIHByb21pc2UuXG4gKlxuICogR3VhcmFudGVlczpcbiAqXG4gKiAxLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlLlxuICogMi4gdGhhdCBlaXRoZXIgdGhlIGZ1bGZpbGxlZCBjYWxsYmFjayBvciB0aGUgcmVqZWN0ZWQgY2FsbGJhY2sgd2lsbCBiZVxuICogICAgY2FsbGVkLCBidXQgbm90IGJvdGguXG4gKiAzLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBub3QgYmUgY2FsbGVkIGluIHRoaXMgdHVybi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgICAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIGZ1bGZpbGxlZCAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogQHBhcmFtIHJlamVjdGVkICAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIHJlamVjdGlvbiBleGNlcHRpb25cbiAqIEBwYXJhbSBwcm9ncmVzc2VkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGludm9rZWQgY2FsbGJhY2tcbiAqL1xuUS53aGVuID0gd2hlbjtcbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbn07XG5cblEudGhlblJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyByZWFzb247IH0pO1xufTtcblxuUS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZWplY3QocmVhc29uKTtcbn07XG5cbi8qKlxuICogSWYgYW4gb2JqZWN0IGlzIG5vdCBhIHByb21pc2UsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlLlxuICogSWYgYSBwcm9taXNlIGlzIHJlamVjdGVkLCBpdCBpcyBhcyBcIm5lYXJcIiBhcyBwb3NzaWJsZSB0b28uXG4gKiBJZiBpdOKAmXMgYSBmdWxmaWxsZWQgcHJvbWlzZSwgdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5lYXJlci5cbiAqIElmIGl04oCZcyBhIGRlZmVycmVkIHByb21pc2UgYW5kIHRoZSBkZWZlcnJlZCBoYXMgYmVlbiByZXNvbHZlZCwgdGhlXG4gKiByZXNvbHV0aW9uIGlzIFwibmVhcmVyXCIuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBtb3N0IHJlc29sdmVkIChuZWFyZXN0KSBmb3JtIG9mIHRoZSBvYmplY3RcbiAqL1xuXG4vLyBYWFggc2hvdWxkIHdlIHJlLWRvIHRoaXM/XG5RLm5lYXJlciA9IG5lYXJlcjtcbmZ1bmN0aW9uIG5lYXJlcih2YWx1ZSkge1xuICAgIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSB2YWx1ZS5pbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHByb21pc2UuXG4gKiBPdGhlcndpc2UgaXQgaXMgYSBmdWxmaWxsZWQgdmFsdWUuXG4gKi9cblEuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBQcm9taXNlO1xufVxuXG5RLmlzUHJvbWlzZUFsaWtlID0gaXNQcm9taXNlQWxpa2U7XG5mdW5jdGlvbiBpc1Byb21pc2VBbGlrZShvYmplY3QpIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSAmJiB0eXBlb2Ygb2JqZWN0LnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBwZW5kaW5nIHByb21pc2UsIG1lYW5pbmcgbm90XG4gKiBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG4gKi9cblEuaXNQZW5kaW5nID0gaXNQZW5kaW5nO1xuZnVuY3Rpb24gaXNQZW5kaW5nKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJwZW5kaW5nXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHZhbHVlIG9yIGZ1bGZpbGxlZFxuICogcHJvbWlzZS5cbiAqL1xuUS5pc0Z1bGZpbGxlZCA9IGlzRnVsZmlsbGVkO1xuZnVuY3Rpb24gaXNGdWxmaWxsZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuICFpc1Byb21pc2Uob2JqZWN0KSB8fCBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHJlamVjdGVkIHByb21pc2UuXG4gKi9cblEuaXNSZWplY3RlZCA9IGlzUmVqZWN0ZWQ7XG5mdW5jdGlvbiBpc1JlamVjdGVkKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59O1xuXG4vLy8vIEJFR0lOIFVOSEFORExFRCBSRUpFQ1RJT04gVFJBQ0tJTkdcblxuLy8gVGhpcyBwcm9taXNlIGxpYnJhcnkgY29uc3VtZXMgZXhjZXB0aW9ucyB0aHJvd24gaW4gaGFuZGxlcnMgc28gdGhleSBjYW4gYmVcbi8vIGhhbmRsZWQgYnkgYSBzdWJzZXF1ZW50IHByb21pc2UuICBUaGUgZXhjZXB0aW9ucyBnZXQgYWRkZWQgdG8gdGhpcyBhcnJheSB3aGVuXG4vLyB0aGV5IGFyZSBjcmVhdGVkLCBhbmQgcmVtb3ZlZCB3aGVuIHRoZXkgYXJlIGhhbmRsZWQuICBOb3RlIHRoYXQgaW4gRVM2IG9yXG4vLyBzaGltbWVkIGVudmlyb25tZW50cywgdGhpcyB3b3VsZCBuYXR1cmFsbHkgYmUgYSBgU2V0YC5cbnZhciB1bmhhbmRsZWRSZWFzb25zID0gW107XG52YXIgdW5oYW5kbGVkUmVqZWN0aW9ucyA9IFtdO1xudmFyIHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucyA9IFtdO1xudmFyIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IHRydWU7XG5cbmZ1bmN0aW9uIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpIHtcbiAgICB1bmhhbmRsZWRSZWFzb25zLmxlbmd0aCA9IDA7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrUmVqZWN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLmVtaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBRLm5leHRUaWNrLnJ1bkFmdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChhcnJheV9pbmRleE9mKHVuaGFuZGxlZFJlamVjdGlvbnMsIHByb21pc2UpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuaGFuZGxlZFJlamVjdGlvblwiLCByZWFzb24sIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgaWYgKHJlYXNvbiAmJiB0eXBlb2YgcmVhc29uLnN0YWNrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChyZWFzb24uc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChcIihubyBzdGFjaykgXCIgKyByZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW50cmFja1JlamVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdCA9IGFycmF5X2luZGV4T2YodW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgaWYgKGF0ICE9PSAtMSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrLnJ1bkFmdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXRSZXBvcnQgPSBhcnJheV9pbmRleE9mKHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGF0UmVwb3J0ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJyZWplY3Rpb25IYW5kbGVkXCIsIHVuaGFuZGxlZFJlYXNvbnNbYXRdLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShhdFJlcG9ydCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5zcGxpY2UoYXQsIDEpO1xuICAgICAgICB1bmhhbmRsZWRSZWFzb25zLnNwbGljZShhdCwgMSk7XG4gICAgfVxufVxuXG5RLnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucyA9IHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucztcblxuUS5nZXRVbmhhbmRsZWRSZWFzb25zID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIHRoYXQgY29uc3VtZXJzIGNhbid0IGludGVyZmVyZSB3aXRoIG91ciBpbnRlcm5hbCBzdGF0ZS5cbiAgICByZXR1cm4gdW5oYW5kbGVkUmVhc29ucy5zbGljZSgpO1xufTtcblxuUS5zdG9wVW5oYW5kbGVkUmVqZWN0aW9uVHJhY2tpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gZmFsc2U7XG59O1xuXG5yZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcblxuLy8vLyBFTkQgVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSByZWplY3RlZCBwcm9taXNlLlxuICogQHBhcmFtIHJlYXNvbiB2YWx1ZSBkZXNjcmliaW5nIHRoZSBmYWlsdXJlXG4gKi9cblEucmVqZWN0ID0gcmVqZWN0O1xuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgIHZhciByZWplY3Rpb24gPSBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHRoZSBlcnJvciBoYXMgYmVlbiBoYW5kbGVkXG4gICAgICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB1bnRyYWNrUmVqZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkID8gcmVqZWN0ZWQocmVhc29uKSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiBmYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiByZWFzb24gfTtcbiAgICB9KTtcblxuICAgIC8vIE5vdGUgdGhhdCB0aGUgcmVhc29uIGhhcyBub3QgYmVlbiBoYW5kbGVkLlxuICAgIHRyYWNrUmVqZWN0aW9uKHJlamVjdGlvbiwgcmVhc29uKTtcblxuICAgIHJldHVybiByZWplY3Rpb247XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIGZ1bGZpbGxlZCBwcm9taXNlIGZvciBhbiBpbW1lZGlhdGUgcmVmZXJlbmNlLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2VcbiAqL1xuUS5mdWxmaWxsID0gZnVsZmlsbDtcbmZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZSh7XG4gICAgICAgIFwid2hlblwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZ2V0XCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwic2V0XCI6IGZ1bmN0aW9uIChuYW1lLCByaHMpIHtcbiAgICAgICAgICAgIHZhbHVlW25hbWVdID0gcmhzO1xuICAgICAgICB9LFxuICAgICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBcInBvc3RcIjogZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIC8vIE1hcmsgTWlsbGVyIHByb3Bvc2VzIHRoYXQgcG9zdCB3aXRoIG5vIG5hbWUgc2hvdWxkIGFwcGx5IGFcbiAgICAgICAgICAgIC8vIHByb21pc2VkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IG51bGwgfHwgbmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYXBwbHlcIjogZnVuY3Rpb24gKHRoaXNwLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodGhpc3AsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBcImtleXNcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdF9rZXlzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIHZvaWQgMCwgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwiZnVsZmlsbGVkXCIsIHZhbHVlOiB2YWx1ZSB9O1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZW5hYmxlcyB0byBRIHByb21pc2VzLlxuICogQHBhcmFtIHByb21pc2UgdGhlbmFibGUgcHJvbWlzZVxuICogQHJldHVybnMgYSBRIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gY29lcmNlKHByb21pc2UpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG4vKipcbiAqIEFubm90YXRlcyBhbiBvYmplY3Qgc3VjaCB0aGF0IGl0IHdpbGwgbmV2ZXIgYmVcbiAqIHRyYW5zZmVycmVkIGF3YXkgZnJvbSB0aGlzIHByb2Nlc3Mgb3ZlciBhbnkgcHJvbWlzZVxuICogY29tbXVuaWNhdGlvbiBjaGFubmVsLlxuICogQHBhcmFtIG9iamVjdFxuICogQHJldHVybnMgcHJvbWlzZSBhIHdyYXBwaW5nIG9mIHRoYXQgb2JqZWN0IHRoYXRcbiAqIGFkZGl0aW9uYWxseSByZXNwb25kcyB0byB0aGUgXCJpc0RlZlwiIG1lc3NhZ2VcbiAqIHdpdGhvdXQgYSByZWplY3Rpb24uXG4gKi9cblEubWFzdGVyID0gbWFzdGVyO1xuZnVuY3Rpb24gbWFzdGVyKG9iamVjdCkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJpc0RlZlwiOiBmdW5jdGlvbiAoKSB7fVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKG9wLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBRKG9iamVjdCkuaW5zcGVjdCgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFNwcmVhZHMgdGhlIHZhbHVlcyBvZiBhIHByb21pc2VkIGFycmF5IG9mIGFyZ3VtZW50cyBpbnRvIHRoZVxuICogZnVsZmlsbG1lbnQgY2FsbGJhY2suXG4gKiBAcGFyYW0gZnVsZmlsbGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdmFyaWFkaWMgYXJndW1lbnRzIGZyb20gdGhlXG4gKiBwcm9taXNlZCBhcnJheVxuICogQHBhcmFtIHJlamVjdGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGV4Y2VwdGlvbiBpZiB0aGUgcHJvbWlzZVxuICogaXMgcmVqZWN0ZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgb3IgdGhyb3duIGV4Y2VwdGlvbiBvZlxuICogZWl0aGVyIGNhbGxiYWNrLlxuICovXG5RLnNwcmVhZCA9IHNwcmVhZDtcbmZ1bmN0aW9uIHNwcmVhZCh2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS5zcHJlYWQoZnVsZmlsbGVkLCByZWplY3RlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnNwcmVhZCA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsKCkudGhlbihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZC5hcHBseSh2b2lkIDAsIGFycmF5KTtcbiAgICB9LCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIFRoZSBhc3luYyBmdW5jdGlvbiBpcyBhIGRlY29yYXRvciBmb3IgZ2VuZXJhdG9yIGZ1bmN0aW9ucywgdHVybmluZ1xuICogdGhlbSBpbnRvIGFzeW5jaHJvbm91cyBnZW5lcmF0b3JzLiAgQWx0aG91Z2ggZ2VuZXJhdG9ycyBhcmUgb25seSBwYXJ0XG4gKiBvZiB0aGUgbmV3ZXN0IEVDTUFTY3JpcHQgNiBkcmFmdHMsIHRoaXMgY29kZSBkb2VzIG5vdCBjYXVzZSBzeW50YXhcbiAqIGVycm9ycyBpbiBvbGRlciBlbmdpbmVzLiAgVGhpcyBjb2RlIHNob3VsZCBjb250aW51ZSB0byB3b3JrIGFuZCB3aWxsXG4gKiBpbiBmYWN0IGltcHJvdmUgb3ZlciB0aW1lIGFzIHRoZSBsYW5ndWFnZSBpbXByb3Zlcy5cbiAqXG4gKiBFUzYgZ2VuZXJhdG9ycyBhcmUgY3VycmVudGx5IHBhcnQgb2YgVjggdmVyc2lvbiAzLjE5IHdpdGggdGhlXG4gKiAtLWhhcm1vbnktZ2VuZXJhdG9ycyBydW50aW1lIGZsYWcgZW5hYmxlZC4gIFNwaWRlck1vbmtleSBoYXMgaGFkIHRoZW1cbiAqIGZvciBsb25nZXIsIGJ1dCB1bmRlciBhbiBvbGRlciBQeXRob24taW5zcGlyZWQgZm9ybS4gIFRoaXMgZnVuY3Rpb25cbiAqIHdvcmtzIG9uIGJvdGgga2luZHMgb2YgZ2VuZXJhdG9ycy5cbiAqXG4gKiBEZWNvcmF0ZXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gc3VjaCB0aGF0OlxuICogIC0gaXQgbWF5IHlpZWxkIHByb21pc2VzXG4gKiAgLSBleGVjdXRpb24gd2lsbCBjb250aW51ZSB3aGVuIHRoYXQgcHJvbWlzZSBpcyBmdWxmaWxsZWRcbiAqICAtIHRoZSB2YWx1ZSBvZiB0aGUgeWllbGQgZXhwcmVzc2lvbiB3aWxsIGJlIHRoZSBmdWxmaWxsZWQgdmFsdWVcbiAqICAtIGl0IHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlICh3aGVuIHRoZSBnZW5lcmF0b3JcbiAqICAgIHN0b3BzIGl0ZXJhdGluZylcbiAqICAtIHRoZSBkZWNvcmF0ZWQgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqICAgIG9mIHRoZSBnZW5lcmF0b3Igb3IgdGhlIGZpcnN0IHJlamVjdGVkIHByb21pc2UgYW1vbmcgdGhvc2VcbiAqICAgIHlpZWxkZWQuXG4gKiAgLSBpZiBhbiBlcnJvciBpcyB0aHJvd24gaW4gdGhlIGdlbmVyYXRvciwgaXQgcHJvcGFnYXRlcyB0aHJvdWdoXG4gKiAgICBldmVyeSBmb2xsb3dpbmcgeWllbGQgdW50aWwgaXQgaXMgY2F1Z2h0LCBvciB1bnRpbCBpdCBlc2NhcGVzXG4gKiAgICB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGFsdG9nZXRoZXIsIGFuZCBpcyB0cmFuc2xhdGVkIGludG8gYVxuICogICAgcmVqZWN0aW9uIGZvciB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgZGVjb3JhdGVkIGdlbmVyYXRvci5cbiAqL1xuUS5hc3luYyA9IGFzeW5jO1xuZnVuY3Rpb24gYXN5bmMobWFrZUdlbmVyYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdoZW4gdmVyYiBpcyBcInNlbmRcIiwgYXJnIGlzIGEgdmFsdWVcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwidGhyb3dcIiwgYXJnIGlzIGFuIGV4Y2VwdGlvblxuICAgICAgICBmdW5jdGlvbiBjb250aW51ZXIodmVyYiwgYXJnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgICAgICAvLyBVbnRpbCBWOCAzLjE5IC8gQ2hyb21pdW0gMjkgaXMgcmVsZWFzZWQsIFNwaWRlck1vbmtleSBpcyB0aGUgb25seVxuICAgICAgICAgICAgLy8gZW5naW5lIHRoYXQgaGFzIGEgZGVwbG95ZWQgYmFzZSBvZiBicm93c2VycyB0aGF0IHN1cHBvcnQgZ2VuZXJhdG9ycy5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIFNNJ3MgZ2VuZXJhdG9ycyB1c2UgdGhlIFB5dGhvbi1pbnNwaXJlZCBzZW1hbnRpY3Mgb2ZcbiAgICAgICAgICAgIC8vIG91dGRhdGVkIEVTNiBkcmFmdHMuICBXZSB3b3VsZCBsaWtlIHRvIHN1cHBvcnQgRVM2LCBidXQgd2UnZCBhbHNvXG4gICAgICAgICAgICAvLyBsaWtlIHRvIG1ha2UgaXQgcG9zc2libGUgdG8gdXNlIGdlbmVyYXRvcnMgaW4gZGVwbG95ZWQgYnJvd3NlcnMsIHNvXG4gICAgICAgICAgICAvLyB3ZSBhbHNvIHN1cHBvcnQgUHl0aG9uLXN0eWxlIGdlbmVyYXRvcnMuICBBdCBzb21lIHBvaW50IHdlIGNhbiByZW1vdmVcbiAgICAgICAgICAgIC8vIHRoaXMgYmxvY2suXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU3RvcEl0ZXJhdGlvbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIC8vIEVTNiBHZW5lcmF0b3JzXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdG9yW3ZlcmJdKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBRKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LnZhbHVlLCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTcGlkZXJNb25rZXkgR2VuZXJhdG9yc1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBSZW1vdmUgdGhpcyBjYXNlIHdoZW4gU00gZG9lcyBFUzYgZ2VuZXJhdG9ycy5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RvcEl0ZXJhdGlvbihleGNlcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUShleGNlcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aGVuKHJlc3VsdCwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBtYWtlR2VuZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJuZXh0XCIpO1xuICAgICAgICB2YXIgZXJyYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJ0aHJvd1wiKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgc3Bhd24gZnVuY3Rpb24gaXMgYSBzbWFsbCB3cmFwcGVyIGFyb3VuZCBhc3luYyB0aGF0IGltbWVkaWF0ZWx5XG4gKiBjYWxscyB0aGUgZ2VuZXJhdG9yIGFuZCBhbHNvIGVuZHMgdGhlIHByb21pc2UgY2hhaW4sIHNvIHRoYXQgYW55XG4gKiB1bmhhbmRsZWQgZXJyb3JzIGFyZSB0aHJvd24gaW5zdGVhZCBvZiBmb3J3YXJkZWQgdG8gdGhlIGVycm9yXG4gKiBoYW5kbGVyLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGl0J3MgZXh0cmVtZWx5IGNvbW1vbiB0byBydW5cbiAqIGdlbmVyYXRvcnMgYXQgdGhlIHRvcC1sZXZlbCB0byB3b3JrIHdpdGggbGlicmFyaWVzLlxuICovXG5RLnNwYXduID0gc3Bhd247XG5mdW5jdGlvbiBzcGF3bihtYWtlR2VuZXJhdG9yKSB7XG4gICAgUS5kb25lKFEuYXN5bmMobWFrZUdlbmVyYXRvcikoKSk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBpbnRlcmZhY2Ugb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW4gU3BpZGVyTW9ua2V5LlxuLyoqXG4gKiBUaHJvd3MgYSBSZXR1cm5WYWx1ZSBleGNlcHRpb24gdG8gc3RvcCBhbiBhc3luY2hyb25vdXMgZ2VuZXJhdG9yLlxuICpcbiAqIFRoaXMgaW50ZXJmYWNlIGlzIGEgc3RvcC1nYXAgbWVhc3VyZSB0byBzdXBwb3J0IGdlbmVyYXRvciByZXR1cm5cbiAqIHZhbHVlcyBpbiBvbGRlciBGaXJlZm94L1NwaWRlck1vbmtleS4gIEluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBFUzZcbiAqIGdlbmVyYXRvcnMgbGlrZSBDaHJvbWl1bSAyOSwganVzdCB1c2UgXCJyZXR1cm5cIiBpbiB5b3VyIGdlbmVyYXRvclxuICogZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB0aGUgc3Vycm91bmRpbmcgZ2VuZXJhdG9yXG4gKiBAdGhyb3dzIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB3aXRoIHRoZSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzYgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24qICgpIHtcbiAqICAgICAgdmFyIGZvbyA9IHlpZWxkIGdldEZvb1Byb21pc2UoKTtcbiAqICAgICAgdmFyIGJhciA9IHlpZWxkIGdldEJhclByb21pc2UoKTtcbiAqICAgICAgcmV0dXJuIGZvbyArIGJhcjtcbiAqIH0pXG4gKiAvLyBPbGRlciBTcGlkZXJNb25rZXkgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24gKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICBRLnJldHVybihmb28gKyBiYXIpO1xuICogfSlcbiAqL1xuUVtcInJldHVyblwiXSA9IF9yZXR1cm47XG5mdW5jdGlvbiBfcmV0dXJuKHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IFFSZXR1cm5WYWx1ZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIHByb21pc2VkIGZ1bmN0aW9uIGRlY29yYXRvciBlbnN1cmVzIHRoYXQgYW55IHByb21pc2UgYXJndW1lbnRzXG4gKiBhcmUgc2V0dGxlZCBhbmQgcGFzc2VkIGFzIHZhbHVlcyAoYHRoaXNgIGlzIGFsc28gc2V0dGxlZCBhbmQgcGFzc2VkXG4gKiBhcyBhIHZhbHVlKS4gIEl0IHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0IG9mIGEgZnVuY3Rpb24gaXNcbiAqIGFsd2F5cyBhIHByb21pc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBhZGQgPSBRLnByb21pc2VkKGZ1bmN0aW9uIChhLCBiKSB7XG4gKiAgICAgcmV0dXJuIGEgKyBiO1xuICogfSk7XG4gKiBhZGQoUShhKSwgUShCKSk7XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGRlY29yYXRlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBoYXMgYmVlbiBkZWNvcmF0ZWQuXG4gKi9cblEucHJvbWlzZWQgPSBwcm9taXNlZDtcbmZ1bmN0aW9uIHByb21pc2VkKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNwcmVhZChbdGhpcywgYWxsKGFyZ3VtZW50cyldLCBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG4vKipcbiAqIHNlbmRzIGEgbWVzc2FnZSB0byBhIHZhbHVlIGluIGEgZnV0dXJlIHR1cm5cbiAqIEBwYXJhbSBvYmplY3QqIHRoZSByZWNpcGllbnRcbiAqIEBwYXJhbSBvcCB0aGUgbmFtZSBvZiB0aGUgbWVzc2FnZSBvcGVyYXRpb24sIGUuZy4sIFwid2hlblwiLFxuICogQHBhcmFtIGFyZ3MgZnVydGhlciBhcmd1bWVudHMgdG8gYmUgZm9yd2FyZGVkIHRvIHRoZSBvcGVyYXRpb25cbiAqIEByZXR1cm5zIHJlc3VsdCB7UHJvbWlzZX0gYSBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cbiAqL1xuUS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuZnVuY3Rpb24gZGlzcGF0Y2gob2JqZWN0LCBvcCwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2gob3AsIGFyZ3MpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChvcCwgYXJncykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnByb21pc2VEaXNwYXRjaChkZWZlcnJlZC5yZXNvbHZlLCBvcCwgYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gZ2V0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICovXG5RLmdldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZ2V0XCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIG9iamVjdCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB2YWx1ZSAgICAgbmV3IHZhbHVlIG9mIHByb3BlcnR5XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5zZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInNldFwiLCBba2V5LCB2YWx1ZV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInNldFwiLCBba2V5LCB2YWx1ZV0pO1xufTtcblxuLyoqXG4gKiBEZWxldGVzIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gZGVsZXRlXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5kZWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImRlbGV0ZVwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImRlbGV0ZVwiLCBba2V5XSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIHZhbHVlICAgICBhIHZhbHVlIHRvIHBvc3QsIHR5cGljYWxseSBhbiBhcnJheSBvZlxuICogICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uIGFyZ3VtZW50cyBmb3IgcHJvbWlzZXMgdGhhdFxuICogICAgICAgICAgICAgICAgICBhcmUgdWx0aW1hdGVseSBiYWNrZWQgd2l0aCBgcmVzb2x2ZWAgdmFsdWVzLFxuICogICAgICAgICAgICAgICAgICBhcyBvcHBvc2VkIHRvIHRob3NlIGJhY2tlZCB3aXRoIFVSTHNcbiAqICAgICAgICAgICAgICAgICAgd2hlcmVpbiB0aGUgcG9zdGVkIHZhbHVlIGNhbiBiZSBhbnlcbiAqICAgICAgICAgICAgICAgICAgSlNPTiBzZXJpYWxpemFibGUgb2JqZWN0LlxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cbi8vIGJvdW5kIGxvY2FsbHkgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IG90aGVyIG1ldGhvZHNcblEubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEucG9zdCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJnc10pO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGEgbWV0aG9kIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIG1ldGhvZCB0byBpbnZva2VcbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgaW52b2NhdGlvbiBhcmd1bWVudHNcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNlbmQgPSAvLyBYWFggTWFyayBNaWxsZXIncyBwcm9wb3NlZCBwYXJsYW5jZVxuUS5tY2FsbCA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLmludm9rZSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5Qcm9taXNlLnByb3RvdHlwZS5tY2FsbCA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAobmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKV0pO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIGFyZ3MgICAgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUS5mYXBwbHkgPSBmdW5jdGlvbiAob2JqZWN0LCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhcHBseSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIENhbGxzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUVtcInRyeVwiXSA9XG5RLmZjYWxsID0gZnVuY3Rpb24gKG9iamVjdCAvKiAuLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmNhbGwgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFycmF5X3NsaWNlKGFyZ3VtZW50cyldKTtcbn07XG5cbi8qKlxuICogQmluZHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uLCB0cmFuc2Zvcm1pbmcgcmV0dXJuIHZhbHVlcyBpbnRvIGEgZnVsZmlsbGVkXG4gKiBwcm9taXNlIGFuZCB0aHJvd24gZXJyb3JzIGludG8gYSByZWplY3RlZCBvbmUuXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZiaW5kID0gZnVuY3Rpb24gKG9iamVjdCAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBwcm9taXNlID0gUShvYmplY3QpO1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmJvdW5kKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS5kaXNwYXRjaChcImFwcGx5XCIsIFtcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKVxuICAgICAgICBdKTtcbiAgICB9O1xufTtcblByb21pc2UucHJvdG90eXBlLmZiaW5kID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmJvdW5kKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS5kaXNwYXRjaChcImFwcGx5XCIsIFtcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKVxuICAgICAgICBdKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0cyB0aGUgbmFtZXMgb2YgdGhlIG93bmVkIHByb3BlcnRpZXMgb2YgYSBwcm9taXNlZFxuICogb2JqZWN0IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUga2V5cyBvZiB0aGUgZXZlbnR1YWxseSBzZXR0bGVkIG9iamVjdFxuICovXG5RLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImtleXNcIiwgW10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImtleXNcIiwgW10pO1xufTtcblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBwcm9taXNlcyBpbnRvIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkuICBJZiBhbnkgb2ZcbiAqIHRoZSBwcm9taXNlcyBnZXRzIHJlamVjdGVkLCB0aGUgd2hvbGUgYXJyYXkgaXMgcmVqZWN0ZWQgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FycmF5Kn0gYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXNcbiAqL1xuLy8gQnkgTWFyayBNaWxsZXJcbi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPXN0cmF3bWFuOmNvbmN1cnJlbmN5JnJldj0xMzA4Nzc2NTIxI2FsbGZ1bGZpbGxlZFxuUS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHZhciBwZW5kaW5nQ291bnQgPSAwO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBhcnJheV9yZWR1Y2UocHJvbWlzZXMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb21pc2UsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc25hcHNob3Q7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXNQcm9taXNlKHByb21pc2UpICYmXG4gICAgICAgICAgICAgICAgKHNuYXBzaG90ID0gcHJvbWlzZS5pbnNwZWN0KCkpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlc1tpbmRleF0gPSBzbmFwc2hvdC52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKytwZW5kaW5nQ291bnQ7XG4gICAgICAgICAgICAgICAgd2hlbihcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLXBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KHsgaW5kZXg6IGluZGV4LCB2YWx1ZTogcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICBpZiAocGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IHJlc29sdmVkIHByb21pc2Ugb2YgYW4gYXJyYXkuIFByaW9yIHJlamVjdGVkIHByb21pc2VzIGFyZVxuICogaWdub3JlZC4gIFJlamVjdHMgb25seSBpZiBhbGwgcHJvbWlzZXMgYXJlIHJlamVjdGVkLlxuICogQHBhcmFtIHtBcnJheSp9IGFuIGFycmF5IGNvbnRhaW5pbmcgdmFsdWVzIG9yIHByb21pc2VzIGZvciB2YWx1ZXNcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IHJlc29sdmVkIHByb21pc2UsXG4gKiBvciBhIHJlamVjdGVkIHByb21pc2UgaWYgYWxsIHByb21pc2VzIGFyZSByZWplY3RlZC5cbiAqL1xuUS5hbnkgPSBhbnk7XG5cbmZ1bmN0aW9uIGFueShwcm9taXNlcykge1xuICAgIGlmIChwcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFEucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHZhciBkZWZlcnJlZCA9IFEuZGVmZXIoKTtcbiAgICB2YXIgcGVuZGluZ0NvdW50ID0gMDtcbiAgICBhcnJheV9yZWR1Y2UocHJvbWlzZXMsIGZ1bmN0aW9uIChwcmV2LCBjdXJyZW50LCBpbmRleCkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHByb21pc2VzW2luZGV4XTtcblxuICAgICAgICBwZW5kaW5nQ291bnQrKztcblxuICAgICAgICB3aGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzKTtcbiAgICAgICAgZnVuY3Rpb24gb25GdWxmaWxsZWQocmVzdWx0KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25SZWplY3RlZCgpIHtcbiAgICAgICAgICAgIHBlbmRpbmdDb3VudC0tO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiQ2FuJ3QgZ2V0IGZ1bGZpbGxtZW50IHZhbHVlIGZyb20gYW55IHByb21pc2UsIGFsbCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwicHJvbWlzZXMgd2VyZSByZWplY3RlZC5cIlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeSh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9ncmVzc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB1bmRlZmluZWQpO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYW55KHRoaXMpO1xufTtcblxuLyoqXG4gKiBXYWl0cyBmb3IgYWxsIHByb21pc2VzIHRvIGJlIHNldHRsZWQsIGVpdGhlciBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkLiAgVGhpcyBpcyBkaXN0aW5jdCBmcm9tIGBhbGxgIHNpbmNlIHRoYXQgd291bGQgc3RvcFxuICogd2FpdGluZyBhdCB0aGUgZmlyc3QgcmVqZWN0aW9uLiAgVGhlIHByb21pc2UgcmV0dXJuZWQgYnlcbiAqIGBhbGxSZXNvbHZlZGAgd2lsbCBuZXZlciBiZSByZWplY3RlZC5cbiAqIEBwYXJhbSBwcm9taXNlcyBhIHByb21pc2UgZm9yIGFuIGFycmF5IChvciBhbiBhcnJheSkgb2YgcHJvbWlzZXNcbiAqIChvciB2YWx1ZXMpXG4gKiBAcmV0dXJuIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcHJvbWlzZXNcbiAqL1xuUS5hbGxSZXNvbHZlZCA9IGRlcHJlY2F0ZShhbGxSZXNvbHZlZCwgXCJhbGxSZXNvbHZlZFwiLCBcImFsbFNldHRsZWRcIik7XG5mdW5jdGlvbiBhbGxSZXNvbHZlZChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcHJvbWlzZXMgPSBhcnJheV9tYXAocHJvbWlzZXMsIFEpO1xuICAgICAgICByZXR1cm4gd2hlbihhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoZW4ocHJvbWlzZSwgbm9vcCwgbm9vcCk7XG4gICAgICAgIH0pKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbFJlc29sdmVkKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAc2VlIFByb21pc2UjYWxsU2V0dGxlZFxuICovXG5RLmFsbFNldHRsZWQgPSBhbGxTZXR0bGVkO1xuZnVuY3Rpb24gYWxsU2V0dGxlZChwcm9taXNlcykge1xuICAgIHJldHVybiBRKHByb21pc2VzKS5hbGxTZXR0bGVkKCk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZWlyIHN0YXRlcyAoYXNcbiAqIHJldHVybmVkIGJ5IGBpbnNwZWN0YCkgd2hlbiB0aGV5IGhhdmUgYWxsIHNldHRsZWQuXG4gKiBAcGFyYW0ge0FycmF5W0FueSpdfSB2YWx1ZXMgYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMge0FycmF5W1N0YXRlXX0gYW4gYXJyYXkgb2Ygc3RhdGVzIGZvciB0aGUgcmVzcGVjdGl2ZSB2YWx1ZXMuXG4gKi9cblByb21pc2UucHJvdG90eXBlLmFsbFNldHRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcmV0dXJuIGFsbChhcnJheV9tYXAocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gUShwcm9taXNlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlZ2FyZGxlc3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuaW5zcGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihyZWdhcmRsZXNzLCByZWdhcmRsZXNzKTtcbiAgICAgICAgfSkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgZmFpbHVyZSBvZiBhIHByb21pc2UsIGdpdmluZyBhbiBvcG9ydHVuaXR5IHRvIHJlY292ZXJcbiAqIHdpdGggYSBjYWxsYmFjay4gIElmIHRoZSBnaXZlbiBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gKiBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBmb3Igc29tZXRoaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBmdWxmaWxsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlmIHRoZVxuICogZ2l2ZW4gcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFja1xuICovXG5RLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgYSBsaXN0ZW5lciB0aGF0IGNhbiByZXNwb25kIHRvIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgZnJvbSBhXG4gKiBwcm9taXNlJ3Mgb3JpZ2luYXRpbmcgZGVmZXJyZWQuIFRoaXMgbGlzdGVuZXIgcmVjZWl2ZXMgdGhlIGV4YWN0IGFyZ3VtZW50c1xuICogcGFzc2VkIHRvIGBgZGVmZXJyZWQubm90aWZ5YGAuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybnMgdGhlIGdpdmVuIHByb21pc2UsIHVuY2hhbmdlZFxuICovXG5RLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5mdW5jdGlvbiBwcm9ncmVzcyhvYmplY3QsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHZvaWQgMCwgcHJvZ3Jlc3NlZCk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGFuIG9wcG9ydHVuaXR5IHRvIG9ic2VydmUgdGhlIHNldHRsaW5nIG9mIGEgcHJvbWlzZSxcbiAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuICBGb3J3YXJkc1xuICogdGhlIHJlc29sdXRpb24gdG8gdGhlIHJldHVybmVkIHByb21pc2Ugd2hlbiB0aGUgY2FsbGJhY2sgaXMgZG9uZS5cbiAqIFRoZSBjYWxsYmFjayBjYW4gcmV0dXJuIGEgcHJvbWlzZSB0byBkZWZlciBjb21wbGV0aW9uLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBvYnNlcnZlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlblxuICogcHJvbWlzZSwgdGFrZXMgbm8gYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSB3aGVuXG4gKiBgYGZpbmBgIGlzIGRvbmUuXG4gKi9cblEuZmluID0gLy8gWFhYIGxlZ2FjeVxuUVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdClbXCJmaW5hbGx5XCJdKGNhbGxiYWNrKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZpbiA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gUShjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVE9ETyBhdHRlbXB0IHRvIHJlY3ljbGUgdGhlIHJlamVjdGlvbiB3aXRoIFwidGhpc1wiLlxuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFRlcm1pbmF0ZXMgYSBjaGFpbiBvZiBwcm9taXNlcywgZm9yY2luZyByZWplY3Rpb25zIHRvIGJlXG4gKiB0aHJvd24gYXMgZXhjZXB0aW9ucy5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBhdCB0aGUgZW5kIG9mIGEgY2hhaW4gb2YgcHJvbWlzZXNcbiAqIEByZXR1cm5zIG5vdGhpbmdcbiAqL1xuUS5kb25lID0gZnVuY3Rpb24gKG9iamVjdCwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRvbmUoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuICAgIHZhciBvblVuaGFuZGxlZEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIC8vIGZvcndhcmQgdG8gYSBmdXR1cmUgdHVybiBzbyB0aGF0IGBgd2hlbmBgXG4gICAgICAgIC8vIGRvZXMgbm90IGNhdGNoIGl0IGFuZCB0dXJuIGl0IGludG8gYSByZWplY3Rpb24uXG4gICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IGBuZXh0VGlja2BpbmcgdmlhIGFuIHVubmVjZXNzYXJ5IGB3aGVuYC5cbiAgICB2YXIgcHJvbWlzZSA9IGZ1bGZpbGxlZCB8fCByZWplY3RlZCB8fCBwcm9ncmVzcyA/XG4gICAgICAgIHRoaXMudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykgOlxuICAgICAgICB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgICAgb25VbmhhbmRsZWRFcnJvciA9IHByb2Nlc3MuZG9tYWluLmJpbmQob25VbmhhbmRsZWRFcnJvcik7XG4gICAgfVxuXG4gICAgcHJvbWlzZS50aGVuKHZvaWQgMCwgb25VbmhhbmRsZWRFcnJvcik7XG59O1xuXG4vKipcbiAqIENhdXNlcyBhIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgaWYgaXQgZG9lcyBub3QgZ2V0IGZ1bGZpbGxlZCBiZWZvcmVcbiAqIHNvbWUgbWlsbGlzZWNvbmRzIHRpbWUgb3V0LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzIHRpbWVvdXRcbiAqIEBwYXJhbSB7QW55Kn0gY3VzdG9tIGVycm9yIG1lc3NhZ2Ugb3IgRXJyb3Igb2JqZWN0IChvcHRpb25hbClcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgaWYgaXQgaXNcbiAqIGZ1bGZpbGxlZCBiZWZvcmUgdGhlIHRpbWVvdXQsIG90aGVyd2lzZSByZWplY3RlZC5cbiAqL1xuUS50aW1lb3V0ID0gZnVuY3Rpb24gKG9iamVjdCwgbXMsIGVycm9yKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aW1lb3V0KG1zLCBlcnJvcik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBlcnJvcikge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWVycm9yIHx8IFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IgfHwgXCJUaW1lZCBvdXQgYWZ0ZXIgXCIgKyBtcyArIFwiIG1zXCIpO1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9IFwiRVRJTUVET1VUXCI7XG4gICAgICAgIH1cbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICB9LCBtcyk7XG5cbiAgICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9LCBkZWZlcnJlZC5ub3RpZnkpO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZ2l2ZW4gdmFsdWUgKG9yIHByb21pc2VkIHZhbHVlKSwgc29tZVxuICogbWlsbGlzZWNvbmRzIGFmdGVyIGl0IHJlc29sdmVkLiBQYXNzZXMgcmVqZWN0aW9ucyBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kc1xuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBhZnRlciBtaWxsaXNlY29uZHNcbiAqIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UuXG4gKiBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSByZWplY3RzLCB0aGF0IGlzIHBhc3NlZCBpbW1lZGlhdGVseS5cbiAqL1xuUS5kZWxheSA9IGZ1bmN0aW9uIChvYmplY3QsIHRpbWVvdXQpIHtcbiAgICBpZiAodGltZW91dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kZWxheSh0aW1lb3V0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFBhc3NlcyBhIGNvbnRpbnVhdGlvbiB0byBhIE5vZGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxuICogYXJndW1lbnRzIHByb3ZpZGVkIGFzIGFuIGFycmF5LCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKlxuICogICAgICBRLm5mYXBwbHkoRlMucmVhZEZpbGUsIFtfX2ZpbGVuYW1lXSlcbiAqICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAqICAgICAgfSlcbiAqXG4gKi9cblEubmZhcHBseSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYXJncykge1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5uZmFwcGx5KGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZhcHBseSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmdzKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUGFzc2VzIGEgY29udGludWF0aW9uIHRvIGEgTm9kZSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgaW5kaXZpZHVhbGx5LCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZXhhbXBsZVxuICogUS5uZmNhbGwoRlMucmVhZEZpbGUsIF9fZmlsZW5hbWUpXG4gKiAudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICogfSlcbiAqXG4gKi9cblEubmZjYWxsID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5uZmFwcGx5KGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZjYWxsID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBXcmFwcyBhIE5vZGVKUyBjb250aW51YXRpb24gcGFzc2luZyBmdW5jdGlvbiBhbmQgcmV0dXJucyBhbiBlcXVpdmFsZW50XG4gKiB2ZXJzaW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZXhhbXBsZVxuICogUS5uZmJpbmQoRlMucmVhZEZpbGUsIF9fZmlsZW5hbWUpKFwidXRmLThcIilcbiAqIC50aGVuKGNvbnNvbGUubG9nKVxuICogLmRvbmUoKVxuICovXG5RLm5mYmluZCA9XG5RLmRlbm9kZWlmeSA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBiYXNlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGVBcmdzID0gYmFzZUFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgICAgIFEoY2FsbGJhY2spLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZiaW5kID1cblByb21pc2UucHJvdG90eXBlLmRlbm9kZWlmeSA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIFEuZGVub2RlaWZ5LmFwcGx5KHZvaWQgMCwgYXJncyk7XG59O1xuXG5RLm5iaW5kID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzcCAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBiYXNlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGVBcmdzID0gYmFzZUFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXNwLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFEoYm91bmQpLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmJpbmQgPSBmdW5jdGlvbiAoLyp0aGlzcCwgLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDApO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gUS5uYmluZC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCBvZiBhIE5vZGUtc3R5bGUgb2JqZWN0IHRoYXQgYWNjZXB0cyBhIE5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrIHdpdGggYSBnaXZlbiBhcnJheSBvZiBhcmd1bWVudHMsIHBsdXMgYSBwcm92aWRlZCBjYWxsYmFjay5cbiAqIEBwYXJhbSBvYmplY3QgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBuYW1lZCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCBvZiBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZDsgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHByb3ZpZGVkIGJ5IFEgYW5kIGFwcGVuZGVkIHRvIHRoZXNlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9yIGVycm9yXG4gKi9cblEubm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLm5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkubnBvc3QobmFtZSwgYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5ubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLm5wb3N0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmdzIHx8IFtdKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2ssIGZvcndhcmRpbmcgdGhlIGdpdmVuIHZhcmlhZGljIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkXG4gKiBjYWxsYmFjayBhcmd1bWVudC5cbiAqIEBwYXJhbSBvYmplY3QgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBuYW1lZCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCBvZiBvYmplY3RcbiAqIEBwYXJhbSAuLi5hcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFjayB3aWxsXG4gKiBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5zZW5kID0gLy8gWFhYIEJhc2VkIG9uIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgXCJzZW5kXCJcblEubm1jYWxsID0gLy8gWFhYIEJhc2VkIG9uIFwiUmVkc2FuZHJvJ3NcIiBwcm9wb3NhbFxuUS5uaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uc2VuZCA9IC8vIFhYWCBCYXNlZCBvbiBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIFwic2VuZFwiXG5Qcm9taXNlLnByb3RvdHlwZS5ubWNhbGwgPSAvLyBYWFggQmFzZWQgb24gXCJSZWRzYW5kcm8nc1wiIHByb3Bvc2FsXG5Qcm9taXNlLnByb3RvdHlwZS5uaW52b2tlID0gZnVuY3Rpb24gKG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogSWYgYSBmdW5jdGlvbiB3b3VsZCBsaWtlIHRvIHN1cHBvcnQgYm90aCBOb2RlIGNvbnRpbnVhdGlvbi1wYXNzaW5nLXN0eWxlIGFuZFxuICogcHJvbWlzZS1yZXR1cm5pbmctc3R5bGUsIGl0IGNhbiBlbmQgaXRzIGludGVybmFsIHByb21pc2UgY2hhaW4gd2l0aFxuICogYG5vZGVpZnkobm9kZWJhY2spYCwgZm9yd2FyZGluZyB0aGUgb3B0aW9uYWwgbm9kZWJhY2sgYXJndW1lbnQuICBJZiB0aGUgdXNlclxuICogZWxlY3RzIHRvIHVzZSBhIG5vZGViYWNrLCB0aGUgcmVzdWx0IHdpbGwgYmUgc2VudCB0aGVyZS4gIElmIHRoZXkgZG8gbm90XG4gKiBwYXNzIGEgbm9kZWJhY2ssIHRoZXkgd2lsbCByZWNlaXZlIHRoZSByZXN1bHQgcHJvbWlzZS5cbiAqIEBwYXJhbSBvYmplY3QgYSByZXN1bHQgKG9yIGEgcHJvbWlzZSBmb3IgYSByZXN1bHQpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBub2RlYmFjayBhIE5vZGUuanMtc3R5bGUgY2FsbGJhY2tcbiAqIEByZXR1cm5zIGVpdGhlciB0aGUgcHJvbWlzZSBvciBub3RoaW5nXG4gKi9cblEubm9kZWlmeSA9IG5vZGVpZnk7XG5mdW5jdGlvbiBub2RlaWZ5KG9iamVjdCwgbm9kZWJhY2spIHtcbiAgICByZXR1cm4gUShvYmplY3QpLm5vZGVpZnkobm9kZWJhY2spO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKG5vZGViYWNrKSB7XG4gICAgaWYgKG5vZGViYWNrKSB7XG4gICAgICAgIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGViYWNrKG51bGwsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGViYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5RLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJRLm5vQ29uZmxpY3Qgb25seSB3b3JrcyB3aGVuIFEgaXMgdXNlZCBhcyBhIGdsb2JhbFwiKTtcbn07XG5cbi8vIEFsbCBjb2RlIGJlZm9yZSB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMuXG52YXIgcUVuZGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xuXG5yZXR1cm4gUTtcblxufSk7XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIFNhZmFyaSA1LTcgbGFja3Mgc3VwcG9ydCBmb3IgY2hhbmdpbmcgdGhlIGBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yYCBwcm9wZXJ0eVxuICogICAgIG9uIG9iamVjdHMuXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhciAoKSB7fVxuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgYXJyLmNvbnN0cnVjdG9yID0gQmFyXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgYXJyLmNvbnN0cnVjdG9yID09PSBCYXIgJiYgLy8gY29uc3RydWN0b3IgY2FuIGJlIHNldFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAvLyBBdm9pZCBnb2luZyB0aHJvdWdoIGFuIEFyZ3VtZW50c0FkYXB0b3JUcmFtcG9saW5lIGluIHRoZSBjb21tb24gY2FzZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBuZXcgQnVmZmVyKGFyZywgYXJndW1lbnRzWzFdKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZylcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLCBhcmcpXG4gIH1cblxuICAvLyBTbGlnaHRseSBsZXNzIGNvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGlzLCBhcmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogJ3V0ZjgnKVxuICB9XG5cbiAgLy8gVW51c3VhbC5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhpcywgYXJnKVxufVxuXG5mdW5jdGlvbiBmcm9tTnVtYmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChsZW5ndGgpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIC8vIEFzc3VtcHRpb246IGJ5dGVMZW5ndGgoKSByZXR1cm4gdmFsdWUgaXMgYWx3YXlzIDwga01heExlbmd0aC5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSByZXR1cm4gZnJvbUJ1ZmZlcih0aGF0LCBvYmplY3QpXG5cbiAgaWYgKGlzQXJyYXkob2JqZWN0KSkgcmV0dXJuIGZyb21BcnJheSh0aGF0LCBvYmplY3QpXG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAob2JqZWN0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbVR5cGVkQXJyYXkodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChvYmplY3QubGVuZ3RoKSByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmplY3QpXG5cbiAgcmV0dXJuIGZyb21Kc29uT2JqZWN0KHRoYXQsIG9iamVjdClcbn1cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlciAodGhhdCwgYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGJ1ZmZlci5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBidWZmZXIuY29weSh0aGF0LCAwLCAwLCBsZW5ndGgpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIER1cGxpY2F0ZSBvZiBmcm9tQXJyYXkoKSB0byBrZWVwIGZyb21BcnJheSgpIG1vbm9tb3JwaGljLlxuZnVuY3Rpb24gZnJvbVR5cGVkQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIC8vIFRydW5jYXRpbmcgdGhlIGVsZW1lbnRzIGlzIHByb2JhYmx5IG5vdCB3aGF0IHBlb3BsZSBleHBlY3QgZnJvbSB0eXBlZFxuICAvLyBhcnJheXMgd2l0aCBCWVRFU19QRVJfRUxFTUVOVCA+IDEgYnV0IGl0J3MgY29tcGF0aWJsZSB3aXRoIHRoZSBiZWhhdmlvclxuICAvLyBvZiB0aGUgb2xkIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXkpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbVR5cGVkQXJyYXkodGhhdCwgbmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEZXNlcmlhbGl6ZSB7IHR5cGU6ICdCdWZmZXInLCBkYXRhOiBbMSwyLDMsLi4uXSB9IGludG8gYSBCdWZmZXIgb2JqZWN0LlxuLy8gUmV0dXJucyBhIHplcm8tbGVuZ3RoIGJ1ZmZlciBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3BlYy5cbmZ1bmN0aW9uIGZyb21Kc29uT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgdmFyIGFycmF5XG4gIHZhciBsZW5ndGggPSAwXG5cbiAgaWYgKG9iamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iamVjdC5kYXRhKSkge1xuICAgIGFycmF5ID0gb2JqZWN0LmRhdGFcbiAgICBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIH1cbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gYWxsb2NhdGUgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhhdC5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgZnJvbVBvb2wgPSBsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSA+Pj4gMVxuICBpZiAoZnJvbVBvb2wpIHRoYXQucGFyZW50ID0gcm9vdFBhcmVudFxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNsb3dCdWZmZXIpKSByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGRlbGV0ZSBidWYucGFyZW50XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIHZhciBpID0gMFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkgYnJlYWtcblxuICAgICsraVxuICB9XG5cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHN0cmluZyA9ICcnICsgc3RyaW5nXG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAvLyBEZXByZWNhdGVkXG4gICAgICBjYXNlICdyYXcnOlxuICAgICAgY2FzZSAncmF3cyc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aCB8IDBcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gX2F1Z21lbnQgKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IHNldCBtZXRob2QgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuaW5kZXhPZiA9IEJQLmluZGV4T2ZcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludExFID0gQlAucmVhZFVJbnRMRVxuICBhcnIucmVhZFVJbnRCRSA9IEJQLnJlYWRVSW50QkVcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50TEUgPSBCUC5yZWFkSW50TEVcbiAgYXJyLnJlYWRJbnRCRSA9IEJQLnJlYWRJbnRCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnRMRSA9IEJQLndyaXRlVUludExFXG4gIGFyci53cml0ZVVJbnRCRSA9IEJQLndyaXRlVUludEJFXG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnRMRSA9IEJQLndyaXRlSW50TEVcbiAgYXJyLndyaXRlSW50QkUgPSBCUC53cml0ZUludEJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gbGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCB8IDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIlxuLyoqXG4gKiBpc0FycmF5XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIHRvU3RyaW5nXG4gKi9cblxudmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGB2YWxgXG4gKiBpcyBhbiBhcnJheS5cbiAqXG4gKiBleGFtcGxlOlxuICpcbiAqICAgICAgICBpc0FycmF5KFtdKTtcbiAqICAgICAgICAvLyA+IHRydWVcbiAqICAgICAgICBpc0FycmF5KGFyZ3VtZW50cyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICogICAgICAgIGlzQXJyYXkoJycpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge21peGVkfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5IHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICEhIHZhbCAmJiAnW29iamVjdCBBcnJheV0nID09IHN0ci5jYWxsKHZhbCk7XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCIoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gTW9kdWxlIHN5c3RlbXMgbWFnaWMgZGFuY2UuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gTm9kZUpTXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gY2hhaUFzUHJvbWlzZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTURcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFpQXNQcm9taXNlZDtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLypnbG9iYWwgc2VsZjogZmFsc2UgKi9cblxuICAgICAgICAvLyBPdGhlciBlbnZpcm9ubWVudCAodXN1YWxseSA8c2NyaXB0PiB0YWcpOiBwbHVnIGluIHRvIGdsb2JhbCBjaGFpIGluc3RhbmNlIGRpcmVjdGx5LlxuICAgICAgICBjaGFpLnVzZShjaGFpQXNQcm9taXNlZCk7XG5cbiAgICAgICAgLy8gRXhwb3NlIGFzIGEgcHJvcGVydHkgb2YgdGhlIGdsb2JhbCBvYmplY3Qgc28gdGhhdCBjb25zdW1lcnMgY2FuIGNvbmZpZ3VyZSB0aGUgYHRyYW5zZmVyUHJvbWlzZW5lc3NgIHByb3BlcnR5LlxuICAgICAgICBzZWxmLmNoYWlBc1Byb21pc2VkID0gY2hhaUFzUHJvbWlzZWQ7XG4gICAgfVxuXG4gICAgY2hhaUFzUHJvbWlzZWQudHJhbnNmZXJQcm9taXNlbmVzcyA9IGZ1bmN0aW9uIChhc3NlcnRpb24sIHByb21pc2UpIHtcbiAgICAgICAgYXNzZXJ0aW9uLnRoZW4gPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKTtcbiAgICB9O1xuXG4gICAgY2hhaUFzUHJvbWlzZWQudHJhbnNmb3JtQXNzZXJ0ZXJBcmdzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjaGFpQXNQcm9taXNlZChjaGFpLCB1dGlscykge1xuICAgICAgICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb247XG4gICAgICAgIHZhciBhc3NlcnQgPSBjaGFpLmFzc2VydDtcblxuICAgICAgICBmdW5jdGlvbiBpc0pRdWVyeVByb21pc2UodGhlbmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhlbmFibGUuYWx3YXlzID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGhlbmFibGUuZG9uZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLmZhaWwgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aGVuYWJsZS5waXBlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGhlbmFibGUucHJvZ3Jlc3MgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aGVuYWJsZS5zdGF0ZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0SXNBYm91dFByb21pc2UoYXNzZXJ0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFzc2VydGlvbi5fb2JqLnRoZW4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IodXRpbHMuaW5zcGVjdChhc3NlcnRpb24uX29iaikgKyBcIiBpcyBub3QgYSB0aGVuYWJsZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNKUXVlcnlQcm9taXNlKGFzc2VydGlvbi5fb2JqKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDaGFpIGFzIFByb21pc2VkIGlzIGluY29tcGF0aWJsZSB3aXRoIGpRdWVyeSdzIHRoZW5hYmxlcywgc29ycnkhIFBsZWFzZSB1c2UgYSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlByb21pc2VzL0ErIGNvbXBhdGlibGUgbGlicmFyeSAoc2VlIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS8pLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1ldGhvZChuYW1lLCBhc3NlcnRlcikge1xuICAgICAgICAgICAgdXRpbHMuYWRkTWV0aG9kKEFzc2VydGlvbi5wcm90b3R5cGUsIG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRJc0Fib3V0UHJvbWlzZSh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXJ0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHJvcGVydHkobmFtZSwgYXNzZXJ0ZXIpIHtcbiAgICAgICAgICAgIHV0aWxzLmFkZFByb3BlcnR5KEFzc2VydGlvbi5wcm90b3R5cGUsIG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRJc0Fib3V0UHJvbWlzZSh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXJ0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZG9Ob3RpZnkocHJvbWlzZSwgZG9uZSkge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgZG9uZSgpOyB9LCBkb25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXNlIGFyZSBmb3IgY2xhcml0eSBhbmQgdG8gYnlwYXNzIENoYWkgcmVmdXNpbmcgdG8gYWxsb3cgYHVuZGVmaW5lZGAgYXMgYWN0dWFsIHdoZW4gdXNlZCB3aXRoIGBhc3NlcnRgLlxuICAgICAgICBmdW5jdGlvbiBhc3NlcnRJZk5lZ2F0ZWQoYXNzZXJ0aW9uLCBtZXNzYWdlLCBleHRyYSkge1xuICAgICAgICAgICAgYXNzZXJ0aW9uLmFzc2VydCh0cnVlLCBudWxsLCBtZXNzYWdlLCBleHRyYS5leHBlY3RlZCwgZXh0cmEuYWN0dWFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydElmTm90TmVnYXRlZChhc3NlcnRpb24sIG1lc3NhZ2UsIGV4dHJhKSB7XG4gICAgICAgICAgICBhc3NlcnRpb24uYXNzZXJ0KGZhbHNlLCBtZXNzYWdlLCBudWxsLCBleHRyYS5leHBlY3RlZCwgZXh0cmEuYWN0dWFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEJhc2VQcm9taXNlKGFzc2VydGlvbikge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGFpbiBzdWJzZXF1ZW50IGFzc2VydGVycyBvbiB0b3Agb2Ygb25lcyBpbiB0aGUgY2hhaW4gYWxyZWFkeSAoY29uc2lkZXJcbiAgICAgICAgICAgIC8vIGBldmVudHVhbGx5LmhhdmUucHJvcGVydHkoXCJmb29cIikudGhhdC5lcXVhbHMoXCJiYXJcIilgKSwgb25seSBydW5uaW5nIHRoZW0gYWZ0ZXIgdGhlIGV4aXN0aW5nIG9uZXMgcGFzcy5cbiAgICAgICAgICAgIC8vIFNvIHRoZSBmaXJzdCBiYXNlLXByb21pc2UgaXMgYGFzc2VydGlvbi5fb2JqYCwgYnV0IGFmdGVyIHRoYXQgd2UgdXNlIHRoZSBhc3NlcnRpb25zIHRoZW1zZWx2ZXMsIGkuZS5cbiAgICAgICAgICAgIC8vIHByZXZpb3VzbHkgZGVyaXZlZCBwcm9taXNlcywgdG8gY2hhaW4gb2ZmIG9mLlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhc3NlcnRpb24udGhlbiA9PT0gXCJmdW5jdGlvblwiID8gYXNzZXJ0aW9uIDogYXNzZXJ0aW9uLl9vYmo7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHcmFiIHRoZXNlIGZpcnN0LCBiZWZvcmUgd2UgbW9kaWZ5IGBBc3NlcnRpb24ucHJvdG90eXBlYC5cblxuICAgICAgICB2YXIgcHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKEFzc2VydGlvbi5wcm90b3R5cGUpO1xuXG4gICAgICAgIHZhciBwcm9wZXJ0eURlc2NzID0ge307XG4gICAgICAgIHByb3BlcnR5TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcHJvcGVydHlEZXNjc1tuYW1lXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQXNzZXJ0aW9uLnByb3RvdHlwZSwgbmFtZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3BlcnR5KFwiZnVsZmlsbGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBkZXJpdmVkUHJvbWlzZSA9IGdldEJhc2VQcm9taXNlKHRoYXQpLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX29iaiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRJZk5lZ2F0ZWQodGhhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgcHJvbWlzZSBub3QgdG8gYmUgZnVsZmlsbGVkIGJ1dCBpdCB3YXMgZnVsZmlsbGVkIHdpdGggI3thY3R9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFjdHVhbDogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0SWZOb3ROZWdhdGVkKHRoYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVjdGVkIHByb21pc2UgdG8gYmUgZnVsZmlsbGVkIGJ1dCBpdCB3YXMgcmVqZWN0ZWQgd2l0aCAje2FjdH1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYWN0dWFsOiByZWFzb24gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY2hhaUFzUHJvbWlzZWQudHJhbnNmZXJQcm9taXNlbmVzcyh0aGF0LCBkZXJpdmVkUHJvbWlzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3BlcnR5KFwicmVqZWN0ZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGRlcml2ZWRQcm9taXNlID0gZ2V0QmFzZVByb21pc2UodGhhdCkudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fb2JqID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydElmTm90TmVnYXRlZCh0aGF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJleHBlY3RlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkIGJ1dCBpdCB3YXMgZnVsZmlsbGVkIHdpdGggI3thY3R9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFjdHVhbDogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0SWZOZWdhdGVkKHRoYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVjdGVkIHByb21pc2Ugbm90IHRvIGJlIHJlamVjdGVkIGJ1dCBpdCB3YXMgcmVqZWN0ZWQgd2l0aCAje2FjdH1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYWN0dWFsOiByZWFzb24gfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSByZWFzb24sIHRyYW5zZm9ybWluZyB0aGlzIGludG8gYSBmdWxmaWxsbWVudCwgdG8gYWxsb3cgZnVydGhlciBhc3NlcnRpb25zLCBlLmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIGBwcm9taXNlLnNob3VsZC5iZS5yZWplY3RlZC5hbmQuZXZlbnR1YWxseS5lcXVhbChcInJlYXNvblwiKWAuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFzb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY2hhaUFzUHJvbWlzZWQudHJhbnNmZXJQcm9taXNlbmVzcyh0aGF0LCBkZXJpdmVkUHJvbWlzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1ldGhvZChcInJlamVjdGVkV2l0aFwiLCBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBkZXNpcmVkUmVhc29uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoQ29uc3RydWN0b3IgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIENvbnN0cnVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IENvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIENvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQ29uc3RydWN0b3IgJiYgQ29uc3RydWN0b3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGRlc2lyZWRSZWFzb24gPSBDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICBDb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3JOYW1lID0gKG5ldyBDb25zdHJ1Y3RvcigpKS5uYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBDb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBkZXJpdmVkUHJvbWlzZSA9IGdldEJhc2VQcm9taXNlKHRoYXQpLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhc3NlcnRpb25NZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydGlvbk1lc3NhZ2UgPSBcImV4cGVjdGVkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgd2l0aCAje2V4cH0gYnV0IGl0IHdhcyBmdWxmaWxsZWQgd2l0aCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIje2FjdH1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gY29uc3RydWN0b3JOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJiID0gbWVzc2FnZSBpbnN0YW5jZW9mIFJlZ0V4cCA/IFwibWF0Y2hpbmdcIiA6IFwiaW5jbHVkaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRpb25NZXNzYWdlID0gXCJleHBlY3RlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkIHdpdGggYW4gZXJyb3IgXCIgKyB2ZXJiICsgXCIgI3tleHB9IGJ1dCBpdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3YXMgZnVsZmlsbGVkIHdpdGggI3thY3R9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVzaXJlZFJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0aW9uTWVzc2FnZSA9IFwiZXhwZWN0ZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZCB3aXRoICN7ZXhwfSBidXQgaXQgd2FzIGZ1bGZpbGxlZCB3aXRoIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiN7YWN0fVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBkZXNpcmVkUmVhc29uO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fb2JqID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0SWZOb3ROZWdhdGVkKHRoYXQsIGFzc2VydGlvbk1lc3NhZ2UsIHsgZXhwZWN0ZWQ6IGV4cGVjdGVkLCBhY3R1YWw6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYXNzZXJ0KHJlYXNvbiBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJleHBlY3RlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkIHdpdGggI3tleHB9IGJ1dCBpdCB3YXMgcmVqZWN0ZWQgd2l0aCAje2FjdH1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgcHJvbWlzZSBub3QgdG8gYmUgcmVqZWN0ZWQgd2l0aCAje2V4cH0gYnV0IGl0IHdhcyByZWplY3RlZCB3aXRoICN7YWN0fVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3JOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFzb25NZXNzYWdlID0gdXRpbHMudHlwZShyZWFzb24pID09PSBcIm9iamVjdFwiICYmIFwibWVzc2FnZVwiIGluIHJlYXNvbiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbi5tZXNzYWdlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiArIHJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UgJiYgcmVhc29uTWVzc2FnZSAhPT0gbnVsbCAmJiByZWFzb25NZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hc3NlcnQobWVzc2FnZS50ZXN0KHJlYXNvbk1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yIG1hdGNoaW5nICN7ZXhwfSBidXQgZ290ICN7YWN0fVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgcHJvbWlzZSBub3QgdG8gYmUgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvciBtYXRjaGluZyAje2V4cH1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hc3NlcnQocmVhc29uTWVzc2FnZS5pbmRleE9mKG1lc3NhZ2UpICE9PSAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVjdGVkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvciBpbmNsdWRpbmcgI3tleHB9IGJ1dCBnb3QgI3thY3R9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJleHBlY3RlZCBwcm9taXNlIG5vdCB0byBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yIGluY2x1ZGluZyAje2V4cH1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2lyZWRSZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYXNzZXJ0KHJlYXNvbiA9PT0gZGVzaXJlZFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZCB3aXRoICN7ZXhwfSBidXQgaXQgd2FzIHJlamVjdGVkIHdpdGggI3thY3R9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVjdGVkIHByb21pc2Ugbm90IHRvIGJlIHJlamVjdGVkIHdpdGggI3tleHB9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNpcmVkUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNoYWlBc1Byb21pc2VkLnRyYW5zZmVyUHJvbWlzZW5lc3ModGhhdCwgZGVyaXZlZFByb21pc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwcm9wZXJ0eShcImV2ZW50dWFsbHlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdXRpbHMuZmxhZyh0aGlzLCBcImV2ZW50dWFsbHlcIiwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1ldGhvZChcIm5vdGlmeVwiLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgZG9Ob3RpZnkoZ2V0QmFzZVByb21pc2UodGhpcyksIGRvbmUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtZXRob2QoXCJiZWNvbWVcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHVhbGx5LmRlZXAuZXF1YWwodmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLy8vLy8vL1xuICAgICAgICAvLyBgZXZlbnR1YWxseWBcblxuICAgICAgICAvLyBXZSBuZWVkIHRvIGJlIGNhcmVmdWwgbm90IHRvIHRyaWdnZXIgYW55IGdldHRlcnMsIHRodXMgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIHVzYWdlLlxuICAgICAgICB2YXIgbWV0aG9kTmFtZXMgPSBwcm9wZXJ0eU5hbWVzLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgIT09IFwiYXNzZXJ0XCIgJiYgdHlwZW9mIHByb3BlcnR5RGVzY3NbbmFtZV0udmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWV0aG9kTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZChtZXRob2ROYW1lLCBmdW5jdGlvbiAob3JpZ2luYWxNZXRob2QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkb0Fzc2VydGVyQXN5bmNBbmRBZGRUaGVuKG9yaWdpbmFsTWV0aG9kLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGdldHRlck5hbWVzID0gcHJvcGVydHlOYW1lcy5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lICE9PSBcIl9vYmpcIiAmJiB0eXBlb2YgcHJvcGVydHlEZXNjc1tuYW1lXS5nZXQgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZ2V0dGVyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZ2V0dGVyTmFtZSkge1xuICAgICAgICAgICAgLy8gQ2hhaW5hYmxlIG1ldGhvZHMgYXJlIHRoaW5ncyBsaWtlIGBhbmAsIHdoaWNoIGNhbiB3b3JrIGJvdGggZm9yIGAuc2hvdWxkLmJlLmFuLmluc3RhbmNlT2ZgIGFuZCBhc1xuICAgICAgICAgICAgLy8gYHNob3VsZC5iZS5hbihcIm9iamVjdFwiKWAuIFdlIG5lZWQgdG8gaGFuZGxlIHRob3NlIHNwZWNpYWxseS5cbiAgICAgICAgICAgIHZhciBpc0NoYWluYWJsZU1ldGhvZCA9IEFzc2VydGlvbi5wcm90b3R5cGUuX19tZXRob2RzLmhhc093blByb3BlcnR5KGdldHRlck5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaXNDaGFpbmFibGVNZXRob2QpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKFxuICAgICAgICAgICAgICAgICAgICBnZXR0ZXJOYW1lLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAob3JpZ2luYWxNZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb0Fzc2VydGVyQXN5bmNBbmRBZGRUaGVuKG9yaWdpbmFsTWV0aG9kLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKG9yaWdpbmFsR2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9Bc3NlcnRlckFzeW5jQW5kQWRkVGhlbihvcmlnaW5hbEdldHRlciwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5KGdldHRlck5hbWUsIGZ1bmN0aW9uIChvcmlnaW5hbEdldHRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9Bc3NlcnRlckFzeW5jQW5kQWRkVGhlbihvcmlnaW5hbEdldHRlciwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRvQXNzZXJ0ZXJBc3luY0FuZEFkZFRoZW4oYXNzZXJ0ZXIsIGFzc2VydGlvbiwgYXJncykge1xuICAgICAgICAgICAgLy8gU2luY2Ugd2UncmUgaW50ZXJjZXB0aW5nIGFsbCBtZXRob2RzL3Byb3BlcnRpZXMsIHdlIG5lZWQgdG8ganVzdCBwYXNzIHRocm91Z2ggaWYgdGhleSBkb24ndCB3YW50XG4gICAgICAgICAgICAvLyBgZXZlbnR1YWxseWAsIG9yIGlmIHdlJ3ZlIGFscmVhZHkgZnVsZmlsbGVkIHRoZSBwcm9taXNlIChzZWUgYmVsb3cpLlxuICAgICAgICAgICAgaWYgKCF1dGlscy5mbGFnKGFzc2VydGlvbiwgXCJldmVudHVhbGx5XCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2VydGVyLmFwcGx5KGFzc2VydGlvbiwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZXJpdmVkUHJvbWlzZSA9IGdldEJhc2VQcm9taXNlKGFzc2VydGlvbikudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdXAgdGhlIGVudmlyb25tZW50IGZvciB0aGUgYXNzZXJ0ZXIgdG8gYWN0dWFsbHkgcnVuOiBgX29iamAgc2hvdWxkIGJlIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gbm93IHRoYXQgd2UgaGF2ZSB0aGUgdmFsdWUsIHdlJ3JlIG5vIGxvbmdlciBpbiBcImV2ZW50dWFsbHlcIiBtb2RlLCBzbyB3ZSB3b24ndCBydW4gYW55IG9mIHRoaXMgY29kZSxcbiAgICAgICAgICAgICAgICAvLyBqdXN0IHRoZSBiYXNlIENoYWkgY29kZSB0aGF0IHdlIGdldCB0byB2aWEgdGhlIHNob3J0LWNpcmN1aXQgYWJvdmUuXG4gICAgICAgICAgICAgICAgYXNzZXJ0aW9uLl9vYmogPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB1dGlscy5mbGFnKGFzc2VydGlvbiwgXCJldmVudHVhbGx5XCIsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzID8gY2hhaUFzUHJvbWlzZWQudHJhbnNmb3JtQXNzZXJ0ZXJBcmdzKGFyZ3MpIDogYXJncztcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRlci5hcHBseShhc3NlcnRpb24sIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBhc3NlcnRlcnMsIGZvciBleGFtcGxlIGBwcm9wZXJ0eWAsIGNhbiBjaGFuZ2UgdGhlIHZhbHVlIG9mIGBfb2JqYCAoaS5lLiBjaGFuZ2UgdGhlIFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICAvLyBmbGFnKSwgd2UgbmVlZCB0byBjb21tdW5pY2F0ZSB0aGlzIHZhbHVlIGNoYW5nZSB0byBzdWJzZXF1ZW50IGNoYWluZWQgYXNzZXJ0ZXJzLiBTaW5jZSB3ZSBidWlsZCBhXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZSBjaGFpbiBwYXJhbGxlbGluZyB0aGUgYXNzZXJ0ZXIgY2hhaW4sIHdlIGNhbiB1c2UgaXQgdG8gY29tbXVuaWNhdGUgc3VjaCBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgIHJldHVybiBhc3NlcnRpb24uX29iajtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjaGFpQXNQcm9taXNlZC50cmFuc2ZlclByb21pc2VuZXNzKGFzc2VydGlvbiwgZGVyaXZlZFByb21pc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8vLy8vL1xuICAgICAgICAvLyBOb3cgdXNlIHRoZSBgQXNzZXJ0aW9uYCBmcmFtZXdvcmsgdG8gYnVpbGQgYW4gYGFzc2VydGAgaW50ZXJmYWNlLlxuICAgICAgICB2YXIgb3JpZ2luYWxBc3NlcnRNZXRob2RzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXNzZXJ0KS5maWx0ZXIoZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFzc2VydFtwcm9wTmFtZV0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXNzZXJ0LmlzRnVsZmlsbGVkID0gZnVuY3Rpb24gKHByb21pc2UsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IEFzc2VydGlvbihwcm9taXNlLCBtZXNzYWdlKSkudG8uYmUuZnVsZmlsbGVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFzc2VydC5pc1JlamVjdGVkID0gZnVuY3Rpb24gKHByb21pc2UsIHRvVGVzdEFnYWluc3QsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9UZXN0QWdhaW5zdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0b1Rlc3RBZ2FpbnN0O1xuICAgICAgICAgICAgICAgIHRvVGVzdEFnYWluc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhc3NlcnRpb24gPSAobmV3IEFzc2VydGlvbihwcm9taXNlLCBtZXNzYWdlKSk7XG4gICAgICAgICAgICByZXR1cm4gdG9UZXN0QWdhaW5zdCAhPT0gdW5kZWZpbmVkID8gYXNzZXJ0aW9uLnRvLmJlLnJlamVjdGVkV2l0aCh0b1Rlc3RBZ2FpbnN0KSA6IGFzc2VydGlvbi50by5iZS5yZWplY3RlZDtcbiAgICAgICAgfTtcblxuICAgICAgICBhc3NlcnQuYmVjb21lcyA9IGZ1bmN0aW9uIChwcm9taXNlLCB2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFzc2VydC5ldmVudHVhbGx5LmRlZXBFcXVhbChwcm9taXNlLCB2YWx1ZSwgbWVzc2FnZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYXNzZXJ0LmRvZXNOb3RCZWNvbWUgPSBmdW5jdGlvbiAocHJvbWlzZSwgdmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3NlcnQuZXZlbnR1YWxseS5ub3REZWVwRXF1YWwocHJvbWlzZSwgdmFsdWUsIG1lc3NhZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFzc2VydC5ldmVudHVhbGx5ID0ge307XG4gICAgICAgIG9yaWdpbmFsQXNzZXJ0TWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChhc3NlcnRNZXRob2ROYW1lKSB7XG4gICAgICAgICAgICBhc3NlcnQuZXZlbnR1YWxseVthc3NlcnRNZXRob2ROYW1lXSA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VzdG9tUmVqZWN0aW9uSGFuZGxlcjtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGFyZ3VtZW50c1thc3NlcnRbYXNzZXJ0TWV0aG9kTmFtZV0ubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVJlamVjdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihtZXNzYWdlICsgXCJcXG5cXG5PcmlnaW5hbCByZWFzb246IFwiICsgdXRpbHMuaW5zcGVjdChyZWFzb24pKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZWRQcm9taXNlID0gcHJvbWlzZS50aGVuKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZnVsZmlsbG1lbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzc2VydFthc3NlcnRNZXRob2ROYW1lXS5hcHBseShhc3NlcnQsIFtmdWxmaWxsbWVudFZhbHVlXS5jb25jYXQob3RoZXJBcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVJlamVjdGlvbkhhbmRsZXJcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuZWRQcm9taXNlLm5vdGlmeSA9IGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvTm90aWZ5KHJldHVybmVkUHJvbWlzZSwgZG9uZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5lZFByb21pc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59KCkpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9jaGFpJyk7XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgdXNlZCA9IFtdXG4gICwgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qIVxuICogQ2hhaSB2ZXJzaW9uXG4gKi9cblxuZXhwb3J0cy52ZXJzaW9uID0gJzMuMi4wJztcblxuLyohXG4gKiBBc3NlcnRpb24gRXJyb3JcbiAqL1xuXG5leHBvcnRzLkFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnYXNzZXJ0aW9uLWVycm9yJyk7XG5cbi8qIVxuICogVXRpbHMgZm9yIHBsdWdpbnMgKG5vdCBleHBvcnRlZClcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vY2hhaS91dGlscycpO1xuXG4vKipcbiAqICMgLnVzZShmdW5jdGlvbilcbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byBleHRlbmQgdGhlIGludGVybmFscyBvZiBDaGFpXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEByZXR1cm5zIHt0aGlzfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy51c2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgaWYgKCF+dXNlZC5pbmRleE9mKGZuKSkge1xuICAgIGZuKHRoaXMsIHV0aWwpO1xuICAgIHVzZWQucHVzaChmbik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogVXRpbGl0eSBGdW5jdGlvbnNcbiAqL1xuXG5leHBvcnRzLnV0aWwgPSB1dGlsO1xuXG4vKiFcbiAqIENvbmZpZ3VyYXRpb25cbiAqL1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jaGFpL2NvbmZpZycpO1xuZXhwb3J0cy5jb25maWcgPSBjb25maWc7XG5cbi8qIVxuICogUHJpbWFyeSBgQXNzZXJ0aW9uYCBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXNzZXJ0aW9uID0gcmVxdWlyZSgnLi9jaGFpL2Fzc2VydGlvbicpO1xuZXhwb3J0cy51c2UoYXNzZXJ0aW9uKTtcblxuLyohXG4gKiBDb3JlIEFzc2VydGlvbnNcbiAqL1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vY2hhaS9jb3JlL2Fzc2VydGlvbnMnKTtcbmV4cG9ydHMudXNlKGNvcmUpO1xuXG4vKiFcbiAqIEV4cGVjdCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgZXhwZWN0ID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9leHBlY3QnKTtcbmV4cG9ydHMudXNlKGV4cGVjdCk7XG5cbi8qIVxuICogU2hvdWxkIGludGVyZmFjZVxuICovXG5cbnZhciBzaG91bGQgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL3Nob3VsZCcpO1xuZXhwb3J0cy51c2Uoc2hvdWxkKTtcblxuLyohXG4gKiBBc3NlcnQgaW50ZXJmYWNlXG4gKi9cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2UvYXNzZXJ0Jyk7XG5leHBvcnRzLnVzZShhc3NlcnQpO1xuIiwiLyohXG4gKiBjaGFpXG4gKiBodHRwOi8vY2hhaWpzLmNvbVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfY2hhaSwgdXRpbCkge1xuICAvKiFcbiAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgdmFyIEFzc2VydGlvbkVycm9yID0gX2NoYWkuQXNzZXJ0aW9uRXJyb3JcbiAgICAsIGZsYWcgPSB1dGlsLmZsYWc7XG5cbiAgLyohXG4gICAqIE1vZHVsZSBleHBvcnQuXG4gICAqL1xuXG4gIF9jaGFpLkFzc2VydGlvbiA9IEFzc2VydGlvbjtcblxuICAvKiFcbiAgICogQXNzZXJ0aW9uIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIENyZWF0ZXMgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIEFzc2VydGlvbiAob2JqLCBtc2csIHN0YWNrKSB7XG4gICAgZmxhZyh0aGlzLCAnc3NmaScsIHN0YWNrIHx8IGFyZ3VtZW50cy5jYWxsZWUpO1xuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIG9iaik7XG4gICAgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXNzZXJ0aW9uLCAnaW5jbHVkZVN0YWNrJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5pbmNsdWRlU3RhY2sgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIGNvbmZpZy5pbmNsdWRlU3RhY2s7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5pbmNsdWRlU3RhY2sgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayBpbnN0ZWFkLicpO1xuICAgICAgY29uZmlnLmluY2x1ZGVTdGFjayA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbiwgJ3Nob3dEaWZmJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5zaG93RGlmZiBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuc2hvd0RpZmYgaW5zdGVhZC4nKTtcbiAgICAgIHJldHVybiBjb25maWcuc2hvd0RpZmY7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5zaG93RGlmZiBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuc2hvd0RpZmYgaW5zdGVhZC4nKTtcbiAgICAgIGNvbmZpZy5zaG93RGlmZiA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5hZGRQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLmFkZE1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgICB1dGlsLmFkZENoYWluYWJsZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwub3ZlcndyaXRlUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5hc3NlcnQoZXhwcmVzc2lvbiwgbWVzc2FnZSwgbmVnYXRlTWVzc2FnZSwgZXhwZWN0ZWQsIGFjdHVhbCwgc2hvd0RpZmYpXG4gICAqXG4gICAqIEV4ZWN1dGVzIGFuIGV4cHJlc3Npb24gYW5kIGNoZWNrIGV4cGVjdGF0aW9ucy4gVGhyb3dzIEFzc2VydGlvbkVycm9yIGZvciByZXBvcnRpbmcgaWYgdGVzdCBkb2Vzbid0IHBhc3MuXG4gICAqXG4gICAqIEBuYW1lIGFzc2VydFxuICAgKiBAcGFyYW0ge1BoaWxvc29waGljYWx9IGV4cHJlc3Npb24gdG8gYmUgdGVzdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nIG9yIEZ1bmN0aW9ufSBtZXNzYWdlIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBtZXNzYWdlIHRvIGRpc3BsYXkgaWYgZXhwcmVzc2lvbiBmYWlsc1xuICAgKiBAcGFyYW0ge1N0cmluZyBvciBGdW5jdGlvbn0gbmVnYXRlZE1lc3NhZ2Ugb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5lZ2F0ZWRNZXNzYWdlIHRvIGRpc3BsYXkgaWYgbmVnYXRlZCBleHByZXNzaW9uIGZhaWxzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkIHZhbHVlIChyZW1lbWJlciB0byBjaGVjayBmb3IgbmVnYXRpb24pXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbCAob3B0aW9uYWwpIHdpbGwgZGVmYXVsdCB0byBgdGhpcy5vYmpgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd0RpZmYgKG9wdGlvbmFsKSB3aGVuIHNldCB0byBgdHJ1ZWAsIGFzc2VydCB3aWxsIGRpc3BsYXkgYSBkaWZmIGluIGFkZGl0aW9uIHRvIHRoZSBtZXNzYWdlIGlmIGV4cHJlc3Npb24gZmFpbHNcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIEFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0ID0gZnVuY3Rpb24gKGV4cHIsIG1zZywgbmVnYXRlTXNnLCBleHBlY3RlZCwgX2FjdHVhbCwgc2hvd0RpZmYpIHtcbiAgICB2YXIgb2sgPSB1dGlsLnRlc3QodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodHJ1ZSAhPT0gc2hvd0RpZmYpIHNob3dEaWZmID0gZmFsc2U7XG4gICAgaWYgKHRydWUgIT09IGNvbmZpZy5zaG93RGlmZikgc2hvd0RpZmYgPSBmYWxzZTtcblxuICAgIGlmICghb2spIHtcbiAgICAgIHZhciBtc2cgPSB1dGlsLmdldE1lc3NhZ2UodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAsIGFjdHVhbCA9IHV0aWwuZ2V0QWN0dWFsKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnLCB7XG4gICAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgLCBzaG93RGlmZjogc2hvd0RpZmZcbiAgICAgIH0sIChjb25maWcuaW5jbHVkZVN0YWNrKSA/IHRoaXMuYXNzZXJ0IDogZmxhZyh0aGlzLCAnc3NmaScpKTtcbiAgICB9XG4gIH07XG5cbiAgLyohXG4gICAqICMjIyAuX29ialxuICAgKlxuICAgKiBRdWljayByZWZlcmVuY2UgdG8gc3RvcmVkIGBhY3R1YWxgIHZhbHVlIGZvciBwbHVnaW4gZGV2ZWxvcGVycy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24ucHJvdG90eXBlLCAnX29iaicsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgICAgfVxuICAgICwgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHZhbCk7XG4gICAgICB9XG4gIH0pO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qKlxuICAgKiAjIyMgY29uZmlnLmluY2x1ZGVTdGFja1xuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgaW5mbHVlbmNlcyB3aGV0aGVyIHN0YWNrIHRyYWNlXG4gICAqIGlzIGluY2x1ZGVkIGluIEFzc2VydGlvbiBlcnJvciBtZXNzYWdlLiBEZWZhdWx0IG9mIGZhbHNlXG4gICAqIHN1cHByZXNzZXMgc3RhY2sgdHJhY2UgaW4gdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAqXG4gICAqICAgICBjaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2sgPSB0cnVlOyAgLy8gZW5hYmxlIHN0YWNrIG9uIGVycm9yXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgIGluY2x1ZGVTdGFjazogZmFsc2UsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcuc2hvd0RpZmZcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIGluZmx1ZW5jZXMgd2hldGhlciBvciBub3RcbiAgICogdGhlIGBzaG93RGlmZmAgZmxhZyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHRocm93blxuICAgKiBBc3NlcnRpb25FcnJvcnMuIGBmYWxzZWAgd2lsbCBhbHdheXMgYmUgYGZhbHNlYDsgYHRydWVgXG4gICAqIHdpbGwgYmUgdHJ1ZSB3aGVuIHRoZSBhc3NlcnRpb24gaGFzIHJlcXVlc3RlZCBhIGRpZmZcbiAgICogYmUgc2hvd24uXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgc2hvd0RpZmY6IHRydWUsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcudHJ1bmNhdGVUaHJlc2hvbGRcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIHNldHMgbGVuZ3RoIHRocmVzaG9sZCBmb3IgYWN0dWFsIGFuZFxuICAgKiBleHBlY3RlZCB2YWx1ZXMgaW4gYXNzZXJ0aW9uIGVycm9ycy4gSWYgdGhpcyB0aHJlc2hvbGQgaXMgZXhjZWVkZWQsIGZvclxuICAgKiBleGFtcGxlIGZvciBsYXJnZSBkYXRhIHN0cnVjdHVyZXMsIHRoZSB2YWx1ZSBpcyByZXBsYWNlZCB3aXRoIHNvbWV0aGluZ1xuICAgKiBsaWtlIGBbIEFycmF5KDMpIF1gIG9yIGB7IE9iamVjdCAocHJvcDEsIHByb3AyKSB9YC5cbiAgICpcbiAgICogU2V0IGl0IHRvIHplcm8gaWYgeW91IHdhbnQgdG8gZGlzYWJsZSB0cnVuY2F0aW5nIGFsdG9nZXRoZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgZXNwZWNpYWxseSB1c2VyZnVsIHdoZW4gZG9pbmcgYXNzZXJ0aW9ucyBvbiBhcnJheXM6IGhhdmluZyB0aGlzXG4gICAqIHNldCB0byBhIHJlYXNvbmFibGUgbGFyZ2UgdmFsdWUgbWFrZXMgdGhlIGZhaWx1cmUgbWVzc2FnZXMgcmVhZGlseVxuICAgKiBpbnNwZWN0YWJsZS5cbiAgICpcbiAgICogICAgIGNoYWkuY29uZmlnLnRydW5jYXRlVGhyZXNob2xkID0gMDsgIC8vIGRpc2FibGUgdHJ1bmNhdGluZ1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgdHJ1bmNhdGVUaHJlc2hvbGQ6IDQwXG5cbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIGh0dHA6Ly9jaGFpanMuY29tXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgXykge1xuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb25cbiAgICAsIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICwgZmxhZyA9IF8uZmxhZztcblxuICAvKipcbiAgICogIyMjIExhbmd1YWdlIENoYWluc1xuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGFyZSBwcm92aWRlZCBhcyBjaGFpbmFibGUgZ2V0dGVycyB0b1xuICAgKiBpbXByb3ZlIHRoZSByZWFkYWJpbGl0eSBvZiB5b3VyIGFzc2VydGlvbnMuIFRoZXlcbiAgICogZG8gbm90IHByb3ZpZGUgdGVzdGluZyBjYXBhYmlsaXRpZXMgdW5sZXNzIHRoZXlcbiAgICogaGF2ZSBiZWVuIG92ZXJ3cml0dGVuIGJ5IGEgcGx1Z2luLlxuICAgKlxuICAgKiAqKkNoYWlucyoqXG4gICAqXG4gICAqIC0gdG9cbiAgICogLSBiZVxuICAgKiAtIGJlZW5cbiAgICogLSBpc1xuICAgKiAtIHRoYXRcbiAgICogLSB3aGljaFxuICAgKiAtIGFuZFxuICAgKiAtIGhhc1xuICAgKiAtIGhhdmVcbiAgICogLSB3aXRoXG4gICAqIC0gYXRcbiAgICogLSBvZlxuICAgKiAtIHNhbWVcbiAgICpcbiAgICogQG5hbWUgbGFuZ3VhZ2UgY2hhaW5zXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIFsgJ3RvJywgJ2JlJywgJ2JlZW4nXG4gICwgJ2lzJywgJ2FuZCcsICdoYXMnLCAnaGF2ZSdcbiAgLCAnd2l0aCcsICd0aGF0JywgJ3doaWNoJywgJ2F0J1xuICAsICdvZicsICdzYW1lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KGNoYWluLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAubm90XG4gICAqXG4gICAqIE5lZ2F0ZXMgYW55IG9mIGFzc2VydGlvbnMgZm9sbG93aW5nIGluIHRoZSBjaGFpbi5cbiAgICpcbiAgICogICAgIGV4cGVjdChmb28pLnRvLm5vdC5lcXVhbCgnYmFyJyk7XG4gICAqICAgICBleHBlY3QoZ29vZEZuKS50by5ub3QudGhyb3coRXJyb3IpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmF6JyB9KS50by5oYXZlLnByb3BlcnR5KCdmb28nKVxuICAgKiAgICAgICAuYW5kLm5vdC5lcXVhbCgnYmFyJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ25vdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICduZWdhdGUnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFxuICAgKlxuICAgKiBTZXRzIHRoZSBgZGVlcGAgZmxhZywgbGF0ZXIgdXNlZCBieSB0aGUgYGVxdWFsYCBhbmRcbiAgICogYHByb3BlcnR5YCBhc3NlcnRpb25zLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZvbykudG8uZGVlcC5lcXVhbCh7IGJhcjogJ2JheicgfSk7XG4gICAqICAgICBleHBlY3QoeyBmb286IHsgYmFyOiB7IGJhejogJ3F1dXgnIH0gfSB9KVxuICAgKiAgICAgICAudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdmb28uYmFyLmJheicsICdxdXV4Jyk7XG4gICAqXG4gICAqIGAuZGVlcC5wcm9wZXJ0eWAgc3BlY2lhbCBjaGFyYWN0ZXJzIGNhbiBiZSBlc2NhcGVkXG4gICAqIGJ5IGFkZGluZyB0d28gc2xhc2hlcyBiZWZvcmUgdGhlIGAuYCBvciBgW11gLlxuICAgKlxuICAgKiAgICAgdmFyIGRlZXBDc3MgPSB7ICcubGluayc6IHsgJ1t0YXJnZXRdJzogNDIgfX07XG4gICAqICAgICBleHBlY3QoZGVlcENzcykudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdcXFxcLmxpbmsuXFxcXFt0YXJnZXRcXFxcXScsIDQyKTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2RlZXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnZGVlcCcsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hbnlcbiAgICpcbiAgICogU2V0cyB0aGUgYGFueWAgZmxhZywgKG9wcG9zaXRlIG9mIHRoZSBgYWxsYCBmbGFnKVxuICAgKiBsYXRlciB1c2VkIGluIHRoZSBga2V5c2AgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZvbykudG8uaGF2ZS5hbnkua2V5cygnYmFyJywgJ2JheicpO1xuICAgKlxuICAgKiBAbmFtZSBhbnlcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdhbnknLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnYW55JywgdHJ1ZSk7XG4gICAgZmxhZyh0aGlzLCAnYWxsJywgZmFsc2UpXG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAuYWxsXG4gICAqXG4gICAqIFNldHMgdGhlIGBhbGxgIGZsYWcgKG9wcG9zaXRlIG9mIHRoZSBgYW55YCBmbGFnKVxuICAgKiBsYXRlciB1c2VkIGJ5IHRoZSBga2V5c2AgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZvbykudG8uaGF2ZS5hbGwua2V5cygnYmFyJywgJ2JheicpO1xuICAgKlxuICAgKiBAbmFtZSBhbGxcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdhbGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnYWxsJywgdHJ1ZSk7XG4gICAgZmxhZyh0aGlzLCAnYW55JywgZmFsc2UpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hKHR5cGUpXG4gICAqXG4gICAqIFRoZSBgYWAgYW5kIGBhbmAgYXNzZXJ0aW9ucyBhcmUgYWxpYXNlcyB0aGF0IGNhbiBiZVxuICAgKiB1c2VkIGVpdGhlciBhcyBsYW5ndWFnZSBjaGFpbnMgb3IgdG8gYXNzZXJ0IGEgdmFsdWUnc1xuICAgKiB0eXBlLlxuICAgKlxuICAgKiAgICAgLy8gdHlwZW9mXG4gICAqICAgICBleHBlY3QoJ3Rlc3QnKS50by5iZS5hKCdzdHJpbmcnKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogJ2JhcicgfSkudG8uYmUuYW4oJ29iamVjdCcpO1xuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLmEoJ251bGwnKTtcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLmFuKCd1bmRlZmluZWQnKTtcbiAgICogICAgIGV4cGVjdChuZXcgUHJvbWlzZSkudG8uYmUuYSgncHJvbWlzZScpO1xuICAgKiAgICAgZXhwZWN0KG5ldyBGbG9hdDMyQXJyYXkoKSkudG8uYmUuYSgnZmxvYXQzMmFycmF5Jyk7XG4gICAqICAgICBleHBlY3QoU3ltYm9sKCkpLnRvLmJlLmEoJ3N5bWJvbCcpO1xuICAgKlxuICAgKiAgICAgLy8gZXM2IG92ZXJyaWRlc1xuICAgKiAgICAgZXhwZWN0KHtbU3ltYm9sLnRvU3RyaW5nVGFnXTooKT0+J2Zvbyd9KS50by5iZS5hKCdmb28nKTtcbiAgICpcbiAgICogICAgIC8vIGxhbmd1YWdlIGNoYWluXG4gICAqICAgICBleHBlY3QoZm9vKS50by5iZS5hbi5pbnN0YW5jZW9mKEZvbyk7XG4gICAqXG4gICAqIEBuYW1lIGFcbiAgICogQGFsaWFzIGFuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYW4gKHR5cGUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGFydGljbGUgPSB+WyAnYScsICdlJywgJ2knLCAnbycsICd1JyBdLmluZGV4T2YodHlwZS5jaGFyQXQoMCkpID8gJ2FuICcgOiAnYSAnO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHR5cGUgPT09IF8udHlwZShvYmopXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlICcgKyBhcnRpY2xlICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgJyArIGFydGljbGUgKyB0eXBlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2FuJywgYW4pO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhJywgYW4pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGUodmFsdWUpXG4gICAqXG4gICAqIFRoZSBgaW5jbHVkZWAgYW5kIGBjb250YWluYCBhc3NlcnRpb25zIGNhbiBiZSB1c2VkIGFzIGVpdGhlciBwcm9wZXJ0eVxuICAgKiBiYXNlZCBsYW5ndWFnZSBjaGFpbnMgb3IgYXMgbWV0aG9kcyB0byBhc3NlcnQgdGhlIGluY2x1c2lvbiBvZiBhbiBvYmplY3RcbiAgICogaW4gYW4gYXJyYXkgb3IgYSBzdWJzdHJpbmcgaW4gYSBzdHJpbmcuIFdoZW4gdXNlZCBhcyBsYW5ndWFnZSBjaGFpbnMsXG4gICAqIHRoZXkgdG9nZ2xlIHRoZSBgY29udGFpbnNgIGZsYWcgZm9yIHRoZSBga2V5c2AgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLDIsM10pLnRvLmluY2x1ZGUoMik7XG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmNvbnRhaW4oJ2ZvbycpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJywgaGVsbG86ICd1bml2ZXJzZScgfSkudG8uaW5jbHVkZS5rZXlzKCdmb28nKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZVxuICAgKiBAYWxpYXMgY29udGFpblxuICAgKiBAYWxpYXMgaW5jbHVkZXNcbiAgICogQGFsaWFzIGNvbnRhaW5zXG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xOdW1iZXJ9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yICgpIHtcbiAgICBmbGFnKHRoaXMsICdjb250YWlucycsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5jbHVkZSAodmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdmFyIGV4cGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKF8udHlwZShvYmopID09PSAnYXJyYXknICYmIF8udHlwZSh2YWwpID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKF8uZXFsKG9ialtpXSwgdmFsKSkge1xuICAgICAgICAgIGV4cGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXy50eXBlKHZhbCkgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoIWZsYWcodGhpcywgJ25lZ2F0ZScpKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsKSBuZXcgQXNzZXJ0aW9uKG9iaikucHJvcGVydHkoaywgdmFsW2tdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN1YnNldCA9IHt9O1xuICAgICAgZm9yICh2YXIgayBpbiB2YWwpIHN1YnNldFtrXSA9IG9ialtrXTtcbiAgICAgIGV4cGVjdGVkID0gXy5lcWwoc3Vic2V0LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBlY3RlZCA9IG9iaiAmJiB+b2JqLmluZGV4T2YodmFsKTtcbiAgICB9XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGV4cGVjdGVkXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGluY2x1ZGUgJyArIF8uaW5zcGVjdCh2YWwpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBpbmNsdWRlICcgKyBfLmluc3BlY3QodmFsKSk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdpbmNsdWRlJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdjb250YWluJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdjb250YWlucycsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnaW5jbHVkZXMnLCBpbmNsdWRlLCBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvcik7XG5cbiAgLyoqXG4gICAqICMjIyAub2tcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgdHJ1dGh5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdldmVydGhpbmcnKS50by5iZS5vaztcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5vaztcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8ubm90LmJlLm9rO1xuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8ubm90LmJlLm9rO1xuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLm5vdC5iZS5vaztcbiAgICpcbiAgICogQG5hbWUgb2tcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdvaycsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdHJ1dGh5J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmYWxzeScpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC50cnVlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGB0cnVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh0cnVlKS50by5iZS50cnVlO1xuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS50cnVlO1xuICAgKlxuICAgKiBAbmFtZSB0cnVlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgndHJ1ZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdHJ1ZSA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdHJ1ZSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZmFsc2UnXG4gICAgICAsIHRoaXMubmVnYXRlID8gZmFsc2UgOiB0cnVlXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZmFsc2VcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYGZhbHNlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8uYmUuZmFsc2U7XG4gICAqICAgICBleHBlY3QoMCkudG8ubm90LmJlLmZhbHNlO1xuICAgKlxuICAgKiBAbmFtZSBmYWxzZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2ZhbHNlJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBmYWxzZSA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZmFsc2UnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydWUnXG4gICAgICAsIHRoaXMubmVnYXRlID8gdHJ1ZSA6IGZhbHNlXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAubnVsbFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgbnVsbGAuXG4gICAqXG4gICAqICAgICBleHBlY3QobnVsbCkudG8uYmUubnVsbDtcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLm5vdC5iZS5udWxsO1xuICAgKlxuICAgKiBAbmFtZSBudWxsXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnbnVsbCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbnVsbCA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgbnVsbCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIG51bGwnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAudW5kZWZpbmVkXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8uYmUudW5kZWZpbmVkO1xuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLm5vdC5iZS51bmRlZmluZWQ7XG4gICAqXG4gICAqIEBuYW1lIHVuZGVmaW5lZFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3VuZGVmaW5lZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdW5kZWZpbmVkID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB1bmRlZmluZWQnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSB1bmRlZmluZWQnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuTmFOXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGBOYU5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5iZS5OYU47XG4gICAqICAgICBleHBlY3QoNCkubm90LnRvLmJlLk5hTjtcbiAgICpcbiAgICogQG5hbWUgTmFOXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnTmFOJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBpc05hTihmbGFnKHRoaXMsICdvYmplY3QnKSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBOYU4nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIE5hTidcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5leGlzdFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgZm9vID0gJ2hpJ1xuICAgKiAgICAgICAsIGJhciA9IG51bGxcbiAgICogICAgICAgLCBiYXo7XG4gICAqXG4gICAqICAgICBleHBlY3QoZm9vKS50by5leGlzdDtcbiAgICogICAgIGV4cGVjdChiYXIpLnRvLm5vdC5leGlzdDtcbiAgICogICAgIGV4cGVjdChiYXopLnRvLm5vdC5leGlzdDtcbiAgICpcbiAgICogQG5hbWUgZXhpc3RcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdleGlzdCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbnVsbCAhPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBleGlzdCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGV4aXN0J1xuICAgICk7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAuZW1wdHlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQncyBsZW5ndGggaXMgYDBgLiBGb3IgYXJyYXlzIGFuZCBzdHJpbmdzLCBpdCBjaGVja3NcbiAgICogdGhlIGBsZW5ndGhgIHByb3BlcnR5LiBGb3Igb2JqZWN0cywgaXQgZ2V0cyB0aGUgY291bnQgb2ZcbiAgICogZW51bWVyYWJsZSBrZXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFtdKS50by5iZS5lbXB0eTtcbiAgICogICAgIGV4cGVjdCgnJykudG8uYmUuZW1wdHk7XG4gICAqICAgICBleHBlY3Qoe30pLnRvLmJlLmVtcHR5O1xuICAgKlxuICAgKiBAbmFtZSBlbXB0eVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2VtcHR5JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBleHBlY3RlZCA9IG9iajtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikgfHwgJ3N0cmluZycgPT09IHR5cGVvZiBvYmplY3QpIHtcbiAgICAgIGV4cGVjdGVkID0gb2JqLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICBleHBlY3RlZCA9IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAhZXhwZWN0ZWRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZW1wdHknXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBlbXB0eSdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hcmd1bWVudHNcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYW4gYXJndW1lbnRzIG9iamVjdC5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIHRlc3QgKCkge1xuICAgKiAgICAgICBleHBlY3QoYXJndW1lbnRzKS50by5iZS5hcmd1bWVudHM7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEBuYW1lIGFyZ3VtZW50c1xuICAgKiBAYWxpYXMgQXJndW1lbnRzXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNoZWNrQXJndW1lbnRzICgpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAnW29iamVjdCBBcmd1bWVudHNdJyA9PT0gdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhcmd1bWVudHMgYnV0IGdvdCAnICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYXJndW1lbnRzJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2FyZ3VtZW50cycsIGNoZWNrQXJndW1lbnRzKTtcbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdBcmd1bWVudHMnLCBjaGVja0FyZ3VtZW50cyk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXF1YWwodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IGVxdWFsIChgPT09YCkgdG8gYHZhbHVlYC5cbiAgICogQWx0ZXJuYXRlbHksIGlmIHRoZSBgZGVlcGAgZmxhZyBpcyBzZXQsIGFzc2VydHMgdGhhdFxuICAgKiB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdoZWxsbycpLnRvLmVxdWFsKCdoZWxsbycpO1xuICAgKiAgICAgZXhwZWN0KDQyKS50by5lcXVhbCg0Mik7XG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmVxdWFsKHRydWUpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5ub3QuZXF1YWwoeyBmb286ICdiYXInIH0pO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5kZWVwLmVxdWFsKHsgZm9vOiAnYmFyJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZXF1YWxcbiAgICogQGFsaWFzIGVxdWFsc1xuICAgKiBAYWxpYXMgZXFcbiAgICogQGFsaWFzIGRlZXAuZXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRFcXVhbCAodmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RlZXAnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZXFsKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHZhbCA9PT0gb2JqXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2V4cH0nXG4gICAgICAgICwgdmFsXG4gICAgICAgICwgdGhpcy5fb2JqXG4gICAgICAgICwgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcXVhbCcsIGFzc2VydEVxdWFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXF1YWxzJywgYXNzZXJ0RXF1YWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcScsIGFzc2VydEVxdWFsKTtcblxuICAvKipcbiAgICogIyMjIC5lcWwodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5lcWwoeyBmb286ICdiYXInIH0pO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5lcWwoWyAxLCAyLCAzIF0pO1xuICAgKlxuICAgKiBAbmFtZSBlcWxcbiAgICogQGFsaWFzIGVxbHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRFcWwob2JqLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgXy5lcWwob2JqLCBmbGFnKHRoaXMsICdvYmplY3QnKSlcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZGVlcGx5IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGRlZXBseSBlcXVhbCAje2V4cH0nXG4gICAgICAsIG9ialxuICAgICAgLCB0aGlzLl9vYmpcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcWwnLCBhc3NlcnRFcWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcWxzJywgYXNzZXJ0RXFsKTtcblxuICAvKipcbiAgICogIyMjIC5hYm92ZSh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZ3JlYXRlciB0aGFuIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMTApLnRvLmJlLmFib3ZlKDUpO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGxlbmd0aGAgdG9cbiAgICogYXNzZXJ0IGEgbWluaW11bSBsZW5ndGguIFRoZSBiZW5lZml0IGJlaW5nIGFcbiAgICogbW9yZSBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlIHRoYW4gaWYgdGhlIGxlbmd0aFxuICAgKiB3YXMgc3VwcGxpZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5hYm92ZSgyKTtcbiAgICpcbiAgICogQG5hbWUgYWJvdmVcbiAgICogQGFsaWFzIGd0XG4gICAqIEBhbGlhcyBncmVhdGVyVGhhblxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRBYm92ZSAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuID4gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgbGVuZ3RoIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgbGVuXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPiBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYWJvdmUgJyArIG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBtb3N0ICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2Fib3ZlJywgYXNzZXJ0QWJvdmUpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdndCcsIGFzc2VydEFib3ZlKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3JlYXRlclRoYW4nLCBhc3NlcnRBYm92ZSk7XG5cbiAgLyoqXG4gICAqICMjIyAubGVhc3QodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEwKS50by5iZS5hdC5sZWFzdCgxMCk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtaW5pbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgub2YuYXQubGVhc3QoMik7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLm9mLmF0LmxlYXN0KDMpO1xuICAgKlxuICAgKiBAbmFtZSBsZWFzdFxuICAgKiBAYWxpYXMgZ3RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydExlYXN0IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPj0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYXQgbGVhc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbGVhc3QgJyArIG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAnICsgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZWFzdCcsIGFzc2VydExlYXN0KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3RlJywgYXNzZXJ0TGVhc3QpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmJlbG93KHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBsZXNzIHRoYW4gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg1KS50by5iZS5iZWxvdygxMCk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtYXhpbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmJlbG93KDQpO1xuICAgKlxuICAgKiBAbmFtZSBiZWxvd1xuICAgKiBAYWxpYXMgbHRcbiAgICogQGFsaWFzIGxlc3NUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEJlbG93IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPCBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IGxlYXN0ICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2JlbG93JywgYXNzZXJ0QmVsb3cpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsdCcsIGFzc2VydEJlbG93KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVzc1RoYW4nLCBhc3NlcnRCZWxvdyk7XG5cbiAgLyoqXG4gICAqICMjIyAubW9zdCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoNSkudG8uYmUuYXQubW9zdCg1KTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIG1heGltdW0gbGVuZ3RoLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5vZi5hdC5tb3N0KDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5vZi5hdC5tb3N0KDMpO1xuICAgKlxuICAgKiBAbmFtZSBtb3N0XG4gICAqIEBhbGlhcyBsdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TW9zdCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuIDw9IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGF0IG1vc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbW9zdCAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFib3ZlICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21vc3QnLCBhc3NlcnRNb3N0KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbHRlJywgYXNzZXJ0TW9zdCk7XG5cbiAgLyoqXG4gICAqICMjIyAud2l0aGluKHN0YXJ0LCBmaW5pc2gpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHdpdGhpbiBhIHJhbmdlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDcpLnRvLmJlLndpdGhpbig1LDEwKTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIGxlbmd0aCByYW5nZS4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgud2l0aGluKDIsNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKlxuICAgKiBAbmFtZSB3aXRoaW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IGxvd2VyYm91bmQgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmaW5pc2ggdXBwZXJib3VuZCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd3aXRoaW4nLCBmdW5jdGlvbiAoc3RhcnQsIGZpbmlzaCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHJhbmdlID0gc3RhcnQgKyAnLi4nICsgZmluaXNoO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuID49IHN0YXJ0ICYmIGxlbiA8PSBmaW5pc2hcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhIGxlbmd0aCB3aXRoaW4gJyArIHJhbmdlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPj0gc3RhcnQgJiYgb2JqIDw9IGZpbmlzaFxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgd2l0aGluICcgKyByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluc3RhbmNlb2YoY29uc3RydWN0b3IpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIENoYWkgPSBuZXcgVGVhKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBleHBlY3QoQ2hhaSkudG8uYmUuYW4uaW5zdGFuY2VvZihUZWEpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5iZS5pbnN0YW5jZW9mKEFycmF5KTtcbiAgICpcbiAgICogQG5hbWUgaW5zdGFuY2VvZlxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhbGlhcyBpbnN0YW5jZU9mXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEluc3RhbmNlT2YgKGNvbnN0cnVjdG9yLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgbmFtZSA9IF8uZ2V0TmFtZShjb25zdHJ1Y3Rvcik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcpIGluc3RhbmNlb2YgY29uc3RydWN0b3JcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJyArIG5hbWVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFuIGluc3RhbmNlIG9mICcgKyBuYW1lXG4gICAgKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbnN0YW5jZW9mJywgYXNzZXJ0SW5zdGFuY2VPZik7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luc3RhbmNlT2YnLCBhc3NlcnRJbnN0YW5jZU9mKTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eShuYW1lLCBbdmFsdWVdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYSBwcm9wZXJ0eSBgbmFtZWAsIG9wdGlvbmFsbHkgYXNzZXJ0aW5nIHRoYXRcbiAgICogdGhlIHZhbHVlIG9mIHRoYXQgcHJvcGVydHkgaXMgc3RyaWN0bHkgZXF1YWwgdG8gIGB2YWx1ZWAuXG4gICAqIElmIHRoZSBgZGVlcGAgZmxhZyBpcyBzZXQsIHlvdSBjYW4gdXNlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXBcbiAgICogcmVmZXJlbmNlcyBpbnRvIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICpcbiAgICogICAgIC8vIHNpbXBsZSByZWZlcmVuY2luZ1xuICAgKiAgICAgdmFyIG9iaiA9IHsgZm9vOiAnYmFyJyB9O1xuICAgKiAgICAgZXhwZWN0KG9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZm9vJyk7XG4gICAqICAgICBleHBlY3Qob2JqKS50by5oYXZlLnByb3BlcnR5KCdmb28nLCAnYmFyJyk7XG4gICAqXG4gICAqICAgICAvLyBkZWVwIHJlZmVyZW5jaW5nXG4gICAqICAgICB2YXIgZGVlcE9iaiA9IHtcbiAgICogICAgICAgICBncmVlbjogeyB0ZWE6ICdtYXRjaGEnIH1cbiAgICogICAgICAgLCB0ZWFzOiBbICdjaGFpJywgJ21hdGNoYScsIHsgdGVhOiAna29uYWNoYScgfSBdXG4gICAqICAgICB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgnZ3JlZW4udGVhJywgJ21hdGNoYScpO1xuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgndGVhc1sxXScsICdtYXRjaGEnKTtcbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ3RlYXNbMl0udGVhJywgJ2tvbmFjaGEnKTtcbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgYSBgZGVlcC5wcm9wZXJ0eWBcbiAgICogYXNzZXJ0aW9uLCBvciB0cmF2ZXJzZSBuZXN0ZWQgYXJyYXlzLlxuICAgKlxuICAgKiAgICAgdmFyIGFyciA9IFtcbiAgICogICAgICAgICBbICdjaGFpJywgJ21hdGNoYScsICdrb25hY2hhJyBdXG4gICAqICAgICAgICwgWyB7IHRlYTogJ2NoYWknIH1cbiAgICogICAgICAgICAsIHsgdGVhOiAnbWF0Y2hhJyB9XG4gICAqICAgICAgICAgLCB7IHRlYTogJ2tvbmFjaGEnIH0gXVxuICAgKiAgICAgXTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhcnIpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgnWzBdWzFdJywgJ21hdGNoYScpO1xuICAgKiAgICAgZXhwZWN0KGFycikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdbMV1bMl0udGVhJywgJ2tvbmFjaGEnKTtcbiAgICpcbiAgICogRnVydGhlcm1vcmUsIGBwcm9wZXJ0eWAgY2hhbmdlcyB0aGUgc3ViamVjdCBvZiB0aGUgYXNzZXJ0aW9uXG4gICAqIHRvIGJlIHRoZSB2YWx1ZSBvZiB0aGF0IHByb3BlcnR5IGZyb20gdGhlIG9yaWdpbmFsIG9iamVjdC4gVGhpc1xuICAgKiBwZXJtaXRzIGZvciBmdXJ0aGVyIGNoYWluYWJsZSBhc3NlcnRpb25zIG9uIHRoYXQgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICBleHBlY3Qob2JqKS50by5oYXZlLnByb3BlcnR5KCdmb28nKVxuICAgKiAgICAgICAudGhhdC5pcy5hKCdzdHJpbmcnKTtcbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLnByb3BlcnR5KCdncmVlbicpXG4gICAqICAgICAgIC50aGF0LmlzLmFuKCdvYmplY3QnKVxuICAgKiAgICAgICAudGhhdC5kZWVwLmVxdWFscyh7IHRlYTogJ21hdGNoYScgfSk7XG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5wcm9wZXJ0eSgndGVhcycpXG4gICAqICAgICAgIC50aGF0LmlzLmFuKCdhcnJheScpXG4gICAqICAgICAgIC53aXRoLmRlZXAucHJvcGVydHkoJ1syXScpXG4gICAqICAgICAgICAgLnRoYXQuZGVlcC5lcXVhbHMoeyB0ZWE6ICdrb25hY2hhJyB9KTtcbiAgICpcbiAgICogTm90ZSB0aGF0IGRvdHMgYW5kIGJyYWNrZXQgaW4gYG5hbWVgIG11c3QgYmUgYmFja3NsYXNoLWVzY2FwZWQgd2hlblxuICAgKiB0aGUgYGRlZXBgIGZsYWcgaXMgc2V0LCB3aGlsZSB0aGV5IG11c3QgTk9UIGJlIGVzY2FwZWQgd2hlbiB0aGUgYGRlZXBgXG4gICAqIGZsYWcgaXMgbm90IHNldC5cbiAgICpcbiAgICogICAgIC8vIHNpbXBsZSByZWZlcmVuY2luZ1xuICAgKiAgICAgdmFyIGNzcyA9IHsgJy5saW5rW3RhcmdldF0nOiA0MiB9O1xuICAgKiAgICAgZXhwZWN0KGNzcykudG8uaGF2ZS5wcm9wZXJ0eSgnLmxpbmtbdGFyZ2V0XScsIDQyKTtcbiAgICpcbiAgICogICAgIC8vIGRlZXAgcmVmZXJlbmNpbmdcbiAgICogICAgIHZhciBkZWVwQ3NzID0geyAnLmxpbmsnOiB7ICdbdGFyZ2V0XSc6IDQyIH19O1xuICAgKiAgICAgZXhwZWN0KGRlZXBDc3MpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgnXFxcXC5saW5rLlxcXFxbdGFyZ2V0XFxcXF0nLCA0Mik7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBhbGlhcyBkZWVwLnByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIChvcHRpb25hbClcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAcmV0dXJucyB2YWx1ZSBvZiBwcm9wZXJ0eSBmb3IgY2hhaW5pbmdcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncHJvcGVydHknLCBmdW5jdGlvbiAobmFtZSwgdmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciBpc0RlZXAgPSAhIWZsYWcodGhpcywgJ2RlZXAnKVxuICAgICAgLCBkZXNjcmlwdG9yID0gaXNEZWVwID8gJ2RlZXAgcHJvcGVydHkgJyA6ICdwcm9wZXJ0eSAnXG4gICAgICAsIG5lZ2F0ZSA9IGZsYWcodGhpcywgJ25lZ2F0ZScpXG4gICAgICAsIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHBhdGhJbmZvID0gaXNEZWVwID8gXy5nZXRQYXRoSW5mbyhuYW1lLCBvYmopIDogbnVsbFxuICAgICAgLCBoYXNQcm9wZXJ0eSA9IGlzRGVlcFxuICAgICAgICA/IHBhdGhJbmZvLmV4aXN0c1xuICAgICAgICA6IF8uaGFzUHJvcGVydHkobmFtZSwgb2JqKVxuICAgICAgLCB2YWx1ZSA9IGlzRGVlcFxuICAgICAgICA/IHBhdGhJbmZvLnZhbHVlXG4gICAgICAgIDogb2JqW25hbWVdO1xuXG4gICAgaWYgKG5lZ2F0ZSAmJiBhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdmFsdWUpIHtcbiAgICAgICAgbXNnID0gKG1zZyAhPSBudWxsKSA/IG1zZyArICc6ICcgOiAnJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyArIF8uaW5zcGVjdChvYmopICsgJyBoYXMgbm8gJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBoYXNQcm9wZXJ0eVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHZhbCA9PT0gdmFsdWVcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9mICN7ZXhwfSwgYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSArICcgb2YgI3thY3R9J1xuICAgICAgICAsIHZhbFxuICAgICAgICAsIHZhbHVlXG4gICAgICApO1xuICAgIH1cblxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHZhbHVlKTtcbiAgfSk7XG5cblxuICAvKipcbiAgICogIyMjIC5vd25Qcm9wZXJ0eShuYW1lKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYW4gb3duIHByb3BlcnR5IGBuYW1lYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLnRvLmhhdmUub3duUHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgKlxuICAgKiBAbmFtZSBvd25Qcm9wZXJ0eVxuICAgKiBAYWxpYXMgaGF2ZU93blByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0T3duUHJvcGVydHkgKG5hbWUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgb2JqLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgb3duIHByb3BlcnR5ICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgb3duIHByb3BlcnR5ICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnb3duUHJvcGVydHknLCBhc3NlcnRPd25Qcm9wZXJ0eSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2hhdmVPd25Qcm9wZXJ0eScsIGFzc2VydE93blByb3BlcnR5KTtcblxuICAvKipcbiAgICogIyMjIC5vd25Qcm9wZXJ0eURlc2NyaXB0b3IobmFtZVssIGRlc2NyaXB0b3JbLCBtZXNzYWdlXV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhbiBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBgbmFtZWAsIHRoYXQgb3B0aW9uYWxseSBtYXRjaGVzIGBkZXNjcmlwdG9yYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdsZW5ndGgnKTtcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdsZW5ndGgnLCB7IGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiA0IH0pO1xuICAgKiAgICAgZXhwZWN0KCd0ZXN0Jykubm90LnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdsZW5ndGgnLCB7IGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiAzIH0pO1xuICAgKiAgICAgZXhwZWN0KCd0ZXN0Jykub3duUHJvcGVydHlEZXNjcmlwdG9yKCdsZW5ndGgnKS50by5oYXZlLnByb3BlcnR5KCdlbnVtZXJhYmxlJywgZmFsc2UpO1xuICAgKiAgICAgZXhwZWN0KCd0ZXN0Jykub3duUHJvcGVydHlEZXNjcmlwdG9yKCdsZW5ndGgnKS50by5oYXZlLmtleXMoJ3ZhbHVlJyk7XG4gICAqXG4gICAqIEBuYW1lIG93blByb3BlcnR5RGVzY3JpcHRvclxuICAgKiBAYWxpYXMgaGF2ZU93blByb3BlcnR5RGVzY3JpcHRvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvciBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0T3duUHJvcGVydHlEZXNjcmlwdG9yIChuYW1lLCBkZXNjcmlwdG9yLCBtc2cpIHtcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtc2cgPSBkZXNjcmlwdG9yO1xuICAgICAgZGVzY3JpcHRvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB2YXIgYWN0dWFsRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0KG9iaiksIG5hbWUpO1xuICAgIGlmIChhY3R1YWxEZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIF8uZXFsKGRlc2NyaXB0b3IsIGFjdHVhbERlc2NyaXB0b3IpXG4gICAgICAgICwgJ2V4cGVjdGVkIHRoZSBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKSArICcgb24gI3t0aGlzfSB0byBtYXRjaCAnICsgXy5pbnNwZWN0KGRlc2NyaXB0b3IpICsgJywgZ290ICcgKyBfLmluc3BlY3QoYWN0dWFsRGVzY3JpcHRvcilcbiAgICAgICAgLCAnZXhwZWN0ZWQgdGhlIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciAnICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvbiAje3RoaXN9IHRvIG5vdCBtYXRjaCAnICsgXy5pbnNwZWN0KGRlc2NyaXB0b3IpXG4gICAgICAgICwgZGVzY3JpcHRvclxuICAgICAgICAsIGFjdHVhbERlc2NyaXB0b3JcbiAgICAgICAgLCB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBhY3R1YWxEZXNjcmlwdG9yXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhbiBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGFuIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgICApO1xuICAgIH1cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBhY3R1YWxEZXNjcmlwdG9yKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ293blByb3BlcnR5RGVzY3JpcHRvcicsIGFzc2VydE93blByb3BlcnR5RGVzY3JpcHRvcik7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2hhdmVPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBhc3NlcnRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlbmd0aFxuICAgKlxuICAgKiBTZXRzIHRoZSBgZG9MZW5ndGhgIGZsYWcgbGF0ZXIgdXNlZCBhcyBhIGNoYWluIHByZWN1cnNvciB0byBhIHZhbHVlXG4gICAqIGNvbXBhcmlzb24gZm9yIHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5iZWxvdyg0KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC53aXRoaW4oMiw0KTtcbiAgICpcbiAgICogKkRlcHJlY2F0aW9uIG5vdGljZToqIFVzaW5nIGBsZW5ndGhgIGFzIGFuIGFzc2VydGlvbiB3aWxsIGJlIGRlcHJlY2F0ZWRcbiAgICogaW4gdmVyc2lvbiAyLjQuMCBhbmQgcmVtb3ZlZCBpbiAzLjAuMC4gQ29kZSB1c2luZyB0aGUgb2xkIHN0eWxlIG9mXG4gICAqIGFzc2VydGluZyBmb3IgYGxlbmd0aGAgcHJvcGVydHkgdmFsdWUgdXNpbmcgYGxlbmd0aCh2YWx1ZSlgIHNob3VsZCBiZVxuICAgKiBzd2l0Y2hlZCB0byB1c2UgYGxlbmd0aE9mKHZhbHVlKWAgaW5zdGVhZC5cbiAgICpcbiAgICogQG5hbWUgbGVuZ3RoXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlbmd0aE9mKHZhbHVlWywgbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgaGFzXG4gICAqIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpO1xuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5oYXZlLmxlbmd0aE9mKDYpO1xuICAgKlxuICAgKiBAbmFtZSBsZW5ndGhPZlxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVuZ3RoQ2hhaW4gKCkge1xuICAgIGZsYWcodGhpcywgJ2RvTGVuZ3RoJywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRMZW5ndGggKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBsZW4gPT0gblxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIG9mICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggb2YgI3thY3R9J1xuICAgICAgLCBuXG4gICAgICAsIGxlblxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdsZW5ndGgnLCBhc3NlcnRMZW5ndGgsIGFzc2VydExlbmd0aENoYWluKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVuZ3RoT2YnLCBhc3NlcnRMZW5ndGgpO1xuXG4gIC8qKlxuICAgKiAjIyMgLm1hdGNoKHJlZ2V4cClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgbWF0Y2hlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubWF0Y2goL15mb28vKTtcbiAgICpcbiAgICogQG5hbWUgbWF0Y2hcbiAgICogQGFsaWFzIG1hdGNoZXNcbiAgICogQHBhcmFtIHtSZWdFeHB9IFJlZ3VsYXJFeHByZXNzaW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIGFzc2VydE1hdGNoKHJlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlLmV4ZWMob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBtYXRjaCAnICsgcmVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIG1hdGNoICcgKyByZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtYXRjaCcsIGFzc2VydE1hdGNoKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWF0Y2hlcycsIGFzc2VydE1hdGNoKTtcblxuICAvKipcbiAgICogIyMjIC5zdHJpbmcoc3RyaW5nKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHN0cmluZyB0YXJnZXQgY29udGFpbnMgYW5vdGhlciBzdHJpbmcuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmhhdmUuc3RyaW5nKCdiYXInKTtcbiAgICpcbiAgICogQG5hbWUgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzdHJpbmcnLCBmdW5jdGlvbiAoc3RyLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykuaXMuYSgnc3RyaW5nJyk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgfm9iai5pbmRleE9mKHN0cilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gY29udGFpbiAnICsgXy5pbnNwZWN0KHN0cilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGNvbnRhaW4gJyArIF8uaW5zcGVjdChzdHIpXG4gICAgKTtcbiAgfSk7XG5cblxuICAvKipcbiAgICogIyMjIC5rZXlzKGtleTEsIFtrZXkyXSwgWy4uLl0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGNvbnRhaW5zIGFueSBvciBhbGwgb2YgdGhlIHBhc3NlZC1pbiBrZXlzLlxuICAgKiBVc2UgaW4gY29tYmluYXRpb24gd2l0aCBgYW55YCwgYGFsbGAsIGBjb250YWluc2AsIG9yIGBoYXZlYCB3aWxsIGFmZmVjdFxuICAgKiB3aGF0IHdpbGwgcGFzcy5cbiAgICpcbiAgICogV2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGFueWAsIGF0IGxlYXN0IG9uZSBrZXkgdGhhdCBpcyBwYXNzZWRcbiAgICogaW4gbXVzdCBleGlzdCBpbiB0aGUgdGFyZ2V0IG9iamVjdC4gVGhpcyBpcyByZWdhcmRsZXNzIHdoZXRoZXIgb3Igbm90XG4gICAqIHRoZSBgaGF2ZWAgb3IgYGNvbnRhaW5gIHF1YWxpZmllcnMgYXJlIHVzZWQuIE5vdGUsIGVpdGhlciBgYW55YCBvciBgYWxsYFxuICAgKiBzaG91bGQgYmUgdXNlZCBpbiB0aGUgYXNzZXJ0aW9uLiBJZiBuZWl0aGVyIGFyZSB1c2VkLCB0aGUgYXNzZXJ0aW9uIGlzXG4gICAqIGRlZmF1bHRlZCB0byBgYWxsYC5cbiAgICpcbiAgICogV2hlbiBib3RoIGBhbGxgIGFuZCBgY29udGFpbmAgYXJlIHVzZWQsIHRoZSB0YXJnZXQgb2JqZWN0IG11c3QgaGF2ZSBhdFxuICAgKiBsZWFzdCBhbGwgb2YgdGhlIHBhc3NlZC1pbiBrZXlzIGJ1dCBtYXkgaGF2ZSBtb3JlIGtleXMgbm90IGxpc3RlZC5cbiAgICpcbiAgICogV2hlbiBib3RoIGBhbGxgIGFuZCBgaGF2ZWAgYXJlIHVzZWQsIHRoZSB0YXJnZXQgb2JqZWN0IG11c3QgYm90aCBjb250YWluXG4gICAqIGFsbCBvZiB0aGUgcGFzc2VkLWluIGtleXMgQU5EIHRoZSBudW1iZXIgb2Yga2V5cyBpbiB0aGUgdGFyZ2V0IG9iamVjdCBtdXN0XG4gICAqIG1hdGNoIHRoZSBudW1iZXIgb2Yga2V5cyBwYXNzZWQgaW4gKGluIG90aGVyIHdvcmRzLCBhIHRhcmdldCBvYmplY3QgbXVzdFxuICAgKiBoYXZlIGFsbCBhbmQgb25seSBhbGwgb2YgdGhlIHBhc3NlZC1pbiBrZXlzKS5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyIH0pLnRvLmhhdmUuYW55LmtleXMoJ2ZvbycsICdiYXonKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyIH0pLnRvLmhhdmUuYW55LmtleXMoJ2ZvbycpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAxLCBiYXI6IDIgfSkudG8uY29udGFpbi5hbnkua2V5cygnYmFyJywgJ2JheicpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAxLCBiYXI6IDIgfSkudG8uY29udGFpbi5hbnkua2V5cyhbJ2ZvbyddKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyIH0pLnRvLmNvbnRhaW4uYW55LmtleXMoeydmb28nOiA2fSk7XG4gICAqICAgICBleHBlY3QoeyBmb286IDEsIGJhcjogMiB9KS50by5oYXZlLmFsbC5rZXlzKFsnYmFyJywgJ2ZvbyddKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyIH0pLnRvLmhhdmUuYWxsLmtleXMoeydiYXInOiA2LCAnZm9vJzogN30pO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAxLCBiYXI6IDIsIGJhejogMyB9KS50by5jb250YWluLmFsbC5rZXlzKFsnYmFyJywgJ2ZvbyddKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyLCBiYXo6IDMgfSkudG8uY29udGFpbi5hbGwua2V5cyh7J2Jhcic6IDZ9KTtcbiAgICpcbiAgICpcbiAgICogQG5hbWUga2V5c1xuICAgKiBAYWxpYXMga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nLi4ufEFycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRLZXlzIChrZXlzKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHN0clxuICAgICAgLCBvayA9IHRydWVcbiAgICAgICwgbWl4ZWRBcmdzTXNnID0gJ2tleXMgbXVzdCBiZSBnaXZlbiBzaW5nbGUgYXJndW1lbnQgb2YgQXJyYXl8T2JqZWN0fFN0cmluZywgb3IgbXVsdGlwbGUgU3RyaW5nIGFyZ3VtZW50cyc7XG5cbiAgICBzd2l0Y2ggKF8udHlwZShrZXlzKSkge1xuICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgdGhyb3cgKG5ldyBFcnJvcihtaXhlZEFyZ3NNc2cpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgdGhyb3cgKG5ldyBFcnJvcihtaXhlZEFyZ3NNc2cpKTtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGtleXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGtleXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGlmICgha2V5cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcigna2V5cyByZXF1aXJlZCcpO1xuXG4gICAgdmFyIGFjdHVhbCA9IE9iamVjdC5rZXlzKG9iailcbiAgICAgICwgZXhwZWN0ZWQgPSBrZXlzXG4gICAgICAsIGxlbiA9IGtleXMubGVuZ3RoXG4gICAgICAsIGFueSA9IGZsYWcodGhpcywgJ2FueScpXG4gICAgICAsIGFsbCA9IGZsYWcodGhpcywgJ2FsbCcpO1xuXG4gICAgaWYgKCFhbnkgJiYgIWFsbCkge1xuICAgICAgYWxsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBIYXMgYW55XG4gICAgaWYgKGFueSkge1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGV4cGVjdGVkLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIH5hY3R1YWwuaW5kZXhPZihrZXkpO1xuICAgICAgfSk7XG4gICAgICBvayA9IGludGVyc2VjdGlvbi5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8vIEhhcyBhbGxcbiAgICBpZiAoYWxsKSB7XG4gICAgICBvayA9IGtleXMuZXZlcnkoZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgcmV0dXJuIH5hY3R1YWwuaW5kZXhPZihrZXkpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWZsYWcodGhpcywgJ25lZ2F0ZScpICYmICFmbGFnKHRoaXMsICdjb250YWlucycpKSB7XG4gICAgICAgIG9rID0gb2sgJiYga2V5cy5sZW5ndGggPT0gYWN0dWFsLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBLZXkgc3RyaW5nXG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgIGtleXMgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpe1xuICAgICAgICByZXR1cm4gXy5pbnNwZWN0KGtleSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0ga2V5cy5wb3AoKTtcbiAgICAgIGlmIChhbGwpIHtcbiAgICAgICAgc3RyID0ga2V5cy5qb2luKCcsICcpICsgJywgYW5kICcgKyBsYXN0O1xuICAgICAgfVxuICAgICAgaWYgKGFueSkge1xuICAgICAgICBzdHIgPSBrZXlzLmpvaW4oJywgJykgKyAnLCBvciAnICsgbGFzdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gXy5pbnNwZWN0KGtleXNbMF0pO1xuICAgIH1cblxuICAgIC8vIEZvcm1cbiAgICBzdHIgPSAobGVuID4gMSA/ICdrZXlzICcgOiAna2V5ICcpICsgc3RyO1xuXG4gICAgLy8gSGF2ZSAvIGluY2x1ZGVcbiAgICBzdHIgPSAoZmxhZyh0aGlzLCAnY29udGFpbnMnKSA/ICdjb250YWluICcgOiAnaGF2ZSAnKSArIHN0cjtcblxuICAgIC8vIEFzc2VydGlvblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBva1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byAnICsgc3RyXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCAnICsgc3RyXG4gICAgICAsIGV4cGVjdGVkLnNsaWNlKDApLnNvcnQoKVxuICAgICAgLCBhY3R1YWwuc29ydCgpXG4gICAgICAsIHRydWVcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgna2V5cycsIGFzc2VydEtleXMpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdrZXknLCBhc3NlcnRLZXlzKTtcblxuICAvKipcbiAgICogIyMjIC50aHJvdyhjb25zdHJ1Y3RvcilcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSBmdW5jdGlvbiB0YXJnZXQgd2lsbCB0aHJvdyBhIHNwZWNpZmljIGVycm9yLCBvciBzcGVjaWZpYyB0eXBlIG9mIGVycm9yXG4gICAqIChhcyBkZXRlcm1pbmVkIHVzaW5nIGBpbnN0YW5jZW9mYCksIG9wdGlvbmFsbHkgd2l0aCBhIFJlZ0V4cCBvciBzdHJpbmcgaW5jbHVzaW9uIHRlc3RcbiAgICogZm9yIHRoZSBlcnJvcidzIG1lc3NhZ2UuXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IFJlZmVyZW5jZUVycm9yKCdUaGlzIGlzIGEgYmFkIGZ1bmN0aW9uLicpO1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH1cbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coUmVmZXJlbmNlRXJyb3IpO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhFcnJvcik7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KC9iYWQgZnVuY3Rpb24vKTtcbiAgICogICAgIGV4cGVjdChmbikudG8ubm90LnRocm93KCdnb29kIGZ1bmN0aW9uJyk7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KFJlZmVyZW5jZUVycm9yLCAvYmFkIGZ1bmN0aW9uLyk7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KGVycik7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLm5vdC50aHJvdyhuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlLicpKTtcbiAgICpcbiAgICogUGxlYXNlIG5vdGUgdGhhdCB3aGVuIGEgdGhyb3cgZXhwZWN0YXRpb24gaXMgbmVnYXRlZCwgaXQgd2lsbCBjaGVjayBlYWNoXG4gICAqIHBhcmFtZXRlciBpbmRlcGVuZGVudGx5LCBzdGFydGluZyB3aXRoIGVycm9yIGNvbnN0cnVjdG9yIHR5cGUuIFRoZSBhcHByb3ByaWF0ZSB3YXlcbiAgICogdG8gY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYSB0eXBlIG9mIGVycm9yIGJ1dCBmb3IgYSBtZXNzYWdlIHRoYXQgZG9lcyBub3QgbWF0Y2hcbiAgICogaXMgdG8gdXNlIGBhbmRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhSZWZlcmVuY2VFcnJvcilcbiAgICogICAgICAgIC5hbmQubm90LnRocm93KC9nb29kIGZ1bmN0aW9uLyk7XG4gICAqXG4gICAqIEBuYW1lIHRocm93XG4gICAqIEBhbGlhcyB0aHJvd3NcbiAgICogQGFsaWFzIFRocm93XG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBleHBlY3RlZCBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgKiBAcmV0dXJucyBlcnJvciBmb3IgY2hhaW5pbmcgKG51bGwgaWYgbm8gZXJyb3IpXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydFRocm93cyAoY29uc3RydWN0b3IsIGVyck1zZywgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgdGhyb3duID0gZmFsc2VcbiAgICAgICwgZGVzaXJlZEVycm9yID0gbnVsbFxuICAgICAgLCBuYW1lID0gbnVsbFxuICAgICAgLCB0aHJvd25FcnJvciA9IG51bGw7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZXJyTXNnID0gbnVsbDtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIFJlZ0V4cCB8fCAnc3RyaW5nJyA9PT0gdHlwZW9mIGNvbnN0cnVjdG9yKSkge1xuICAgICAgZXJyTXNnID0gY29uc3RydWN0b3I7XG4gICAgICBjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBkZXNpcmVkRXJyb3IgPSBjb25zdHJ1Y3RvcjtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgIGVyck1zZyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5hbWUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGUubmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgaWYgKG5hbWUgPT09ICdFcnJvcicgJiYgY29uc3RydWN0b3IgIT09IEVycm9yKSB7XG4gICAgICAgIG5hbWUgPSAobmV3IGNvbnN0cnVjdG9yKCkpLm5hbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgb2JqKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBmaXJzdCwgY2hlY2sgZGVzaXJlZCBlcnJvclxuICAgICAgaWYgKGRlc2lyZWRFcnJvcikge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIGVyciA9PT0gZGVzaXJlZEVycm9yXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfSdcbiAgICAgICAgICAsIChkZXNpcmVkRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGRlc2lyZWRFcnJvci50b1N0cmluZygpIDogZGVzaXJlZEVycm9yKVxuICAgICAgICAgICwgKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLnRvU3RyaW5nKCkgOiBlcnIpXG4gICAgICAgICk7XG5cbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIG5leHQsIGNoZWNrIGNvbnN0cnVjdG9yXG4gICAgICBpZiAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvclxuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICwgbmFtZVxuICAgICAgICAgICwgKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLnRvU3RyaW5nKCkgOiBlcnIpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFlcnJNc2cpIHtcbiAgICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5leHQsIGNoZWNrIG1lc3NhZ2VcbiAgICAgIHZhciBtZXNzYWdlID0gJ2Vycm9yJyA9PT0gXy50eXBlKGVycikgJiYgXCJtZXNzYWdlXCIgaW4gZXJyXG4gICAgICAgID8gZXJyLm1lc3NhZ2VcbiAgICAgICAgOiAnJyArIGVycjtcblxuICAgICAgaWYgKChtZXNzYWdlICE9IG51bGwpICYmIGVyck1zZyAmJiBlcnJNc2cgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBlcnJNc2cuZXhlYyhtZXNzYWdlKVxuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3IgbWF0Y2hpbmcgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3Igbm90IG1hdGNoaW5nICN7ZXhwfSdcbiAgICAgICAgICAsIGVyck1zZ1xuICAgICAgICAgICwgbWVzc2FnZVxuICAgICAgICApO1xuXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGVycik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmICgobWVzc2FnZSAhPSBudWxsKSAmJiBlcnJNc2cgJiYgJ3N0cmluZycgPT09IHR5cGVvZiBlcnJNc2cpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICB+bWVzc2FnZS5pbmRleE9mKGVyck1zZylcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIGluY2x1ZGluZyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciBub3QgaW5jbHVkaW5nICN7YWN0fSdcbiAgICAgICAgICAsIGVyck1zZ1xuICAgICAgICAgICwgbWVzc2FnZVxuICAgICAgICApO1xuXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGVycik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3duID0gdHJ1ZTtcbiAgICAgICAgdGhyb3duRXJyb3IgPSBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFjdHVhbGx5R290ID0gJydcbiAgICAgICwgZXhwZWN0ZWRUaHJvd24gPSBuYW1lICE9PSBudWxsXG4gICAgICAgID8gbmFtZVxuICAgICAgICA6IGRlc2lyZWRFcnJvclxuICAgICAgICAgID8gJyN7ZXhwfScgLy9fLmluc3BlY3QoZGVzaXJlZEVycm9yKVxuICAgICAgICAgIDogJ2FuIGVycm9yJztcblxuICAgIGlmICh0aHJvd24pIHtcbiAgICAgIGFjdHVhbGx5R290ID0gJyBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHRocm93biA9PT0gdHJ1ZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAnICsgZXhwZWN0ZWRUaHJvd24gKyBhY3R1YWxseUdvdFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgJyArIGV4cGVjdGVkVGhyb3duICsgYWN0dWFsbHlHb3RcbiAgICAgICwgKGRlc2lyZWRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZGVzaXJlZEVycm9yLnRvU3RyaW5nKCkgOiBkZXNpcmVkRXJyb3IpXG4gICAgICAsICh0aHJvd25FcnJvciBpbnN0YW5jZW9mIEVycm9yID8gdGhyb3duRXJyb3IudG9TdHJpbmcoKSA6IHRocm93bkVycm9yKVxuICAgICk7XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCB0aHJvd25FcnJvcik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGhyb3cnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd0aHJvd3MnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdUaHJvdycsIGFzc2VydFRocm93cyk7XG5cbiAgLyoqXG4gICAqICMjIyAucmVzcG9uZFRvKG1ldGhvZClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSBvYmplY3Qgb3IgY2xhc3MgdGFyZ2V0IHdpbGwgcmVzcG9uZCB0byBhIG1ldGhvZC5cbiAgICpcbiAgICogICAgIEtsYXNzLnByb3RvdHlwZS5iYXIgPSBmdW5jdGlvbigpe307XG4gICAqICAgICBleHBlY3QoS2xhc3MpLnRvLnJlc3BvbmRUbygnYmFyJyk7XG4gICAqICAgICBleHBlY3Qob2JqKS50by5yZXNwb25kVG8oJ2JhcicpO1xuICAgKlxuICAgKiBUbyBjaGVjayBpZiBhIGNvbnN0cnVjdG9yIHdpbGwgcmVzcG9uZCB0byBhIHN0YXRpYyBmdW5jdGlvbixcbiAgICogc2V0IHRoZSBgaXRzZWxmYCBmbGFnLlxuICAgKlxuICAgKiAgICAgS2xhc3MuYmF6ID0gZnVuY3Rpb24oKXt9O1xuICAgKiAgICAgZXhwZWN0KEtsYXNzKS5pdHNlbGYudG8ucmVzcG9uZFRvKCdiYXonKTtcbiAgICpcbiAgICogQG5hbWUgcmVzcG9uZFRvXG4gICAqIEBhbGlhcyByZXNwb25kc1RvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiByZXNwb25kVG8gKG1ldGhvZCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGl0c2VsZiA9IGZsYWcodGhpcywgJ2l0c2VsZicpXG4gICAgICAsIGNvbnRleHQgPSAoJ2Z1bmN0aW9uJyA9PT0gXy50eXBlKG9iaikgJiYgIWl0c2VsZilcbiAgICAgICAgPyBvYmoucHJvdG90eXBlW21ldGhvZF1cbiAgICAgICAgOiBvYmpbbWV0aG9kXTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAnZnVuY3Rpb24nID09PSB0eXBlb2YgY29udGV4dFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byByZXNwb25kIHRvICcgKyBfLmluc3BlY3QobWV0aG9kKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgcmVzcG9uZCB0byAnICsgXy5pbnNwZWN0KG1ldGhvZClcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncmVzcG9uZFRvJywgcmVzcG9uZFRvKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncmVzcG9uZHNUbycsIHJlc3BvbmRUbyk7XG5cbiAgLyoqXG4gICAqICMjIyAuaXRzZWxmXG4gICAqXG4gICAqIFNldHMgdGhlIGBpdHNlbGZgIGZsYWcsIGxhdGVyIHVzZWQgYnkgdGhlIGByZXNwb25kVG9gIGFzc2VydGlvbi5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIEZvbygpIHt9XG4gICAqICAgICBGb28uYmFyID0gZnVuY3Rpb24oKSB7fVxuICAgKiAgICAgRm9vLnByb3RvdHlwZS5iYXogPSBmdW5jdGlvbigpIHt9XG4gICAqXG4gICAqICAgICBleHBlY3QoRm9vKS5pdHNlbGYudG8ucmVzcG9uZFRvKCdiYXInKTtcbiAgICogICAgIGV4cGVjdChGb28pLml0c2VsZi5ub3QudG8ucmVzcG9uZFRvKCdiYXonKTtcbiAgICpcbiAgICogQG5hbWUgaXRzZWxmXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnaXRzZWxmJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ2l0c2VsZicsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5zYXRpc2Z5KG1ldGhvZClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgcGFzc2VzIGEgZ2l2ZW4gdHJ1dGggdGVzdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5zYXRpc2Z5KGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtID4gMDsgfSk7XG4gICAqXG4gICAqIEBuYW1lIHNhdGlzZnlcbiAgICogQGFsaWFzIHNhdGlzZmllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtYXRjaGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gc2F0aXNmeSAobWF0Y2hlciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHZhciByZXN1bHQgPSBtYXRjaGVyKG9iaik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlc3VsdFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBzYXRpc2Z5ICcgKyBfLm9iakRpc3BsYXkobWF0Y2hlcilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHNhdGlzZnknICsgXy5vYmpEaXNwbGF5KG1hdGNoZXIpXG4gICAgICAsIHRoaXMubmVnYXRlID8gZmFsc2UgOiB0cnVlXG4gICAgICAsIHJlc3VsdFxuICAgICk7XG4gIH1cbiAgXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3NhdGlzZnknLCBzYXRpc2Z5KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc2F0aXNmaWVzJywgc2F0aXNmeSk7XG5cbiAgLyoqXG4gICAqICMjIyAuY2xvc2VUbyhleHBlY3RlZCwgZGVsdGEpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIGBleHBlY3RlZGAsIHRvIHdpdGhpbiBhICsvLSBgZGVsdGFgIHJhbmdlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uYmUuY2xvc2VUbygxLCAwLjUpO1xuICAgKlxuICAgKiBAbmFtZSBjbG9zZVRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdjbG9zZVRvJywgZnVuY3Rpb24gKGV4cGVjdGVkLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykuaXMuYSgnbnVtYmVyJyk7XG4gICAgaWYgKF8udHlwZShleHBlY3RlZCkgIT09ICdudW1iZXInIHx8IF8udHlwZShkZWx0YSkgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBhcmd1bWVudHMgdG8gY2xvc2VUbyBtdXN0IGJlIG51bWJlcnMnKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgTWF0aC5hYnMob2JqIC0gZXhwZWN0ZWQpIDw9IGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGNsb3NlIHRvICcgKyBleHBlY3RlZCArICcgKy8tICcgKyBkZWx0YVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgY2xvc2UgdG8gJyArIGV4cGVjdGVkICsgJyArLy0gJyArIGRlbHRhXG4gICAgKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gaXNTdWJzZXRPZihzdWJzZXQsIHN1cGVyc2V0LCBjbXApIHtcbiAgICByZXR1cm4gc3Vic2V0LmV2ZXJ5KGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIGlmICghY21wKSByZXR1cm4gc3VwZXJzZXQuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG5cbiAgICAgIHJldHVybiBzdXBlcnNldC5zb21lKGZ1bmN0aW9uKGVsZW0yKSB7XG4gICAgICAgIHJldHVybiBjbXAoZWxlbSwgZWxlbTIpO1xuICAgICAgfSk7XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm1lbWJlcnMoc2V0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIHN1cGVyc2V0IG9mIGBzZXRgLFxuICAgKiBvciB0aGF0IHRoZSB0YXJnZXQgYW5kIGBzZXRgIGhhdmUgdGhlIHNhbWUgc3RyaWN0bHktZXF1YWwgKD09PSkgbWVtYmVycy5cbiAgICogQWx0ZXJuYXRlbHksIGlmIHRoZSBgZGVlcGAgZmxhZyBpcyBzZXQsIHNldCBtZW1iZXJzIGFyZSBjb21wYXJlZCBmb3IgZGVlcFxuICAgKiBlcXVhbGl0eS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUubWVtYmVycyhbMywgMl0pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8ubm90LmluY2x1ZGUubWVtYmVycyhbMywgMiwgOF0pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KFs0LCAyXSkudG8uaGF2ZS5tZW1iZXJzKFsyLCA0XSk7XG4gICAqICAgICBleHBlY3QoWzUsIDJdKS50by5ub3QuaGF2ZS5tZW1iZXJzKFs1LCAyLCAxXSk7XG4gICAqXG4gICAqICAgICBleHBlY3QoW3sgaWQ6IDEgfV0pLnRvLmRlZXAuaW5jbHVkZS5tZW1iZXJzKFt7IGlkOiAxIH1dKTtcbiAgICpcbiAgICogQG5hbWUgbWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtZW1iZXJzJywgZnVuY3Rpb24gKHN1YnNldCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgbmV3IEFzc2VydGlvbihvYmopLnRvLmJlLmFuKCdhcnJheScpO1xuICAgIG5ldyBBc3NlcnRpb24oc3Vic2V0KS50by5iZS5hbignYXJyYXknKTtcblxuICAgIHZhciBjbXAgPSBmbGFnKHRoaXMsICdkZWVwJykgPyBfLmVxbCA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChmbGFnKHRoaXMsICdjb250YWlucycpKSB7XG4gICAgICByZXR1cm4gdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaXNTdWJzZXRPZihzdWJzZXQsIG9iaiwgY21wKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGEgc3VwZXJzZXQgb2YgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhIHN1cGVyc2V0IG9mICN7YWN0fSdcbiAgICAgICAgLCBvYmpcbiAgICAgICAgLCBzdWJzZXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGlzU3Vic2V0T2Yob2JqLCBzdWJzZXQsIGNtcCkgJiYgaXNTdWJzZXRPZihzdWJzZXQsIG9iaiwgY21wKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgdGhlIHNhbWUgbWVtYmVycyBhcyAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgdGhlIHNhbWUgbWVtYmVycyBhcyAje2FjdH0nXG4gICAgICAgICwgb2JqXG4gICAgICAgICwgc3Vic2V0XG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuY2hhbmdlKGZ1bmN0aW9uKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBjaGFuZ2VzIGFuIG9iamVjdCBwcm9wZXJ0eVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgKz0gMyB9O1xuICAgKiAgICAgdmFyIG5vQ2hhbmdlRm4gPSBmdW5jdGlvbigpIHsgcmV0dXJuICdmb28nICsgJ2Jhcic7IH1cbiAgICogICAgIGV4cGVjdChmbikudG8uY2hhbmdlKG9iaiwgJ3ZhbCcpO1xuICAgKiAgICAgZXhwZWN0KG5vQ2hhbmdGbikudG8ubm90LmNoYW5nZShvYmosICd2YWwnKVxuICAgKlxuICAgKiBAbmFtZSBjaGFuZ2VcbiAgICogQGFsaWFzIGNoYW5nZXNcbiAgICogQGFsaWFzIENoYW5nZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0Q2hhbmdlcyAob2JqZWN0LCBwcm9wLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgZm4gPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iamVjdCwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICAgIG5ldyBBc3NlcnRpb24oZm4pLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgaW5pdGlhbCA9IG9iamVjdFtwcm9wXTtcbiAgICBmbigpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpbml0aWFsICE9PSBvYmplY3RbcHJvcF1cbiAgICAgICwgJ2V4cGVjdGVkIC4nICsgcHJvcCArICcgdG8gY2hhbmdlJ1xuICAgICAgLCAnZXhwZWN0ZWQgLicgKyBwcm9wICsgJyB0byBub3QgY2hhbmdlJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdjaGFuZ2UnLCBhc3NlcnRDaGFuZ2VzKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnY2hhbmdlcycsIGFzc2VydENoYW5nZXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY3JlYXNlKGZ1bmN0aW9uKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBpbmNyZWFzZXMgYW4gb2JqZWN0IHByb3BlcnR5XG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDE1IH07XG4gICAqICAgICBleHBlY3QoZm4pLnRvLmluY3JlYXNlKG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNyZWFzZVxuICAgKiBAYWxpYXMgaW5jcmVhc2VzXG4gICAqIEBhbGlhcyBJbmNyZWFzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0SW5jcmVhc2VzIChvYmplY3QsIHByb3AsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBmbiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqZWN0LCBtc2cpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gICAgbmV3IEFzc2VydGlvbihmbikuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciBpbml0aWFsID0gb2JqZWN0W3Byb3BdO1xuICAgIGZuKCk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIG9iamVjdFtwcm9wXSAtIGluaXRpYWwgPiAwXG4gICAgICAsICdleHBlY3RlZCAuJyArIHByb3AgKyAnIHRvIGluY3JlYXNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgLicgKyBwcm9wICsgJyB0byBub3QgaW5jcmVhc2UnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2luY3JlYXNlJywgYXNzZXJ0SW5jcmVhc2VzKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnaW5jcmVhc2VzJywgYXNzZXJ0SW5jcmVhc2VzKTtcblxuICAvKipcbiAgICogIyMjIC5kZWNyZWFzZShmdW5jdGlvbilcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZGVjcmVhc2VzIGFuIG9iamVjdCBwcm9wZXJ0eVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSA1IH07XG4gICAqICAgICBleHBlY3QoZm4pLnRvLmRlY3JlYXNlKG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBkZWNyZWFzZVxuICAgKiBAYWxpYXMgZGVjcmVhc2VzXG4gICAqIEBhbGlhcyBEZWNyZWFzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RGVjcmVhc2VzIChvYmplY3QsIHByb3AsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBmbiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqZWN0LCBtc2cpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gICAgbmV3IEFzc2VydGlvbihmbikuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciBpbml0aWFsID0gb2JqZWN0W3Byb3BdO1xuICAgIGZuKCk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIG9iamVjdFtwcm9wXSAtIGluaXRpYWwgPCAwXG4gICAgICAsICdleHBlY3RlZCAuJyArIHByb3AgKyAnIHRvIGRlY3JlYXNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgLicgKyBwcm9wICsgJyB0byBub3QgZGVjcmVhc2UnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2RlY3JlYXNlJywgYXNzZXJ0RGVjcmVhc2VzKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnZGVjcmVhc2VzJywgYXNzZXJ0RGVjcmVhc2VzKTtcblxuICAvKipcbiAgICogIyMjIC5leHRlbnNpYmxlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGV4dGVuc2libGUgKGNhbiBoYXZlIG5ldyBwcm9wZXJ0aWVzIGFkZGVkIHRvIFxuICAgKiBpdCkuXG4gICAqXG4gICAqICAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAqICAgICB2YXIgc2VhbGVkT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pO1xuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHt9KS50by5iZS5leHRlbnNpYmxlO1xuICAgKiAgICAgZXhwZWN0KG5vbkV4dGVuc2libGVPYmplY3QpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICAgKiAgICAgZXhwZWN0KHNlYWxlZE9iamVjdCkudG8ubm90LmJlLmV4dGVuc2libGU7XG4gICAqICAgICBleHBlY3QoZnJvemVuT2JqZWN0KS50by5ub3QuYmUuZXh0ZW5zaWJsZTtcbiAgICpcbiAgICogQG5hbWUgZXh0ZW5zaWJsZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2V4dGVuc2libGUnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIE9iamVjdC5pc0V4dGVuc2libGUob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBleHRlbnNpYmxlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgZXh0ZW5zaWJsZSdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5zZWFsZWRcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc2VhbGVkIChjYW5ub3QgaGF2ZSBuZXcgcHJvcGVydGllcyBhZGRlZCB0byBpdFxuICAgKiBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIHJlbW92ZWQpLlxuICAgKlxuICAgKiAgICAgdmFyIHNlYWxlZE9iamVjdCA9IE9iamVjdC5zZWFsKHt9KTtcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICpcbiAgICogICAgIGV4cGVjdChzZWFsZWRPYmplY3QpLnRvLmJlLnNlYWxlZDtcbiAgICogICAgIGV4cGVjdChmcm96ZW5PYmplY3QpLnRvLmJlLnNlYWxlZDtcbiAgICogICAgIGV4cGVjdCh7fSkudG8ubm90LmJlLnNlYWxlZDtcbiAgICpcbiAgICogQG5hbWUgc2VhbGVkXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnc2VhbGVkJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBPYmplY3QuaXNTZWFsZWQob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBzZWFsZWQnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBzZWFsZWQnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZnJvemVuXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGZyb3plbiAoY2Fubm90IGhhdmUgbmV3IHByb3BlcnRpZXMgYWRkZWQgdG8gaXRcbiAgICogYW5kIGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBtb2RpZmllZCkuXG4gICAqXG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqXG4gICAqICAgICBleHBlY3QoZnJvemVuT2JqZWN0KS50by5iZS5mcm96ZW47XG4gICAqICAgICBleHBlY3Qoe30pLnRvLm5vdC5iZS5mcm96ZW47XG4gICAqXG4gICAqIEBuYW1lIGZyb3plblxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2Zyb3plbicsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgT2JqZWN0LmlzRnJvemVuKG9iailcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZnJvemVuJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgZnJvemVuJ1xuICAgICk7XG4gIH0pO1xuXG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG5cbiAgLyohXG4gICAqIENoYWkgZGVwZW5kZW5jaWVzLlxuICAgKi9cblxuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb25cbiAgICAsIGZsYWcgPSB1dGlsLmZsYWc7XG5cbiAgLyohXG4gICAqIE1vZHVsZSBleHBvcnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiAjIyMgYXNzZXJ0KGV4cHJlc3Npb24sIG1lc3NhZ2UpXG4gICAqXG4gICAqIFdyaXRlIHlvdXIgb3duIHRlc3QgZXhwcmVzc2lvbnMuXG4gICAqXG4gICAqICAgICBhc3NlcnQoJ2ZvbycgIT09ICdiYXInLCAnZm9vIGlzIG5vdCBiYXInKTtcbiAgICogICAgIGFzc2VydChBcnJheS5pc0FycmF5KFtdKSwgJ2VtcHR5IGFycmF5cyBhcmUgYXJyYXlzJyk7XG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cHJlc3Npb24gdG8gdGVzdCBmb3IgdHJ1dGhpbmVzc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSB0byBkaXNwbGF5IG9uIGVycm9yXG4gICAqIEBuYW1lIGFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB2YXIgYXNzZXJ0ID0gY2hhaS5hc3NlcnQgPSBmdW5jdGlvbiAoZXhwcmVzcywgZXJybXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKG51bGwsIG51bGwsIGNoYWkuYXNzZXJ0KTtcbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwcmVzc1xuICAgICAgLCBlcnJtc2dcbiAgICAgICwgJ1sgbmVnYXRpb24gbWVzc2FnZSB1bmF2YWlsYWJsZSBdJ1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0sIFtvcGVyYXRvcl0pXG4gICAqXG4gICAqIFRocm93IGEgZmFpbHVyZS4gTm9kZS5qcyBgYXNzZXJ0YCBtb2R1bGUtY29tcGF0aWJsZS5cbiAgICpcbiAgICogQG5hbWUgZmFpbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5mYWlsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ2Fzc2VydC5mYWlsKCknO1xuICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICwgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAsIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgIH0sIGFzc2VydC5mYWlsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc09rKG9iamVjdCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgdHJ1dGh5LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzT2soJ2V2ZXJ5dGhpbmcnLCAnZXZlcnl0aGluZyBpcyBvaycpO1xuICAgKiAgICAgYXNzZXJ0LmlzT2soZmFsc2UsICd0aGlzIHdpbGwgZmFpbCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc09rXG4gICAqIEBhbGlhcyBva1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3QgdG8gdGVzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNPayA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLmlzLm9rO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90T2sob2JqZWN0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBmYWxzeS5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdE9rKCdldmVyeXRoaW5nJywgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RPayhmYWxzZSwgJ3RoaXMgd2lsbCBwYXNzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90T2tcbiAgICogQGFsaWFzIG5vdE9rXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE9rID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykuaXMubm90Lm9rO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBub24tc3RyaWN0IGVxdWFsaXR5IChgPT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5lcXVhbCgzLCAnMycsICc9PSBjb2VyY2VzIHZhbHVlcyB0byBzdHJpbmdzJyk7XG4gICAqXG4gICAqIEBuYW1lIGVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0LmVxdWFsKTtcblxuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHAgPT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3thY3R9J1xuICAgICAgLCBleHBcbiAgICAgICwgYWN0XG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgbm9uLXN0cmljdCBpbmVxdWFsaXR5IChgIT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RFcXVhbCgzLCA0LCAndGhlc2UgbnVtYmVycyBhcmUgbm90IGVxdWFsJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0Lm5vdEVxdWFsKTtcblxuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHAgIT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3thY3R9J1xuICAgICAgLCBleHBcbiAgICAgICwgYWN0XG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgc3RyaWN0IGVxdWFsaXR5IChgPT09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgdHJ1ZSwgJ3RoZXNlIGJvb2xlYW5zIGFyZSBzdHJpY3RseSBlcXVhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBzdHJpY3RFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5lcXVhbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBzdHJpY3QgaW5lcXVhbGl0eSAoYCE9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKDMsICczJywgJ25vIGNvZXJjaW9uIGZvciBzdHJpY3QgZXF1YWxpdHknKTtcbiAgICpcbiAgICogQG5hbWUgbm90U3RyaWN0RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZykudG8ubm90LmVxdWFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBhY3R1YWxgIGlzIGRlZXBseSBlcXVhbCB0byBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBFcXVhbCh7IHRlYTogJ2dyZWVuJyB9LCB7IHRlYTogJ2dyZWVuJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5lcWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnQgdGhhdCBgYWN0dWFsYCBpcyBub3QgZGVlcGx5IGVxdWFsIHRvIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RGVlcEVxdWFsKHsgdGVhOiAnZ3JlZW4nIH0sIHsgdGVhOiAnamFzbWluZScgfSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZykudG8ubm90LmVxbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzVHJ1ZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyB0cnVlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVNlcnZlZCA9IHRydWU7XG4gICAqICAgICBhc3NlcnQuaXNUcnVlKHRlYVNlcnZlZCwgJ3RoZSB0ZWEgaGFzIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzVHJ1ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNBYm92ZSA9IGZ1bmN0aW9uICh2YWwsIGFidiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYWJvdmUoYWJ2KTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAuaXNBYm92ZSh2YWx1ZVRvQ2hlY2ssIHZhbHVlVG9CZUFib3ZlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlVG9DaGVja2AgaXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuICg+KSBgdmFsdWVUb0JlQWJvdmVgXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNBYm92ZSg1LCAyLCAnNSBpcyBzdHJpY3RseSBncmVhdGVyIHRoYW4gMicpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Fib3ZlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9DaGVja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQmVBYm92ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNCZWxvdyA9IGZ1bmN0aW9uICh2YWwsIGJsdywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYmVsb3coYmx3KTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAuaXNCZWxvdyh2YWx1ZVRvQ2hlY2ssIHZhbHVlVG9CZUJlbG93LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlVG9DaGVja2AgaXMgc3RyaWN0bHkgbGVzcyB0aGFuICg8KSBgdmFsdWVUb0JlQmVsb3dgXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNCZWxvdygzLCA2LCAnMyBpcyBzdHJpY3RseSBsZXNzIHRoYW4gNicpO1xuICAgKlxuICAgKiBAbmFtZSBpc0JlbG93XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9DaGVja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQmVCZWxvd1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNUcnVlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykuaXNbJ3RydWUnXTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0ZhbHNlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGZhbHNlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVNlcnZlZCA9IGZhbHNlO1xuICAgKiAgICAgYXNzZXJ0LmlzRmFsc2UodGVhU2VydmVkLCAnbm8gdGVhIHlldD8gaG1tLi4uJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRmFsc2VcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRmFsc2UgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pc1snZmFsc2UnXTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc051bGwodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbnVsbC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc051bGwoZXJyLCAndGhlcmUgd2FzIG5vIGVycm9yJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTnVsbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOdWxsID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXF1YWwobnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3ROdWxsKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG5vdCBudWxsLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICd0YXN0eSBjaGFpJztcbiAgICogICAgIGFzc2VydC5pc05vdE51bGwodGVhLCAnZ3JlYXQsIHRpbWUgZm9yIHRlYSEnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3ROdWxsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE51bGwgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuZXF1YWwobnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOYU5cbiAgICogQXNzZXJ0cyB0aGF0IHZhbHVlIGlzIE5hTlxuICAgKlxuICAgKiAgICBhc3NlcnQuaXNOYU4oJ2ZvbycsICdmb28gaXMgTmFOJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTmFOXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05hTiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLk5hTjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE5hTlxuICAgKiBBc3NlcnRzIHRoYXQgdmFsdWUgaXMgbm90IE5hTlxuICAgKlxuICAgKiAgICBhc3NlcnQuaXNOb3ROYU4oNCwgJzQgaXMgbm90IE5hTicpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE5hTlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgYXNzZXJ0LmlzTm90TmFOID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykubm90LnRvLmJlLk5hTjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1VuZGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciB0ZWE7XG4gICAqICAgICBhc3NlcnQuaXNVbmRlZmluZWQodGVhLCAnbm8gdGVhIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNVbmRlZmluZWRcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXF1YWwodW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0RlZmluZWQodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICdjdXAgb2YgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNEZWZpbmVkKHRlYSwgJ3RlYSBoYXMgYmVlbiBkZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRGVmaW5lZFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNEZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGdW5jdGlvbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gc2VydmVUZWEoKSB7IHJldHVybiAnY3VwIG9mIHRlYSc7IH07XG4gICAqICAgICBhc3NlcnQuaXNGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBjYW4gaGF2ZSB0ZWEgbm93Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRnVuY3Rpb25cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RnVuY3Rpb24odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBmdW5jdGlvbi5cbiAgICpcbiAgICogICAgIHZhciBzZXJ2ZVRlYSA9IFsgJ2hlYXQnLCAncG91cicsICdzaXAnIF07XG4gICAqICAgICBhc3NlcnQuaXNOb3RGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBoYXZlIGxpc3RlZCB0aGUgc3RlcHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzT2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIG9iamVjdCAoYXMgcmV2ZWFsZWQgYnlcbiAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgKS5cbiAgICpcbiAgICogICAgIHZhciBzZWxlY3Rpb24gPSB7IG5hbWU6ICdDaGFpJywgc2VydmU6ICd3aXRoIHNwaWNlcycgfTtcbiAgICogICAgIGFzc2VydC5pc09iamVjdChzZWxlY3Rpb24sICd0ZWEgc2VsZWN0aW9uIGlzIGFuIG9iamVjdCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc09iamVjdFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNPYmplY3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE9iamVjdCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhbiBvYmplY3QuXG4gICAqXG4gICAqICAgICB2YXIgc2VsZWN0aW9uID0gJ2NoYWknXG4gICAqICAgICBhc3NlcnQuaXNOb3RPYmplY3Qoc2VsZWN0aW9uLCAndGVhIHNlbGVjdGlvbiBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RPYmplY3QobnVsbCwgJ251bGwgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE9iamVjdFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RPYmplY3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSgnb2JqZWN0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNBcnJheSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBhcnJheS5cbiAgICpcbiAgICogICAgIHZhciBtZW51ID0gWyAnZ3JlZW4nLCAnY2hhaScsICdvb2xvbmcnIF07XG4gICAqICAgICBhc3NlcnQuaXNBcnJheShtZW51LCAnd2hhdCBraW5kIG9mIHRlYSBkbyB3ZSB3YW50PycpO1xuICAgKlxuICAgKiBAbmFtZSBpc0FycmF5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0FycmF5ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYW4oJ2FycmF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RBcnJheSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhbiBhcnJheS5cbiAgICpcbiAgICogICAgIHZhciBtZW51ID0gJ2dyZWVufGNoYWl8b29sb25nJztcbiAgICogICAgIGFzc2VydC5pc05vdEFycmF5KG1lbnUsICd3aGF0IGtpbmQgb2YgdGVhIGRvIHdlIHdhbnQ/Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90QXJyYXlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90QXJyYXkgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYW4oJ2FycmF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNTdHJpbmcodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gICAqXG4gICAqICAgICB2YXIgdGVhT3JkZXIgPSAnY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNTdHJpbmcodGVhT3JkZXIsICdvcmRlciBwbGFjZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNTdHJpbmdcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzU3RyaW5nID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSgnc3RyaW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RTdHJpbmcodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBzdHJpbmcuXG4gICAqXG4gICAqICAgICB2YXIgdGVhT3JkZXIgPSA0O1xuICAgKiAgICAgYXNzZXJ0LmlzTm90U3RyaW5nKHRlYU9yZGVyLCAnb3JkZXIgcGxhY2VkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90U3RyaW5nXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdFN0cmluZyA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdzdHJpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc051bWJlcih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIG51bWJlci5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gMjtcbiAgICogICAgIGFzc2VydC5pc051bWJlcihjdXBzLCAnaG93IG1hbnkgY3VwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc051bWJlclxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSgnbnVtYmVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3ROdW1iZXIodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBudW1iZXIuXG4gICAqXG4gICAqICAgICB2YXIgY3VwcyA9ICcyIGN1cHMgcGxlYXNlJztcbiAgICogICAgIGFzc2VydC5pc05vdE51bWJlcihjdXBzLCAnaG93IG1hbnkgY3VwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE51bWJlclxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3ROdW1iZXIgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSgnbnVtYmVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNCb29sZWFuKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgYm9vbGVhbi5cbiAgICpcbiAgICogICAgIHZhciB0ZWFSZWFkeSA9IHRydWVcbiAgICogICAgICAgLCB0ZWFTZXJ2ZWQgPSBmYWxzZTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pc0Jvb2xlYW4odGVhUmVhZHksICdpcyB0aGUgdGVhIHJlYWR5Jyk7XG4gICAqICAgICBhc3NlcnQuaXNCb29sZWFuKHRlYVNlcnZlZCwgJ2hhcyB0ZWEgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNCb29sZWFuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdib29sZWFuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RCb29sZWFuKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgYm9vbGVhbi5cbiAgICpcbiAgICogICAgIHZhciB0ZWFSZWFkeSA9ICd5ZXAnXG4gICAqICAgICAgICwgdGVhU2VydmVkID0gJ25vcGUnO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90Qm9vbGVhbih0ZWFSZWFkeSwgJ2lzIHRoZSB0ZWEgcmVhZHknKTtcbiAgICogICAgIGFzc2VydC5pc05vdEJvb2xlYW4odGVhU2VydmVkLCAnaGFzIHRlYSBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEJvb2xlYW5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90Qm9vbGVhbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdib29sZWFuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAudHlwZU9mKHZhbHVlLCBuYW1lLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgJ3MgdHlwZSBpcyBgbmFtZWAsIGFzIGRldGVybWluZWQgYnlcbiAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnR5cGVPZih7IHRlYTogJ2NoYWknIH0sICdvYmplY3QnLCAnd2UgaGF2ZSBhbiBvYmplY3QnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoWydjaGFpJywgJ2phc21pbmUnXSwgJ2FycmF5JywgJ3dlIGhhdmUgYW4gYXJyYXknKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoJ3RlYScsICdzdHJpbmcnLCAnd2UgaGF2ZSBhIHN0cmluZycpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZigvdGVhLywgJ3JlZ2V4cCcsICd3ZSBoYXZlIGEgcmVndWxhciBleHByZXNzaW9uJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKG51bGwsICdudWxsJywgJ3dlIGhhdmUgYSBudWxsJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKHVuZGVmaW5lZCwgJ3VuZGVmaW5lZCcsICd3ZSBoYXZlIGFuIHVuZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSB0eXBlT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnR5cGVPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90VHlwZU9mKHZhbHVlLCBuYW1lLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgJ3MgdHlwZSBpcyBfbm90XyBgbmFtZWAsIGFzIGRldGVybWluZWQgYnlcbiAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFR5cGVPZigndGVhJywgJ251bWJlcicsICdzdHJpbmdzIGFyZSBub3QgbnVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RUeXBlT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVvZiBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RUeXBlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pbnN0YW5jZU9mKG9iamVjdCwgY29uc3RydWN0b3IsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgY2hhaSA9IG5ldyBUZWEoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pbnN0YW5jZU9mKGNoYWksIFRlYSwgJ2NoYWkgaXMgYW4gaW5zdGFuY2Ugb2YgdGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIGluc3RhbmNlT2ZcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5zdGFuY2VPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmluc3RhbmNlT2YodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5zdGFuY2VPZihvYmplY3QsIGNvbnN0cnVjdG9yLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgY2hhaSA9IG5ldyBTdHJpbmcoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbnN0YW5jZU9mKGNoYWksIFRlYSwgJ2NoYWkgaXMgbm90IGFuIGluc3RhbmNlIG9mIHRlYScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbnN0YW5jZU9mXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluc3RhbmNlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuaW5zdGFuY2VPZih0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgaW5jbHVkZXMgYG5lZWRsZWAuIFdvcmtzXG4gICAqIGZvciBzdHJpbmdzIGFuZCBhcnJheXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZSgnZm9vYmFyJywgJ2JhcicsICdmb29iYXIgY29udGFpbnMgc3RyaW5nIFwiYmFyXCInKTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKFsgMSwgMiwgMyBdLCAzLCAnYXJyYXkgY29udGFpbnMgdmFsdWUnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQuaW5jbHVkZSkuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGhheXN0YWNrYCBkb2VzIG5vdCBpbmNsdWRlIGBuZWVkbGVgLiBXb3Jrc1xuICAgKiBmb3Igc3RyaW5ncyBhbmQgYXJyYXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoJ2Zvb2JhcicsICdiYXonLCAnc3RyaW5nIG5vdCBpbmNsdWRlIHN1YnN0cmluZycpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoWyAxLCAyLCAzIF0sIDQsICdhcnJheSBub3QgaW5jbHVkZSBjb250YWluIHZhbHVlJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdEluY2x1ZGUpLm5vdC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubWF0Y2godmFsdWUsIHJlZ2V4cCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBtYXRjaGVzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubWF0Y2goJ2Zvb2JhcicsIC9eZm9vLywgJ3JlZ2V4cCBtYXRjaGVzJyk7XG4gICAqXG4gICAqIEBuYW1lIG1hdGNoXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm1hdGNoID0gZnVuY3Rpb24gKGV4cCwgcmUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2cpLnRvLm1hdGNoKHJlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RNYXRjaCh2YWx1ZSwgcmVnZXhwLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGRvZXMgbm90IG1hdGNoIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90TWF0Y2goJ2Zvb2JhcicsIC9eZm9vLywgJ3JlZ2V4cCBkb2VzIG5vdCBtYXRjaCcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RNYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RNYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnKS50by5ub3QubWF0Y2gocmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQucHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5wcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90UHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RQcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICdjb2ZmZWUnKTtcbiAgICpcbiAgICogQG5hbWUgbm90UHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAsIHdoaWNoIGNhbiBiZSBhXG4gICAqIHN0cmluZyB1c2luZyBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBkZWVwIHJlZmVyZW5jZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwUHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJyk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5kZWVwLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCB3aGljaFxuICAgKiBjYW4gYmUgYSBzdHJpbmcgdXNpbmcgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RGVlcFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5vb2xvbmcnKTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5ub3QuaGF2ZS5kZWVwLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIHdpdGggdmFsdWUgZ2l2ZW5cbiAgICogYnkgYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5wcm9wZXJ0eVZhbCh7IHRlYTogJ2lzIGdvb2QnIH0sICd0ZWEnLCAnaXMgZ29vZCcpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eU5vdFZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCwgYnV0IHdpdGggYSB2YWx1ZVxuICAgKiBkaWZmZXJlbnQgZnJvbSB0aGF0IGdpdmVuIGJ5IGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQucHJvcGVydHlOb3RWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAndGVhJywgJ2lzIGJhZCcpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eU5vdFZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHlOb3RWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLm5vdC5oYXZlLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIHdpdGggdmFsdWUgZ2l2ZW5cbiAgICogYnkgYHZhbHVlYC4gYHByb3BlcnR5YCBjYW4gdXNlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXBcbiAgICogcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nLCAnbWF0Y2hhJyk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLmRlZXAucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwUHJvcGVydHlOb3RWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAsIGJ1dCB3aXRoIGEgdmFsdWVcbiAgICogZGlmZmVyZW50IGZyb20gdGhhdCBnaXZlbiBieSBgdmFsdWVgLiBgcHJvcGVydHlgIGNhbiB1c2UgZG90LSBhbmRcbiAgICogYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcFByb3BlcnR5Tm90VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicsICdrb25hY2hhJyk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBQcm9wZXJ0eU5vdFZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcFByb3BlcnR5Tm90VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5ub3QuaGF2ZS5kZWVwLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubGVuZ3RoT2Yob2JqZWN0LCBsZW5ndGgsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGBsZW5ndGhgIHByb3BlcnR5IHdpdGggdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmxlbmd0aE9mKFsxLDIsM10sIDMsICdhcnJheSBoYXMgbGVuZ3RoIG9mIDMnKTtcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZignZm9vYmFyJywgNSwgJ3N0cmluZyBoYXMgbGVuZ3RoIG9mIDYnKTtcbiAgICpcbiAgICogQG5hbWUgbGVuZ3RoT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmxlbmd0aE9mID0gZnVuY3Rpb24gKGV4cCwgbGVuLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnKS50by5oYXZlLmxlbmd0aChsZW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnRocm93cyhmdW5jdGlvbiwgW2NvbnN0cnVjdG9yL3N0cmluZy9yZWdleHBdLCBbc3RyaW5nL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBmdW5jdGlvbmAgd2lsbCB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuIGluc3RhbmNlIG9mXG4gICAqIGBjb25zdHJ1Y3RvcmAsIG9yIGFsdGVybmF0ZWx5IHRoYXQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvciB3aXRoIG1lc3NhZ2VcbiAgICogbWF0Y2hpbmcgYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCAnZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yJyk7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCAvZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yLyk7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBSZWZlcmVuY2VFcnJvcik7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBSZWZlcmVuY2VFcnJvciwgJ2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvcicpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgUmVmZXJlbmNlRXJyb3IsIC9mdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3IvKTtcbiAgICpcbiAgICogQG5hbWUgdGhyb3dzXG4gICAqIEBhbGlhcyB0aHJvd1xuICAgKiBAYWxpYXMgVGhyb3dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25cbiAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgZXJydCB8fCBlcnJ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBlcnJzID0gZXJydDtcbiAgICAgIGVycnQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBhc3NlcnRFcnIgPSBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLnRocm93KGVycnQsIGVycnMpO1xuICAgIHJldHVybiBmbGFnKGFzc2VydEVyciwgJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RUaHJvdyhmdW5jdGlvbiwgW2NvbnN0cnVjdG9yL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBmdW5jdGlvbmAgd2lsbCBfbm90XyB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuIGluc3RhbmNlIG9mXG4gICAqIGBjb25zdHJ1Y3RvcmAsIG9yIGFsdGVybmF0ZWx5IHRoYXQgaXQgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAqIG1hdGNoaW5nIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgRXJyb3IsICdmdW5jdGlvbiBkb2VzIG5vdCB0aHJvdycpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90VGhyb3dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25cbiAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uIChmbiwgdHlwZSwgbXNnKSB7XG4gICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdHlwZSkge1xuICAgICAgbXNnID0gdHlwZTtcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZykudG8ubm90LlRocm93KHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm9wZXJhdG9yKHZhbDEsIG9wZXJhdG9yLCB2YWwyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIENvbXBhcmVzIHR3byB2YWx1ZXMgdXNpbmcgYG9wZXJhdG9yYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vcGVyYXRvcigxLCAnPCcsIDIsICdldmVyeXRoaW5nIGlzIG9rJyk7XG4gICAqICAgICBhc3NlcnQub3BlcmF0b3IoMSwgJz4nLCAyLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICpcbiAgICogQG5hbWUgb3BlcmF0b3JcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsMVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsMlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub3BlcmF0b3IgPSBmdW5jdGlvbiAodmFsLCBvcGVyYXRvciwgdmFsMiwgbXNnKSB7XG4gICAgdmFyIG9rO1xuICAgIHN3aXRjaChvcGVyYXRvcikge1xuICAgICAgY2FzZSAnPT0nOlxuICAgICAgICBvayA9IHZhbCA9PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgIG9rID0gdmFsID09PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJz4nOlxuICAgICAgICBvayA9IHZhbCA+IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnPj0nOlxuICAgICAgICBvayA9IHZhbCA+PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzwnOlxuICAgICAgICBvayA9IHZhbCA8IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnPD0nOlxuICAgICAgICBvayA9IHZhbCA8PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgb2sgPSB2YWwgIT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICchPT0nOlxuICAgICAgICBvayA9IHZhbCAhPT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3BlcmF0b3IgXCInICsgb3BlcmF0b3IgKyAnXCInKTtcbiAgICB9XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKG9rLCBtc2cpO1xuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICB0cnVlID09PSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIHV0aWwuaW5zcGVjdCh2YWwpICsgJyB0byBiZSAnICsgb3BlcmF0b3IgKyAnICcgKyB1dGlsLmluc3BlY3QodmFsMilcbiAgICAgICwgJ2V4cGVjdGVkICcgKyB1dGlsLmluc3BlY3QodmFsKSArICcgdG8gbm90IGJlICcgKyBvcGVyYXRvciArICcgJyArIHV0aWwuaW5zcGVjdCh2YWwyKSApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmNsb3NlVG8oYWN0dWFsLCBleHBlY3RlZCwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgYGV4cGVjdGVkYCwgdG8gd2l0aGluIGEgKy8tIGBkZWx0YWAgcmFuZ2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuY2xvc2VUbygxLjUsIDEsIDAuNSwgJ251bWJlcnMgYXJlIGNsb3NlJyk7XG4gICAqXG4gICAqIEBuYW1lIGNsb3NlVG9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFjdHVhbFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jbG9zZVRvID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBkZWx0YSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZykudG8uYmUuY2xvc2VUbyhleHAsIGRlbHRhKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5zYW1lTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMuXG4gICAqIE9yZGVyIGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuc2FtZU1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMSwgMyBdLCAnc2FtZSBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIHNhbWVNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc2FtZU1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2cpLnRvLmhhdmUuc2FtZS5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuc2FtZURlZXBNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycyAtIHVzaW5nIGEgZGVlcCBlcXVhbGl0eSBjaGVja2luZy5cbiAgICogT3JkZXIgaXMgbm90IHRha2VuIGludG8gYWNjb3VudC5cbiAgICpcbiAgICogICAgIGFzc2VydC5zYW1lRGVlcE1lbWJlcnMoWyB7YjogM30sIHthOiAyfSwge2M6IDV9IF0sIFsge2M6IDV9LCB7YjogM30sIHthOiAyfSBdLCAnc2FtZSBkZWVwIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgc2FtZURlZXBNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc2FtZURlZXBNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnKS50by5oYXZlLnNhbWUuZGVlcC5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZU1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXMgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YC5cbiAgICogT3JkZXIgaXMgbm90IHRha2VuIGludG8gYWNjb3VudC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxIF0sICdpbmNsdWRlIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2cpLnRvLmluY2x1ZGUubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgIC8qKlxuICAgKiAjIyMgLmNoYW5nZXMoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHkpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGNoYW5nZXMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gMjIgfTtcbiAgICogICAgIGFzc2VydC5jaGFuZ2VzKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgY2hhbmdlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNoYW5nZXMgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCkge1xuICAgIG5ldyBBc3NlcnRpb24oZm4pLnRvLmNoYW5nZShvYmosIHByb3ApO1xuICB9XG5cbiAgIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RDaGFuZ2UoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHkpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGNoYW5nZXMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZygnZm9vJyk7IH07XG4gICAqICAgICBhc3NlcnQuZG9lc05vdENoYW5nZShmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RDaGFuZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90Q2hhbmdlID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3ApIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGZuKS50by5ub3QuY2hhbmdlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuaW5jcmVhc2VzKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBpbmNyZWFzZXMgYW4gb2JqZWN0IHByb3BlcnR5XG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDEzIH07XG4gICAqICAgICBhc3NlcnQuaW5jcmVhc2VzKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jcmVhc2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jcmVhc2VzID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3ApIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGZuKS50by5pbmNyZWFzZShvYmosIHByb3ApO1xuICB9XG5cbiAgIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RJbmNyZWFzZShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgaW5jcmVhc2Ugb2JqZWN0IHByb3BlcnR5XG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDggfTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SW5jcmVhc2UoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SW5jcmVhc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90SW5jcmVhc2UgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCkge1xuICAgIG5ldyBBc3NlcnRpb24oZm4pLnRvLm5vdC5pbmNyZWFzZShvYmosIHByb3ApO1xuICB9XG5cbiAgIC8qKlxuICAgKiAjIyMgLmRlY3JlYXNlcyhmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZGVjcmVhc2VzIGFuIG9iamVjdCBwcm9wZXJ0eVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSA1IH07XG4gICAqICAgICBhc3NlcnQuZGVjcmVhc2VzKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZGVjcmVhc2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVjcmVhc2VzID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3ApIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGZuKS50by5kZWNyZWFzZShvYmosIHByb3ApO1xuICB9XG5cbiAgIC8qKlxuICAgKiAjIyMgLmRvZXNOb3REZWNyZWFzZShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgZGVjcmVhc2VzIGFuIG9iamVjdCBwcm9wZXJ0eVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSAxNSB9O1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3REZWNyZWFzZShmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3REZWNyZWFzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3REZWNyZWFzZSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wKSB7XG4gICAgbmV3IEFzc2VydGlvbihmbikudG8ubm90LmRlY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKiFcbiAgICogIyMjIC5pZkVycm9yKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyBpZiB2YWx1ZSBpcyBub3QgYSBmYWxzZSB2YWx1ZSwgYW5kIHRocm93cyBpZiBpdCBpcyBhIHRydWUgdmFsdWUuXG4gICAqIFRoaXMgaXMgYWRkZWQgdG8gYWxsb3cgZm9yIGNoYWkgdG8gYmUgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciBOb2RlJ3NcbiAgICogYXNzZXJ0IGNsYXNzLlxuICAgKlxuICAgKiAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignSSBhbSBhIGN1c3RvbSBlcnJvcicpO1xuICAgKiAgICAgYXNzZXJ0LmlmRXJyb3IoZXJyKTsgLy8gUmV0aHJvd3MgZXJyIVxuICAgKlxuICAgKiBAbmFtZSBpZkVycm9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhyb3codmFsKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNFeHRlbnNpYmxlKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIGV4dGVuc2libGUgKGNhbiBoYXZlIG5ldyBwcm9wZXJ0aWVzIGFkZGVkIHRvIGl0KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0V4dGVuc2libGUoe30pO1xuICAgKlxuICAgKiBAbmFtZSBpc0V4dGVuc2libGVcbiAgICogQGFsaWFzIGV4dGVuc2libGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0V4dGVuc2libGUgPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5iZS5leHRlbnNpYmxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RXh0ZW5zaWJsZShvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBfbm90XyBleHRlbnNpYmxlLlxuICAgKlxuICAgKiAgICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgKiAgICAgdmFyIHNlYWxlZE9iamVjdCA9IE9iamVjdC5zZWFsKHt9KTtcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXNlKHt9KTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdEV4dGVuc2libGUobm9uRXh0ZW5zaWJsZU9iamVjdCk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlKHNlYWxlZE9iamVjdCk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlKGZyb3plbk9iamVjdCk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90RXh0ZW5zaWJsZVxuICAgKiBAYWxpYXMgbm90RXh0ZW5zaWJsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90RXh0ZW5zaWJsZSA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzU2VhbGVkKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIHNlYWxlZCAoY2Fubm90IGhhdmUgbmV3IHByb3BlcnRpZXMgYWRkZWQgdG8gaXRcbiAgICogYW5kIGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSByZW1vdmVkKS5cbiAgICpcbiAgICogICAgIHZhciBzZWFsZWRPYmplY3QgPSBPYmplY3Quc2VhbCh7fSk7XG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzU2VhbGVkKHNlYWxlZE9iamVjdCk7XG4gICAqICAgICBhc3NlcnQuaXNTZWFsZWQoZnJvemVuT2JqZWN0KTtcbiAgICpcbiAgICogQG5hbWUgaXNTZWFsZWRcbiAgICogQGFsaWFzIHNlYWxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzU2VhbGVkID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uYmUuc2VhbGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90U2VhbGVkKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIF9ub3RfIHNlYWxlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdFNlYWxlZCh7fSk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90U2VhbGVkXG4gICAqIEBhbGlhcyBub3RTZWFsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdFNlYWxlZCA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLm5vdC5iZS5zZWFsZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGcm96ZW4ob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgZnJvemVuIChjYW5ub3QgaGF2ZSBuZXcgcHJvcGVydGllcyBhZGRlZCB0byBpdFxuICAgKiBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIG1vZGlmaWVkKS5cbiAgICpcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICogICAgIGFzc2VydC5mcm96ZW4oZnJvemVuT2JqZWN0KTtcbiAgICpcbiAgICogQG5hbWUgaXNGcm96ZW5cbiAgICogQGFsaWFzIGZyb3plblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRnJvemVuID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uYmUuZnJvemVuO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RnJvemVuKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIF9ub3RfIGZyb3plbi5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdEZyb3plbih7fSk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90RnJvemVuXG4gICAqIEBhbGlhcyBub3RGcm96ZW5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEZyb3plbiA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLm5vdC5iZS5mcm96ZW47XG4gIH07XG5cbiAgLyohXG4gICAqIEFsaWFzZXMuXG4gICAqL1xuXG4gIChmdW5jdGlvbiBhbGlhcyhuYW1lLCBhcyl7XG4gICAgYXNzZXJ0W2FzXSA9IGFzc2VydFtuYW1lXTtcbiAgICByZXR1cm4gYWxpYXM7XG4gIH0pXG4gICgnaXNPaycsICdvaycpXG4gICgnaXNOb3RPaycsICdub3RPaycpXG4gICgndGhyb3dzJywgJ3Rocm93JylcbiAgKCd0aHJvd3MnLCAnVGhyb3cnKVxuICAoJ2lzRXh0ZW5zaWJsZScsICdleHRlbnNpYmxlJylcbiAgKCdpc05vdEV4dGVuc2libGUnLCAnbm90RXh0ZW5zaWJsZScpXG4gICgnaXNTZWFsZWQnLCAnc2VhbGVkJylcbiAgKCdpc05vdFNlYWxlZCcsICdub3RTZWFsZWQnKVxuICAoJ2lzRnJvemVuJywgJ2Zyb3plbicpXG4gICgnaXNOb3RGcm96ZW4nLCAnbm90RnJvemVuJyk7XG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuICBjaGFpLmV4cGVjdCA9IGZ1bmN0aW9uICh2YWwsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IGNoYWkuQXNzZXJ0aW9uKHZhbCwgbWVzc2FnZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0sIFtvcGVyYXRvcl0pXG4gICAqXG4gICAqIFRocm93IGEgZmFpbHVyZS5cbiAgICpcbiAgICogQG5hbWUgZmFpbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGNoYWkuZXhwZWN0LmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnZXhwZWN0LmZhaWwoKSc7XG4gICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSwge1xuICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgfSwgY2hhaS5leHBlY3QuZmFpbCk7XG4gIH07XG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb247XG5cbiAgZnVuY3Rpb24gbG9hZFNob3VsZCAoKSB7XG4gICAgLy8gZXhwbGljaXRseSBkZWZpbmUgdGhpcyBtZXRob2QgYXMgZnVuY3Rpb24gYXMgdG8gaGF2ZSBpdCdzIG5hbWUgdG8gaW5jbHVkZSBhcyBgc3NmaWBcbiAgICBmdW5jdGlvbiBzaG91bGRHZXR0ZXIoKSB7XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFN0cmluZyB8fCB0aGlzIGluc3RhbmNlb2YgTnVtYmVyIHx8IHRoaXMgaW5zdGFuY2VvZiBCb29sZWFuICkge1xuICAgICAgICByZXR1cm4gbmV3IEFzc2VydGlvbih0aGlzLnZhbHVlT2YoKSwgbnVsbCwgc2hvdWxkR2V0dGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMsIG51bGwsIHNob3VsZEdldHRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFNldHRlcih2YWx1ZSkge1xuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvY2hhaS9pc3N1ZXMvODY6IHRoaXMgbWFrZXNcbiAgICAgIC8vIGB3aGF0ZXZlci5zaG91bGQgPSBzb21lVmFsdWVgIGFjdHVhbGx5IHNldCBgc29tZVZhbHVlYCwgd2hpY2ggaXNcbiAgICAgIC8vIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBgZ2xvYmFsLnNob3VsZCA9IHJlcXVpcmUoJ2NoYWknKS5zaG91bGQoKWAuXG4gICAgICAvL1xuICAgICAgLy8gTm90ZSB0aGF0IHdlIGhhdmUgdG8gdXNlIFtbRGVmaW5lUHJvcGVydHldXSBpbnN0ZWFkIG9mIFtbUHV0XV1cbiAgICAgIC8vIHNpbmNlIG90aGVyd2lzZSB3ZSB3b3VsZCB0cmlnZ2VyIHRoaXMgdmVyeSBzZXR0ZXIhXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Nob3VsZCcsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gbW9kaWZ5IE9iamVjdC5wcm90b3R5cGUgdG8gaGF2ZSBgc2hvdWxkYFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCAnc2hvdWxkJywge1xuICAgICAgc2V0OiBzaG91bGRTZXR0ZXJcbiAgICAgICwgZ2V0OiBzaG91bGRHZXR0ZXJcbiAgICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB2YXIgc2hvdWxkID0ge307XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLmZhaWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdLCBbb3BlcmF0b3JdKVxuICAgICAqXG4gICAgICogVGhyb3cgYSBmYWlsdXJlLlxuICAgICAqXG4gICAgICogQG5hbWUgZmFpbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdzaG91bGQuZmFpbCgpJztcbiAgICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAsIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgICAgfSwgc2hvdWxkLmZhaWwpO1xuICAgIH07XG5cbiAgICBzaG91bGQuZXF1YWwgPSBmdW5jdGlvbiAodmFsMSwgdmFsMiwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbDEsIG1zZykudG8uZXF1YWwodmFsMik7XG4gICAgfTtcblxuICAgIHNob3VsZC5UaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLlRocm93KGVycnQsIGVycnMpO1xuICAgIH07XG5cbiAgICBzaG91bGQuZXhpc3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmV4aXN0O1xuICAgIH1cblxuICAgIC8vIG5lZ2F0aW9uXG4gICAgc2hvdWxkLm5vdCA9IHt9XG5cbiAgICBzaG91bGQubm90LmVxdWFsID0gZnVuY3Rpb24gKHZhbDEsIHZhbDIsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwxLCBtc2cpLnRvLm5vdC5lcXVhbCh2YWwyKTtcbiAgICB9O1xuXG4gICAgc2hvdWxkLm5vdC5UaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLm5vdC5UaHJvdyhlcnJ0LCBlcnJzKTtcbiAgICB9O1xuXG4gICAgc2hvdWxkLm5vdC5leGlzdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmV4aXN0O1xuICAgIH1cblxuICAgIHNob3VsZFsndGhyb3cnXSA9IHNob3VsZFsnVGhyb3cnXTtcbiAgICBzaG91bGQubm90Wyd0aHJvdyddID0gc2hvdWxkLm5vdFsnVGhyb3cnXTtcblxuICAgIHJldHVybiBzaG91bGQ7XG4gIH07XG5cbiAgY2hhaS5zaG91bGQgPSBsb2FkU2hvdWxkO1xuICBjaGFpLlNob3VsZCA9IGxvYWRTaG91bGQ7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gYWRkQ2hhaW5pbmdNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4vKiFcbiAqIE1vZHVsZSB2YXJpYWJsZXNcbiAqL1xuXG4vLyBDaGVjayB3aGV0aGVyIGBfX3Byb3RvX19gIGlzIHN1cHBvcnRlZFxudmFyIGhhc1Byb3RvU3VwcG9ydCA9ICdfX3Byb3RvX18nIGluIE9iamVjdDtcblxuLy8gV2l0aG91dCBgX19wcm90b19fYCBzdXBwb3J0LCB0aGlzIG1vZHVsZSB3aWxsIG5lZWQgdG8gYWRkIHByb3BlcnRpZXMgdG8gYSBmdW5jdGlvbi5cbi8vIEhvd2V2ZXIsIHNvbWUgRnVuY3Rpb24ucHJvdG90eXBlIG1ldGhvZHMgY2Fubm90IGJlIG92ZXJ3cml0dGVuLFxuLy8gYW5kIHRoZXJlIHNlZW1zIG5vIGVhc3kgY3Jvc3MtcGxhdGZvcm0gd2F5IHRvIGRldGVjdCB0aGVtIChAc2VlIGNoYWlqcy9jaGFpL2lzc3Vlcy82OSkuXG52YXIgZXhjbHVkZU5hbWVzID0gL14oPzpsZW5ndGh8bmFtZXxhcmd1bWVudHN8Y2FsbGVyKSQvO1xuXG4vLyBDYWNoZSBgRnVuY3Rpb25gIHByb3BlcnRpZXNcbnZhciBjYWxsICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLFxuICAgIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vKipcbiAqICMjIyBhZGRDaGFpbmFibGVNZXRob2QgKGN0eCwgbmFtZSwgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKVxuICpcbiAqIEFkZHMgYSBtZXRob2QgdG8gYW4gb2JqZWN0LCBzdWNoIHRoYXQgdGhlIG1ldGhvZCBjYW4gYWxzbyBiZSBjaGFpbmVkLlxuICpcbiAqICAgICB1dGlscy5hZGRDaGFpbmFibGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuZXF1YWwoc3RyKTtcbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnZm9vJywgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICpcbiAqIFRoZSByZXN1bHQgY2FuIHRoZW4gYmUgdXNlZCBhcyBib3RoIGEgbWV0aG9kIGFzc2VydGlvbiwgZXhlY3V0aW5nIGJvdGggYG1ldGhvZGAgYW5kXG4gKiBgY2hhaW5pbmdCZWhhdmlvcmAsIG9yIGFzIGEgbGFuZ3VhZ2UgY2hhaW4sIHdoaWNoIG9ubHkgZXhlY3V0ZXMgYGNoYWluaW5nQmVoYXZpb3JgLlxuICpcbiAqICAgICBleHBlY3QoZm9vU3RyKS50by5iZS5mb28oJ2JhcicpO1xuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvby5lcXVhbCgnZm9vJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIG1ldGhvZCBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIGBuYW1lYCwgd2hlbiBjYWxsZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoYWluaW5nQmVoYXZpb3IgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkXG4gKiBAbmFtZSBhZGRDaGFpbmFibGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgaWYgKHR5cGVvZiBjaGFpbmluZ0JlaGF2aW9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hhaW5pbmdCZWhhdmlvciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgfVxuXG4gIHZhciBjaGFpbmFibGVCZWhhdmlvciA9IHtcbiAgICAgIG1ldGhvZDogbWV0aG9kXG4gICAgLCBjaGFpbmluZ0JlaGF2aW9yOiBjaGFpbmluZ0JlaGF2aW9yXG4gIH07XG5cbiAgLy8gc2F2ZSB0aGUgbWV0aG9kcyBzbyB3ZSBjYW4gb3ZlcndyaXRlIHRoZW0gbGF0ZXIsIGlmIHdlIG5lZWQgdG8uXG4gIGlmICghY3R4Ll9fbWV0aG9kcykge1xuICAgIGN0eC5fX21ldGhvZHMgPSB7fTtcbiAgfVxuICBjdHguX19tZXRob2RzW25hbWVdID0gY2hhaW5hYmxlQmVoYXZpb3I7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdmFyIGFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydCgpIHtcbiAgICAgICAgICB2YXIgb2xkX3NzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgICAgICAgaWYgKG9sZF9zc2ZpICYmIGNvbmZpZy5pbmNsdWRlU3RhY2sgPT09IGZhbHNlKVxuICAgICAgICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIGFzc2VydCk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXNlIGBfX3Byb3RvX19gIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAoaGFzUHJvdG9TdXBwb3J0KSB7XG4gICAgICAgICAgLy8gSW5oZXJpdCBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBvYmplY3QgYnkgcmVwbGFjaW5nIHRoZSBgRnVuY3Rpb25gIHByb3RvdHlwZVxuICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBhc3NlcnQuX19wcm90b19fID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBgY2FsbGAgYW5kIGBhcHBseWAgbWV0aG9kcyBmcm9tIGBGdW5jdGlvbmBcbiAgICAgICAgICBwcm90b3R5cGUuY2FsbCA9IGNhbGw7XG4gICAgICAgICAgcHJvdG90eXBlLmFwcGx5ID0gYXBwbHk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCByZWRlZmluZSBhbGwgcHJvcGVydGllcyAoc2xvdyEpXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhc3NlcnRlck5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3R4KTtcbiAgICAgICAgICBhc3NlcnRlck5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGFzc2VydGVyTmFtZSkge1xuICAgICAgICAgICAgaWYgKCFleGNsdWRlTmFtZXMudGVzdChhc3NlcnRlck5hbWUpKSB7XG4gICAgICAgICAgICAgIHZhciBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3R4LCBhc3NlcnRlck5hbWUpO1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXNzZXJ0LCBhc3NlcnRlck5hbWUsIHBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgYXNzZXJ0KTtcbiAgICAgICAgcmV0dXJuIGFzc2VydDtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuLyoqXG4gKiAjIyMgLmFkZE1ldGhvZCAoY3R4LCBuYW1lLCBtZXRob2QpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmVxdWFsKHN0cik7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIG1ldGhvZCBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lIGFkZE1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBtZXRob2QpIHtcbiAgY3R4W25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvbGRfc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBpZiAob2xkX3NzZmkgJiYgY29uZmlnLmluY2x1ZGVTdGFjayA9PT0gZmFsc2UpXG4gICAgICBmbGFnKHRoaXMsICdzc2ZpJywgY3R4W25hbWVdKTtcbiAgICB2YXIgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRQcm9wZXJ0eSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgYWRkUHJvcGVydHkgKGN0eCwgbmFtZSwgZ2V0dGVyKVxuICpcbiAqIEFkZHMgYSBwcm9wZXJ0eSB0byB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkUHJvcGVydHkoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKCkge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuaW5zdGFuY2VvZihGb28pO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkUHJvcGVydHkoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uYmUuZm9vO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHRvIHdoaWNoIHRoZSBwcm9wZXJ0eSBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgcHJvcGVydHkgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXIgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWUgYWRkUHJvcGVydHlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBnZXR0ZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZmxhZyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgZmxhZyhvYmplY3QsIGtleSwgW3ZhbHVlXSlcbiAqXG4gKiBHZXQgb3Igc2V0IGEgZmxhZyB2YWx1ZSBvbiBhbiBvYmplY3QuIElmIGFcbiAqIHZhbHVlIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgc2V0LCBlbHNlIGl0IHdpbGxcbiAqIHJldHVybiB0aGUgY3VycmVudGx5IHNldCB2YWx1ZSBvciBgdW5kZWZpbmVkYCBpZlxuICogdGhlIHZhbHVlIGlzIG5vdCBzZXQuXG4gKlxuICogICAgIHV0aWxzLmZsYWcodGhpcywgJ2ZvbycsICdiYXInKTsgLy8gc2V0dGVyXG4gKiAgICAgdXRpbHMuZmxhZyh0aGlzLCAnZm9vJyk7IC8vIGdldHRlciwgcmV0dXJucyBgYmFyYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgY29uc3RydWN0ZWQgQXNzZXJ0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAob3B0aW9uYWwpXG4gKiBAbmFtZSBmbGFnXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgdmFyIGZsYWdzID0gb2JqLl9fZmxhZ3MgfHwgKG9iai5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgZmxhZ3Nba2V5XSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmbGFnc1trZXldO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0QWN0dWFsIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMgZ2V0QWN0dWFsKG9iamVjdCwgW2FjdHVhbF0pXG4gKlxuICogUmV0dXJucyB0aGUgYGFjdHVhbGAgdmFsdWUgZm9yIGFuIEFzc2VydGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgYXJncykge1xuICByZXR1cm4gYXJncy5sZW5ndGggPiA0ID8gYXJnc1s0XSA6IG9iai5fb2JqO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsXG4gKiBpbmhlcml0ZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIG1lc3NhZ2UgY29tcG9zaXRpb24gdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGFuY2llc1xuICovXG5cbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJylcbiAgLCBnZXRBY3R1YWwgPSByZXF1aXJlKCcuL2dldEFjdHVhbCcpXG4gICwgaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpXG4gICwgb2JqRGlzcGxheSA9IHJlcXVpcmUoJy4vb2JqRGlzcGxheScpO1xuXG4vKipcbiAqICMjIyAuZ2V0TWVzc2FnZShvYmplY3QsIG1lc3NhZ2UsIG5lZ2F0ZU1lc3NhZ2UpXG4gKlxuICogQ29uc3RydWN0IHRoZSBlcnJvciBtZXNzYWdlIGJhc2VkIG9uIGZsYWdzXG4gKiBhbmQgdGVtcGxhdGUgdGFncy4gVGVtcGxhdGUgdGFncyB3aWxsIHJldHVyblxuICogYSBzdHJpbmdpZmllZCBpbnNwZWN0aW9uIG9mIHRoZSBvYmplY3QgcmVmZXJlbmNlZC5cbiAqXG4gKiBNZXNzYWdlIHRlbXBsYXRlIHRhZ3M6XG4gKiAtIGAje3RoaXN9YCBjdXJyZW50IGFzc2VydGVkIG9iamVjdFxuICogLSBgI3thY3R9YCBhY3R1YWwgdmFsdWVcbiAqIC0gYCN7ZXhwfWAgZXhwZWN0ZWQgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqIEBuYW1lIGdldE1lc3NhZ2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBhcmdzKSB7XG4gIHZhciBuZWdhdGUgPSBmbGFnKG9iaiwgJ25lZ2F0ZScpXG4gICAgLCB2YWwgPSBmbGFnKG9iaiwgJ29iamVjdCcpXG4gICAgLCBleHBlY3RlZCA9IGFyZ3NbM11cbiAgICAsIGFjdHVhbCA9IGdldEFjdHVhbChvYmosIGFyZ3MpXG4gICAgLCBtc2cgPSBuZWdhdGUgPyBhcmdzWzJdIDogYXJnc1sxXVxuICAgICwgZmxhZ01zZyA9IGZsYWcob2JqLCAnbWVzc2FnZScpO1xuXG4gIGlmKHR5cGVvZiBtc2cgPT09IFwiZnVuY3Rpb25cIikgbXNnID0gbXNnKCk7XG4gIG1zZyA9IG1zZyB8fCAnJztcbiAgbXNnID0gbXNnXG4gICAgLnJlcGxhY2UoLyN7dGhpc30vZywgb2JqRGlzcGxheSh2YWwpKVxuICAgIC5yZXBsYWNlKC8je2FjdH0vZywgb2JqRGlzcGxheShhY3R1YWwpKVxuICAgIC5yZXBsYWNlKC8je2V4cH0vZywgb2JqRGlzcGxheShleHBlY3RlZCkpO1xuXG4gIHJldHVybiBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgKyBtc2cgOiBtc2c7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0TmFtZSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIGdldE5hbWUoZnVuYylcbiAqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24sIGluIGEgY3Jvc3MtYnJvd3NlciB3YXkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiAodXN1YWxseSBhIGNvbnN0cnVjdG9yKVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKGZ1bmMubmFtZSkgcmV0dXJuIGZ1bmMubmFtZTtcblxuICB2YXIgbWF0Y2ggPSAvXlxccz9mdW5jdGlvbiAoW14oXSopXFwoLy5leGVjKGZ1bmMpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gPyBtYXRjaFsxXSA6IFwiXCI7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0UGF0aEluZm8gdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBoYXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vaGFzUHJvcGVydHknKTtcblxuLyoqXG4gKiAjIyMgLmdldFBhdGhJbmZvKHBhdGgsIG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIHByb3BlcnR5IGluZm8gaW4gYW5cbiAqIG9iamVjdCBnaXZlbiBhIHN0cmluZyBwYXRoLlxuICpcbiAqIFRoZSBwYXRoIGluZm8gY29uc2lzdHMgb2YgYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAqIHBhcmVudCAtIFRoZSBwYXJlbnQgb2JqZWN0IG9mIHRoZSBwcm9wZXJ0eSByZWZlcmVuY2VkIGJ5IGBwYXRoYFxuICogKiBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpbmFsIHByb3BlcnR5LCBhIG51bWJlciBpZiBpdCB3YXMgYW4gYXJyYXkgaW5kZXhlclxuICogKiB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHksIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKiAqIGV4aXN0cyAtIFdoZXRoZXIgdGhlIHByb3BlcnR5IGV4aXN0cyBvciBub3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gaW5mb1xuICogQG5hbWUgZ2V0UGF0aEluZm9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQYXRoSW5mbyhwYXRoLCBvYmopIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aChwYXRoKSxcbiAgICAgIGxhc3QgPSBwYXJzZWRbcGFyc2VkLmxlbmd0aCAtIDFdO1xuXG4gIHZhciBpbmZvID0ge1xuICAgIHBhcmVudDogcGFyc2VkLmxlbmd0aCA+IDEgPyBfZ2V0UGF0aFZhbHVlKHBhcnNlZCwgb2JqLCBwYXJzZWQubGVuZ3RoIC0gMSkgOiBvYmosXG4gICAgbmFtZTogbGFzdC5wIHx8IGxhc3QuaSxcbiAgICB2YWx1ZTogX2dldFBhdGhWYWx1ZShwYXJzZWQsIG9iailcbiAgfTtcbiAgaW5mby5leGlzdHMgPSBoYXNQcm9wZXJ0eShpbmZvLm5hbWUsIGluZm8ucGFyZW50KTtcblxuICByZXR1cm4gaW5mbztcbn07XG5cblxuLyohXG4gKiAjIyBwYXJzZVBhdGgocGF0aClcbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0byBwYXJzZSBzdHJpbmcgb2JqZWN0XG4gKiBwYXRocy4gVXNlIGluIGNvbmp1bmN0aW9uIHdpdGggYF9nZXRQYXRoVmFsdWVgLlxuICpcbiAqICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aCgnbXlvYmplY3QucHJvcGVydHkuc3VicHJvcCcpO1xuICpcbiAqICMjIyBQYXRoczpcbiAqXG4gKiAqIENhbiBiZSBhcyBuZWFyIGluZmluaXRlbHkgZGVlcCBhbmQgbmVzdGVkXG4gKiAqIEFycmF5cyBhcmUgYWxzbyB2YWxpZCB1c2luZyB0aGUgZm9ybWFsIGBteW9iamVjdC5kb2N1bWVudFszXS5wcm9wZXJ0eWAuXG4gKiAqIExpdGVyYWwgZG90cyBhbmQgYnJhY2tldHMgKG5vdCBkZWxpbWl0ZXIpIG11c3QgYmUgYmFja3NsYXNoLWVzY2FwZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBhcnNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBzdHIgPSBwYXRoLnJlcGxhY2UoLyhbXlxcXFxdKVxcWy9nLCAnJDEuWycpXG4gICAgLCBwYXJ0cyA9IHN0ci5tYXRjaCgvKFxcXFxcXC58W14uXSs/KSsvZyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlID0gL15cXFsoXFxkKylcXF0kL1xuICAgICAgLCBtQXJyID0gcmUuZXhlYyh2YWx1ZSk7XG4gICAgaWYgKG1BcnIpIHJldHVybiB7IGk6IHBhcnNlRmxvYXQobUFyclsxXSkgfTtcbiAgICBlbHNlIHJldHVybiB7IHA6IHZhbHVlLnJlcGxhY2UoL1xcXFwoWy5cXFtcXF1dKS9nLCAnJDEnKSB9O1xuICB9KTtcbn1cblxuXG4vKiFcbiAqICMjIF9nZXRQYXRoVmFsdWUocGFyc2VkLCBvYmopXG4gKlxuICogSGVscGVyIGNvbXBhbmlvbiBmdW5jdGlvbiBmb3IgYC5wYXJzZVBhdGhgIHRoYXQgcmV0dXJuc1xuICogdGhlIHZhbHVlIGxvY2F0ZWQgYXQgdGhlIHBhcnNlZCBhZGRyZXNzLlxuICpcbiAqICAgICAgdmFyIHZhbHVlID0gZ2V0UGF0aFZhbHVlKHBhcnNlZCwgb2JqKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyc2VkIGRlZmluaXRpb24gZnJvbSBgcGFyc2VQYXRoYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gc2VhcmNoIGFnYWluc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBvYmplY3QgdG8gc2VhcmNoIGFnYWluc3RcbiAqIEByZXR1cm5zIHtPYmplY3R8VW5kZWZpbmVkfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX2dldFBhdGhWYWx1ZSAocGFyc2VkLCBvYmosIGluZGV4KSB7XG4gIHZhciB0bXAgPSBvYmpcbiAgICAsIHJlcztcblxuICBpbmRleCA9IChpbmRleCA9PT0gdW5kZWZpbmVkID8gcGFyc2VkLmxlbmd0aCA6IGluZGV4KTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGV4OyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJzZWRbaV07XG4gICAgaWYgKHRtcCkge1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgcGFydC5wKVxuICAgICAgICB0bXAgPSB0bXBbcGFydC5wXTtcbiAgICAgIGVsc2UgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgcGFydC5pKVxuICAgICAgICB0bXAgPSB0bXBbcGFydC5pXTtcbiAgICAgIGlmIChpID09IChsIC0gMSkpIHJlcyA9IHRtcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuIiwiLyohXG4gKiBDaGFpIC0gZ2V0UGF0aFZhbHVlIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2dpY2FscGFyYWRveC9maWx0clxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGdldFBhdGhJbmZvID0gcmVxdWlyZSgnLi9nZXRQYXRoSW5mbycpO1xuXG4vKipcbiAqICMjIyAuZ2V0UGF0aFZhbHVlKHBhdGgsIG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIHZhbHVlcyBpbiBhblxuICogb2JqZWN0IGdpdmVuIGEgc3RyaW5nIHBhdGguXG4gKlxuICogICAgIHZhciBvYmogPSB7XG4gKiAgICAgICAgIHByb3AxOiB7XG4gKiAgICAgICAgICAgICBhcnI6IFsnYScsICdiJywgJ2MnXVxuICogICAgICAgICAgICwgc3RyOiAnSGVsbG8nXG4gKiAgICAgICAgIH1cbiAqICAgICAgICwgcHJvcDI6IHtcbiAqICAgICAgICAgICAgIGFycjogWyB7IG5lc3RlZDogJ1VuaXZlcnNlJyB9IF1cbiAqICAgICAgICAgICAsIHN0cjogJ0hlbGxvIGFnYWluISdcbiAqICAgICAgICAgfVxuICogICAgIH1cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHdvdWxkIGJlIHRoZSByZXN1bHRzLlxuICpcbiAqICAgICBnZXRQYXRoVmFsdWUoJ3Byb3AxLnN0cicsIG9iaik7IC8vIEhlbGxvXG4gKiAgICAgZ2V0UGF0aFZhbHVlKCdwcm9wMS5hdHRbMl0nLCBvYmopOyAvLyBiXG4gKiAgICAgZ2V0UGF0aFZhbHVlKCdwcm9wMi5hcnJbMF0ubmVzdGVkJywgb2JqKTsgLy8gVW5pdmVyc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gdmFsdWUgb3IgYHVuZGVmaW5lZGBcbiAqIEBuYW1lIGdldFBhdGhWYWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwYXRoLCBvYmopIHtcbiAgdmFyIGluZm8gPSBnZXRQYXRoSW5mbyhwYXRoLCBvYmopO1xuICByZXR1cm4gaW5mby52YWx1ZTtcbn07IFxuIiwiLyohXG4gKiBDaGFpIC0gZ2V0UHJvcGVydGllcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldFByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LCBlbnVtZXJhYmxlIG9yIG5vdCxcbiAqIGluaGVyaXRlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fVxuICogQG5hbWUgZ2V0UHJvcGVydGllc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xuXG4gIGZ1bmN0aW9uIGFkZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgaWYgKHJlc3VsdC5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHByb3BlcnR5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgd2hpbGUgKHByb3RvICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLmZvckVhY2goYWRkUHJvcGVydHkpO1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gaGFzUHJvcGVydHkgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKTtcblxuLyoqXG4gKiAjIyMgLmhhc1Byb3BlcnR5KG9iamVjdCwgbmFtZSlcbiAqXG4gKiBUaGlzIGFsbG93cyBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXNcbiAqIG5hbWVkIHByb3BlcnR5IG9yIG51bWVyaWMgYXJyYXkgaW5kZXguXG4gKlxuICogQmFzaWNhbGx5IGRvZXMgdGhlIHNhbWUgdGhpbmcgYXMgdGhlIGBpbmBcbiAqIG9wZXJhdG9yIGJ1dCB3b3JrcyBwcm9wZXJseSB3aXRoIG5hdGl2ZXNcbiAqIGFuZCBudWxsL3VuZGVmaW5lZCB2YWx1ZXMuXG4gKlxuICogICAgIHZhciBvYmogPSB7XG4gKiAgICAgICAgIGFycjogWydhJywgJ2InLCAnYyddXG4gKiAgICAgICAsIHN0cjogJ0hlbGxvJ1xuICogICAgIH1cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHdvdWxkIGJlIHRoZSByZXN1bHRzLlxuICpcbiAqICAgICBoYXNQcm9wZXJ0eSgnc3RyJywgb2JqKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eSgnY29uc3RydWN0b3InLCBvYmopOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KCdiYXInLCBvYmopOyAgLy8gZmFsc2VcbiAqICAgICBcbiAqICAgICBoYXNQcm9wZXJ0eSgnbGVuZ3RoJywgb2JqLnN0cik7IC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eSgxLCBvYmouc3RyKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eSg1LCBvYmouc3RyKTsgIC8vIGZhbHNlXG4gKlxuICogICAgIGhhc1Byb3BlcnR5KCdsZW5ndGgnLCBvYmouYXJyKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eSgyLCBvYmouYXJyKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eSgzLCBvYmouYXJyKTsgIC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIHtPYmp1ZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59IHdoZXRoZXIgaXQgZXhpc3RzXG4gKiBAbmFtZSBnZXRQYXRoSW5mb1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgbGl0ZXJhbHMgPSB7XG4gICAgJ251bWJlcic6IE51bWJlclxuICAsICdzdHJpbmcnOiBTdHJpbmdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzUHJvcGVydHkobmFtZSwgb2JqKSB7XG4gIHZhciBvdCA9IHR5cGUob2JqKTtcblxuICAvLyBCYWQgT2JqZWN0LCBvYnZpb3VzbHkgbm8gcHJvcHMgYXQgYWxsXG4gIGlmKG90ID09PSAnbnVsbCcgfHwgb3QgPT09ICd1bmRlZmluZWQnKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBUaGUgYGluYCBvcGVyYXRvciBkb2VzIG5vdCB3b3JrIHdpdGggY2VydGFpbiBsaXRlcmFsc1xuICAvLyBib3ggdGhlc2UgYmVmb3JlIHRoZSBjaGVja1xuICBpZihsaXRlcmFsc1tvdF0gJiYgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgb2JqID0gbmV3IGxpdGVyYWxzW290XShvYmopO1xuXG4gIHJldHVybiBuYW1lIGluIG9iajtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExIEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNYWluIGV4cG9ydHNcbiAqL1xuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qIVxuICogdGVzdCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50ZXN0ID0gcmVxdWlyZSgnLi90ZXN0Jyk7XG5cbi8qIVxuICogdHlwZSB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKTtcblxuLyohXG4gKiBtZXNzYWdlIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmdldE1lc3NhZ2UgPSByZXF1aXJlKCcuL2dldE1lc3NhZ2UnKTtcblxuLyohXG4gKiBhY3R1YWwgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZ2V0QWN0dWFsID0gcmVxdWlyZSgnLi9nZXRBY3R1YWwnKTtcblxuLyohXG4gKiBJbnNwZWN0IHV0aWxcbiAqL1xuXG5leHBvcnRzLmluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKTtcblxuLyohXG4gKiBPYmplY3QgRGlzcGxheSB1dGlsXG4gKi9cblxuZXhwb3J0cy5vYmpEaXNwbGF5ID0gcmVxdWlyZSgnLi9vYmpEaXNwbGF5Jyk7XG5cbi8qIVxuICogRmxhZyB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5mbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG5cbi8qIVxuICogRmxhZyB0cmFuc2ZlcnJpbmcgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKiFcbiAqIERlZXAgZXF1YWwgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZXFsID0gcmVxdWlyZSgnZGVlcC1lcWwnKTtcblxuLyohXG4gKiBEZWVwIHBhdGggdmFsdWVcbiAqL1xuXG5leHBvcnRzLmdldFBhdGhWYWx1ZSA9IHJlcXVpcmUoJy4vZ2V0UGF0aFZhbHVlJyk7XG5cbi8qIVxuICogRGVlcCBwYXRoIGluZm9cbiAqL1xuXG5leHBvcnRzLmdldFBhdGhJbmZvID0gcmVxdWlyZSgnLi9nZXRQYXRoSW5mbycpO1xuXG4vKiFcbiAqIENoZWNrIGlmIGEgcHJvcGVydHkgZXhpc3RzXG4gKi9cblxuZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vaGFzUHJvcGVydHknKTtcblxuLyohXG4gKiBGdW5jdGlvbiBuYW1lXG4gKi9cblxuZXhwb3J0cy5nZXROYW1lID0gcmVxdWlyZSgnLi9nZXROYW1lJyk7XG5cbi8qIVxuICogYWRkIFByb3BlcnR5XG4gKi9cblxuZXhwb3J0cy5hZGRQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vYWRkUHJvcGVydHknKTtcblxuLyohXG4gKiBhZGQgTWV0aG9kXG4gKi9cblxuZXhwb3J0cy5hZGRNZXRob2QgPSByZXF1aXJlKCcuL2FkZE1ldGhvZCcpO1xuXG4vKiFcbiAqIG92ZXJ3cml0ZSBQcm9wZXJ0eVxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL292ZXJ3cml0ZVByb3BlcnR5Jyk7XG5cbi8qIVxuICogb3ZlcndyaXRlIE1ldGhvZFxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlTWV0aG9kID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVNZXRob2QnKTtcblxuLyohXG4gKiBBZGQgYSBjaGFpbmFibGUgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5hZGRDaGFpbmFibGVNZXRob2QgPSByZXF1aXJlKCcuL2FkZENoYWluYWJsZU1ldGhvZCcpO1xuXG4vKiFcbiAqIE92ZXJ3cml0ZSBjaGFpbmFibGUgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgPSByZXF1aXJlKCcuL292ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCcpO1xuXG4iLCIvLyBUaGlzIGlzIChhbG1vc3QpIGRpcmVjdGx5IGZyb20gTm9kZS5qcyB1dGlsc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2Jsb2IvZjhjMzM1ZDBjYWY0N2YxNmQzMTQxM2Y4OWFhMjhlZGEzODc4ZTNhYS9saWIvdXRpbC5qc1xuXG52YXIgZ2V0TmFtZSA9IHJlcXVpcmUoJy4vZ2V0TmFtZScpO1xudmFyIGdldFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2dldFByb3BlcnRpZXMnKTtcbnZhciBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnNwZWN0O1xuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNob3dIaWRkZW4gRmxhZyB0aGF0IHNob3dzIGhpZGRlbiAobm90IGVudW1lcmFibGUpXG4gKiAgICBwcm9wZXJ0aWVzIG9mIG9iamVjdHMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVwdGggRGVwdGggaW4gd2hpY2ggdG8gZGVzY2VuZCBpbiBvYmplY3QuIERlZmF1bHQgaXMgMi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sb3JzIEZsYWcgdG8gdHVybiBvbiBBTlNJIGVzY2FwZSBjb2RlcyB0byBjb2xvciB0aGVcbiAqICAgIG91dHB1dC4gRGVmYXVsdCBpcyBmYWxzZSAobm8gY29sb3JpbmcpLlxuICovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycykge1xuICB2YXIgY3R4ID0ge1xuICAgIHNob3dIaWRkZW46IHNob3dIaWRkZW4sXG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyOyB9XG4gIH07XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgKHR5cGVvZiBkZXB0aCA9PT0gJ3VuZGVmaW5lZCcgPyAyIDogZGVwdGgpKTtcbn1cblxuLy8gUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBhIERPTSBlbGVtZW50LlxudmFyIGlzRE9NRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iamVjdCAmJlxuICAgICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdC5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZyc7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmluc3BlY3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMpO1xuICAgIGlmICh0eXBlb2YgcmV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIElmIHRoaXMgaXMgYSBET00gZWxlbWVudCwgdHJ5IHRvIGdldCB0aGUgb3V0ZXIgSFRNTC5cbiAgaWYgKGlzRE9NRWxlbWVudCh2YWx1ZSkpIHtcbiAgICBpZiAoJ291dGVySFRNTCcgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5vdXRlckhUTUw7XG4gICAgICAvLyBUaGlzIHZhbHVlIGRvZXMgbm90IGhhdmUgYW4gb3V0ZXJIVE1MIGF0dHJpYnV0ZSxcbiAgICAgIC8vICAgaXQgY291bGQgc3RpbGwgYmUgYW4gWE1MIGVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXR0ZW1wdCB0byBzZXJpYWxpemUgaXRcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChkb2N1bWVudC54bWxWZXJzaW9uKSB7XG4gICAgICAgICAgdmFyIHhtbFNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICAgICAgICAgIHJldHVybiB4bWxTZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGaXJlZm94IDExLSBkbyBub3Qgc3VwcG9ydCBvdXRlckhUTUxcbiAgICAgICAgICAvLyAgIEl0IGRvZXMsIGhvd2V2ZXIsIHN1cHBvcnQgaW5uZXJIVE1MXG4gICAgICAgICAgLy8gICBVc2UgdGhlIGZvbGxvd2luZyB0byByZW5kZXIgdGhlIGVsZW1lbnRcbiAgICAgICAgICB2YXIgbnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAnXycpO1xuXG4gICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHZhbHVlLmNsb25lTm9kZShmYWxzZSkpO1xuICAgICAgICAgIGh0bWwgPSBjb250YWluZXIuaW5uZXJIVE1MXG4gICAgICAgICAgICAucmVwbGFjZSgnPjwnLCAnPicgKyB2YWx1ZS5pbm5lckhUTUwgKyAnPCcpO1xuICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgYSBub24tbmF0aXZlIERPTSBpbXBsZW1lbnRhdGlvbixcbiAgICAgICAgLy8gICBjb250aW51ZSB3aXRoIHRoZSBub3JtYWwgZmxvdzpcbiAgICAgICAgLy8gICBwcmludGluZyB0aGUgZWxlbWVudCBhcyBpZiBpdCBpcyBhbiBvYmplY3QuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIgdmlzaWJsZUtleXMgPSBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyh2YWx1ZSk7XG4gIHZhciBrZXlzID0gY3R4LnNob3dIaWRkZW4gPyBnZXRQcm9wZXJ0aWVzKHZhbHVlKSA6IHZpc2libGVLZXlzO1xuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgLy8gSW4gSUUsIGVycm9ycyBoYXZlIGEgc2luZ2xlIGBzdGFja2AgcHJvcGVydHksIG9yIGlmIHRoZXkgYXJlIHZhbmlsbGEgYEVycm9yYCxcbiAgLy8gYSBgc3RhY2tgIHBsdXMgYGRlc2NyaXB0aW9uYCBwcm9wZXJ0eTsgaWdub3JlIHRob3NlIGZvciBjb25zaXN0ZW5jeS5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwIHx8IChpc0Vycm9yKHZhbHVlKSAmJiAoXG4gICAgICAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJ3N0YWNrJykgfHxcbiAgICAgIChrZXlzLmxlbmd0aCA9PT0gMiAmJiBrZXlzWzBdID09PSAnZGVzY3JpcHRpb24nICYmIGtleXNbMV0gPT09ICdzdGFjaycpXG4gICAgICkpKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIG5hbWUgPSBnZXROYW1lKHZhbHVlKTtcbiAgICAgIHZhciBuYW1lU3VmZml4ID0gbmFtZSA/ICc6ICcgKyBuYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lU3VmZml4ICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgbmFtZSA9IGdldE5hbWUodmFsdWUpO1xuICAgIHZhciBuYW1lU3VmZml4ID0gbmFtZSA/ICc6ICcgKyBuYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG5hbWVTdWZmaXggKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAodmFsdWUgPT09IDAgJiYgKDEvdmFsdWUpID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCctMCcsICdudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICB9XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyO1xuICBpZiAodmFsdWUuX19sb29rdXBHZXR0ZXJfXykge1xuICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKGtleSkpIHtcbiAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2aXNpYmxlS2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKHZhbHVlW2tleV0pIDwgMCkge1xuICAgICAgaWYgKHJlY3Vyc2VUaW1lcyA9PT0gbnVsbCkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlW2tleV0sIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKSB8fFxuICAgICAgICAgKHR5cGVvZiBhciA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoYXIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIHR5cGVvZiByZSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIHR5cGVvZiBkID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJztcbn1cblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLyohXG4gKiBDaGFpIC0gZmxhZyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuLyoqXG4gKiAjIyMgLm9iakRpc3BsYXkgKG9iamVjdClcbiAqXG4gKiBEZXRlcm1pbmVzIGlmIGFuIG9iamVjdCBvciBhbiBhcnJheSBtYXRjaGVzXG4gKiBjcml0ZXJpYSB0byBiZSBpbnNwZWN0ZWQgaW4tbGluZSBmb3IgZXJyb3JcbiAqIG1lc3NhZ2VzIG9yIHNob3VsZCBiZSB0cnVuY2F0ZWQuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gamF2YXNjcmlwdCBvYmplY3QgdG8gaW5zcGVjdFxuICogQG5hbWUgb2JqRGlzcGxheVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9IGluc3BlY3Qob2JqKVxuICAgICwgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuXG4gIGlmIChjb25maWcudHJ1bmNhdGVUaHJlc2hvbGQgJiYgc3RyLmxlbmd0aCA+PSBjb25maWcudHJ1bmNhdGVUaHJlc2hvbGQpIHtcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgcmV0dXJuICFvYmoubmFtZSB8fCBvYmoubmFtZSA9PT0gJydcbiAgICAgICAgPyAnW0Z1bmN0aW9uXSdcbiAgICAgICAgOiAnW0Z1bmN0aW9uOiAnICsgb2JqLm5hbWUgKyAnXSc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm4gJ1sgQXJyYXkoJyArIG9iai5sZW5ndGggKyAnKSBdJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLCBrc3RyID0ga2V5cy5sZW5ndGggPiAyXG4gICAgICAgICAgPyBrZXlzLnNwbGljZSgwLCAyKS5qb2luKCcsICcpICsgJywgLi4uJ1xuICAgICAgICAgIDoga2V5cy5qb2luKCcsICcpO1xuICAgICAgcmV0dXJuICd7IE9iamVjdCAoJyArIGtzdHIgKyAnKSB9JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kIChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcilcbiAqXG4gKiBPdmVyd2l0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBjaGFpbmFibGUgbWV0aG9kXG4gKiBhbmQgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBvclxuICogcHJvcGVydHkuICBNdXN0IHJldHVybiBmdW5jdGlvbnMgdG8gYmUgdXNlZCBmb3JcbiAqIG5hbWUuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdsZW5ndGgnLFxuICogICAgICAgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICwgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoJ2ZvbycsIGZuLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmhhdmUubGVuZ3RoKDMpO1xuICogICAgIGV4cGVjdChteUZvbykudG8uaGF2ZS5sZW5ndGguYWJvdmUoMyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgbWV0aG9kIC8gcHJvcGVydHkgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCAvIHByb3BlcnR5IHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoYWluaW5nQmVoYXZpb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgcHJvcGVydHlcbiAqIEBuYW1lIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcikge1xuICB2YXIgY2hhaW5hYmxlQmVoYXZpb3IgPSBjdHguX19tZXRob2RzW25hbWVdO1xuXG4gIHZhciBfY2hhaW5pbmdCZWhhdmlvciA9IGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3I7XG4gIGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNoYWluaW5nQmVoYXZpb3IoX2NoYWluaW5nQmVoYXZpb3IpLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgfTtcblxuICB2YXIgX21ldGhvZCA9IGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZDtcbiAgY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX21ldGhvZCkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICB9O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZU1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgb3ZlcndyaXRlTWV0aG9kIChjdHgsIG5hbWUsIGZuKVxuICpcbiAqIE92ZXJ3aXRlcyBhbiBhbHJlYWR5IGV4aXN0aW5nIG1ldGhvZCBhbmQgcHJvdmlkZXNcbiAqIGFjY2VzcyB0byBwcmV2aW91cyBmdW5jdGlvbi4gTXVzdCByZXR1cm4gZnVuY3Rpb25cbiAqIHRvIGJlIHVzZWQgZm9yIG5hbWUuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdlcXVhbCcsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEZvbykge1xuICogICAgICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmoudmFsdWUpLnRvLmVxdWFsKHN0cik7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5lcXVhbCgnYmFyJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgbWV0aG9kIGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gb3ZlcndyaXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWUgb3ZlcndyaXRlTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGN0eCwgbmFtZSwgbWV0aG9kKSB7XG4gIHZhciBfbWV0aG9kID0gY3R4W25hbWVdXG4gICAgLCBfc3VwZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG4gIGlmIChfbWV0aG9kICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBfbWV0aG9kKVxuICAgIF9zdXBlciA9IF9tZXRob2Q7XG5cbiAgY3R4W25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX3N1cGVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVQcm9wZXJ0eSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgb3ZlcndyaXRlUHJvcGVydHkgKGN0eCwgbmFtZSwgZm4pXG4gKlxuICogT3ZlcndpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgcHJvcGVydHkgZ2V0dGVyIGFuZCBwcm92aWRlc1xuICogYWNjZXNzIHRvIHByZXZpb3VzIHZhbHVlLiBNdXN0IHJldHVybiBmdW5jdGlvbiB0byB1c2UgYXMgZ2V0dGVyLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVQcm9wZXJ0eShjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdvaycsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEZvbykge1xuICogICAgICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmoubmFtZSkudG8uZXF1YWwoJ2JhcicpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlUHJvcGVydHkoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uYmUub2s7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHByb3BlcnR5IHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGdldHRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZSBvdmVyd3JpdGVQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIGdldHRlcikge1xuICB2YXIgX2dldCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3R4LCBuYW1lKVxuICAgICwgX3N1cGVyID0gZnVuY3Rpb24gKCkge307XG5cbiAgaWYgKF9nZXQgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIF9nZXQuZ2V0KVxuICAgIF9zdXBlciA9IF9nZXQuZ2V0XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyKF9zdXBlcikuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSB0ZXN0IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRhbmNpZXNcbiAqL1xuXG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG4vKipcbiAqICMgdGVzdChvYmplY3QsIGV4cHJlc3Npb24pXG4gKlxuICogVGVzdCBhbmQgb2JqZWN0IGZvciBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgYXJncykge1xuICB2YXIgbmVnYXRlID0gZmxhZyhvYmosICduZWdhdGUnKVxuICAgICwgZXhwciA9IGFyZ3NbMF07XG4gIHJldHVybiBuZWdhdGUgPyAhZXhwciA6IGV4cHI7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gdHJhbnNmZXJGbGFncyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgdHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG9iamVjdCwgaW5jbHVkZUFsbCA9IHRydWUpXG4gKlxuICogVHJhbnNmZXIgYWxsIHRoZSBmbGFncyBmb3IgYGFzc2VydGlvbmAgdG8gYG9iamVjdGAuIElmXG4gKiBgaW5jbHVkZUFsbGAgaXMgc2V0IHRvIGBmYWxzZWAsIHRoZW4gdGhlIGJhc2UgQ2hhaVxuICogYXNzZXJ0aW9uIGZsYWdzIChuYW1lbHkgYG9iamVjdGAsIGBzc2ZpYCwgYW5kIGBtZXNzYWdlYClcbiAqIHdpbGwgbm90IGJlIHRyYW5zZmVycmVkLlxuICpcbiAqXG4gKiAgICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBBc3NlcnRpb24oKTtcbiAqICAgICB1dGlscy50cmFuc2ZlckZsYWdzKGFzc2VydGlvbiwgbmV3QXNzZXJ0aW9uKTtcbiAqXG4gKiAgICAgdmFyIGFub3RoZXJBc3Nlcml0b24gPSBuZXcgQXNzZXJ0aW9uKG15T2JqKTtcbiAqICAgICB1dGlscy50cmFuc2ZlckZsYWdzKGFzc2VydGlvbiwgYW5vdGhlckFzc2VydGlvbiwgZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7QXNzZXJ0aW9ufSBhc3NlcnRpb24gdGhlIGFzc2VydGlvbiB0byB0cmFuc2ZlciB0aGUgZmxhZ3MgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0aGUgb2JqZWN0IHRvIHRyYW5zZmVyIHRoZSBmbGFncyB0bzsgdXN1YWxseSBhIG5ldyBhc3NlcnRpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZUFsbFxuICogQG5hbWUgdHJhbnNmZXJGbGFnc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBvYmplY3QsIGluY2x1ZGVBbGwpIHtcbiAgdmFyIGZsYWdzID0gYXNzZXJ0aW9uLl9fZmxhZ3MgfHwgKGFzc2VydGlvbi5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgaWYgKCFvYmplY3QuX19mbGFncykge1xuICAgIG9iamVjdC5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIGluY2x1ZGVBbGwgPSBhcmd1bWVudHMubGVuZ3RoID09PSAzID8gaW5jbHVkZUFsbCA6IHRydWU7XG5cbiAgZm9yICh2YXIgZmxhZyBpbiBmbGFncykge1xuICAgIGlmIChpbmNsdWRlQWxsIHx8XG4gICAgICAgIChmbGFnICE9PSAnb2JqZWN0JyAmJiBmbGFnICE9PSAnc3NmaScgJiYgZmxhZyAhPSAnbWVzc2FnZScpKSB7XG4gICAgICBvYmplY3QuX19mbGFnc1tmbGFnXSA9IGZsYWdzW2ZsYWddO1xuICAgIH1cbiAgfVxufTtcbiIsIi8qIVxuICogYXNzZXJ0aW9uLWVycm9yXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIgPGpha2VAcXVhbGlhbmN5LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBvbmUgb2JqZWN0IHRvIGFub3RoZXIgZXhjbHVkaW5nIGFueSBvcmlnaW5hbGx5XG4gKiBsaXN0ZWQuIFJldHVybmVkIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGEgbmV3IGB7fWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4Y2x1ZGVkIHByb3BlcnRpZXMgLi4uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBleGNsdWRlICgpIHtcbiAgdmFyIGV4Y2x1ZGVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIGZ1bmN0aW9uIGV4Y2x1ZGVQcm9wcyAocmVzLCBvYmopIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCF+ZXhjbHVkZXMuaW5kZXhPZihrZXkpKSByZXNba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGV4dGVuZEV4Y2x1ZGUgKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAsIGkgPSAwXG4gICAgICAsIHJlcyA9IHt9O1xuXG4gICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleGNsdWRlUHJvcHMocmVzLCBhcmdzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VydGlvbkVycm9yO1xuXG4vKipcbiAqICMjIyBBc3NlcnRpb25FcnJvclxuICpcbiAqIEFuIGV4dGVuc2lvbiBvZiB0aGUgSmF2YVNjcmlwdCBgRXJyb3JgIGNvbnN0cnVjdG9yIGZvclxuICogYXNzZXJ0aW9uIGFuZCB2YWxpZGF0aW9uIHNjZW5hcmlvcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgdG8gaW5jbHVkZSAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge2NhbGxlZX0gc3RhcnQgc3RhY2sgZnVuY3Rpb24gKG9wdGlvbmFsKVxuICovXG5cbmZ1bmN0aW9uIEFzc2VydGlvbkVycm9yIChtZXNzYWdlLCBfcHJvcHMsIHNzZikge1xuICB2YXIgZXh0ZW5kID0gZXhjbHVkZSgnbmFtZScsICdtZXNzYWdlJywgJ3N0YWNrJywgJ2NvbnN0cnVjdG9yJywgJ3RvSlNPTicpXG4gICAgLCBwcm9wcyA9IGV4dGVuZChfcHJvcHMgfHwge30pO1xuXG4gIC8vIGRlZmF1bHQgdmFsdWVzXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Vuc3BlY2lmaWVkIEFzc2VydGlvbkVycm9yJztcbiAgdGhpcy5zaG93RGlmZiA9IGZhbHNlO1xuXG4gIC8vIGNvcHkgZnJvbSBwcm9wZXJ0aWVzXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHRoaXNba2V5XSA9IHByb3BzW2tleV07XG4gIH1cblxuICAvLyBjYXB0dXJlIHN0YWNrIHRyYWNlXG4gIHNzZiA9IHNzZiB8fCBhcmd1bWVudHMuY2FsbGVlO1xuICBpZiAoc3NmICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3NmKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH1cbn1cblxuLyohXG4gKiBJbmhlcml0IGZyb20gRXJyb3IucHJvdG90eXBlXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG4vKiFcbiAqIFN0YXRpY2FsbHkgc2V0IG5hbWVcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG5cbi8qIVxuICogRW5zdXJlIGNvcnJlY3QgY29uc3RydWN0b3JcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqXG4gKiBBbGxvdyBlcnJvcnMgdG8gYmUgY29udmVydGVkIHRvIEpTT04gZm9yIHN0YXRpYyB0cmFuc2Zlci5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGUgc3RhY2sgKGRlZmF1bHQ6IGB0cnVlYClcbiAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHRoYXQgY2FuIGJlIGBKU09OLnN0cmluZ2lmeWBcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gIHZhciBleHRlbmQgPSBleGNsdWRlKCdjb25zdHJ1Y3RvcicsICd0b0pTT04nLCAnc3RhY2snKVxuICAgICwgcHJvcHMgPSBleHRlbmQoeyBuYW1lOiB0aGlzLm5hbWUgfSwgdGhpcyk7XG5cbiAgLy8gaW5jbHVkZSBzdGFjayBpZiBleGlzdHMgYW5kIG5vdCB0dXJuZWQgb2ZmXG4gIGlmIChmYWxzZSAhPT0gc3RhY2sgJiYgdGhpcy5zdGFjaykge1xuICAgIHByb3BzLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2VxbCcpO1xuIiwiLyohXG4gKiBkZWVwLWVxbFxuICogQ29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5cbi8qIVxuICogQnVmZmVyLmlzQnVmZmVyIGJyb3dzZXIgc2hpbVxuICovXG5cbnZhciBCdWZmZXI7XG50cnkgeyBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7IH1cbmNhdGNoKGV4KSB7XG4gIEJ1ZmZlciA9IHt9O1xuICBCdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBFcXVhbDtcblxuLyoqXG4gKiBBc3NlcnQgc3VwZXItc3RyaWN0IChlZ2FsKSBlcXVhbGl0eSBiZXR3ZWVuXG4gKiB0d28gb2JqZWN0cyBvZiBhbnkgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcGFyYW0ge0FycmF5fSBtZW1vaXNlZCAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuICovXG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiLCBtKSB7XG4gIGlmIChzYW1lVmFsdWUoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICgnZGF0ZScgPT09IHR5cGUoYSkpIHtcbiAgICByZXR1cm4gZGF0ZUVxdWFsKGEsIGIpO1xuICB9IGVsc2UgaWYgKCdyZWdleHAnID09PSB0eXBlKGEpKSB7XG4gICAgcmV0dXJuIHJlZ2V4cEVxdWFsKGEsIGIpO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhKSkge1xuICAgIHJldHVybiBidWZmZXJFcXVhbChhLCBiKTtcbiAgfSBlbHNlIGlmICgnYXJndW1lbnRzJyA9PT0gdHlwZShhKSkge1xuICAgIHJldHVybiBhcmd1bWVudHNFcXVhbChhLCBiLCBtKTtcbiAgfSBlbHNlIGlmICghdHlwZUVxdWFsKGEsIGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKCgnb2JqZWN0JyAhPT0gdHlwZShhKSAmJiAnb2JqZWN0JyAhPT0gdHlwZShiKSlcbiAgJiYgKCdhcnJheScgIT09IHR5cGUoYSkgJiYgJ2FycmF5JyAhPT0gdHlwZShiKSkpIHtcbiAgICByZXR1cm4gc2FtZVZhbHVlKGEsIGIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmplY3RFcXVhbChhLCBiLCBtKTtcbiAgfVxufVxuXG4vKiFcbiAqIFN0cmljdCAoZWdhbCkgZXF1YWxpdHkgdGVzdC4gRW5zdXJlcyB0aGF0IE5hTiBhbHdheXNcbiAqIGVxdWFscyBOYU4gYW5kIGAtMGAgZG9lcyBub3QgZXF1YWwgYCswYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuICovXG5cbmZ1bmN0aW9uIHNhbWVWYWx1ZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0aGUgdHlwZXMgb2YgdHdvIGdpdmVuIG9iamVjdHMgYW5kXG4gKiByZXR1cm4gaWYgdGhleSBhcmUgZXF1YWwuIE5vdGUgdGhhdCBhbiBBcnJheVxuICogaGFzIGEgdHlwZSBvZiBgYXJyYXlgIChub3QgYG9iamVjdGApIGFuZCBhcmd1bWVudHNcbiAqIGhhdmUgYSB0eXBlIG9mIGBhcmd1bWVudHNgIChub3QgYGFycmF5YC9gb2JqZWN0YCkuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gdHlwZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIHR5cGUoYSkgPT09IHR5cGUoYik7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gRGF0ZSBvYmplY3RzIGJ5IGFzc2VydGluZyB0aGF0XG4gKiB0aGUgdGltZSB2YWx1ZXMgYXJlIGVxdWFsIHVzaW5nIGBzYXZlVmFsdWVgLlxuICpcbiAqIEBwYXJhbSB7RGF0ZX0gYVxuICogQHBhcmFtIHtEYXRlfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBkYXRlRXF1YWwoYSwgYikge1xuICBpZiAoJ2RhdGUnICE9PSB0eXBlKGIpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBzYW1lVmFsdWUoYS5nZXRUaW1lKCksIGIuZ2V0VGltZSgpKTtcbn1cblxuLyohXG4gKiBDb21wYXJlIHR3byByZWd1bGFyIGV4cHJlc3Npb25zIGJ5IGNvbnZlcnRpbmcgdGhlbVxuICogdG8gc3RyaW5nIGFuZCBjaGVja2luZyBmb3IgYHNhbWVWYWx1ZWAuXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IGFcbiAqIEBwYXJhbSB7UmVnRXhwfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiByZWdleHBFcXVhbChhLCBiKSB7XG4gIGlmICgncmVnZXhwJyAhPT0gdHlwZShiKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gc2FtZVZhbHVlKGEudG9TdHJpbmcoKSwgYi50b1N0cmluZygpKTtcbn1cblxuLyohXG4gKiBBc3NlcnQgZGVlcCBlcXVhbGl0eSBvZiB0d28gYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAqIFVuZm9ydHVuYXRlbHksIHRoZXNlIG11c3QgYmUgc2xpY2VkIHRvIGFycmF5c1xuICogcHJpb3IgdG8gdGVzdCB0byBlbnN1cmUgbm8gYmFkIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBhXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gYlxuICogQHBhcmFtIHtBcnJheX0gbWVtb2l6ZSAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBhcmd1bWVudHNFcXVhbChhLCBiLCBtKSB7XG4gIGlmICgnYXJndW1lbnRzJyAhPT0gdHlwZShiKSkgcmV0dXJuIGZhbHNlO1xuICBhID0gW10uc2xpY2UuY2FsbChhKTtcbiAgYiA9IFtdLnNsaWNlLmNhbGwoYik7XG4gIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgbSk7XG59XG5cbi8qIVxuICogR2V0IGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHJldHVybiB7QXJyYXl9IHByb3BlcnR5IG5hbWVzXG4gKi9cblxuZnVuY3Rpb24gZW51bWVyYWJsZShhKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIGEpIHJlcy5wdXNoKGtleSk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qIVxuICogU2ltcGxlIGVxdWFsaXR5IGZvciBmbGF0IGl0ZXJhYmxlIG9iamVjdHNcbiAqIHN1Y2ggYXMgQXJyYXlzIG9yIE5vZGUuanMgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBhXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBpdGVyYWJsZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSAgYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICB2YXIgaSA9IDA7XG4gIHZhciBtYXRjaCA9IHRydWU7XG5cbiAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbi8qIVxuICogRXh0ZW5zaW9uIHRvIGBpdGVyYWJsZUVxdWFsYCBzcGVjaWZpY2FsbHlcbiAqIGZvciBOb2RlLmpzIEJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGJ1ZmZlckVxdWFsKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwoYSwgYik7XG59XG5cbi8qIVxuICogQmxvY2sgZm9yIGBvYmplY3RFcXVhbGAgZW5zdXJpbmcgbm9uLWV4aXN0aW5nXG4gKiB2YWx1ZXMgZG9uJ3QgZ2V0IGluLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gaXNWYWx1ZShhKSB7XG4gIHJldHVybiBhICE9PSBudWxsICYmIGEgIT09IHVuZGVmaW5lZDtcbn1cblxuLyohXG4gKiBSZWN1cnNpdmVseSBjaGVjayB0aGUgZXF1YWxpdHkgb2YgdHdvIG9iamVjdHMuXG4gKiBPbmNlIGJhc2ljIHNhbWVuZXNzIGhhcyBiZWVuIGVzdGFibGlzaGVkIGl0IHdpbGxcbiAqIGRlZmVyIHRvIGBkZWVwRXF1YWxgIGZvciBlYWNoIGVudW1lcmFibGUga2V5XG4gKiBpbiB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIG9iamVjdEVxdWFsKGEsIGIsIG0pIHtcbiAgaWYgKCFpc1ZhbHVlKGEpIHx8ICFpc1ZhbHVlKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpO1xuICBpZiAobSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKG1baV1bMF0gPT09IGEgJiYgbVtpXVsxXSA9PT0gYilcbiAgICAgIHx8ICAobVtpXVswXSA9PT0gYiAmJiBtW2ldWzFdID09PSBhKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbSA9IFtdO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBlbnVtZXJhYmxlKGEpO1xuICAgIHZhciBrYiA9IGVudW1lcmFibGUoYik7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG5cbiAgaWYgKCFpdGVyYWJsZUVxdWFsKGthLCBrYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtLnB1c2goWyBhLCBiIF0pO1xuXG4gIHZhciBrZXk7XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3R5cGUnKTtcbiIsIi8qIVxuICogdHlwZS1kZXRlY3RcbiAqIENvcHlyaWdodChjKSAyMDEzIGpha2UgbHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydHNcbiAqL1xuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZ2V0VHlwZTtcblxuLyohXG4gKiBEZXRlY3RhYmxlIGphdmFzY3JpcHQgbmF0aXZlc1xuICovXG5cbnZhciBuYXRpdmVzID0ge1xuICAgICdbb2JqZWN0IEFycmF5XSc6ICdhcnJheSdcbiAgLCAnW29iamVjdCBSZWdFeHBdJzogJ3JlZ2V4cCdcbiAgLCAnW29iamVjdCBGdW5jdGlvbl0nOiAnZnVuY3Rpb24nXG4gICwgJ1tvYmplY3QgQXJndW1lbnRzXSc6ICdhcmd1bWVudHMnXG4gICwgJ1tvYmplY3QgRGF0ZV0nOiAnZGF0ZSdcbn07XG5cbi8qKlxuICogIyMjIHR5cGVPZiAob2JqKVxuICpcbiAqIFVzZSBzZXZlcmFsIGRpZmZlcmVudCB0ZWNobmlxdWVzIHRvIGRldGVybWluZVxuICogdGhlIHR5cGUgb2Ygb2JqZWN0IGJlaW5nIHRlc3RlZC5cbiAqXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IG9iamVjdCB0eXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGdldFR5cGUgKG9iaikge1xuICB2YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gIGlmIChuYXRpdmVzW3N0cl0pIHJldHVybiBuYXRpdmVzW3N0cl07XG4gIGlmIChvYmogPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAob2JqID09PSBPYmplY3Qob2JqKSkgcmV0dXJuICdvYmplY3QnO1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn1cblxuZXhwb3J0cy5MaWJyYXJ5ID0gTGlicmFyeTtcblxuLyoqXG4gKiAjIyMgTGlicmFyeVxuICpcbiAqIENyZWF0ZSBhIHJlcG9zaXRvcnkgZm9yIGN1c3RvbSB0eXBlIGRldGVjdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxpYiA9IG5ldyB0eXBlLkxpYnJhcnk7XG4gKiBgYGBcbiAqXG4gKi9cblxuZnVuY3Rpb24gTGlicmFyeSAoKSB7XG4gIHRoaXMudGVzdHMgPSB7fTtcbn1cblxuLyoqXG4gKiAjIyMjIC5vZiAob2JqKVxuICpcbiAqIEV4cG9zZSByZXBsYWNlbWVudCBgdHlwZW9mYCBkZXRlY3Rpb24gdG8gdGhlIGxpYnJhcnkuXG4gKlxuICogYGBganNcbiAqIGlmICgnc3RyaW5nJyA9PT0gbGliLm9mKCdoZWxsbyB3b3JsZCcpKSB7XG4gKiAgIC8vIC4uLlxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAqIEByZXR1cm4ge1N0cmluZ30gdHlwZVxuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLm9mID0gZ2V0VHlwZTtcblxuLyoqXG4gKiAjIyMjIC5kZWZpbmUgKHR5cGUsIHRlc3QpXG4gKlxuICogQWRkIGEgdGVzdCB0byBmb3IgdGhlIGAudGVzdCgpYCBhc3NlcnRpb24uXG4gKlxuICogQ2FuIGJlIGRlZmluZWQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb246XG4gKlxuICogYGBganNcbiAqIGxpYi5kZWZpbmUoJ2ludCcsIC9eWzAtOV0rJC8pO1xuICogYGBgXG4gKlxuICogLi4uIG9yIGFzIGEgZnVuY3Rpb246XG4gKlxuICogYGBganNcbiAqIGxpYi5kZWZpbmUoJ2JsbicsIGZ1bmN0aW9uIChvYmopIHtcbiAqICAgaWYgKCdib29sZWFuJyA9PT0gbGliLm9mKG9iaikpIHJldHVybiB0cnVlO1xuICogICB2YXIgYmxucyA9IFsgJ3llcycsICdubycsICd0cnVlJywgJ2ZhbHNlJywgMSwgMCBdO1xuICogICBpZiAoJ3N0cmluZycgPT09IGxpYi5vZihvYmopKSBvYmogPSBvYmoudG9Mb3dlckNhc2UoKTtcbiAqICAgcmV0dXJuICEhIH5ibG5zLmluZGV4T2Yob2JqKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7UmVnRXhwfEZ1bmN0aW9ufSB0ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uICh0eXBlLCB0ZXN0KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy50ZXN0c1t0eXBlXTtcbiAgdGhpcy50ZXN0c1t0eXBlXSA9IHRlc3Q7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiAjIyMjIC50ZXN0IChvYmosIHRlc3QpXG4gKlxuICogQXNzZXJ0IHRoYXQgYW4gb2JqZWN0IGlzIG9mIHR5cGUuIFdpbGwgZmlyc3RcbiAqIGNoZWNrIG5hdGl2ZXMsIGFuZCBpZiB0aGF0IGRvZXMgbm90IHBhc3MgaXQgd2lsbFxuICogdXNlIHRoZSB1c2VyIGRlZmluZWQgY3VzdG9tIHRlc3RzLlxuICpcbiAqIGBgYGpzXG4gKiBhc3NlcnQobGliLnRlc3QoJzEnLCAnaW50JykpO1xuICogYXNzZXJ0KGxpYi50ZXN0KCd5ZXMnLCAnYmxuJykpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAob2JqLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSBnZXRUeXBlKG9iaikpIHJldHVybiB0cnVlO1xuICB2YXIgdGVzdCA9IHRoaXMudGVzdHNbdHlwZV07XG5cbiAgaWYgKHRlc3QgJiYgJ3JlZ2V4cCcgPT09IGdldFR5cGUodGVzdCkpIHtcbiAgICByZXR1cm4gdGVzdC50ZXN0KG9iaik7XG4gIH0gZWxzZSBpZiAodGVzdCAmJiAnZnVuY3Rpb24nID09PSBnZXRUeXBlKHRlc3QpKSB7XG4gICAgcmV0dXJuIHRlc3Qob2JqKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1R5cGUgdGVzdCBcIicgKyB0eXBlICsgJ1wiIG5vdCBkZWZpbmVkIG9yIGludmFsaWQuJyk7XG4gIH1cbn07XG4iLCIvKiFcbiAqIHR5cGUtZGV0ZWN0XG4gKiBDb3B5cmlnaHQoYykgMjAxMyBqYWtlIGx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRzXG4gKi9cblxudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGdldFR5cGU7XG5cbi8qKlxuICogIyMjIHR5cGVPZiAob2JqKVxuICpcbiAqIFVzZSBzZXZlcmFsIGRpZmZlcmVudCB0ZWNobmlxdWVzIHRvIGRldGVybWluZVxuICogdGhlIHR5cGUgb2Ygb2JqZWN0IGJlaW5nIHRlc3RlZC5cbiAqXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IG9iamVjdCB0eXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG52YXIgb2JqZWN0VHlwZVJlZ2V4cCA9IC9eXFxbb2JqZWN0ICguKilcXF0kLztcblxuZnVuY3Rpb24gZ2V0VHlwZShvYmopIHtcbiAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKS5tYXRjaChvYmplY3RUeXBlUmVnZXhwKVsxXS50b0xvd2VyQ2FzZSgpO1xuICAvLyBMZXQgXCJuZXcgU3RyaW5nKCcnKVwiIHJldHVybiAnb2JqZWN0J1xuICBpZiAodHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgJiYgb2JqIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuICdwcm9taXNlJztcbiAgLy8gUGhhbnRvbUpTIGhhcyB0eXBlIFwiRE9NV2luZG93XCIgZm9yIG51bGxcbiAgaWYgKG9iaiA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgLy8gUGhhbnRvbUpTIGhhcyB0eXBlIFwiRE9NV2luZG93XCIgZm9yIHVuZGVmaW5lZFxuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydHMuTGlicmFyeSA9IExpYnJhcnk7XG5cbi8qKlxuICogIyMjIExpYnJhcnlcbiAqXG4gKiBDcmVhdGUgYSByZXBvc2l0b3J5IGZvciBjdXN0b20gdHlwZSBkZXRlY3Rpb24uXG4gKlxuICogYGBganNcbiAqIHZhciBsaWIgPSBuZXcgdHlwZS5MaWJyYXJ5O1xuICogYGBgXG4gKlxuICovXG5cbmZ1bmN0aW9uIExpYnJhcnkoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaWJyYXJ5KSkgcmV0dXJuIG5ldyBMaWJyYXJ5KCk7XG4gIHRoaXMudGVzdHMgPSB7fTtcbn1cblxuLyoqXG4gKiAjIyMjIC5vZiAob2JqKVxuICpcbiAqIEV4cG9zZSByZXBsYWNlbWVudCBgdHlwZW9mYCBkZXRlY3Rpb24gdG8gdGhlIGxpYnJhcnkuXG4gKlxuICogYGBganNcbiAqIGlmICgnc3RyaW5nJyA9PT0gbGliLm9mKCdoZWxsbyB3b3JsZCcpKSB7XG4gKiAgIC8vIC4uLlxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAqIEByZXR1cm4ge1N0cmluZ30gdHlwZVxuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLm9mID0gZ2V0VHlwZTtcblxuLyoqXG4gKiAjIyMjIC5kZWZpbmUgKHR5cGUsIHRlc3QpXG4gKlxuICogQWRkIGEgdGVzdCB0byBmb3IgdGhlIGAudGVzdCgpYCBhc3NlcnRpb24uXG4gKlxuICogQ2FuIGJlIGRlZmluZWQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb246XG4gKlxuICogYGBganNcbiAqIGxpYi5kZWZpbmUoJ2ludCcsIC9eWzAtOV0rJC8pO1xuICogYGBgXG4gKlxuICogLi4uIG9yIGFzIGEgZnVuY3Rpb246XG4gKlxuICogYGBganNcbiAqIGxpYi5kZWZpbmUoJ2JsbicsIGZ1bmN0aW9uIChvYmopIHtcbiAqICAgaWYgKCdib29sZWFuJyA9PT0gbGliLm9mKG9iaikpIHJldHVybiB0cnVlO1xuICogICB2YXIgYmxucyA9IFsgJ3llcycsICdubycsICd0cnVlJywgJ2ZhbHNlJywgMSwgMCBdO1xuICogICBpZiAoJ3N0cmluZycgPT09IGxpYi5vZihvYmopKSBvYmogPSBvYmoudG9Mb3dlckNhc2UoKTtcbiAqICAgcmV0dXJuICEhIH5ibG5zLmluZGV4T2Yob2JqKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7UmVnRXhwfEZ1bmN0aW9ufSB0ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uKHR5cGUsIHRlc3QpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLnRlc3RzW3R5cGVdO1xuICB0aGlzLnRlc3RzW3R5cGVdID0gdGVzdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqICMjIyMgLnRlc3QgKG9iaiwgdGVzdClcbiAqXG4gKiBBc3NlcnQgdGhhdCBhbiBvYmplY3QgaXMgb2YgdHlwZS4gV2lsbCBmaXJzdFxuICogY2hlY2sgbmF0aXZlcywgYW5kIGlmIHRoYXQgZG9lcyBub3QgcGFzcyBpdCB3aWxsXG4gKiB1c2UgdGhlIHVzZXIgZGVmaW5lZCBjdXN0b20gdGVzdHMuXG4gKlxuICogYGBganNcbiAqIGFzc2VydChsaWIudGVzdCgnMScsICdpbnQnKSk7XG4gKiBhc3NlcnQobGliLnRlc3QoJ3llcycsICdibG4nKSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlicmFyeS5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKG9iaiwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gZ2V0VHlwZShvYmopKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIHRlc3QgPSB0aGlzLnRlc3RzW3R5cGVdO1xuXG4gIGlmICh0ZXN0ICYmICdyZWdleHAnID09PSBnZXRUeXBlKHRlc3QpKSB7XG4gICAgcmV0dXJuIHRlc3QudGVzdChvYmopO1xuICB9IGVsc2UgaWYgKHRlc3QgJiYgJ2Z1bmN0aW9uJyA9PT0gZ2V0VHlwZSh0ZXN0KSkge1xuICAgIHJldHVybiB0ZXN0KG9iaik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdUeXBlIHRlc3QgXCInICsgdHlwZSArICdcIiBub3QgZGVmaW5lZCBvciBpbnZhbGlkLicpO1xuICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4oZnVuY3Rpb24oZml4dHVyZXMpe1xuICAgIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZUpTXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZml4dHVyZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpe1xuICAgICAgICBkZWZpbmUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiBmaXh0dXJlcztcbiAgICAgICAgfSk7XG4gICAgfSBlbHNle1xuICAgICAgICB2YXIgZ2xvYmFsID0gKGZhbHNlIHx8IGV2YWwpKCd0aGlzJyk7XG4gICAgICAgIGdsb2JhbC5maXh0dXJlcyA9IGZpeHR1cmVzO1xuICAgIH1cblxufShuZXcgZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGZpeHR1cmVzQ2FjaGUgPSB7fTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHNlbGYuY29udGFpbmVySWQgPSAnanMtZml4dHVyZXMnO1xuICAgICAgICBzZWxmLnBhdGggPSAnc3BlYy9qYXZhc2NyaXB0cy9maXh0dXJlcyc7XG4gICAgICAgIHNlbGYud2luZG93ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLmNvbnRhaW5lcklkKTtcbiAgICAgICAgICAgIGlmICghaWZyYW1lKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIGlmcmFtZS5jb250ZW50V2luZG93IHx8IGlmcmFtZS5jb250ZW50RG9jdW1lbnQ7IFxuICAgICAgICB9O1xuICAgICAgICBzZWxmLmJvZHkgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKCFzZWxmLndpbmRvdygpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBzZWxmLndpbmRvdygpLmRvY3VtZW50LmJvZHkuaW5uZXJIVE1MO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7IFxuICAgICAgICB9O1xuICAgICAgICBzZWxmLmxvYWQgPSBmdW5jdGlvbihodG1sKXtcbiAgICAgICAgICAgIHZhciBjYiA9IHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nID8gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLTFdIDogbnVsbDtcbiAgICAgICAgICAgIGFkZFRvQ29udGFpbmVyKHNlbGYucmVhZC5hcHBseShzZWxmLCBhcmd1bWVudHMpLCBjYik7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuc2V0ID0gZnVuY3Rpb24oaHRtbCl7XG4gICAgICAgICAgICBhZGRUb0NvbnRhaW5lcihodG1sKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5jYWNoZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLnJlYWQuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5zYW5kYm94ID0gZnVuY3Rpb24ob2JqKXtcbiAgICAgICAgICAgIGFkZFRvQ29udGFpbmVyKG9ialRvSFRNTChvYmopKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5yZWFkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBodG1sQ2h1bmtzID0gJyc7XG5cbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkuZm9yRWFjaChmdW5jdGlvbihhcmd1bWVudCl7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N0cmluZycpIGh0bWxDaHVua3MgKz0gZ2V0Rml4dHVyZUh0bWwoYXJndW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaHRtbENodW5rcztcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5jbGVhckNhY2hlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGZpeHR1cmVzQ2FjaGUgPSB7fTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5jbGVhblVwID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLmNvbnRhaW5lcklkKTtcbiAgICAgICAgICAgIGlmKCFpZnJhbWUpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY3JlYXRlQ29udGFpbmVyICA9IGZ1bmN0aW9uKGh0bWwpe1xuICAgICAgICAgICAgdmFyIGNiID0gdHlwZW9mIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicgPyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtMV0gOiBudWxsO1xuICAgICAgICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnaWQnLCBzZWxmLmNvbnRhaW5lcklkKTtcbiAgICAgICAgICAgIGlmcmFtZS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgIGlmcmFtZS5zdHlsZS5maWx0ZXIgPSAnYWxwaGEoMCknO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICB2YXIgZG9jID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cgfHwgaWZyYW1lLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgICAgIGRvYyA9IGRvYy5kb2N1bWVudCA/IGRvYy5kb2N1bWVudCA6IGRvYztcblxuICAgICAgICAgICAgaWYgKGNiKXtcbiAgICAgICAgICAgICAgICB2YXIgaWZyYW1lUmVhZHkgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpZnJhbWVSZWFkeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvYy5vcGVuKCk7XG4gICAgICAgICAgICBkb2MuZGVmYXVsdFZpZXcub25lcnJvciA9IGNhcHR1cmVFcnJvcnM7XG4gICAgICAgICAgICBkb2Mud3JpdGUoaHRtbCk7XG4gICAgICAgICAgICBkb2MuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFkZFRvQ29udGFpbmVyID0gZnVuY3Rpb24oaHRtbCwgY2Ipe1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYuY29udGFpbmVySWQpO1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIpIGNyZWF0ZUNvbnRhaW5lci5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgZWxzZSBzZWxmLndpbmRvdygpLmRvY3VtZW50LmJvZHkuaW5uZXJIVE1MICs9IGh0bWw7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjYXB0dXJlRXJyb3JzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmICh3aW5kb3cub25lcnJvcil7XG4gICAgICAgICAgICAgICAgLy8gUmV3cml0ZSB0aGUgbWVzc2FnZSBwcmVmaXggdG8gaW5kaWNhdGUgdGhhdCB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBvY2N1cnJlZCBpbiB0aGUgZml4dHVyZS5cbiAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF0gPSBhcmd1bWVudHNbMF0ucmVwbGFjZSgvXlteOl0qLywgXCJVbmNhdWdodCBmaXh0dXJlIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5vbmVycm9yLmFwcGx5KHdpbmRvdywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0Rml4dHVyZUh0bWwgPSBmdW5jdGlvbih1cmwpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaXh0dXJlc0NhY2hlW3VybF0gPT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgICAgICBsb2FkRml4dHVyZUludG9DYWNoZSh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpeHR1cmVzQ2FjaGVbdXJsXTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxvYWRGaXh0dXJlSW50b0NhY2hlID0gZnVuY3Rpb24ocmVsYXRpdmVVcmwpe1xuICAgICAgICAgICAgdmFyIHVybCA9IG1ha2VGaXh0dXJlVXJsKHJlbGF0aXZlVXJsKTtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCArICc/JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpLCBmYWxzZSk7XG4gICAgICAgICAgICByZXF1ZXN0LnNlbmQobnVsbCk7XG4gICAgICAgICAgICBmaXh0dXJlc0NhY2hlW3JlbGF0aXZlVXJsXSA9IHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWFrZUZpeHR1cmVVcmwgPSBmdW5jdGlvbihyZWxhdGl2ZVVybCl7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wYXRoLm1hdGNoKCcvJCcpID8gc2VsZi5wYXRoICsgcmVsYXRpdmVVcmwgOiBzZWxmLnBhdGggKyAnLycgKyByZWxhdGl2ZVVybDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9ialRvSFRNTCA9IGZ1bmN0aW9uKG9iail7XG4gICAgICAgICAgICB2YXIgZGl2RWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyBcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmope1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycpeyAvLyBJRSA8IDkgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICBkaXZFbGVtLmNsYXNzTmFtZSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGl2RWxlbS5zZXRBdHRyaWJ1dGUoa2V5LCBvYmpba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGl2RWxlbS5vdXRlckhUTUw7XG4gICAgICAgIH07XG4gICAgfVxuKSk7XG4iLCIvLyB2aW06dHM9NDpzdHM9NDpzdz00OlxuLyohXG4gKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMiBLcmlzIEtvd2FsIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUXG4gKiBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL3Jhdy9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIFdpdGggcGFydHMgYnkgVHlsZXIgQ2xvc2VcbiAqIENvcHlyaWdodCAyMDA3LTIwMDkgVHlsZXIgQ2xvc2UgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgWCBsaWNlbnNlIGZvdW5kXG4gKiBhdCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLmh0bWxcbiAqIEZvcmtlZCBhdCByZWZfc2VuZC5qcyB2ZXJzaW9uOiAyMDA5LTA1LTExXG4gKlxuICogV2l0aCBwYXJ0cyBieSBNYXJrIE1pbGxlclxuICogQ29weXJpZ2h0IChDKSAyMDExIEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbihmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gVGhpcyBmaWxlIHdpbGwgZnVuY3Rpb24gcHJvcGVybHkgYXMgYSA8c2NyaXB0PiB0YWcsIG9yIGEgbW9kdWxlXG4gICAgLy8gdXNpbmcgQ29tbW9uSlMgYW5kIE5vZGVKUyBvciBSZXF1aXJlSlMgbW9kdWxlIGZvcm1hdHMuICBJblxuICAgIC8vIENvbW1vbi9Ob2RlL1JlcXVpcmVKUywgdGhlIG1vZHVsZSBleHBvcnRzIHRoZSBRIEFQSSBhbmQgd2hlblxuICAgIC8vIGV4ZWN1dGVkIGFzIGEgc2ltcGxlIDxzY3JpcHQ+LCBpdCBjcmVhdGVzIGEgUSBnbG9iYWwgaW5zdGVhZC5cblxuICAgIC8vIE1vbnRhZ2UgUmVxdWlyZVxuICAgIGlmICh0eXBlb2YgYm9vdHN0cmFwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYm9vdHN0cmFwKFwicHJvbWlzZVwiLCBkZWZpbml0aW9uKTtcblxuICAgIC8vIENvbW1vbkpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuXG4gICAgLy8gUmVxdWlyZUpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG5cbiAgICAvLyBTRVMgKFNlY3VyZSBFY21hU2NyaXB0KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoIXNlcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXMubWFrZVEgPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG5cbiAgICAvLyA8c2NyaXB0PlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBQcmVmZXIgd2luZG93IG92ZXIgc2VsZiBmb3IgYWRkLW9uIHNjcmlwdHMuIFVzZSBzZWxmIGZvclxuICAgICAgICAvLyBub24td2luZG93ZWQgY29udGV4dHMuXG4gICAgICAgIHZhciBnbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogc2VsZjtcblxuICAgICAgICAvLyBHZXQgdGhlIGB3aW5kb3dgIG9iamVjdCwgc2F2ZSB0aGUgcHJldmlvdXMgUSBnbG9iYWxcbiAgICAgICAgLy8gYW5kIGluaXRpYWxpemUgUSBhcyBhIGdsb2JhbC5cbiAgICAgICAgdmFyIHByZXZpb3VzUSA9IGdsb2JhbC5RO1xuICAgICAgICBnbG9iYWwuUSA9IGRlZmluaXRpb24oKTtcblxuICAgICAgICAvLyBBZGQgYSBub0NvbmZsaWN0IGZ1bmN0aW9uIHNvIFEgY2FuIGJlIHJlbW92ZWQgZnJvbSB0aGVcbiAgICAgICAgLy8gZ2xvYmFsIG5hbWVzcGFjZS5cbiAgICAgICAgZ2xvYmFsLlEubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdsb2JhbC5RID0gcHJldmlvdXNRO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGVudmlyb25tZW50IHdhcyBub3QgYW50aWNpcGF0ZWQgYnkgUS4gUGxlYXNlIGZpbGUgYSBidWcuXCIpO1xuICAgIH1cblxufSkoZnVuY3Rpb24gKCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoYXNTdGFja3MgPSBmYWxzZTtcbnRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG59IGNhdGNoIChlKSB7XG4gICAgaGFzU3RhY2tzID0gISFlLnN0YWNrO1xufVxuXG4vLyBBbGwgY29kZSBhZnRlciB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMgcmVwb3J0ZWRcbi8vIGJ5IFEuXG52YXIgcVN0YXJ0aW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG52YXIgcUZpbGVOYW1lO1xuXG4vLyBzaGltc1xuXG4vLyB1c2VkIGZvciBmYWxsYmFjayBpbiBcImFsbFJlc29sdmVkXCJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBwb3NzaWJsZSBtZWFucyB0byBleGVjdXRlIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuXG4vLyBvZiB0aGUgZXZlbnQgbG9vcC5cbnZhciBuZXh0VGljayA9KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBsaW5rZWQgbGlzdCBvZiB0YXNrcyAoc2luZ2xlLCB3aXRoIGhlYWQgbm9kZSlcbiAgICB2YXIgaGVhZCA9IHt0YXNrOiB2b2lkIDAsIG5leHQ6IG51bGx9O1xuICAgIHZhciB0YWlsID0gaGVhZDtcbiAgICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB2YXIgcmVxdWVzdFRpY2sgPSB2b2lkIDA7XG4gICAgdmFyIGlzTm9kZUpTID0gZmFsc2U7XG4gICAgLy8gcXVldWUgZm9yIGxhdGUgdGFza3MsIHVzZWQgYnkgdW5oYW5kbGVkIHJlamVjdGlvbiB0cmFja2luZ1xuICAgIHZhciBsYXRlclF1ZXVlID0gW107XG5cbiAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOiB0cnVlICovXG4gICAgICAgIHZhciB0YXNrLCBkb21haW47XG5cbiAgICAgICAgd2hpbGUgKGhlYWQubmV4dCkge1xuICAgICAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgICAgICAgIHRhc2sgPSBoZWFkLnRhc2s7XG4gICAgICAgICAgICBoZWFkLnRhc2sgPSB2b2lkIDA7XG4gICAgICAgICAgICBkb21haW4gPSBoZWFkLmRvbWFpbjtcblxuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGhlYWQuZG9tYWluID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuU2luZ2xlKHRhc2ssIGRvbWFpbik7XG5cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobGF0ZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRhc2sgPSBsYXRlclF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgcnVuU2luZ2xlKHRhc2spO1xuICAgICAgICB9XG4gICAgICAgIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIHJ1bnMgYSBzaW5nbGUgZnVuY3Rpb24gaW4gdGhlIGFzeW5jIHF1ZXVlXG4gICAgZnVuY3Rpb24gcnVuU2luZ2xlKHRhc2ssIGRvbWFpbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGFzaygpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChpc05vZGVKUykge1xuICAgICAgICAgICAgICAgIC8vIEluIG5vZGUsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIGNvbnNpZGVyZWQgZmF0YWwgZXJyb3JzLlxuICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gc3luY2hyb25vdXNseSB0byBpbnRlcnJ1cHQgZmx1c2hpbmchXG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY29udGludWF0aW9uIGlmIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaXMgc3VwcHJlc3NlZFxuICAgICAgICAgICAgICAgIC8vIGxpc3RlbmluZyBcInVuY2F1Z2h0RXhjZXB0aW9uXCIgZXZlbnRzIChhcyBkb21haW5zIGRvZXMpLlxuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGluIG5leHQgZXZlbnQgdG8gYXZvaWQgdGljayByZWN1cnNpb24uXG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gYnJvd3NlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC5cbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHNsb3ctZG93bnMuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmV4dFRpY2sgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICB0YWlsID0gdGFpbC5uZXh0ID0ge1xuICAgICAgICAgICAgdGFzazogdGFzayxcbiAgICAgICAgICAgIGRvbWFpbjogaXNOb2RlSlMgJiYgcHJvY2Vzcy5kb21haW4sXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdFRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgcHJvY2Vzcy50b1N0cmluZygpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIiAmJiBwcm9jZXNzLm5leHRUaWNrKSB7XG4gICAgICAgIC8vIEVuc3VyZSBRIGlzIGluIGEgcmVhbCBOb2RlIGVudmlyb25tZW50LCB3aXRoIGEgYHByb2Nlc3MubmV4dFRpY2tgLlxuICAgICAgICAvLyBUbyBzZWUgdGhyb3VnaCBmYWtlIE5vZGUgZW52aXJvbm1lbnRzOlxuICAgICAgICAvLyAqIE1vY2hhIHRlc3QgcnVubmVyIC0gZXhwb3NlcyBhIGBwcm9jZXNzYCBnbG9iYWwgd2l0aG91dCBhIGBuZXh0VGlja2BcbiAgICAgICAgLy8gKiBCcm93c2VyaWZ5IC0gZXhwb3NlcyBhIGBwcm9jZXNzLm5leFRpY2tgIGZ1bmN0aW9uIHRoYXQgdXNlc1xuICAgICAgICAvLyAgIGBzZXRUaW1lb3V0YC4gSW4gdGhpcyBjYXNlIGBzZXRJbW1lZGlhdGVgIGlzIHByZWZlcnJlZCBiZWNhdXNlXG4gICAgICAgIC8vICAgIGl0IGlzIGZhc3Rlci4gQnJvd3NlcmlmeSdzIGBwcm9jZXNzLnRvU3RyaW5nKClgIHlpZWxkc1xuICAgICAgICAvLyAgIFwiW29iamVjdCBPYmplY3RdXCIsIHdoaWxlIGluIGEgcmVhbCBOb2RlIGVudmlyb25tZW50XG4gICAgICAgIC8vICAgYHByb2Nlc3MubmV4dFRpY2soKWAgeWllbGRzIFwiW29iamVjdCBwcm9jZXNzXVwiLlxuICAgICAgICBpc05vZGVKUyA9IHRydWU7XG5cbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIEluIElFMTAsIE5vZGUuanMgMC45Kywgb3IgaHR0cHM6Ly9naXRodWIuY29tL05vYmxlSlMvc2V0SW1tZWRpYXRlXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IHNldEltbWVkaWF0ZS5iaW5kKHdpbmRvdywgZmx1c2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAvLyBodHRwOi8vd3d3Lm5vbmJsb2NraW5nLmlvLzIwMTEvMDYvd2luZG93bmV4dHRpY2suaHRtbFxuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAvLyBBdCBsZWFzdCBTYWZhcmkgVmVyc2lvbiA2LjAuNSAoODUzNi4zMC4xKSBpbnRlcm1pdHRlbnRseSBjYW5ub3QgY3JlYXRlXG4gICAgICAgIC8vIHdvcmtpbmcgbWVzc2FnZSBwb3J0cyB0aGUgZmlyc3QgdGltZSBhIHBhZ2UgbG9hZHMuXG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSByZXF1ZXN0UG9ydFRpY2s7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcXVlc3RQb3J0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE9wZXJhIHJlcXVpcmVzIHVzIHRvIHByb3ZpZGUgYSBtZXNzYWdlIHBheWxvYWQsIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgd2UgdXNlIGl0LlxuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgIHJlcXVlc3RQb3J0VGljaygpO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb2xkIGJyb3dzZXJzXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHJ1bnMgYSB0YXNrIGFmdGVyIGFsbCBvdGhlciB0YXNrcyBoYXZlIGJlZW4gcnVuXG4gICAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIHVuaGFuZGxlZCByZWplY3Rpb24gdHJhY2tpbmcgdGhhdCBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciBhbGwgYHRoZW5gZCB0YXNrcyBoYXZlIGJlZW4gcnVuLlxuICAgIG5leHRUaWNrLnJ1bkFmdGVyID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgbGF0ZXJRdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXF1ZXN0VGljaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbmV4dFRpY2s7XG59KSgpO1xuXG4vLyBBdHRlbXB0IHRvIG1ha2UgZ2VuZXJpY3Mgc2FmZSBpbiB0aGUgZmFjZSBvZiBkb3duc3RyZWFtXG4vLyBtb2RpZmljYXRpb25zLlxuLy8gVGhlcmUgaXMgbm8gc2l0dWF0aW9uIHdoZXJlIHRoaXMgaXMgbmVjZXNzYXJ5LlxuLy8gSWYgeW91IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsIHRoZXNlIHByaW1vcmRpYWxzIG5lZWQgdG8gYmVcbi8vIGRlZXBseSBmcm96ZW4gYW55d2F5LCBhbmQgaWYgeW91IGRvbuKAmXQgbmVlZCBhIHNlY3VyaXR5IGd1YXJhbnRlZSxcbi8vIHRoaXMgaXMganVzdCBwbGFpbiBwYXJhbm9pZC5cbi8vIEhvd2V2ZXIsIHRoaXMgKiptaWdodCoqIGhhdmUgdGhlIG5pY2Ugc2lkZS1lZmZlY3Qgb2YgcmVkdWNpbmcgdGhlIHNpemUgb2Zcbi8vIHRoZSBtaW5pZmllZCBjb2RlIGJ5IHJlZHVjaW5nIHguY2FsbCgpIHRvIG1lcmVseSB4KClcbi8vIFNlZSBNYXJrIE1pbGxlcuKAmXMgZXhwbGFuYXRpb24gb2Ygd2hhdCB0aGlzIGRvZXMuXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1jb252ZW50aW9uczpzYWZlX21ldGFfcHJvZ3JhbW1pbmdcbnZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG4vLyBUaGlzIGlzIGVxdWl2YWxlbnQsIGJ1dCBzbG93ZXI6XG4vLyB1bmN1cnJ5VGhpcyA9IEZ1bmN0aW9uX2JpbmQuYmluZChGdW5jdGlvbl9iaW5kLmNhbGwpO1xuLy8gaHR0cDovL2pzcGVyZi5jb20vdW5jdXJyeXRoaXNcblxudmFyIGFycmF5X3NsaWNlID0gdW5jdXJyeVRoaXMoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcblxudmFyIGFycmF5X3JlZHVjZSA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCBiYXNpcykge1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIGNvbmNlcm5pbmcgdGhlIGluaXRpYWwgdmFsdWUsIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHNlZWsgdG8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhcnJheSwgYWNjb3VudGluZ1xuICAgICAgICAgICAgLy8gZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IGlzIGlzIGEgc3BhcnNlIGFycmF5XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzaXMgPSB0aGlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1Y2VcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgYXJyYXkgaXMgc3BhcnNlXG4gICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGJhc2lzID0gY2FsbGJhY2soYmFzaXMsIHRoaXNbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2lzO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9pbmRleE9mID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5vdCBhIHZlcnkgZ29vZCBzaGltLCBidXQgZ29vZCBlbm91Z2ggZm9yIG91ciBvbmUgdXNlIG9mIGl0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9tYXAgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUubWFwIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3ApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29sbGVjdCA9IFtdO1xuICAgICAgICBhcnJheV9yZWR1Y2Uoc2VsZiwgZnVuY3Rpb24gKHVuZGVmaW5lZCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBjb2xsZWN0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzcCwgdmFsdWUsIGluZGV4LCBzZWxmKSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0O1xuICAgIH1cbik7XG5cbnZhciBvYmplY3RfY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiAocHJvdG90eXBlKSB7XG4gICAgZnVuY3Rpb24gVHlwZSgpIHsgfVxuICAgIFR5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHJldHVybiBuZXcgVHlwZSgpO1xufTtcblxudmFyIG9iamVjdF9oYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG52YXIgb2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RfaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBvYmplY3RfdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IE9iamVjdCh2YWx1ZSk7XG59XG5cbi8vIGdlbmVyYXRvciByZWxhdGVkIHNoaW1zXG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBmdW5jdGlvbiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG5mdW5jdGlvbiBpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgb2JqZWN0X3RvU3RyaW5nKGV4Y2VwdGlvbikgPT09IFwiW29iamVjdCBTdG9wSXRlcmF0aW9uXVwiIHx8XG4gICAgICAgIGV4Y2VwdGlvbiBpbnN0YW5jZW9mIFFSZXR1cm5WYWx1ZVxuICAgICk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBoZWxwZXIgYW5kIFEucmV0dXJuIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluXG4vLyBTcGlkZXJNb25rZXkuXG52YXIgUVJldHVyblZhbHVlO1xuaWYgKHR5cGVvZiBSZXR1cm5WYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFFSZXR1cm5WYWx1ZSA9IFJldHVyblZhbHVlO1xufSBlbHNlIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG59XG5cbi8vIGxvbmcgc3RhY2sgdHJhY2VzXG5cbnZhciBTVEFDS19KVU1QX1NFUEFSQVRPUiA9IFwiRnJvbSBwcmV2aW91cyBldmVudDpcIjtcblxuZnVuY3Rpb24gbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIHRyYW5zZm9ybSB0aGUgZXJyb3Igc3RhY2sgdHJhY2UgYnkgcmVtb3ZpbmcgTm9kZSBhbmQgUVxuICAgIC8vIGNydWZ0LCB0aGVuIGNvbmNhdGVuYXRpbmcgd2l0aCB0aGUgc3RhY2sgdHJhY2Ugb2YgYHByb21pc2VgLiBTZWUgIzU3LlxuICAgIGlmIChoYXNTdGFja3MgJiZcbiAgICAgICAgcHJvbWlzZS5zdGFjayAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2sgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2suaW5kZXhPZihTVEFDS19KVU1QX1NFUEFSQVRPUikgPT09IC0xXG4gICAgKSB7XG4gICAgICAgIHZhciBzdGFja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcCA9IHByb21pc2U7ICEhcDsgcCA9IHAuc291cmNlKSB7XG4gICAgICAgICAgICBpZiAocC5zdGFjaykge1xuICAgICAgICAgICAgICAgIHN0YWNrcy51bnNoaWZ0KHAuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrcy51bnNoaWZ0KGVycm9yLnN0YWNrKTtcblxuICAgICAgICB2YXIgY29uY2F0ZWRTdGFja3MgPSBzdGFja3Muam9pbihcIlxcblwiICsgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgKyBcIlxcblwiKTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBmaWx0ZXJTdGFja1N0cmluZyhjb25jYXRlZFN0YWNrcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdGFja1N0cmluZyhzdGFja1N0cmluZykge1xuICAgIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBkZXNpcmVkTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgaWYgKCFpc0ludGVybmFsRnJhbWUobGluZSkgJiYgIWlzTm9kZUZyYW1lKGxpbmUpICYmIGxpbmUpIHtcbiAgICAgICAgICAgIGRlc2lyZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNpcmVkTGluZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgcmV0dXJuIHN0YWNrTGluZS5pbmRleE9mKFwiKG1vZHVsZS5qczpcIikgIT09IC0xIHx8XG4gICAgICAgICAgIHN0YWNrTGluZS5pbmRleE9mKFwiKG5vZGUuanM6XCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSkge1xuICAgIC8vIE5hbWVkIGZ1bmN0aW9uczogXCJhdCBmdW5jdGlvbk5hbWUgKGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyKVwiXG4gICAgLy8gSW4gSUUxMCBmdW5jdGlvbiBuYW1lIGNhbiBoYXZlIHNwYWNlcyAoXCJBbm9ueW1vdXMgZnVuY3Rpb25cIikgT19vXG4gICAgdmFyIGF0dGVtcHQxID0gL2F0IC4rIFxcKCguKyk6KFxcZCspOig/OlxcZCspXFwpJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MSkge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQxWzFdLCBOdW1iZXIoYXR0ZW1wdDFbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb25zOiBcImF0IGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDIgPSAvYXQgKFteIF0rKTooXFxkKyk6KD86XFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQyKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDJbMV0sIE51bWJlcihhdHRlbXB0MlsyXSldO1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3ggc3R5bGU6IFwiZnVuY3Rpb25AZmlsZW5hbWU6bGluZU51bWJlciBvciBAZmlsZW5hbWU6bGluZU51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQzID0gLy4qQCguKyk6KFxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mykge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQzWzFdLCBOdW1iZXIoYXR0ZW1wdDNbMl0pXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJuYWxGcmFtZShzdGFja0xpbmUpIHtcbiAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSk7XG5cbiAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgIHZhciBsaW5lTnVtYmVyID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuXG4gICAgcmV0dXJuIGZpbGVOYW1lID09PSBxRmlsZU5hbWUgJiZcbiAgICAgICAgbGluZU51bWJlciA+PSBxU3RhcnRpbmdMaW5lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPD0gcUVuZGluZ0xpbmU7XG59XG5cbi8vIGRpc2NvdmVyIG93biBmaWxlIG5hbWUgYW5kIGxpbmUgbnVtYmVyIHJhbmdlIGZvciBmaWx0ZXJpbmcgc3RhY2tcbi8vIHRyYWNlc1xuZnVuY3Rpb24gY2FwdHVyZUxpbmUoKSB7XG4gICAgaWYgKCFoYXNTdGFja3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGxpbmVzWzBdLmluZGV4T2YoXCJAXCIpID4gMCA/IGxpbmVzWzFdIDogbGluZXNbMl07XG4gICAgICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoZmlyc3RMaW5lKTtcbiAgICAgICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHFGaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShjYWxsYmFjaywgbmFtZSwgYWx0ZXJuYXRpdmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyBcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCIgKyBhbHRlcm5hdGl2ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIiwgbmV3IEVycm9yKFwiXCIpLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLy8gZW5kIG9mIHNoaW1zXG4vLyBiZWdpbm5pbmcgb2YgcmVhbCB3b3JrXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UsIHBhc3NlcyBwcm9taXNlcyB0aHJvdWdoLCBvclxuICogY29lcmNlcyBwcm9taXNlcyBmcm9tIGRpZmZlcmVudCBzeXN0ZW1zLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2Ugb3IgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBRKHZhbHVlKSB7XG4gICAgLy8gSWYgdGhlIG9iamVjdCBpcyBhbHJlYWR5IGEgUHJvbWlzZSwgcmV0dXJuIGl0IGRpcmVjdGx5LiAgVGhpcyBlbmFibGVzXG4gICAgLy8gdGhlIHJlc29sdmUgZnVuY3Rpb24gdG8gYm90aCBiZSB1c2VkIHRvIGNyZWF0ZWQgcmVmZXJlbmNlcyBmcm9tIG9iamVjdHMsXG4gICAgLy8gYnV0IHRvIHRvbGVyYWJseSBjb2VyY2Ugbm9uLXByb21pc2VzIHRvIHByb21pc2VzLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGFzc2ltaWxhdGUgdGhlbmFibGVzXG4gICAgaWYgKGlzUHJvbWlzZUFsaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVsZmlsbCh2YWx1ZSk7XG4gICAgfVxufVxuUS5yZXNvbHZlID0gUTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHRhc2sgaW4gYSBmdXR1cmUgdHVybiBvZiB0aGUgZXZlbnQgbG9vcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2tcbiAqL1xuUS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4vKipcbiAqIENvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGxvbmcgc3RhY2sgdHJhY2VzIHdpbGwgYmUgb25cbiAqL1xuUS5sb25nU3RhY2tTdXBwb3J0ID0gZmFsc2U7XG5cbi8vIGVuYWJsZSBsb25nIHN0YWNrcyBpZiBRX0RFQlVHIGlzIHNldFxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuUV9ERUJVRykge1xuICAgIFEubG9uZ1N0YWNrU3VwcG9ydCA9IHRydWU7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHtwcm9taXNlLCByZXNvbHZlLCByZWplY3R9IG9iamVjdC5cbiAqXG4gKiBgcmVzb2x2ZWAgaXMgYSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBhIG1vcmUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoZVxuICogcHJvbWlzZS4gVG8gZnVsZmlsbCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGFueSB2YWx1ZSB0aGF0IGlzXG4gKiBub3QgYSB0aGVuYWJsZS4gVG8gcmVqZWN0IHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYSByZWplY3RlZFxuICogdGhlbmFibGUsIG9yIGludm9rZSBgcmVqZWN0YCB3aXRoIHRoZSByZWFzb24gZGlyZWN0bHkuIFRvIHJlc29sdmUgdGhlXG4gKiBwcm9taXNlIHRvIGFub3RoZXIgdGhlbmFibGUsIHRodXMgcHV0dGluZyBpdCBpbiB0aGUgc2FtZSBzdGF0ZSwgaW52b2tlXG4gKiBgcmVzb2x2ZWAgd2l0aCB0aGF0IG90aGVyIHRoZW5hYmxlLlxuICovXG5RLmRlZmVyID0gZGVmZXI7XG5mdW5jdGlvbiBkZWZlcigpIHtcbiAgICAvLyBpZiBcIm1lc3NhZ2VzXCIgaXMgYW4gXCJBcnJheVwiLCB0aGF0IGluZGljYXRlcyB0aGF0IHRoZSBwcm9taXNlIGhhcyBub3QgeWV0XG4gICAgLy8gYmVlbiByZXNvbHZlZC4gIElmIGl0IGlzIFwidW5kZWZpbmVkXCIsIGl0IGhhcyBiZWVuIHJlc29sdmVkLiAgRWFjaFxuICAgIC8vIGVsZW1lbnQgb2YgdGhlIG1lc3NhZ2VzIGFycmF5IGlzIGl0c2VsZiBhbiBhcnJheSBvZiBjb21wbGV0ZSBhcmd1bWVudHMgdG9cbiAgICAvLyBmb3J3YXJkIHRvIHRoZSByZXNvbHZlZCBwcm9taXNlLiAgV2UgY29lcmNlIHRoZSByZXNvbHV0aW9uIHZhbHVlIHRvIGFcbiAgICAvLyBwcm9taXNlIHVzaW5nIHRoZSBgcmVzb2x2ZWAgZnVuY3Rpb24gYmVjYXVzZSBpdCBoYW5kbGVzIGJvdGggZnVsbHlcbiAgICAvLyBub24tdGhlbmFibGUgdmFsdWVzIGFuZCBvdGhlciB0aGVuYWJsZXMgZ3JhY2VmdWxseS5cbiAgICB2YXIgbWVzc2FnZXMgPSBbXSwgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXSwgcmVzb2x2ZWRQcm9taXNlO1xuXG4gICAgdmFyIGRlZmVycmVkID0gb2JqZWN0X2NyZWF0ZShkZWZlci5wcm90b3R5cGUpO1xuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgb3BlcmFuZHMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goYXJncyk7XG4gICAgICAgICAgICBpZiAob3AgPT09IFwid2hlblwiICYmIG9wZXJhbmRzWzFdKSB7IC8vIHByb2dyZXNzIG9wZXJhbmRcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVycy5wdXNoKG9wZXJhbmRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkocmVzb2x2ZWRQcm9taXNlLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkXG4gICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWFyZXJWYWx1ZSA9IG5lYXJlcihyZXNvbHZlZFByb21pc2UpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKG5lYXJlclZhbHVlKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmVhcmVyVmFsdWU7IC8vIHNob3J0ZW4gY2hhaW5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVhcmVyVmFsdWU7XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcInBlbmRpbmdcIiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZFByb21pc2UuaW5zcGVjdCgpO1xuICAgIH07XG5cbiAgICBpZiAoUS5sb25nU3RhY2tTdXBwb3J0ICYmIGhhc1N0YWNrcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGRvbid0IHRyeSB0byB1c2UgYEVycm9yLmNhcHR1cmVTdGFja1RyYWNlYCBvciB0cmFuc2ZlciB0aGVcbiAgICAgICAgICAgIC8vIGFjY2Vzc29yIGFyb3VuZDsgdGhhdCBjYXVzZXMgbWVtb3J5IGxlYWtzIGFzIHBlciBHSC0xMTEuIEp1c3RcbiAgICAgICAgICAgIC8vIHJlaWZ5IHRoZSBzdGFjayB0cmFjZSBhcyBhIHN0cmluZyBBU0FQLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUsIGN1dCBvZmYgdGhlIGZpcnN0IGxpbmU7IGl0J3MgYWx3YXlzIGp1c3RcbiAgICAgICAgICAgIC8vIFwiW29iamVjdCBQcm9taXNlXVxcblwiLCBhcyBwZXIgdGhlIGB0b1N0cmluZ2AuXG4gICAgICAgICAgICBwcm9taXNlLnN0YWNrID0gZS5zdGFjay5zdWJzdHJpbmcoZS5zdGFjay5pbmRleE9mKFwiXFxuXCIpICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOT1RFOiB3ZSBkbyB0aGUgY2hlY2tzIGZvciBgcmVzb2x2ZWRQcm9taXNlYCBpbiBlYWNoIG1ldGhvZCwgaW5zdGVhZCBvZlxuICAgIC8vIGNvbnNvbGlkYXRpbmcgdGhlbSBpbnRvIGBiZWNvbWVgLCBzaW5jZSBvdGhlcndpc2Ugd2UnZCBjcmVhdGUgbmV3XG4gICAgLy8gcHJvbWlzZXMgd2l0aCB0aGUgbGluZXMgYGJlY29tZSh3aGF0ZXZlcih2YWx1ZSkpYC4gU2VlIGUuZy4gR0gtMjUyLlxuXG4gICAgZnVuY3Rpb24gYmVjb21lKG5ld1Byb21pc2UpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmV3UHJvbWlzZTtcbiAgICAgICAgcHJvbWlzZS5zb3VyY2UgPSBuZXdQcm9taXNlO1xuXG4gICAgICAgIGFycmF5X3JlZHVjZShtZXNzYWdlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbmV3UHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkobmV3UHJvbWlzZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcblxuICAgICAgICBtZXNzYWdlcyA9IHZvaWQgMDtcbiAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUoUSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBkZWZlcnJlZC5mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShmdWxmaWxsKHZhbHVlKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShyZWplY3QocmVhc29uKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb2dyZXNzTGlzdGVuZXJzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9ncmVzc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIE5vZGUtc3R5bGUgY2FsbGJhY2sgdGhhdCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBkZWZlcnJlZFxuICogcHJvbWlzZS5cbiAqIEByZXR1cm5zIGEgbm9kZWJhY2tcbiAqL1xuZGVmZXIucHJvdG90eXBlLm1ha2VOb2RlUmVzb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUoYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHJlc29sdmVyIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgbm90aGluZyBhbmQgYWNjZXB0c1xuICogdGhlIHJlc29sdmUsIHJlamVjdCwgYW5kIG5vdGlmeSBmdW5jdGlvbnMgZm9yIGEgZGVmZXJyZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCBtYXkgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZ2l2ZW4gcmVzb2x2ZSBhbmQgcmVqZWN0XG4gKiBmdW5jdGlvbnMsIG9yIHJlamVjdGVkIGJ5IGEgdGhyb3duIGV4Y2VwdGlvbiBpbiByZXNvbHZlclxuICovXG5RLlByb21pc2UgPSBwcm9taXNlOyAvLyBFUzZcblEucHJvbWlzZSA9IHByb21pc2U7XG5mdW5jdGlvbiBwcm9taXNlKHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG5wcm9taXNlLnJhY2UgPSByYWNlOyAvLyBFUzZcbnByb21pc2UuYWxsID0gYWxsOyAvLyBFUzZcbnByb21pc2UucmVqZWN0ID0gcmVqZWN0OyAvLyBFUzZcbnByb21pc2UucmVzb2x2ZSA9IFE7IC8vIEVTNlxuXG4vLyBYWFggZXhwZXJpbWVudGFsLiAgVGhpcyBtZXRob2QgaXMgYSB3YXkgdG8gZGVub3RlIHRoYXQgYSBsb2NhbCB2YWx1ZSBpc1xuLy8gc2VyaWFsaXphYmxlIGFuZCBzaG91bGQgYmUgaW1tZWRpYXRlbHkgZGlzcGF0Y2hlZCB0byBhIHJlbW90ZSB1cG9uIHJlcXVlc3QsXG4vLyBpbnN0ZWFkIG9mIHBhc3NpbmcgYSByZWZlcmVuY2UuXG5RLnBhc3NCeUNvcHkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgLy9mcmVlemUob2JqZWN0KTtcbiAgICAvL3Bhc3NCeUNvcGllcy5zZXQob2JqZWN0LCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucGFzc0J5Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJZiB0d28gcHJvbWlzZXMgZXZlbnR1YWxseSBmdWxmaWxsIHRvIHRoZSBzYW1lIHZhbHVlLCBwcm9taXNlcyB0aGF0IHZhbHVlLFxuICogYnV0IG90aGVyd2lzZSByZWplY3RzLlxuICogQHBhcmFtIHgge0FueSp9XG4gKiBAcGFyYW0geSB7QW55Kn1cbiAqIEByZXR1cm5zIHtBbnkqfSBhIHByb21pc2UgZm9yIHggYW5kIHkgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGJ1dCBhIHJlamVjdGlvblxuICogb3RoZXJ3aXNlLlxuICpcbiAqL1xuUS5qb2luID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gUSh4KS5qb2luKHkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgcmV0dXJuIFEoW3RoaXMsIHRoYXRdKS5zcHJlYWQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFwiPT09XCIgc2hvdWxkIGJlIE9iamVjdC5pcyBvciBlcXVpdlxuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBqb2luOiBub3QgdGhlIHNhbWU6IFwiICsgeCArIFwiIFwiICsgeSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBmaXJzdCBvZiBhbiBhcnJheSBvZiBwcm9taXNlcyB0byBiZWNvbWUgc2V0dGxlZC5cbiAqIEBwYXJhbSBhbnN3ZXJzIHtBcnJheVtBbnkqXX0gcHJvbWlzZXMgdG8gcmFjZVxuICogQHJldHVybnMge0FueSp9IHRoZSBmaXJzdCBwcm9taXNlIHRvIGJlIHNldHRsZWRcbiAqL1xuUS5yYWNlID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2UoYW5zd2VyUHMpIHtcbiAgICByZXR1cm4gcHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIFN3aXRjaCB0byB0aGlzIG9uY2Ugd2UgY2FuIGFzc3VtZSBhdCBsZWFzdCBFUzVcbiAgICAgICAgLy8gYW5zd2VyUHMuZm9yRWFjaChmdW5jdGlvbiAoYW5zd2VyUCkge1xuICAgICAgICAvLyAgICAgUShhbnN3ZXJQKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyBVc2UgdGhpcyBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFuc3dlclBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBRKGFuc3dlclBzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKFEucmFjZSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBQcm9taXNlIHdpdGggYSBwcm9taXNlIGRlc2NyaXB0b3Igb2JqZWN0IGFuZCBvcHRpb25hbCBmYWxsYmFja1xuICogZnVuY3Rpb24uICBUaGUgZGVzY3JpcHRvciBjb250YWlucyBtZXRob2RzIGxpa2Ugd2hlbihyZWplY3RlZCksIGdldChuYW1lKSxcbiAqIHNldChuYW1lLCB2YWx1ZSksIHBvc3QobmFtZSwgYXJncyksIGFuZCBkZWxldGUobmFtZSksIHdoaWNoIGFsbFxuICogcmV0dXJuIGVpdGhlciBhIHZhbHVlLCBhIHByb21pc2UgZm9yIGEgdmFsdWUsIG9yIGEgcmVqZWN0aW9uLiAgVGhlIGZhbGxiYWNrXG4gKiBhY2NlcHRzIHRoZSBvcGVyYXRpb24gbmFtZSwgYSByZXNvbHZlciwgYW5kIGFueSBmdXJ0aGVyIGFyZ3VtZW50cyB0aGF0IHdvdWxkXG4gKiBoYXZlIGJlZW4gZm9yd2FyZGVkIHRvIHRoZSBhcHByb3ByaWF0ZSBtZXRob2QgYWJvdmUgaGFkIGEgbWV0aG9kIGJlZW5cbiAqIHByb3ZpZGVkIHdpdGggdGhlIHByb3BlciBuYW1lLiAgVGhlIEFQSSBtYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IHRoZSBuYXR1cmVcbiAqIG9mIHRoZSByZXR1cm5lZCBvYmplY3QsIGFwYXJ0IGZyb20gdGhhdCBpdCBpcyB1c2FibGUgd2hlcmVldmVyIHByb21pc2VzIGFyZVxuICogYm91Z2h0IGFuZCBzb2xkLlxuICovXG5RLm1ha2VQcm9taXNlID0gUHJvbWlzZTtcbmZ1bmN0aW9uIFByb21pc2UoZGVzY3JpcHRvciwgZmFsbGJhY2ssIGluc3BlY3QpIHtcbiAgICBpZiAoZmFsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICBmYWxsYmFjayA9IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQcm9taXNlIGRvZXMgbm90IHN1cHBvcnQgb3BlcmF0aW9uOiBcIiArIG9wXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGluc3BlY3QgPT09IHZvaWQgMCkge1xuICAgICAgICBpbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0ZTogXCJ1bmtub3duXCJ9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Jbb3BdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVzY3JpcHRvcltvcF0uYXBwbHkocHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbGxiYWNrLmNhbGwocHJvbWlzZSwgb3AsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gaW5zcGVjdDtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkIGB2YWx1ZU9mYCBhbmQgYGV4Y2VwdGlvbmAgc3VwcG9ydFxuICAgIGlmIChpbnNwZWN0KSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgcHJvbWlzZS5leGNlcHRpb24gPSBpbnNwZWN0ZWQucmVhc29uO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluc3BlY3RlZCA9IGluc3BlY3QoKTtcbiAgICAgICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicGVuZGluZ1wiIHx8XG4gICAgICAgICAgICAgICAgaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgUHJvbWlzZV1cIjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBkb25lID0gZmFsc2U7ICAgLy8gZW5zdXJlIHRoZSB1bnRydXN0ZWQgcHJvbWlzZSBtYWtlcyBhdCBtb3N0IGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjYWxsIHRvIG9uZSBvZiB0aGUgY2FsbGJhY2tzXG5cbiAgICBmdW5jdGlvbiBfZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bGZpbGxlZCA9PT0gXCJmdW5jdGlvblwiID8gZnVsZmlsbGVkKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZWplY3RlZChleGNlcHRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXhjZXB0aW9uLCBzZWxmKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkKGV4Y2VwdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChuZXdFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ld0V4Y2VwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9wcm9ncmVzc2VkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJvZ3Jlc3NlZCA9PT0gXCJmdW5jdGlvblwiID8gcHJvZ3Jlc3NlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9mdWxmaWxsZWQodmFsdWUpKTtcbiAgICAgICAgfSwgXCJ3aGVuXCIsIFtmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9yZWplY3RlZChleGNlcHRpb24pKTtcbiAgICAgICAgfV0pO1xuICAgIH0pO1xuXG4gICAgLy8gUHJvZ3Jlc3MgcHJvcGFnYXRvciBuZWVkIHRvIGJlIGF0dGFjaGVkIGluIHRoZSBjdXJyZW50IHRpY2suXG4gICAgc2VsZi5wcm9taXNlRGlzcGF0Y2godm9pZCAwLCBcIndoZW5cIiwgW3ZvaWQgMCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZTtcbiAgICAgICAgdmFyIHRocmV3ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IF9wcm9ncmVzc2VkKHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyZXcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhyZXcpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cblEudGFwID0gZnVuY3Rpb24gKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGFwKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogV29ya3MgYWxtb3N0IGxpa2UgXCJmaW5hbGx5XCIsIGJ1dCBub3QgY2FsbGVkIGZvciByZWplY3Rpb25zLlxuICogT3JpZ2luYWwgcmVzb2x1dGlvbiB2YWx1ZSBpcyBwYXNzZWQgdGhyb3VnaCBjYWxsYmFjayB1bmFmZmVjdGVkLlxuICogQ2FsbGJhY2sgbWF5IHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGF3YWl0ZWQgZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtRLlByb21pc2V9XG4gKiBAZXhhbXBsZVxuICogZG9Tb21ldGhpbmcoKVxuICogICAudGhlbiguLi4pXG4gKiAgIC50YXAoY29uc29sZS5sb2cpXG4gKiAgIC50aGVuKC4uLik7XG4gKi9cblByb21pc2UucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gUShjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwodmFsdWUpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIG9ic2VydmVyIG9uIGEgcHJvbWlzZS5cbiAqXG4gKiBHdWFyYW50ZWVzOlxuICpcbiAqIDEuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UuXG4gKiAyLiB0aGF0IGVpdGhlciB0aGUgZnVsZmlsbGVkIGNhbGxiYWNrIG9yIHRoZSByZWplY3RlZCBjYWxsYmFjayB3aWxsIGJlXG4gKiAgICBjYWxsZWQsIGJ1dCBub3QgYm90aC5cbiAqIDMuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIG5vdCBiZSBjYWxsZWQgaW4gdGhpcyB0dXJuLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAgICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSB0byBvYnNlcnZlXG4gKiBAcGFyYW0gZnVsZmlsbGVkICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZnVsZmlsbGVkIHZhbHVlXG4gKiBAcGFyYW0gcmVqZWN0ZWQgICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgcmVqZWN0aW9uIGV4Y2VwdGlvblxuICogQHBhcmFtIHByb2dyZXNzZWQgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGFueSBwcm9ncmVzcyBub3RpZmljYXRpb25zXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgaW52b2tlZCBjYWxsYmFja1xuICovXG5RLndoZW4gPSB3aGVuO1xuZnVuY3Rpb24gd2hlbih2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xufTtcblxuUS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCB2YWx1ZSkge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IHJlYXNvbjsgfSk7XG59O1xuXG5RLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGhlblJlamVjdChyZWFzb24pO1xufTtcblxuLyoqXG4gKiBJZiBhbiBvYmplY3QgaXMgbm90IGEgcHJvbWlzZSwgaXQgaXMgYXMgXCJuZWFyXCIgYXMgcG9zc2libGUuXG4gKiBJZiBhIHByb21pc2UgaXMgcmVqZWN0ZWQsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlIHRvby5cbiAqIElmIGl04oCZcyBhIGZ1bGZpbGxlZCBwcm9taXNlLCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmVhcmVyLlxuICogSWYgaXTigJlzIGEgZGVmZXJyZWQgcHJvbWlzZSBhbmQgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkLCB0aGVcbiAqIHJlc29sdXRpb24gaXMgXCJuZWFyZXJcIi5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIG1vc3QgcmVzb2x2ZWQgKG5lYXJlc3QpIGZvcm0gb2YgdGhlIG9iamVjdFxuICovXG5cbi8vIFhYWCBzaG91bGQgd2UgcmUtZG8gdGhpcz9cblEubmVhcmVyID0gbmVhcmVyO1xuZnVuY3Rpb24gbmVhcmVyKHZhbHVlKSB7XG4gICAgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IHZhbHVlLmluc3BlY3QoKTtcbiAgICAgICAgaWYgKGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcHJvbWlzZS5cbiAqIE90aGVyd2lzZSBpdCBpcyBhIGZ1bGZpbGxlZCB2YWx1ZS5cbiAqL1xuUS5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIFByb21pc2U7XG59XG5cblEuaXNQcm9taXNlQWxpa2UgPSBpc1Byb21pc2VBbGlrZTtcbmZ1bmN0aW9uIGlzUHJvbWlzZUFsaWtlKG9iamVjdCkge1xuICAgIHJldHVybiBpc09iamVjdChvYmplY3QpICYmIHR5cGVvZiBvYmplY3QudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHBlbmRpbmcgcHJvbWlzZSwgbWVhbmluZyBub3RcbiAqIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cbiAqL1xuUS5pc1BlbmRpbmcgPSBpc1BlbmRpbmc7XG5mdW5jdGlvbiBpc1BlbmRpbmcob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicGVuZGluZ1wiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgdmFsdWUgb3IgZnVsZmlsbGVkXG4gKiBwcm9taXNlLlxuICovXG5RLmlzRnVsZmlsbGVkID0gaXNGdWxmaWxsZWQ7XG5mdW5jdGlvbiBpc0Z1bGZpbGxlZChvYmplY3QpIHtcbiAgICByZXR1cm4gIWlzUHJvbWlzZShvYmplY3QpIHx8IG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqL1xuUS5pc1JlamVjdGVkID0gaXNSZWplY3RlZDtcbmZ1bmN0aW9uIGlzUmVqZWN0ZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn07XG5cbi8vLy8gQkVHSU4gVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vLyBUaGlzIHByb21pc2UgbGlicmFyeSBjb25zdW1lcyBleGNlcHRpb25zIHRocm93biBpbiBoYW5kbGVycyBzbyB0aGV5IGNhbiBiZVxuLy8gaGFuZGxlZCBieSBhIHN1YnNlcXVlbnQgcHJvbWlzZS4gIFRoZSBleGNlcHRpb25zIGdldCBhZGRlZCB0byB0aGlzIGFycmF5IHdoZW5cbi8vIHRoZXkgYXJlIGNyZWF0ZWQsIGFuZCByZW1vdmVkIHdoZW4gdGhleSBhcmUgaGFuZGxlZC4gIE5vdGUgdGhhdCBpbiBFUzYgb3Jcbi8vIHNoaW1tZWQgZW52aXJvbm1lbnRzLCB0aGlzIHdvdWxkIG5hdHVyYWxseSBiZSBhIGBTZXRgLlxudmFyIHVuaGFuZGxlZFJlYXNvbnMgPSBbXTtcbnZhciB1bmhhbmRsZWRSZWplY3Rpb25zID0gW107XG52YXIgcmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zID0gW107XG52YXIgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcblxuZnVuY3Rpb24gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCkge1xuICAgIHVuaGFuZGxlZFJlYXNvbnMubGVuZ3RoID0gMDtcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJhY2tSZWplY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIFEubmV4dFRpY2sucnVuQWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGFycmF5X2luZGV4T2YodW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbWl0KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsIHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgcmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVuaGFuZGxlZFJlamVjdGlvbnMucHVzaChwcm9taXNlKTtcbiAgICBpZiAocmVhc29uICYmIHR5cGVvZiByZWFzb24uc3RhY2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKHJlYXNvbi5zdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKFwiKG5vIHN0YWNrKSBcIiArIHJlYXNvbik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1bnRyYWNrUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0ID0gYXJyYXlfaW5kZXhPZih1bmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKTtcbiAgICBpZiAoYXQgIT09IC0xKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvY2Vzcy5lbWl0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2sucnVuQWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhdFJlcG9ydCA9IGFycmF5X2luZGV4T2YocmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICBpZiAoYXRSZXBvcnQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInJlamVjdGlvbkhhbmRsZWRcIiwgdW5oYW5kbGVkUmVhc29uc1thdF0sIHByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMuc3BsaWNlKGF0UmVwb3J0LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShhdCwgMSk7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICB9XG59XG5cblEucmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zID0gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zO1xuXG5RLmdldFVuaGFuZGxlZFJlYXNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTWFrZSBhIGNvcHkgc28gdGhhdCBjb25zdW1lcnMgY2FuJ3QgaW50ZXJmZXJlIHdpdGggb3VyIGludGVybmFsIHN0YXRlLlxuICAgIHJldHVybiB1bmhhbmRsZWRSZWFzb25zLnNsaWNlKCk7XG59O1xuXG5RLnN0b3BVbmhhbmRsZWRSZWplY3Rpb25UcmFja2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSBmYWxzZTtcbn07XG5cbnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuXG4vLy8vIEVORCBVTkhBTkRMRUQgUkVKRUNUSU9OIFRSQUNLSU5HXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHJlamVjdGVkIHByb21pc2UuXG4gKiBAcGFyYW0gcmVhc29uIHZhbHVlIGRlc2NyaWJpbmcgdGhlIGZhaWx1cmVcbiAqL1xuUS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgdmFyIHJlamVjdGlvbiA9IFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhlIGVycm9yIGhhcyBiZWVuIGhhbmRsZWRcbiAgICAgICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIHVudHJhY2tSZWplY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZChyZWFzb24pIDogdGhpcztcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJyZWplY3RlZFwiLCByZWFzb246IHJlYXNvbiB9O1xuICAgIH0pO1xuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSByZWFzb24gaGFzIG5vdCBiZWVuIGhhbmRsZWQuXG4gICAgdHJhY2tSZWplY3Rpb24ocmVqZWN0aW9uLCByZWFzb24pO1xuXG4gICAgcmV0dXJuIHJlamVjdGlvbjtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgZnVsZmlsbGVkIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZVxuICovXG5RLmZ1bGZpbGwgPSBmdWxmaWxsO1xuZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJnZXRcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXRcIjogZnVuY3Rpb24gKG5hbWUsIHJocykge1xuICAgICAgICAgICAgdmFsdWVbbmFtZV0gPSByaHM7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVsZXRlXCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwicG9zdFwiOiBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgICAgICAgICAgLy8gTWFyayBNaWxsZXIgcHJvcG9zZXMgdGhhdCBwb3N0IHdpdGggbm8gbmFtZSBzaG91bGQgYXBwbHkgYVxuICAgICAgICAgICAgLy8gcHJvbWlzZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCB8fCBuYW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJhcHBseVwiOiBmdW5jdGlvbiAodGhpc3AsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0aGlzcCwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIFwia2V5c1wiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0X2tleXModmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgdm9pZCAwLCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJmdWxmaWxsZWRcIiwgdmFsdWU6IHZhbHVlIH07XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlbmFibGVzIHRvIFEgcHJvbWlzZXMuXG4gKiBAcGFyYW0gcHJvbWlzZSB0aGVuYWJsZSBwcm9taXNlXG4gKiBAcmV0dXJucyBhIFEgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBjb2VyY2UocHJvbWlzZSkge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbi8qKlxuICogQW5ub3RhdGVzIGFuIG9iamVjdCBzdWNoIHRoYXQgaXQgd2lsbCBuZXZlciBiZVxuICogdHJhbnNmZXJyZWQgYXdheSBmcm9tIHRoaXMgcHJvY2VzcyBvdmVyIGFueSBwcm9taXNlXG4gKiBjb21tdW5pY2F0aW9uIGNoYW5uZWwuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBwcm9taXNlIGEgd3JhcHBpbmcgb2YgdGhhdCBvYmplY3QgdGhhdFxuICogYWRkaXRpb25hbGx5IHJlc3BvbmRzIHRvIHRoZSBcImlzRGVmXCIgbWVzc2FnZVxuICogd2l0aG91dCBhIHJlamVjdGlvbi5cbiAqL1xuUS5tYXN0ZXIgPSBtYXN0ZXI7XG5mdW5jdGlvbiBtYXN0ZXIob2JqZWN0KSB7XG4gICAgcmV0dXJuIFByb21pc2Uoe1xuICAgICAgICBcImlzRGVmXCI6IGZ1bmN0aW9uICgpIHt9XG4gICAgfSwgZnVuY3Rpb24gZmFsbGJhY2sob3AsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG9iamVjdCwgb3AsIGFyZ3MpO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFEob2JqZWN0KS5pbnNwZWN0KCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogU3ByZWFkcyB0aGUgdmFsdWVzIG9mIGEgcHJvbWlzZWQgYXJyYXkgb2YgYXJndW1lbnRzIGludG8gdGhlXG4gKiBmdWxmaWxsbWVudCBjYWxsYmFjay5cbiAqIEBwYXJhbSBmdWxmaWxsZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB2YXJpYWRpYyBhcmd1bWVudHMgZnJvbSB0aGVcbiAqIHByb21pc2VkIGFycmF5XG4gKiBAcGFyYW0gcmVqZWN0ZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgZXhjZXB0aW9uIGlmIHRoZSBwcm9taXNlXG4gKiBpcyByZWplY3RlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvciB0aHJvd24gZXhjZXB0aW9uIG9mXG4gKiBlaXRoZXIgY2FsbGJhY2suXG4gKi9cblEuc3ByZWFkID0gc3ByZWFkO1xuZnVuY3Rpb24gc3ByZWFkKHZhbHVlLCBmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIFEodmFsdWUpLnNwcmVhZChmdWxmaWxsZWQsIHJlamVjdGVkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hbGwoKS50aGVuKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gZnVsZmlsbGVkLmFwcGx5KHZvaWQgMCwgYXJyYXkpO1xuICAgIH0sIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogVGhlIGFzeW5jIGZ1bmN0aW9uIGlzIGEgZGVjb3JhdG9yIGZvciBnZW5lcmF0b3IgZnVuY3Rpb25zLCB0dXJuaW5nXG4gKiB0aGVtIGludG8gYXN5bmNocm9ub3VzIGdlbmVyYXRvcnMuICBBbHRob3VnaCBnZW5lcmF0b3JzIGFyZSBvbmx5IHBhcnRcbiAqIG9mIHRoZSBuZXdlc3QgRUNNQVNjcmlwdCA2IGRyYWZ0cywgdGhpcyBjb2RlIGRvZXMgbm90IGNhdXNlIHN5bnRheFxuICogZXJyb3JzIGluIG9sZGVyIGVuZ2luZXMuICBUaGlzIGNvZGUgc2hvdWxkIGNvbnRpbnVlIHRvIHdvcmsgYW5kIHdpbGxcbiAqIGluIGZhY3QgaW1wcm92ZSBvdmVyIHRpbWUgYXMgdGhlIGxhbmd1YWdlIGltcHJvdmVzLlxuICpcbiAqIEVTNiBnZW5lcmF0b3JzIGFyZSBjdXJyZW50bHkgcGFydCBvZiBWOCB2ZXJzaW9uIDMuMTkgd2l0aCB0aGVcbiAqIC0taGFybW9ueS1nZW5lcmF0b3JzIHJ1bnRpbWUgZmxhZyBlbmFibGVkLiAgU3BpZGVyTW9ua2V5IGhhcyBoYWQgdGhlbVxuICogZm9yIGxvbmdlciwgYnV0IHVuZGVyIGFuIG9sZGVyIFB5dGhvbi1pbnNwaXJlZCBmb3JtLiAgVGhpcyBmdW5jdGlvblxuICogd29ya3Mgb24gYm90aCBraW5kcyBvZiBnZW5lcmF0b3JzLlxuICpcbiAqIERlY29yYXRlcyBhIGdlbmVyYXRvciBmdW5jdGlvbiBzdWNoIHRoYXQ6XG4gKiAgLSBpdCBtYXkgeWllbGQgcHJvbWlzZXNcbiAqICAtIGV4ZWN1dGlvbiB3aWxsIGNvbnRpbnVlIHdoZW4gdGhhdCBwcm9taXNlIGlzIGZ1bGZpbGxlZFxuICogIC0gdGhlIHZhbHVlIG9mIHRoZSB5aWVsZCBleHByZXNzaW9uIHdpbGwgYmUgdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogIC0gaXQgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgKHdoZW4gdGhlIGdlbmVyYXRvclxuICogICAgc3RvcHMgaXRlcmF0aW5nKVxuICogIC0gdGhlIGRlY29yYXRlZCBmdW5jdGlvbiByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICogICAgb2YgdGhlIGdlbmVyYXRvciBvciB0aGUgZmlyc3QgcmVqZWN0ZWQgcHJvbWlzZSBhbW9uZyB0aG9zZVxuICogICAgeWllbGRlZC5cbiAqICAtIGlmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgZ2VuZXJhdG9yLCBpdCBwcm9wYWdhdGVzIHRocm91Z2hcbiAqICAgIGV2ZXJ5IGZvbGxvd2luZyB5aWVsZCB1bnRpbCBpdCBpcyBjYXVnaHQsIG9yIHVudGlsIGl0IGVzY2FwZXNcbiAqICAgIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gYWx0b2dldGhlciwgYW5kIGlzIHRyYW5zbGF0ZWQgaW50byBhXG4gKiAgICByZWplY3Rpb24gZm9yIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZSBkZWNvcmF0ZWQgZ2VuZXJhdG9yLlxuICovXG5RLmFzeW5jID0gYXN5bmM7XG5mdW5jdGlvbiBhc3luYyhtYWtlR2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwic2VuZFwiLCBhcmcgaXMgYSB2YWx1ZVxuICAgICAgICAvLyB3aGVuIHZlcmIgaXMgXCJ0aHJvd1wiLCBhcmcgaXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRpbnVlcih2ZXJiLCBhcmcpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8vIFVudGlsIFY4IDMuMTkgLyBDaHJvbWl1bSAyOSBpcyByZWxlYXNlZCwgU3BpZGVyTW9ua2V5IGlzIHRoZSBvbmx5XG4gICAgICAgICAgICAvLyBlbmdpbmUgdGhhdCBoYXMgYSBkZXBsb3llZCBiYXNlIG9mIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgU00ncyBnZW5lcmF0b3JzIHVzZSB0aGUgUHl0aG9uLWluc3BpcmVkIHNlbWFudGljcyBvZlxuICAgICAgICAgICAgLy8gb3V0ZGF0ZWQgRVM2IGRyYWZ0cy4gIFdlIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBFUzYsIGJ1dCB3ZSdkIGFsc29cbiAgICAgICAgICAgIC8vIGxpa2UgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZ2VuZXJhdG9ycyBpbiBkZXBsb3llZCBicm93c2Vycywgc29cbiAgICAgICAgICAgIC8vIHdlIGFsc28gc3VwcG9ydCBQeXRob24tc3R5bGUgZ2VuZXJhdG9ycy4gIEF0IHNvbWUgcG9pbnQgd2UgY2FuIHJlbW92ZVxuICAgICAgICAgICAgLy8gdGhpcyBibG9jay5cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTdG9wSXRlcmF0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRVM2IEdlbmVyYXRvcnNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFEocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQudmFsdWUsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNwaWRlck1vbmtleSBHZW5lcmF0b3JzXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFJlbW92ZSB0aGlzIGNhc2Ugd2hlbiBTTSBkb2VzIEVTNiBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRvclt2ZXJiXShhcmcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBRKGV4Y2VwdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IG1ha2VHZW5lcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcIm5leHRcIik7XG4gICAgICAgIHZhciBlcnJiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcInRocm93XCIpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBzcGF3biBmdW5jdGlvbiBpcyBhIHNtYWxsIHdyYXBwZXIgYXJvdW5kIGFzeW5jIHRoYXQgaW1tZWRpYXRlbHlcbiAqIGNhbGxzIHRoZSBnZW5lcmF0b3IgYW5kIGFsc28gZW5kcyB0aGUgcHJvbWlzZSBjaGFpbiwgc28gdGhhdCBhbnlcbiAqIHVuaGFuZGxlZCBlcnJvcnMgYXJlIHRocm93biBpbnN0ZWFkIG9mIGZvcndhcmRlZCB0byB0aGUgZXJyb3JcbiAqIGhhbmRsZXIuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgaXQncyBleHRyZW1lbHkgY29tbW9uIHRvIHJ1blxuICogZ2VuZXJhdG9ycyBhdCB0aGUgdG9wLWxldmVsIHRvIHdvcmsgd2l0aCBsaWJyYXJpZXMuXG4gKi9cblEuc3Bhd24gPSBzcGF3bjtcbmZ1bmN0aW9uIHNwYXduKG1ha2VHZW5lcmF0b3IpIHtcbiAgICBRLmRvbmUoUS5hc3luYyhtYWtlR2VuZXJhdG9yKSgpKTtcbn1cblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGludGVyZmFjZSBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG4vKipcbiAqIFRocm93cyBhIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB0byBzdG9wIGFuIGFzeW5jaHJvbm91cyBnZW5lcmF0b3IuXG4gKlxuICogVGhpcyBpbnRlcmZhY2UgaXMgYSBzdG9wLWdhcCBtZWFzdXJlIHRvIHN1cHBvcnQgZ2VuZXJhdG9yIHJldHVyblxuICogdmFsdWVzIGluIG9sZGVyIEZpcmVmb3gvU3BpZGVyTW9ua2V5LiAgSW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEVTNlxuICogZ2VuZXJhdG9ycyBsaWtlIENocm9taXVtIDI5LCBqdXN0IHVzZSBcInJldHVyblwiIGluIHlvdXIgZ2VuZXJhdG9yXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSByZXR1cm4gdmFsdWUgZm9yIHRoZSBzdXJyb3VuZGluZyBnZW5lcmF0b3JcbiAqIEB0aHJvd3MgUmV0dXJuVmFsdWUgZXhjZXB0aW9uIHdpdGggdGhlIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIC8vIEVTNiBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiogKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICByZXR1cm4gZm9vICsgYmFyO1xuICogfSlcbiAqIC8vIE9sZGVyIFNwaWRlck1vbmtleSBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiAoKSB7XG4gKiAgICAgIHZhciBmb28gPSB5aWVsZCBnZXRGb29Qcm9taXNlKCk7XG4gKiAgICAgIHZhciBiYXIgPSB5aWVsZCBnZXRCYXJQcm9taXNlKCk7XG4gKiAgICAgIFEucmV0dXJuKGZvbyArIGJhcik7XG4gKiB9KVxuICovXG5RW1wicmV0dXJuXCJdID0gX3JldHVybjtcbmZ1bmN0aW9uIF9yZXR1cm4odmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgUVJldHVyblZhbHVlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgcHJvbWlzZWQgZnVuY3Rpb24gZGVjb3JhdG9yIGVuc3VyZXMgdGhhdCBhbnkgcHJvbWlzZSBhcmd1bWVudHNcbiAqIGFyZSBzZXR0bGVkIGFuZCBwYXNzZWQgYXMgdmFsdWVzIChgdGhpc2AgaXMgYWxzbyBzZXR0bGVkIGFuZCBwYXNzZWRcbiAqIGFzIGEgdmFsdWUpLiAgSXQgd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZSByZXN1bHQgb2YgYSBmdW5jdGlvbiBpc1xuICogYWx3YXlzIGEgcHJvbWlzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGFkZCA9IFEucHJvbWlzZWQoZnVuY3Rpb24gKGEsIGIpIHtcbiAqICAgICByZXR1cm4gYSArIGI7XG4gKiB9KTtcbiAqIGFkZChRKGEpLCBRKEIpKTtcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gZGVjb3JhdGVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGhhcyBiZWVuIGRlY29yYXRlZC5cbiAqL1xuUS5wcm9taXNlZCA9IHByb21pc2VkO1xuZnVuY3Rpb24gcHJvbWlzZWQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3ByZWFkKFt0aGlzLCBhbGwoYXJndW1lbnRzKV0sIGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8qKlxuICogc2VuZHMgYSBtZXNzYWdlIHRvIGEgdmFsdWUgaW4gYSBmdXR1cmUgdHVyblxuICogQHBhcmFtIG9iamVjdCogdGhlIHJlY2lwaWVudFxuICogQHBhcmFtIG9wIHRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlIG9wZXJhdGlvbiwgZS5nLiwgXCJ3aGVuXCIsXG4gKiBAcGFyYW0gYXJncyBmdXJ0aGVyIGFyZ3VtZW50cyB0byBiZSBmb3J3YXJkZWQgdG8gdGhlIG9wZXJhdGlvblxuICogQHJldHVybnMgcmVzdWx0IHtQcm9taXNlfSBhIHByb21pc2UgZm9yIHRoZSByZXN1bHQgb2YgdGhlIG9wZXJhdGlvblxuICovXG5RLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5mdW5jdGlvbiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChvcCwgYXJncyk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKG9wLCBhcmdzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGRlZmVycmVkLnJlc29sdmUsIG9wLCBhcmdzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBnZXRcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHByb3BlcnR5IHZhbHVlXG4gKi9cblEuZ2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3Igb2JqZWN0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHZhbHVlICAgICBuZXcgdmFsdWUgb2YgcHJvcGVydHlcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBkZWxldGVcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLmRlbCA9IC8vIFhYWCBsZWdhY3lcblFbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbCA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gdmFsdWUgICAgIGEgdmFsdWUgdG8gcG9zdCwgdHlwaWNhbGx5IGFuIGFycmF5IG9mXG4gKiAgICAgICAgICAgICAgICAgIGludm9jYXRpb24gYXJndW1lbnRzIGZvciBwcm9taXNlcyB0aGF0XG4gKiAgICAgICAgICAgICAgICAgIGFyZSB1bHRpbWF0ZWx5IGJhY2tlZCB3aXRoIGByZXNvbHZlYCB2YWx1ZXMsXG4gKiAgICAgICAgICAgICAgICAgIGFzIG9wcG9zZWQgdG8gdGhvc2UgYmFja2VkIHdpdGggVVJMc1xuICogICAgICAgICAgICAgICAgICB3aGVyZWluIHRoZSBwb3N0ZWQgdmFsdWUgY2FuIGJlIGFueVxuICogICAgICAgICAgICAgICAgICBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QuXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuLy8gYm91bmQgbG9jYWxseSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgb3RoZXIgbWV0aG9kc1xuUS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBpbnZvY2F0aW9uIGFyZ3VtZW50c1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5RLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEuaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblByb21pc2UucHJvdG90eXBlLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gYXJncyAgICAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZhcHBseSA9IGZ1bmN0aW9uIChvYmplY3QsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RW1widHJ5XCJdID1cblEuZmNhbGwgPSBmdW5jdGlvbiAob2JqZWN0IC8qIC4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzKV0pO1xufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24sIHRyYW5zZm9ybWluZyByZXR1cm4gdmFsdWVzIGludG8gYSBmdWxmaWxsZWRcbiAqIHByb21pc2UgYW5kIHRocm93biBlcnJvcnMgaW50byBhIHJlamVjdGVkIG9uZS5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmJpbmQgPSBmdW5jdGlvbiAob2JqZWN0IC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSBRKG9iamVjdCk7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuZmJpbmQgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIHRoZSBuYW1lcyBvZiB0aGUgb3duZWQgcHJvcGVydGllcyBvZiBhIHByb21pc2VkXG4gKiBvYmplY3QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBrZXlzIG9mIHRoZSBldmVudHVhbGx5IHNldHRsZWQgb2JqZWN0XG4gKi9cblEua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheS4gIElmIGFueSBvZlxuICogdGhlIHByb21pc2VzIGdldHMgcmVqZWN0ZWQsIHRoZSB3aG9sZSBhcnJheSBpcyByZWplY3RlZCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QXJyYXkqfSBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlc1xuICovXG4vLyBCeSBNYXJrIE1pbGxlclxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9c3RyYXdtYW46Y29uY3VycmVuY3kmcmV2PTEzMDg3NzY1MjEjYWxsZnVsZmlsbGVkXG5RLmFsbCA9IGFsbDtcbmZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgdmFyIHBlbmRpbmdDb3VudCA9IDA7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIGFycmF5X3JlZHVjZShwcm9taXNlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgcHJvbWlzZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpc1Byb21pc2UocHJvbWlzZSkgJiZcbiAgICAgICAgICAgICAgICAoc25hcHNob3QgPSBwcm9taXNlLmluc3BlY3QoKSkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHNuYXBzaG90LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICArK3BlbmRpbmdDb3VudDtcbiAgICAgICAgICAgICAgICB3aGVuKFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tcGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoeyBpbmRleDogaW5kZXgsIHZhbHVlOiBwcm9ncmVzcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIGlmIChwZW5kaW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgcmVzb2x2ZWQgcHJvbWlzZSBvZiBhbiBhcnJheS4gUHJpb3IgcmVqZWN0ZWQgcHJvbWlzZXMgYXJlXG4gKiBpZ25vcmVkLiAgUmVqZWN0cyBvbmx5IGlmIGFsbCBwcm9taXNlcyBhcmUgcmVqZWN0ZWQuXG4gKiBAcGFyYW0ge0FycmF5Kn0gYW4gYXJyYXkgY29udGFpbmluZyB2YWx1ZXMgb3IgcHJvbWlzZXMgZm9yIHZhbHVlc1xuICogQHJldHVybnMgYSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgcmVzb2x2ZWQgcHJvbWlzZSxcbiAqIG9yIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiBhbGwgcHJvbWlzZXMgYXJlIHJlamVjdGVkLlxuICovXG5RLmFueSA9IGFueTtcblxuZnVuY3Rpb24gYW55KHByb21pc2VzKSB7XG4gICAgaWYgKHByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gUS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmVycmVkID0gUS5kZWZlcigpO1xuICAgIHZhciBwZW5kaW5nQ291bnQgPSAwO1xuICAgIGFycmF5X3JlZHVjZShwcm9taXNlcywgZnVuY3Rpb24gKHByZXYsIGN1cnJlbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gcHJvbWlzZXNbaW5kZXhdO1xuXG4gICAgICAgIHBlbmRpbmdDb3VudCsrO1xuXG4gICAgICAgIHdoZW4ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpO1xuICAgICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxlZChyZXN1bHQpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblJlamVjdGVkKCkge1xuICAgICAgICAgICAgcGVuZGluZ0NvdW50LS07XG4gICAgICAgICAgICBpZiAocGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJDYW4ndCBnZXQgZnVsZmlsbG1lbnQgdmFsdWUgZnJvbSBhbnkgcHJvbWlzZSwgYWxsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJwcm9taXNlcyB3ZXJlIHJlamVjdGVkLlwiXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Qcm9ncmVzcyhwcm9ncmVzcykge1xuICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb2dyZXNzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHVuZGVmaW5lZCk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbnkodGhpcyk7XG59O1xuXG4vKipcbiAqIFdhaXRzIGZvciBhbGwgcHJvbWlzZXMgdG8gYmUgc2V0dGxlZCwgZWl0aGVyIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQuICBUaGlzIGlzIGRpc3RpbmN0IGZyb20gYGFsbGAgc2luY2UgdGhhdCB3b3VsZCBzdG9wXG4gKiB3YWl0aW5nIGF0IHRoZSBmaXJzdCByZWplY3Rpb24uICBUaGUgcHJvbWlzZSByZXR1cm5lZCBieVxuICogYGFsbFJlc29sdmVkYCB3aWxsIG5ldmVyIGJlIHJlamVjdGVkLlxuICogQHBhcmFtIHByb21pc2VzIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgKG9yIGFuIGFycmF5KSBvZiBwcm9taXNlc1xuICogKG9yIHZhbHVlcylcbiAqIEByZXR1cm4gYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiBwcm9taXNlc1xuICovXG5RLmFsbFJlc29sdmVkID0gZGVwcmVjYXRlKGFsbFJlc29sdmVkLCBcImFsbFJlc29sdmVkXCIsIFwiYWxsU2V0dGxlZFwiKTtcbmZ1bmN0aW9uIGFsbFJlc29sdmVkKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICBwcm9taXNlcyA9IGFycmF5X21hcChwcm9taXNlcywgUSk7XG4gICAgICAgIHJldHVybiB3aGVuKGFsbChhcnJheV9tYXAocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hlbihwcm9taXNlLCBub29wLCBub29wKTtcbiAgICAgICAgfSkpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZXM7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGxSZXNvbHZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWxsUmVzb2x2ZWQodGhpcyk7XG59O1xuXG4vKipcbiAqIEBzZWUgUHJvbWlzZSNhbGxTZXR0bGVkXG4gKi9cblEuYWxsU2V0dGxlZCA9IGFsbFNldHRsZWQ7XG5mdW5jdGlvbiBhbGxTZXR0bGVkKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZXMpLmFsbFNldHRsZWQoKTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBwcm9taXNlcyBpbnRvIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgdGhlaXIgc3RhdGVzIChhc1xuICogcmV0dXJuZWQgYnkgYGluc3BlY3RgKSB3aGVuIHRoZXkgaGF2ZSBhbGwgc2V0dGxlZC5cbiAqIEBwYXJhbSB7QXJyYXlbQW55Kl19IHZhbHVlcyBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyB7QXJyYXlbU3RhdGVdfSBhbiBhcnJheSBvZiBzdGF0ZXMgZm9yIHRoZSByZXNwZWN0aXZlIHZhbHVlcy5cbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUuYWxsU2V0dGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICByZXR1cm4gYWxsKGFycmF5X21hcChwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBRKHByb21pc2UpO1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVnYXJkbGVzcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5pbnNwZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHJlZ2FyZGxlc3MsIHJlZ2FyZGxlc3MpO1xuICAgICAgICB9KSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENhcHR1cmVzIHRoZSBmYWlsdXJlIG9mIGEgcHJvbWlzZSwgZ2l2aW5nIGFuIG9wb3J0dW5pdHkgdG8gcmVjb3ZlclxuICogd2l0aCBhIGNhbGxiYWNrLiAgSWYgdGhlIGdpdmVuIHByb21pc2UgaXMgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAqIHByb21pc2UgaXMgZnVsZmlsbGVkLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGZvciBzb21ldGhpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIGZ1bGZpbGwgdGhlIHJldHVybmVkIHByb21pc2UgaWYgdGhlXG4gKiBnaXZlbiBwcm9taXNlIGlzIHJlamVjdGVkXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrXG4gKi9cblEuZmFpbCA9IC8vIFhYWCBsZWdhY3lcblFbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aGVuKHZvaWQgMCwgcmVqZWN0ZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFpbCA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAocmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgcmVqZWN0ZWQpO1xufTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGxpc3RlbmVyIHRoYXQgY2FuIHJlc3BvbmQgdG8gcHJvZ3Jlc3Mgbm90aWZpY2F0aW9ucyBmcm9tIGFcbiAqIHByb21pc2UncyBvcmlnaW5hdGluZyBkZWZlcnJlZC4gVGhpcyBsaXN0ZW5lciByZWNlaXZlcyB0aGUgZXhhY3QgYXJndW1lbnRzXG4gKiBwYXNzZWQgdG8gYGBkZWZlcnJlZC5ub3RpZnlgYC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBmb3Igc29tZXRoaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byByZWNlaXZlIGFueSBwcm9ncmVzcyBub3RpZmljYXRpb25zXG4gKiBAcmV0dXJucyB0aGUgZ2l2ZW4gcHJvbWlzZSwgdW5jaGFuZ2VkXG4gKi9cblEucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbmZ1bmN0aW9uIHByb2dyZXNzKG9iamVjdCwgcHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGhlbih2b2lkIDAsIHZvaWQgMCwgcHJvZ3Jlc3NlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgdm9pZCAwLCBwcm9ncmVzc2VkKTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgYW4gb3Bwb3J0dW5pdHkgdG8gb2JzZXJ2ZSB0aGUgc2V0dGxpbmcgb2YgYSBwcm9taXNlLFxuICogcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCBvciByZWplY3RlZC4gIEZvcndhcmRzXG4gKiB0aGUgcmVzb2x1dGlvbiB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aGVuIHRoZSBjYWxsYmFjayBpcyBkb25lLlxuICogVGhlIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBwcm9taXNlIHRvIGRlZmVyIGNvbXBsZXRpb24uXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIG9ic2VydmUgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuXG4gKiBwcm9taXNlLCB0YWtlcyBubyBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIHdoZW5cbiAqIGBgZmluYGAgaXMgZG9uZS5cbiAqL1xuUS5maW4gPSAvLyBYWFggbGVnYWN5XG5RW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KVtcImZpbmFsbHlcIl0oY2FsbGJhY2spO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmluID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBRKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBUT0RPIGF0dGVtcHQgdG8gcmVjeWNsZSB0aGUgcmVqZWN0aW9uIHdpdGggXCJ0aGlzXCIuXG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogVGVybWluYXRlcyBhIGNoYWluIG9mIHByb21pc2VzLCBmb3JjaW5nIHJlamVjdGlvbnMgdG8gYmVcbiAqIHRocm93biBhcyBleGNlcHRpb25zLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGF0IHRoZSBlbmQgb2YgYSBjaGFpbiBvZiBwcm9taXNlc1xuICogQHJldHVybnMgbm90aGluZ1xuICovXG5RLmRvbmUgPSBmdW5jdGlvbiAob2JqZWN0LCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZG9uZShmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG4gICAgdmFyIG9uVW5oYW5kbGVkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgLy8gZm9yd2FyZCB0byBhIGZ1dHVyZSB0dXJuIHNvIHRoYXQgYGB3aGVuYGBcbiAgICAgICAgLy8gZG9lcyBub3QgY2F0Y2ggaXQgYW5kIHR1cm4gaXQgaW50byBhIHJlamVjdGlvbi5cbiAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIHByb21pc2UpO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgYG5leHRUaWNrYGluZyB2aWEgYW4gdW5uZWNlc3NhcnkgYHdoZW5gLlxuICAgIHZhciBwcm9taXNlID0gZnVsZmlsbGVkIHx8IHJlamVjdGVkIHx8IHByb2dyZXNzID9cbiAgICAgICAgdGhpcy50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSA6XG4gICAgICAgIHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgICBvblVuaGFuZGxlZEVycm9yID0gcHJvY2Vzcy5kb21haW4uYmluZChvblVuaGFuZGxlZEVycm9yKTtcbiAgICB9XG5cbiAgICBwcm9taXNlLnRoZW4odm9pZCAwLCBvblVuaGFuZGxlZEVycm9yKTtcbn07XG5cbi8qKlxuICogQ2F1c2VzIGEgcHJvbWlzZSB0byBiZSByZWplY3RlZCBpZiBpdCBkb2VzIG5vdCBnZXQgZnVsZmlsbGVkIGJlZm9yZVxuICogc29tZSBtaWxsaXNlY29uZHMgdGltZSBvdXQuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHMgdGltZW91dFxuICogQHBhcmFtIHtBbnkqfSBjdXN0b20gZXJyb3IgbWVzc2FnZSBvciBFcnJvciBvYmplY3QgKG9wdGlvbmFsKVxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpZiBpdCBpc1xuICogZnVsZmlsbGVkIGJlZm9yZSB0aGUgdGltZW91dCwgb3RoZXJ3aXNlIHJlamVjdGVkLlxuICovXG5RLnRpbWVvdXQgPSBmdW5jdGlvbiAob2JqZWN0LCBtcywgZXJyb3IpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRpbWVvdXQobXMsIGVycm9yKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMsIGVycm9yKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZXJyb3IgfHwgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvciB8fCBcIlRpbWVkIG91dCBhZnRlciBcIiArIG1zICsgXCIgbXNcIik7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gXCJFVElNRURPVVRcIjtcbiAgICAgICAgfVxuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgIH0sIG1zKTtcblxuICAgIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgIH0sIGRlZmVycmVkLm5vdGlmeSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBnaXZlbiB2YWx1ZSAob3IgcHJvbWlzZWQgdmFsdWUpLCBzb21lXG4gKiBtaWxsaXNlY29uZHMgYWZ0ZXIgaXQgcmVzb2x2ZWQuIFBhc3NlcyByZWplY3Rpb25zIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGFmdGVyIG1pbGxpc2Vjb25kc1xuICogdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZS5cbiAqIElmIHRoZSBnaXZlbiBwcm9taXNlIHJlamVjdHMsIHRoYXQgaXMgcGFzc2VkIGltbWVkaWF0ZWx5LlxuICovXG5RLmRlbGF5ID0gZnVuY3Rpb24gKG9iamVjdCwgdGltZW91dCkge1xuICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGltZW91dCA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gUShvYmplY3QpLmRlbGF5KHRpbWVvdXQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUGFzc2VzIGEgY29udGludWF0aW9uIHRvIGEgTm9kZSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgYXMgYW4gYXJyYXksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqXG4gKiAgICAgIFEubmZhcHBseShGUy5yZWFkRmlsZSwgW19fZmlsZW5hbWVdKVxuICogICAgICAudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICogICAgICB9KVxuICpcbiAqL1xuUS5uZmFwcGx5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBpbmRpdmlkdWFsbHksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mY2FsbChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSlcbiAqIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiB9KVxuICpcbiAqL1xuUS5uZmNhbGwgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmNhbGwgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFdyYXBzIGEgTm9kZUpTIGNvbnRpbnVhdGlvbiBwYXNzaW5nIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGFuIGVxdWl2YWxlbnRcbiAqIHZlcnNpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mYmluZChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSkoXCJ1dGYtOFwiKVxuICogLnRoZW4oY29uc29sZS5sb2cpXG4gKiAuZG9uZSgpXG4gKi9cblEubmZiaW5kID1cblEuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgUShjYWxsYmFjaykuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmJpbmQgPVxuUHJvbWlzZS5wcm90b3R5cGUuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gUS5kZW5vZGVpZnkuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cblEubmJpbmQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpc3AsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgUShib3VuZCkuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uYmluZCA9IGZ1bmN0aW9uICgvKnRoaXNwLCAuLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMCk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLm5iaW5kLmFwcGx5KHZvaWQgMCwgYXJncyk7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2sgd2l0aCBhIGdpdmVuIGFycmF5IG9mIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkIGNhbGxiYWNrLlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIHtBcnJheX0gYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5ubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEubnBvc3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ucG9zdChuYW1lLCBhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUubnBvc3QgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MgfHwgW10pO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjaywgZm9yd2FyZGluZyB0aGUgZ2l2ZW4gdmFyaWFkaWMgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWRcbiAqIGNhbGxiYWNrIGFyZ3VtZW50LlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIC4uLmFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZDsgdGhlIGNhbGxiYWNrIHdpbGxcbiAqIGJlIHByb3ZpZGVkIGJ5IFEgYW5kIGFwcGVuZGVkIHRvIHRoZXNlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9yIGVycm9yXG4gKi9cblEubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUS5ubWNhbGwgPSAvLyBYWFggQmFzZWQgb24gXCJSZWRzYW5kcm8nc1wiIHByb3Bvc2FsXG5RLm5pbnZva2UgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5zZW5kID0gLy8gWFhYIEJhc2VkIG9uIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgXCJzZW5kXCJcblByb21pc2UucHJvdG90eXBlLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblByb21pc2UucHJvdG90eXBlLm5pbnZva2UgPSBmdW5jdGlvbiAobmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBJZiBhIGZ1bmN0aW9uIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBib3RoIE5vZGUgY29udGludWF0aW9uLXBhc3Npbmctc3R5bGUgYW5kXG4gKiBwcm9taXNlLXJldHVybmluZy1zdHlsZSwgaXQgY2FuIGVuZCBpdHMgaW50ZXJuYWwgcHJvbWlzZSBjaGFpbiB3aXRoXG4gKiBgbm9kZWlmeShub2RlYmFjaylgLCBmb3J3YXJkaW5nIHRoZSBvcHRpb25hbCBub2RlYmFjayBhcmd1bWVudC4gIElmIHRoZSB1c2VyXG4gKiBlbGVjdHMgdG8gdXNlIGEgbm9kZWJhY2ssIHRoZSByZXN1bHQgd2lsbCBiZSBzZW50IHRoZXJlLiAgSWYgdGhleSBkbyBub3RcbiAqIHBhc3MgYSBub2RlYmFjaywgdGhleSB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdCBwcm9taXNlLlxuICogQHBhcmFtIG9iamVjdCBhIHJlc3VsdCAob3IgYSBwcm9taXNlIGZvciBhIHJlc3VsdClcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5vZGViYWNrIGEgTm9kZS5qcy1zdHlsZSBjYWxsYmFja1xuICogQHJldHVybnMgZWl0aGVyIHRoZSBwcm9taXNlIG9yIG5vdGhpbmdcbiAqL1xuUS5ub2RlaWZ5ID0gbm9kZWlmeTtcbmZ1bmN0aW9uIG5vZGVpZnkob2JqZWN0LCBub2RlYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdCkubm9kZWlmeShub2RlYmFjayk7XG59XG5cblByb21pc2UucHJvdG90eXBlLm5vZGVpZnkgPSBmdW5jdGlvbiAobm9kZWJhY2spIHtcbiAgICBpZiAobm9kZWJhY2spIHtcbiAgICAgICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbm9kZWJhY2sobnVsbCwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbm9kZWJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cblEubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlEubm9Db25mbGljdCBvbmx5IHdvcmtzIHdoZW4gUSBpcyB1c2VkIGFzIGEgZ2xvYmFsXCIpO1xufTtcblxuLy8gQWxsIGNvZGUgYmVmb3JlIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcy5cbnZhciBxRW5kaW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG5cbnJldHVybiBRO1xuXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbUZyb21TZWVkID0gcmVxdWlyZSgnLi9yYW5kb20vcmFuZG9tLWZyb20tc2VlZCcpO1xuXG52YXIgT1JJR0lOQUwgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfLSc7XG52YXIgYWxwaGFiZXQ7XG52YXIgcHJldmlvdXNTZWVkO1xuXG52YXIgc2h1ZmZsZWQ7XG5cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHNodWZmbGVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNldENoYXJhY3RlcnMoX2FscGhhYmV0Xykge1xuICAgIGlmICghX2FscGhhYmV0Xykge1xuICAgICAgICBpZiAoYWxwaGFiZXQgIT09IE9SSUdJTkFMKSB7XG4gICAgICAgICAgICBhbHBoYWJldCA9IE9SSUdJTkFMO1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKF9hbHBoYWJldF8gPT09IGFscGhhYmV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoX2FscGhhYmV0Xy5sZW5ndGggIT09IE9SSUdJTkFMLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1c3RvbSBhbHBoYWJldCBmb3Igc2hvcnRpZCBtdXN0IGJlICcgKyBPUklHSU5BTC5sZW5ndGggKyAnIHVuaXF1ZSBjaGFyYWN0ZXJzLiBZb3Ugc3VibWl0dGVkICcgKyBfYWxwaGFiZXRfLmxlbmd0aCArICcgY2hhcmFjdGVyczogJyArIF9hbHBoYWJldF8pO1xuICAgIH1cblxuICAgIHZhciB1bmlxdWUgPSBfYWxwaGFiZXRfLnNwbGl0KCcnKS5maWx0ZXIoZnVuY3Rpb24oaXRlbSwgaW5kLCBhcnIpe1xuICAgICAgIHJldHVybiBpbmQgIT09IGFyci5sYXN0SW5kZXhPZihpdGVtKTtcbiAgICB9KTtcblxuICAgIGlmICh1bmlxdWUubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VzdG9tIGFscGhhYmV0IGZvciBzaG9ydGlkIG11c3QgYmUgJyArIE9SSUdJTkFMLmxlbmd0aCArICcgdW5pcXVlIGNoYXJhY3RlcnMuIFRoZXNlIGNoYXJhY3RlcnMgd2VyZSBub3QgdW5pcXVlOiAnICsgdW5pcXVlLmpvaW4oJywgJykpO1xuICAgIH1cblxuICAgIGFscGhhYmV0ID0gX2FscGhhYmV0XztcbiAgICByZXNldCgpO1xufVxuXG5mdW5jdGlvbiBjaGFyYWN0ZXJzKF9hbHBoYWJldF8pIHtcbiAgICBzZXRDaGFyYWN0ZXJzKF9hbHBoYWJldF8pO1xuICAgIHJldHVybiBhbHBoYWJldDtcbn1cblxuZnVuY3Rpb24gc2V0U2VlZChzZWVkKSB7XG4gICAgcmFuZG9tRnJvbVNlZWQuc2VlZChzZWVkKTtcbiAgICBpZiAocHJldmlvdXNTZWVkICE9PSBzZWVkKSB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHByZXZpb3VzU2VlZCA9IHNlZWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzaHVmZmxlKCkge1xuICAgIGlmICghYWxwaGFiZXQpIHtcbiAgICAgICAgc2V0Q2hhcmFjdGVycyhPUklHSU5BTCk7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUFycmF5ID0gYWxwaGFiZXQuc3BsaXQoJycpO1xuICAgIHZhciB0YXJnZXRBcnJheSA9IFtdO1xuICAgIHZhciByID0gcmFuZG9tRnJvbVNlZWQubmV4dFZhbHVlKCk7XG4gICAgdmFyIGNoYXJhY3RlckluZGV4O1xuXG4gICAgd2hpbGUgKHNvdXJjZUFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgciA9IHJhbmRvbUZyb21TZWVkLm5leHRWYWx1ZSgpO1xuICAgICAgICBjaGFyYWN0ZXJJbmRleCA9IE1hdGguZmxvb3IociAqIHNvdXJjZUFycmF5Lmxlbmd0aCk7XG4gICAgICAgIHRhcmdldEFycmF5LnB1c2goc291cmNlQXJyYXkuc3BsaWNlKGNoYXJhY3RlckluZGV4LCAxKVswXSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRBcnJheS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2h1ZmZsZWQoKSB7XG4gICAgaWYgKHNodWZmbGVkKSB7XG4gICAgICAgIHJldHVybiBzaHVmZmxlZDtcbiAgICB9XG4gICAgc2h1ZmZsZWQgPSBzaHVmZmxlKCk7XG4gICAgcmV0dXJuIHNodWZmbGVkO1xufVxuXG4vKipcbiAqIGxvb2t1cCBzaHVmZmxlZCBsZXR0ZXJcbiAqIEBwYXJhbSBpbmRleFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbG9va3VwKGluZGV4KSB7XG4gICAgdmFyIGFscGhhYmV0U2h1ZmZsZWQgPSBnZXRTaHVmZmxlZCgpO1xuICAgIHJldHVybiBhbHBoYWJldFNodWZmbGVkW2luZGV4XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY2hhcmFjdGVyczogY2hhcmFjdGVycyxcbiAgICBzZWVkOiBzZXRTZWVkLFxuICAgIGxvb2t1cDogbG9va3VwLFxuICAgIHNodWZmbGVkOiBnZXRTaHVmZmxlZFxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbHBoYWJldCA9IHJlcXVpcmUoJy4vYWxwaGFiZXQnKTtcblxuLyoqXG4gKiBEZWNvZGUgdGhlIGlkIHRvIGdldCB0aGUgdmVyc2lvbiBhbmQgd29ya2VyXG4gKiBNYWlubHkgZm9yIGRlYnVnZ2luZyBhbmQgdGVzdGluZy5cbiAqIEBwYXJhbSBpZCAtIHRoZSBzaG9ydGlkLWdlbmVyYXRlZCBpZC5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGlkKSB7XG4gICAgdmFyIGNoYXJhY3RlcnMgPSBhbHBoYWJldC5zaHVmZmxlZCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IGNoYXJhY3RlcnMuaW5kZXhPZihpZC5zdWJzdHIoMCwgMSkpICYgMHgwZixcbiAgICAgICAgd29ya2VyOiBjaGFyYWN0ZXJzLmluZGV4T2YoaWQuc3Vic3RyKDEsIDEpKSAmIDB4MGZcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbUJ5dGUgPSByZXF1aXJlKCcuL3JhbmRvbS9yYW5kb20tYnl0ZScpO1xuXG5mdW5jdGlvbiBlbmNvZGUobG9va3VwLCBudW1iZXIpIHtcbiAgICB2YXIgbG9vcENvdW50ZXIgPSAwO1xuICAgIHZhciBkb25lO1xuXG4gICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgIHN0ciA9IHN0ciArIGxvb2t1cCggKCAobnVtYmVyID4+ICg0ICogbG9vcENvdW50ZXIpKSAmIDB4MGYgKSB8IHJhbmRvbUJ5dGUoKSApO1xuICAgICAgICBkb25lID0gbnVtYmVyIDwgKE1hdGgucG93KDE2LCBsb29wQ291bnRlciArIDEgKSApO1xuICAgICAgICBsb29wQ291bnRlcisrO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gcmVxdWlyZSgnLi9hbHBoYWJldCcpO1xudmFyIGVuY29kZSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG52YXIgZGVjb2RlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbnZhciBpc1ZhbGlkID0gcmVxdWlyZSgnLi9pcy12YWxpZCcpO1xuXG4vLyBJZ25vcmUgYWxsIG1pbGxpc2Vjb25kcyBiZWZvcmUgYSBjZXJ0YWluIHRpbWUgdG8gcmVkdWNlIHRoZSBzaXplIG9mIHRoZSBkYXRlIGVudHJvcHkgd2l0aG91dCBzYWNyaWZpY2luZyB1bmlxdWVuZXNzLlxuLy8gVGhpcyBudW1iZXIgc2hvdWxkIGJlIHVwZGF0ZWQgZXZlcnkgeWVhciBvciBzbyB0byBrZWVwIHRoZSBnZW5lcmF0ZWQgaWQgc2hvcnQuXG4vLyBUbyByZWdlbmVyYXRlIGBuZXcgRGF0ZSgpIC0gMGAgYW5kIGJ1bXAgdGhlIHZlcnNpb24uIEFsd2F5cyBidW1wIHRoZSB2ZXJzaW9uIVxudmFyIFJFRFVDRV9USU1FID0gMTQyNjQ1MjQxNDA5MztcblxuLy8gZG9uJ3QgY2hhbmdlIHVubGVzcyB3ZSBjaGFuZ2UgdGhlIGFsZ29zIG9yIFJFRFVDRV9USU1FXG4vLyBtdXN0IGJlIGFuIGludGVnZXIgYW5kIGxlc3MgdGhhbiAxNlxudmFyIHZlcnNpb24gPSA1O1xuXG4vLyBpZiB5b3UgYXJlIHVzaW5nIGNsdXN0ZXIgb3IgbXVsdGlwbGUgc2VydmVycyB1c2UgdGhpcyB0byBtYWtlIGVhY2ggaW5zdGFuY2Vcbi8vIGhhcyBhIHVuaXF1ZSB2YWx1ZSBmb3Igd29ya2VyXG4vLyBOb3RlOiBJIGRvbid0IGtub3cgaWYgdGhpcyBpcyBhdXRvbWF0aWNhbGx5IHNldCB3aGVuIHVzaW5nIHRoaXJkXG4vLyBwYXJ0eSBjbHVzdGVyIHNvbHV0aW9ucyBzdWNoIGFzIHBtMi5cbnZhciBjbHVzdGVyV29ya2VySWQgPSByZXF1aXJlKCcuL3V0aWwvY2x1c3Rlci13b3JrZXItaWQnKSB8fCAwO1xuXG4vLyBDb3VudGVyIGlzIHVzZWQgd2hlbiBzaG9ydGlkIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiBvbmUgc2Vjb25kLlxudmFyIGNvdW50ZXI7XG5cbi8vIFJlbWVtYmVyIHRoZSBsYXN0IHRpbWUgc2hvcnRpZCB3YXMgY2FsbGVkIGluIGNhc2UgY291bnRlciBpcyBuZWVkZWQuXG52YXIgcHJldmlvdXNTZWNvbmRzO1xuXG4vKipcbiAqIEdlbmVyYXRlIHVuaXF1ZSBpZFxuICogUmV0dXJucyBzdHJpbmcgaWRcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG5cbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICB2YXIgc2Vjb25kcyA9IE1hdGguZmxvb3IoKERhdGUubm93KCkgLSBSRURVQ0VfVElNRSkgKiAwLjAwMSk7XG5cbiAgICBpZiAoc2Vjb25kcyA9PT0gcHJldmlvdXNTZWNvbmRzKSB7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudGVyID0gMDtcbiAgICAgICAgcHJldmlvdXNTZWNvbmRzID0gc2Vjb25kcztcbiAgICB9XG5cbiAgICBzdHIgPSBzdHIgKyBlbmNvZGUoYWxwaGFiZXQubG9va3VwLCB2ZXJzaW9uKTtcbiAgICBzdHIgPSBzdHIgKyBlbmNvZGUoYWxwaGFiZXQubG9va3VwLCBjbHVzdGVyV29ya2VySWQpO1xuICAgIGlmIChjb3VudGVyID4gMCkge1xuICAgICAgICBzdHIgPSBzdHIgKyBlbmNvZGUoYWxwaGFiZXQubG9va3VwLCBjb3VudGVyKTtcbiAgICB9XG4gICAgc3RyID0gc3RyICsgZW5jb2RlKGFscGhhYmV0Lmxvb2t1cCwgc2Vjb25kcyk7XG5cbiAgICByZXR1cm4gc3RyO1xufVxuXG5cbi8qKlxuICogU2V0IHRoZSBzZWVkLlxuICogSGlnaGx5IHJlY29tbWVuZGVkIGlmIHlvdSBkb24ndCB3YW50IHBlb3BsZSB0byB0cnkgdG8gZmlndXJlIG91dCB5b3VyIGlkIHNjaGVtYS5cbiAqIGV4cG9zZWQgYXMgc2hvcnRpZC5zZWVkKGludClcbiAqIEBwYXJhbSBzZWVkIEludGVnZXIgdmFsdWUgdG8gc2VlZCB0aGUgcmFuZG9tIGFscGhhYmV0LiAgQUxXQVlTIFVTRSBUSEUgU0FNRSBTRUVEIG9yIHlvdSBtaWdodCBnZXQgb3ZlcmxhcHMuXG4gKi9cbmZ1bmN0aW9uIHNlZWQoc2VlZFZhbHVlKSB7XG4gICAgYWxwaGFiZXQuc2VlZChzZWVkVmFsdWUpO1xuICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNsdXN0ZXIgd29ya2VyIG9yIG1hY2hpbmUgaWRcbiAqIGV4cG9zZWQgYXMgc2hvcnRpZC53b3JrZXIoaW50KVxuICogQHBhcmFtIHdvcmtlcklkIHdvcmtlciBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXIuICBOdW1iZXIgbGVzcyB0aGFuIDE2IGlzIHJlY29tbWVuZGVkLlxuICogcmV0dXJucyBzaG9ydGlkIG1vZHVsZSBzbyBpdCBjYW4gYmUgY2hhaW5lZC5cbiAqL1xuZnVuY3Rpb24gd29ya2VyKHdvcmtlcklkKSB7XG4gICAgY2x1c3RlcldvcmtlcklkID0gd29ya2VySWQ7XG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vKipcbiAqXG4gKiBzZXRzIG5ldyBjaGFyYWN0ZXJzIHRvIHVzZSBpbiB0aGUgYWxwaGFiZXRcbiAqIHJldHVybnMgdGhlIHNodWZmbGVkIGFscGhhYmV0XG4gKi9cbmZ1bmN0aW9uIGNoYXJhY3RlcnMobmV3Q2hhcmFjdGVycykge1xuICAgIGlmIChuZXdDaGFyYWN0ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWxwaGFiZXQuY2hhcmFjdGVycyhuZXdDaGFyYWN0ZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWxwaGFiZXQuc2h1ZmZsZWQoKTtcbn1cblxuXG4vLyBFeHBvcnQgYWxsIG90aGVyIGZ1bmN0aW9ucyBhcyBwcm9wZXJ0aWVzIG9mIHRoZSBnZW5lcmF0ZSBmdW5jdGlvblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZTtcbm1vZHVsZS5leHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XG5tb2R1bGUuZXhwb3J0cy5zZWVkID0gc2VlZDtcbm1vZHVsZS5leHBvcnRzLndvcmtlciA9IHdvcmtlcjtcbm1vZHVsZS5leHBvcnRzLmNoYXJhY3RlcnMgPSBjaGFyYWN0ZXJzO1xubW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xubW9kdWxlLmV4cG9ydHMuaXNWYWxpZCA9IGlzVmFsaWQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWxwaGFiZXQgPSByZXF1aXJlKCcuL2FscGhhYmV0Jyk7XG5cbmZ1bmN0aW9uIGlzU2hvcnRJZChpZCkge1xuICAgIGlmICghaWQgfHwgdHlwZW9mIGlkICE9PSAnc3RyaW5nJyB8fCBpZC5sZW5ndGggPCA2ICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJhY3RlcnMgPSBhbHBoYWJldC5jaGFyYWN0ZXJzKCk7XG4gICAgdmFyIGludmFsaWRDaGFyYWN0ZXJzID0gaWQuc3BsaXQoJycpLm1hcChmdW5jdGlvbihjaGFyKXtcbiAgICAgICAgaWYgKGNoYXJhY3RlcnMuaW5kZXhPZihjaGFyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFyO1xuICAgICAgICB9XG4gICAgfSkuam9pbignJykuc3BsaXQoJycpLmpvaW4oJycpO1xuXG4gICAgcmV0dXJuIGludmFsaWRDaGFyYWN0ZXJzLmxlbmd0aCA9PT0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Nob3J0SWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0bzsgLy8gSUUgMTEgdXNlcyB3aW5kb3cubXNDcnlwdG9cblxuZnVuY3Rpb24gcmFuZG9tQnl0ZSgpIHtcbiAgICBpZiAoIWNyeXB0byB8fCAhY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSAmIDB4MzA7XG4gICAgfVxuICAgIHZhciBkZXN0ID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhkZXN0KTtcbiAgICByZXR1cm4gZGVzdFswXSAmIDB4MzA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmFuZG9tQnl0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gRm91bmQgdGhpcyBzZWVkLWJhc2VkIHJhbmRvbSBnZW5lcmF0b3Igc29tZXdoZXJlXG4vLyBCYXNlZCBvbiBUaGUgQ2VudHJhbCBSYW5kb21pemVyIDEuMyAoQykgMTk5NyBieSBQYXVsIEhvdWxlIChob3VsZUBtc2MuY29ybmVsbC5lZHUpXG5cbnZhciBzZWVkID0gMTtcblxuLyoqXG4gKiByZXR1cm4gYSByYW5kb20gbnVtYmVyIGJhc2VkIG9uIGEgc2VlZFxuICogQHBhcmFtIHNlZWRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldE5leHRWYWx1ZSgpIHtcbiAgICBzZWVkID0gKHNlZWQgKiA5MzAxICsgNDkyOTcpICUgMjMzMjgwO1xuICAgIHJldHVybiBzZWVkLygyMzMyODAuMCk7XG59XG5cbmZ1bmN0aW9uIHNldFNlZWQoX3NlZWRfKSB7XG4gICAgc2VlZCA9IF9zZWVkXztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbmV4dFZhbHVlOiBnZXROZXh0VmFsdWUsXG4gICAgc2VlZDogc2V0U2VlZFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAwO1xuIiwiKGZ1bmN0aW9uIChzaW5vbkNoYWkpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIE1vZHVsZSBzeXN0ZW1zIG1hZ2ljIGRhbmNlLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIE5vZGVKU1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHNpbm9uQ2hhaTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRFxuICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpbm9uQ2hhaTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXIgZW52aXJvbm1lbnQgKHVzdWFsbHkgPHNjcmlwdD4gdGFnKTogcGx1ZyBpbiB0byBnbG9iYWwgY2hhaSBpbnN0YW5jZSBkaXJlY3RseS5cbiAgICAgICAgY2hhaS51c2Uoc2lub25DaGFpKTtcbiAgICB9XG59KGZ1bmN0aW9uIHNpbm9uQ2hhaShjaGFpLCB1dGlscykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgZnVuY3Rpb24gaXNTcHkocHV0YXRpdmVTcHkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwdXRhdGl2ZVNweSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICB0eXBlb2YgcHV0YXRpdmVTcHkuZ2V0Q2FsbCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICB0eXBlb2YgcHV0YXRpdmVTcHkuY2FsbGVkV2l0aEV4YWN0bHkgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aW1lc0luV29yZHMoY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50ID09PSAxID8gXCJvbmNlXCIgOlxuICAgICAgICAgICAgICAgY291bnQgPT09IDIgPyBcInR3aWNlXCIgOlxuICAgICAgICAgICAgICAgY291bnQgPT09IDMgPyBcInRocmljZVwiIDpcbiAgICAgICAgICAgICAgIChjb3VudCB8fCAwKSArIFwiIHRpbWVzXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDYWxsKHB1dGF0aXZlQ2FsbCkge1xuICAgICAgICByZXR1cm4gcHV0YXRpdmVDYWxsICYmIGlzU3B5KHB1dGF0aXZlQ2FsbC5wcm94eSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0Q2FuV29ya1dpdGgoYXNzZXJ0aW9uKSB7XG4gICAgICAgIGlmICghaXNTcHkoYXNzZXJ0aW9uLl9vYmopICYmICFpc0NhbGwoYXNzZXJ0aW9uLl9vYmopKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHV0aWxzLmluc3BlY3QoYXNzZXJ0aW9uLl9vYmopICsgXCIgaXMgbm90IGEgc3B5IG9yIGEgY2FsbCB0byBhIHNweSFcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNZXNzYWdlcyhzcHksIGFjdGlvbiwgbm9uTmVnYXRlZFN1ZmZpeCwgYWx3YXlzLCBhcmdzKSB7XG4gICAgICAgIHZhciB2ZXJiUGhyYXNlID0gYWx3YXlzID8gXCJhbHdheXMgaGF2ZSBcIiA6IFwiaGF2ZSBcIjtcbiAgICAgICAgbm9uTmVnYXRlZFN1ZmZpeCA9IG5vbk5lZ2F0ZWRTdWZmaXggfHwgXCJcIjtcbiAgICAgICAgaWYgKGlzU3B5KHNweS5wcm94eSkpIHtcbiAgICAgICAgICAgIHNweSA9IHNweS5wcm94eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByaW50ZkFycmF5KGFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3B5LnByaW50Zi5hcHBseShzcHksIGFycmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZmZpcm1hdGl2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmludGZBcnJheShbXCJleHBlY3RlZCAlbiB0byBcIiArIHZlcmJQaHJhc2UgKyBhY3Rpb24gKyBub25OZWdhdGVkU3VmZml4XS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5lZ2F0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaW50ZkFycmF5KFtcImV4cGVjdGVkICVuIHRvIG5vdCBcIiArIHZlcmJQaHJhc2UgKyBhY3Rpb25dLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2lub25Qcm9wZXJ0eShuYW1lLCBhY3Rpb24sIG5vbk5lZ2F0ZWRTdWZmaXgpIHtcbiAgICAgICAgdXRpbHMuYWRkUHJvcGVydHkoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCBuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnRDYW5Xb3JrV2l0aCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gZ2V0TWVzc2FnZXModGhpcy5fb2JqLCBhY3Rpb24sIG5vbk5lZ2F0ZWRTdWZmaXgsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KHRoaXMuX29ialtuYW1lXSwgbWVzc2FnZXMuYWZmaXJtYXRpdmUsIG1lc3NhZ2VzLm5lZ2F0aXZlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2lub25Qcm9wZXJ0eUFzQm9vbGVhbk1ldGhvZChuYW1lLCBhY3Rpb24sIG5vbk5lZ2F0ZWRTdWZmaXgpIHtcbiAgICAgICAgdXRpbHMuYWRkTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgbmFtZSwgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgYXNzZXJ0Q2FuV29ya1dpdGgodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IGdldE1lc3NhZ2VzKHRoaXMuX29iaiwgYWN0aW9uLCBub25OZWdhdGVkU3VmZml4LCBmYWxzZSwgW3RpbWVzSW5Xb3JkcyhhcmcpXSk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydCh0aGlzLl9vYmpbbmFtZV0gPT09IGFyZywgbWVzc2FnZXMuYWZmaXJtYXRpdmUsIG1lc3NhZ2VzLm5lZ2F0aXZlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU2lub25NZXRob2RIYW5kbGVyKHNpbm9uTmFtZSwgYWN0aW9uLCBub25OZWdhdGVkU3VmZml4KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnRDYW5Xb3JrV2l0aCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIGFsd2F5c1Npbm9uTWV0aG9kID0gXCJhbHdheXNcIiArIHNpbm9uTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgc2lub25OYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRCZUFsd2F5cyA9IHV0aWxzLmZsYWcodGhpcywgXCJhbHdheXNcIikgJiYgdHlwZW9mIHRoaXMuX29ialthbHdheXNTaW5vbk1ldGhvZF0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIHZhciBzaW5vbk1ldGhvZCA9IHNob3VsZEJlQWx3YXlzID8gYWx3YXlzU2lub25NZXRob2QgOiBzaW5vbk5hbWU7XG5cbiAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IGdldE1lc3NhZ2VzKHRoaXMuX29iaiwgYWN0aW9uLCBub25OZWdhdGVkU3VmZml4LCBzaG91bGRCZUFsd2F5cywgc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KHRoaXMuX29ialtzaW5vbk1ldGhvZF0uYXBwbHkodGhpcy5fb2JqLCBhcmd1bWVudHMpLCBtZXNzYWdlcy5hZmZpcm1hdGl2ZSwgbWVzc2FnZXMubmVnYXRpdmUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNpbm9uTWV0aG9kQXNQcm9wZXJ0eShuYW1lLCBhY3Rpb24sIG5vbk5lZ2F0ZWRTdWZmaXgpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBjcmVhdGVTaW5vbk1ldGhvZEhhbmRsZXIobmFtZSwgYWN0aW9uLCBub25OZWdhdGVkU3VmZml4KTtcbiAgICAgICAgdXRpbHMuYWRkUHJvcGVydHkoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCBuYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleGNlcHRpb25hbFNpbm9uTWV0aG9kKGNoYWlOYW1lLCBzaW5vbk5hbWUsIGFjdGlvbiwgbm9uTmVnYXRlZFN1ZmZpeCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGNyZWF0ZVNpbm9uTWV0aG9kSGFuZGxlcihzaW5vbk5hbWUsIGFjdGlvbiwgbm9uTmVnYXRlZFN1ZmZpeCk7XG4gICAgICAgIHV0aWxzLmFkZE1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsIGNoYWlOYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaW5vbk1ldGhvZChuYW1lLCBhY3Rpb24sIG5vbk5lZ2F0ZWRTdWZmaXgpIHtcbiAgICAgICAgZXhjZXB0aW9uYWxTaW5vbk1ldGhvZChuYW1lLCBuYW1lLCBhY3Rpb24sIG5vbk5lZ2F0ZWRTdWZmaXgpO1xuICAgIH1cblxuICAgIHV0aWxzLmFkZFByb3BlcnR5KGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgXCJhbHdheXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlscy5mbGFnKHRoaXMsIFwiYWx3YXlzXCIsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgc2lub25Qcm9wZXJ0eShcImNhbGxlZFwiLCBcImJlZW4gY2FsbGVkXCIsIFwiIGF0IGxlYXN0IG9uY2UsIGJ1dCBpdCB3YXMgbmV2ZXIgY2FsbGVkXCIpO1xuICAgIHNpbm9uUHJvcGVydHlBc0Jvb2xlYW5NZXRob2QoXCJjYWxsQ291bnRcIiwgXCJiZWVuIGNhbGxlZCBleGFjdGx5ICUxXCIsIFwiLCBidXQgaXQgd2FzIGNhbGxlZCAlYyVDXCIpO1xuICAgIHNpbm9uUHJvcGVydHkoXCJjYWxsZWRPbmNlXCIsIFwiYmVlbiBjYWxsZWQgZXhhY3RseSBvbmNlXCIsIFwiLCBidXQgaXQgd2FzIGNhbGxlZCAlYyVDXCIpO1xuICAgIHNpbm9uUHJvcGVydHkoXCJjYWxsZWRUd2ljZVwiLCBcImJlZW4gY2FsbGVkIGV4YWN0bHkgdHdpY2VcIiwgXCIsIGJ1dCBpdCB3YXMgY2FsbGVkICVjJUNcIik7XG4gICAgc2lub25Qcm9wZXJ0eShcImNhbGxlZFRocmljZVwiLCBcImJlZW4gY2FsbGVkIGV4YWN0bHkgdGhyaWNlXCIsIFwiLCBidXQgaXQgd2FzIGNhbGxlZCAlYyVDXCIpO1xuICAgIHNpbm9uTWV0aG9kQXNQcm9wZXJ0eShcImNhbGxlZFdpdGhOZXdcIiwgXCJiZWVuIGNhbGxlZCB3aXRoIG5ld1wiKTtcbiAgICBzaW5vbk1ldGhvZChcImNhbGxlZEJlZm9yZVwiLCBcImJlZW4gY2FsbGVkIGJlZm9yZSAlMVwiKTtcbiAgICBzaW5vbk1ldGhvZChcImNhbGxlZEFmdGVyXCIsIFwiYmVlbiBjYWxsZWQgYWZ0ZXIgJTFcIik7XG4gICAgc2lub25NZXRob2QoXCJjYWxsZWRPblwiLCBcImJlZW4gY2FsbGVkIHdpdGggJTEgYXMgdGhpc1wiLCBcIiwgYnV0IGl0IHdhcyBjYWxsZWQgd2l0aCAldCBpbnN0ZWFkXCIpO1xuICAgIHNpbm9uTWV0aG9kKFwiY2FsbGVkV2l0aFwiLCBcImJlZW4gY2FsbGVkIHdpdGggYXJndW1lbnRzICUqXCIsIFwiJUNcIik7XG4gICAgc2lub25NZXRob2QoXCJjYWxsZWRXaXRoRXhhY3RseVwiLCBcImJlZW4gY2FsbGVkIHdpdGggZXhhY3QgYXJndW1lbnRzICUqXCIsIFwiJUNcIik7XG4gICAgc2lub25NZXRob2QoXCJjYWxsZWRXaXRoTWF0Y2hcIiwgXCJiZWVuIGNhbGxlZCB3aXRoIGFyZ3VtZW50cyBtYXRjaGluZyAlKlwiLCBcIiVDXCIpO1xuICAgIHNpbm9uTWV0aG9kKFwicmV0dXJuZWRcIiwgXCJyZXR1cm5lZCAlMVwiKTtcbiAgICBleGNlcHRpb25hbFNpbm9uTWV0aG9kKFwidGhyb3duXCIsIFwidGhyZXdcIiwgXCJ0aHJvd24gJTFcIik7XG59KSk7XG4iLCIvKipcbiAqIFNpbm9uIGNvcmUgdXRpbGl0aWVzLiBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xudmFyIHNpbm9uID0gKGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHNpbm9uTW9kdWxlO1xuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICBzaW5vbk1vZHVsZSA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc2lub24vdXRpbC9jb3JlXCIpO1xuICAgICAgICByZXF1aXJlKFwiLi9zaW5vbi9leHRlbmRcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL3Npbm9uL3R5cGVPZlwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vc2lub24vdGltZXNfaW5fd29yZHNcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL3Npbm9uL3NweVwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vc2lub24vY2FsbFwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vc2lub24vYmVoYXZpb3JcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL3Npbm9uL3N0dWJcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL3Npbm9uL21vY2tcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL3Npbm9uL2NvbGxlY3Rpb25cIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL3Npbm9uL2Fzc2VydFwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vc2lub24vc2FuZGJveFwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vc2lub24vdGVzdFwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vc2lub24vdGVzdF9jYXNlXCIpO1xuICAgICAgICByZXF1aXJlKFwiLi9zaW5vbi9tYXRjaFwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vc2lub24vZm9ybWF0XCIpO1xuICAgICAgICByZXF1aXJlKFwiLi9zaW5vbi9sb2dfZXJyb3JcIik7XG4gICAgfVxuXG4gICAgaWYgKGlzQU1EKSB7XG4gICAgICAgIGRlZmluZShsb2FkRGVwZW5kZW5jaWVzKTtcbiAgICB9IGVsc2UgaWYgKGlzTm9kZSkge1xuICAgICAgICBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUpO1xuICAgICAgICBzaW5vbk1vZHVsZSA9IG1vZHVsZS5leHBvcnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNpbm9uTW9kdWxlID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbm9uTW9kdWxlO1xufSgpKTtcbiIsIi8qKlxuICogQGRlcGVuZCB0aW1lc19pbl93b3Jkcy5qc1xuICogQGRlcGVuZCB1dGlsL2NvcmUuanNcbiAqIEBkZXBlbmQgbWF0Y2guanNcbiAqIEBkZXBlbmQgZm9ybWF0LmpzXG4gKi9cbi8qKlxuICogQXNzZXJ0aW9ucyBtYXRjaGluZyB0aGUgdGVzdCBzcHkgcmV0cmlldmFsIGludGVyZmFjZS5cbiAqXG4gKiBAYXV0aG9yIENocmlzdGlhbiBKb2hhbnNlbiAoY2hyaXN0aWFuQGNqb2hhbnNlbi5ubylcbiAqIEBsaWNlbnNlIEJTRFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIENocmlzdGlhbiBKb2hhbnNlblxuICovXG4oZnVuY3Rpb24gKHNpbm9uR2xvYmFsLCBnbG9iYWwpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIGZ1bmN0aW9uIG1ha2VBcGkoc2lub24pIHtcbiAgICAgICAgdmFyIGFzc2VydDtcblxuICAgICAgICBmdW5jdGlvbiB2ZXJpZnlJc1N0dWIoKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZmFpbChcImZha2UgaXMgbm90IGEgc3B5XCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtZXRob2QucHJveHkgJiYgbWV0aG9kLnByb3h5LmlzU2lub25Qcm94eSkge1xuICAgICAgICAgICAgICAgICAgICB2ZXJpZnlJc1N0dWIobWV0aG9kLnByb3h5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZmFpbChtZXRob2QgKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmdldENhbGwgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmZhaWwobWV0aG9kICsgXCIgaXMgbm90IHN0dWJiZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZhaWxBc3NlcnRpb24ob2JqZWN0LCBtc2cpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdCB8fCBnbG9iYWw7XG4gICAgICAgICAgICB2YXIgZmFpbE1ldGhvZCA9IG9iamVjdC5mYWlsIHx8IGFzc2VydC5mYWlsO1xuICAgICAgICAgICAgZmFpbE1ldGhvZC5jYWxsKG9iamVjdCwgbXNnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1pcnJvclByb3BBc0Fzc2VydGlvbihuYW1lLCBtZXRob2QsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1ldGhvZDtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBuYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhc3NlcnRbbmFtZV0gPSBmdW5jdGlvbiAoZmFrZSkge1xuICAgICAgICAgICAgICAgIHZlcmlmeUlzU3R1YihmYWtlKTtcblxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIHZhciBmYWlsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkID0gIW1ldGhvZChmYWtlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmYWlsZWQgPSB0eXBlb2YgZmFrZVttZXRob2RdID09PSBcImZ1bmN0aW9uXCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgIWZha2VbbWV0aG9kXS5hcHBseShmYWtlLCBhcmdzKSA6ICFmYWtlW21ldGhvZF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGZhaWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsQXNzZXJ0aW9uKHRoaXMsIChmYWtlLnByaW50ZiB8fCBmYWtlLnByb3h5LnByaW50ZikuYXBwbHkoZmFrZSwgW21lc3NhZ2VdLmNvbmNhdChhcmdzKSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5wYXNzKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBleHBvc2VkTmFtZShwcmVmaXgsIHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiAhcHJlZml4IHx8IC9eZmFpbC8udGVzdChwcm9wKSA/IHByb3AgOlxuICAgICAgICAgICAgICAgIHByZWZpeCArIHByb3Auc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQgPSB7XG4gICAgICAgICAgICBmYWlsRXhjZXB0aW9uOiBcIkFzc2VydEVycm9yXCIsXG5cbiAgICAgICAgICAgIGZhaWw6IGZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gdGhpcy5mYWlsRXhjZXB0aW9uIHx8IGFzc2VydC5mYWlsRXhjZXB0aW9uO1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwYXNzOiBmdW5jdGlvbiBwYXNzKCkge30sXG5cbiAgICAgICAgICAgIGNhbGxPcmRlcjogZnVuY3Rpb24gYXNzZXJ0Q2FsbE9yZGVyKCkge1xuICAgICAgICAgICAgICAgIHZlcmlmeUlzU3R1Yi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHZhciBleHBlY3RlZCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIGFjdHVhbCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNpbm9uLmNhbGxlZEluT3JkZXIoYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBbXS5qb2luLmNhbGwoYXJndW1lbnRzLCBcIiwgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBjYWxscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FsbHNbLS1pXS5jYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbCA9IHNpbm9uLm9yZGVyQnlGaXJzdENhbGwoY2FsbHMpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBmYWlscywgd2UnbGwganVzdCBmYWxsIGJhY2sgdG8gdGhlIGJsYW5rIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZmFpbEFzc2VydGlvbih0aGlzLCBcImV4cGVjdGVkIFwiICsgZXhwZWN0ZWQgKyBcIiB0byBiZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2FsbGVkIGluIG9yZGVyIGJ1dCB3ZXJlIGNhbGxlZCBhcyBcIiArIGFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LnBhc3MoXCJjYWxsT3JkZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2FsbENvdW50OiBmdW5jdGlvbiBhc3NlcnRDYWxsQ291bnQobWV0aG9kLCBjb3VudCkge1xuICAgICAgICAgICAgICAgIHZlcmlmeUlzU3R1YihtZXRob2QpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZC5jYWxsQ291bnQgIT09IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCBcIiArIHNpbm9uLnRpbWVzSW5Xb3Jkcyhjb3VudCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHdhcyBjYWxsZWQgJWMlQ1wiO1xuICAgICAgICAgICAgICAgICAgICBmYWlsQXNzZXJ0aW9uKHRoaXMsIG1ldGhvZC5wcmludGYobXNnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LnBhc3MoXCJjYWxsQ291bnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZXhwb3NlOiBmdW5jdGlvbiBleHBvc2UodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRhcmdldCBpcyBudWxsIG9yIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IHR5cGVvZiBvLnByZWZpeCA9PT0gXCJ1bmRlZmluZWRcIiAmJiBcImFzc2VydFwiIHx8IG8ucHJlZml4O1xuICAgICAgICAgICAgICAgIHZhciBpbmNsdWRlRmFpbCA9IHR5cGVvZiBvLmluY2x1ZGVGYWlsID09PSBcInVuZGVmaW5lZFwiIHx8ICEhby5pbmNsdWRlRmFpbDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIG1ldGhvZCBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IFwiZXhwb3NlXCIgJiYgKGluY2x1ZGVGYWlsIHx8ICEvXihmYWlsKS8udGVzdChtZXRob2QpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2V4cG9zZWROYW1lKHByZWZpeCwgbWV0aG9kKV0gPSB0aGlzW21ldGhvZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKGFjdHVhbCwgZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlciA9IHNpbm9uLm1hdGNoKGV4cGVjdGF0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlci50ZXN0KGFjdHVhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LnBhc3MoXCJtYXRjaFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJleHBlY3RlZCB2YWx1ZSB0byBtYXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgICAgZXhwZWN0ZWQgPSBcIiArIHNpbm9uLmZvcm1hdChleHBlY3RhdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiAgICBhY3R1YWwgPSBcIiArIHNpbm9uLmZvcm1hdChhY3R1YWwpXG4gICAgICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICAgICAgZmFpbEFzc2VydGlvbih0aGlzLCBmb3JtYXR0ZWQuam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcImNhbGxlZFwiLCBcImV4cGVjdGVkICVuIHRvIGhhdmUgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZSBidXQgd2FzIG5ldmVyIGNhbGxlZFwiKTtcbiAgICAgICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwibm90Q2FsbGVkXCIsIGZ1bmN0aW9uIChzcHkpIHtcbiAgICAgICAgICAgIHJldHVybiAhc3B5LmNhbGxlZDtcbiAgICAgICAgfSwgXCJleHBlY3RlZCAlbiB0byBub3QgaGF2ZSBiZWVuIGNhbGxlZCBidXQgd2FzIGNhbGxlZCAlYyVDXCIpO1xuICAgICAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXCJjYWxsZWRPbmNlXCIsIFwiZXhwZWN0ZWQgJW4gdG8gYmUgY2FsbGVkIG9uY2UgYnV0IHdhcyBjYWxsZWQgJWMlQ1wiKTtcbiAgICAgICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiY2FsbGVkVHdpY2VcIiwgXCJleHBlY3RlZCAlbiB0byBiZSBjYWxsZWQgdHdpY2UgYnV0IHdhcyBjYWxsZWQgJWMlQ1wiKTtcbiAgICAgICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiY2FsbGVkVGhyaWNlXCIsIFwiZXhwZWN0ZWQgJW4gdG8gYmUgY2FsbGVkIHRocmljZSBidXQgd2FzIGNhbGxlZCAlYyVDXCIpO1xuICAgICAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXCJjYWxsZWRPblwiLCBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCB3aXRoICUxIGFzIHRoaXMgYnV0IHdhcyBjYWxsZWQgd2l0aCAldFwiKTtcbiAgICAgICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFxuICAgICAgICAgICAgXCJhbHdheXNDYWxsZWRPblwiLFxuICAgICAgICAgICAgXCJleHBlY3RlZCAlbiB0byBhbHdheXMgYmUgY2FsbGVkIHdpdGggJTEgYXMgdGhpcyBidXQgd2FzIGNhbGxlZCB3aXRoICV0XCJcbiAgICAgICAgKTtcbiAgICAgICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiY2FsbGVkV2l0aE5ld1wiLCBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCB3aXRoIG5ld1wiKTtcbiAgICAgICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiYWx3YXlzQ2FsbGVkV2l0aE5ld1wiLCBcImV4cGVjdGVkICVuIHRvIGFsd2F5cyBiZSBjYWxsZWQgd2l0aCBuZXdcIik7XG4gICAgICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcImNhbGxlZFdpdGhcIiwgXCJleHBlY3RlZCAlbiB0byBiZSBjYWxsZWQgd2l0aCBhcmd1bWVudHMgJSolQ1wiKTtcbiAgICAgICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiY2FsbGVkV2l0aE1hdGNoXCIsIFwiZXhwZWN0ZWQgJW4gdG8gYmUgY2FsbGVkIHdpdGggbWF0Y2ggJSolQ1wiKTtcbiAgICAgICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiYWx3YXlzQ2FsbGVkV2l0aFwiLCBcImV4cGVjdGVkICVuIHRvIGFsd2F5cyBiZSBjYWxsZWQgd2l0aCBhcmd1bWVudHMgJSolQ1wiKTtcbiAgICAgICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiYWx3YXlzQ2FsbGVkV2l0aE1hdGNoXCIsIFwiZXhwZWN0ZWQgJW4gdG8gYWx3YXlzIGJlIGNhbGxlZCB3aXRoIG1hdGNoICUqJUNcIik7XG4gICAgICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcImNhbGxlZFdpdGhFeGFjdGx5XCIsIFwiZXhwZWN0ZWQgJW4gdG8gYmUgY2FsbGVkIHdpdGggZXhhY3QgYXJndW1lbnRzICUqJUNcIik7XG4gICAgICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcImFsd2F5c0NhbGxlZFdpdGhFeGFjdGx5XCIsIFwiZXhwZWN0ZWQgJW4gdG8gYWx3YXlzIGJlIGNhbGxlZCB3aXRoIGV4YWN0IGFyZ3VtZW50cyAlKiVDXCIpO1xuICAgICAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXCJuZXZlckNhbGxlZFdpdGhcIiwgXCJleHBlY3RlZCAlbiB0byBuZXZlciBiZSBjYWxsZWQgd2l0aCBhcmd1bWVudHMgJSolQ1wiKTtcbiAgICAgICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwibmV2ZXJDYWxsZWRXaXRoTWF0Y2hcIiwgXCJleHBlY3RlZCAlbiB0byBuZXZlciBiZSBjYWxsZWQgd2l0aCBtYXRjaCAlKiVDXCIpO1xuICAgICAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXCJ0aHJld1wiLCBcIiVuIGRpZCBub3QgdGhyb3cgZXhjZXB0aW9uJUNcIik7XG4gICAgICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcImFsd2F5c1RocmV3XCIsIFwiJW4gZGlkIG5vdCBhbHdheXMgdGhyb3cgZXhjZXB0aW9uJUNcIik7XG5cbiAgICAgICAgc2lub24uYXNzZXJ0ID0gYXNzZXJ0O1xuICAgICAgICByZXR1cm4gYXNzZXJ0O1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICB2YXIgc2lub24gPSByZXF1aXJlKFwiLi91dGlsL2NvcmVcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL21hdGNoXCIpO1xuICAgICAgICByZXF1aXJlKFwiLi9mb3JtYXRcIik7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZUFwaShzaW5vbik7XG4gICAgfVxuXG4gICAgaWYgKGlzQU1EKSB7XG4gICAgICAgIGRlZmluZShsb2FkRGVwZW5kZW5jaWVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzaW5vbkdsb2JhbCkge1xuICAgICAgICBtYWtlQXBpKHNpbm9uR2xvYmFsKTtcbiAgICB9XG59KFxuICAgIHR5cGVvZiBzaW5vbiA9PT0gXCJvYmplY3RcIiAmJiBzaW5vbiwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiBzZWxmXG4pKTtcbiIsIi8qKlxuICogQGRlcGVuZCB1dGlsL2NvcmUuanNcbiAqIEBkZXBlbmQgZXh0ZW5kLmpzXG4gKi9cbi8qKlxuICogU3R1YiBiZWhhdmlvclxuICpcbiAqIEBhdXRob3IgQ2hyaXN0aWFuIEpvaGFuc2VuIChjaHJpc3RpYW5AY2pvaGFuc2VuLm5vKVxuICogQGF1dGhvciBUaW0gRmlzY2hiYWNoIChtYWlsQHRpbWZpc2NoYmFjaC5kZSlcbiAqIEBsaWNlbnNlIEJTRFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIENocmlzdGlhbiBKb2hhbnNlblxuICovXG4oZnVuY3Rpb24gKHNpbm9uR2xvYmFsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gICAgdmFyIGpvaW4gPSBBcnJheS5wcm90b3R5cGUuam9pbjtcbiAgICB2YXIgdXNlTGVmdE1vc3RDYWxsYmFjayA9IC0xO1xuICAgIHZhciB1c2VSaWdodE1vc3RDYWxsYmFjayA9IC0yO1xuXG4gICAgdmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICBmdW5jdGlvbiB0aHJvd3NFeGNlcHRpb24oZXJyb3IsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5leGNlcHRpb24gPSBuZXcgRXJyb3IobWVzc2FnZSB8fCBcIlwiKTtcbiAgICAgICAgICAgIHRoaXMuZXhjZXB0aW9uLm5hbWUgPSBlcnJvcjtcbiAgICAgICAgfSBlbHNlIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXhjZXB0aW9uID0gbmV3IEVycm9yKFwiRXJyb3JcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4Y2VwdGlvbiA9IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2FsbGJhY2soYmVoYXZpb3IsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGNhbGxBcmdBdCA9IGJlaGF2aW9yLmNhbGxBcmdBdDtcblxuICAgICAgICBpZiAoY2FsbEFyZ0F0ID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhcmdzW2NhbGxBcmdBdF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJndW1lbnRMaXN0O1xuXG4gICAgICAgIGlmIChjYWxsQXJnQXQgPT09IHVzZUxlZnRNb3N0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIGFyZ3VtZW50TGlzdCA9IGFyZ3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FsbEFyZ0F0ID09PSB1c2VSaWdodE1vc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgYXJndW1lbnRMaXN0ID0gc2xpY2UuY2FsbChhcmdzKS5yZXZlcnNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FsbEFyZ1Byb3AgPSBiZWhhdmlvci5jYWxsQXJnUHJvcDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50TGlzdC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghY2FsbEFyZ1Byb3AgJiYgdHlwZW9mIGFyZ3VtZW50TGlzdFtpXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50TGlzdFtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhbGxBcmdQcm9wICYmIGFyZ3VtZW50TGlzdFtpXSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBhcmd1bWVudExpc3RbaV1bY2FsbEFyZ1Byb3BdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRMaXN0W2ldW2NhbGxBcmdQcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcGkoc2lub24pIHtcbiAgICAgICAgZnVuY3Rpb24gZ2V0Q2FsbGJhY2tFcnJvcihiZWhhdmlvciwgZnVuYywgYXJncykge1xuICAgICAgICAgICAgaWYgKGJlaGF2aW9yLmNhbGxBcmdBdCA8IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJlaGF2aW9yLmNhbGxBcmdQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IHNpbm9uLmZ1bmN0aW9uTmFtZShiZWhhdmlvci5zdHViKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBleHBlY3RlZCB0byB5aWVsZCB0byAnXCIgKyBiZWhhdmlvci5jYWxsQXJnUHJvcCArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIicsIGJ1dCBubyBvYmplY3Qgd2l0aCBzdWNoIGEgcHJvcGVydHkgd2FzIHBhc3NlZC5cIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSBzaW5vbi5mdW5jdGlvbk5hbWUoYmVoYXZpb3Iuc3R1YikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgZXhwZWN0ZWQgdG8geWllbGQsIGJ1dCBubyBjYWxsYmFjayB3YXMgcGFzc2VkLlwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiIFJlY2VpdmVkIFtcIiArIGpvaW4uY2FsbChhcmdzLCBcIiwgXCIpICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFwiYXJndW1lbnQgYXQgaW5kZXggXCIgKyBiZWhhdmlvci5jYWxsQXJnQXQgKyBcIiBpcyBub3QgYSBmdW5jdGlvbjogXCIgKyBmdW5jO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKGJlaGF2aW9yLCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlaGF2aW9yLmNhbGxBcmdBdCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBmdW5jID0gZ2V0Q2FsbGJhY2soYmVoYXZpb3IsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihnZXRDYWxsYmFja0Vycm9yKGJlaGF2aW9yLCBmdW5jLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJlaGF2aW9yLmNhbGxiYWNrQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuYy5hcHBseShiZWhhdmlvci5jYWxsYmFja0NvbnRleHQsIGJlaGF2aW9yLmNhbGxiYWNrQXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuYy5hcHBseShiZWhhdmlvci5jYWxsYmFja0NvbnRleHQsIGJlaGF2aW9yLmNhbGxiYWNrQXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvdG8gPSB7XG4gICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzdHViKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJlaGF2aW9yID0gc2lub24uZXh0ZW5kKHt9LCBzaW5vbi5iZWhhdmlvcik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGJlaGF2aW9yLmNyZWF0ZTtcbiAgICAgICAgICAgICAgICBiZWhhdmlvci5zdHViID0gc3R1YjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBiZWhhdmlvcjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGlzUHJlc2VudDogZnVuY3Rpb24gaXNQcmVzZW50KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHRoaXMuY2FsbEFyZ0F0ID09PSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4Y2VwdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRoaXMucmV0dXJuQXJnQXQgPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuVGhpcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZURlZmluZWQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW52b2tlOiBmdW5jdGlvbiBpbnZva2UoY29udGV4dCwgYXJncykge1xuICAgICAgICAgICAgICAgIGNhbGxDYWxsYmFjayh0aGlzLCBhcmdzKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnJldHVybkFyZ0F0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW3RoaXMucmV0dXJuQXJnQXRdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXR1cm5UaGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJldHVyblZhbHVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25DYWxsOiBmdW5jdGlvbiBvbkNhbGwoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHViLm9uQ2FsbChpbmRleCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkZpcnN0Q2FsbDogZnVuY3Rpb24gb25GaXJzdENhbGwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3R1Yi5vbkZpcnN0Q2FsbCgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25TZWNvbmRDYWxsOiBmdW5jdGlvbiBvblNlY29uZENhbGwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3R1Yi5vblNlY29uZENhbGwoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uVGhpcmRDYWxsOiBmdW5jdGlvbiBvblRoaXJkQ2FsbCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHViLm9uVGhpcmRDYWxsKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB3aXRoQXJnczogZnVuY3Rpb24gd2l0aEFyZ3MoLyogYXJndW1lbnRzICovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkRlZmluaW5nIGEgc3R1YiBieSBpbnZva2luZyBcXFwic3R1Yi5vbkNhbGwoLi4uKS53aXRoQXJncyguLi4pXFxcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiaXMgbm90IHN1cHBvcnRlZC4gVXNlIFxcXCJzdHViLndpdGhBcmdzKC4uLikub25DYWxsKC4uLilcXFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ0byBkZWZpbmUgc2VxdWVudGlhbCBiZWhhdmlvciBmb3IgY2FsbHMgd2l0aCBjZXJ0YWluIGFyZ3VtZW50cy5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjYWxsc0FyZzogZnVuY3Rpb24gY2FsbHNBcmcocG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IGluZGV4IGlzIG5vdCBudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQXJnQXQgPSBwb3M7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FyZ3VtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEFyZ1Byb3AgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FzeW5jID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNhbGxzQXJnT246IGZ1bmN0aW9uIGNhbGxzQXJnT24ocG9zLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IGluZGV4IGlzIG5vdCBudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgY29udGV4dCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEFyZ0F0ID0gcG9zO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBcmd1bWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQXJnUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrQXN5bmMgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2FsbHNBcmdXaXRoOiBmdW5jdGlvbiBjYWxsc0FyZ1dpdGgocG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IGluZGV4IGlzIG5vdCBudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQXJnQXQgPSBwb3M7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FyZ3VtZW50cyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxBcmdQcm9wID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBc3luYyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjYWxsc0FyZ09uV2l0aDogZnVuY3Rpb24gY2FsbHNBcmdXaXRoKHBvcywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBpbmRleCBpcyBub3QgbnVtYmVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IGNvbnRleHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxBcmdBdCA9IHBvcztcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrQXJndW1lbnRzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxBcmdQcm9wID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBc3luYyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB5aWVsZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxBcmdBdCA9IHVzZUxlZnRNb3N0Q2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FyZ3VtZW50cyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxBcmdQcm9wID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBc3luYyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB5aWVsZHNSaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEFyZ0F0ID0gdXNlUmlnaHRNb3N0Q2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FyZ3VtZW50cyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxBcmdQcm9wID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBc3luYyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB5aWVsZHNPbjogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IGNvbnRleHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxBcmdBdCA9IHVzZUxlZnRNb3N0Q2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FyZ3VtZW50cyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQXJnUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrQXN5bmMgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgeWllbGRzVG86IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQXJnQXQgPSB1c2VMZWZ0TW9zdENhbGxiYWNrO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBcmd1bWVudHMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0NvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQXJnUHJvcCA9IHByb3A7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FzeW5jID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHlpZWxkc1RvT246IGZ1bmN0aW9uIChwcm9wLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBjb250ZXh0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQXJnQXQgPSB1c2VMZWZ0TW9zdENhbGxiYWNrO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBcmd1bWVudHMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEFyZ1Byb3AgPSBwcm9wO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBc3luYyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0aHJvd3M6IHRocm93c0V4Y2VwdGlvbixcbiAgICAgICAgICAgIHRocm93c0V4Y2VwdGlvbjogdGhyb3dzRXhjZXB0aW9uLFxuXG4gICAgICAgICAgICByZXR1cm5zOiBmdW5jdGlvbiByZXR1cm5zKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuVmFsdWVEZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4Y2VwdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmV0dXJuc0FyZzogZnVuY3Rpb24gcmV0dXJuc0FyZyhwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvcyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgaW5kZXggaXMgbm90IG51bWJlclwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJldHVybkFyZ0F0ID0gcG9zO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZXR1cm5zVGhpczogZnVuY3Rpb24gcmV0dXJuc1RoaXMoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXR1cm5UaGlzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jVmVyc2lvbihzeW5jRm5OYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzW3N5bmNGbk5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhc3luY2hyb25vdXMgdmVyc2lvbnMgb2YgY2FsbHNBcmcqIGFuZCB5aWVsZHMqIG1ldGhvZHNcbiAgICAgICAgZm9yICh2YXIgbWV0aG9kIGluIHByb3RvKSB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIGF2b2lkIGNyZWF0aW5nIGFub3RoZXJhc3luYyB2ZXJzaW9ucyBvZiB0aGUgbmV3bHkgYWRkZWQgYXN5bmMgbWV0aG9kc1xuICAgICAgICAgICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KG1ldGhvZCkgJiYgbWV0aG9kLm1hdGNoKC9eKGNhbGxzQXJnfHlpZWxkcykvKSAmJiAhbWV0aG9kLm1hdGNoKC9Bc3luYy8pKSB7XG4gICAgICAgICAgICAgICAgcHJvdG9bbWV0aG9kICsgXCJBc3luY1wiXSA9IGNyZWF0ZUFzeW5jVmVyc2lvbihtZXRob2QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2lub24uYmVoYXZpb3IgPSBwcm90bztcbiAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICB2YXIgc2lub24gPSByZXF1aXJlKFwiLi91dGlsL2NvcmVcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL2V4dGVuZFwiKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlQXBpKHNpbm9uKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBTUQpIHtcbiAgICAgICAgZGVmaW5lKGxvYWREZXBlbmRlbmNpZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgICBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNpbm9uR2xvYmFsKSB7XG4gICAgICAgIG1ha2VBcGkoc2lub25HbG9iYWwpO1xuICAgIH1cbn0oXG4gICAgdHlwZW9mIHNpbm9uID09PSBcIm9iamVjdFwiICYmIHNpbm9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbikpO1xuIiwiLyoqXG4gICogQGRlcGVuZCB1dGlsL2NvcmUuanNcbiAgKiBAZGVwZW5kIG1hdGNoLmpzXG4gICogQGRlcGVuZCBmb3JtYXQuanNcbiAgKi9cbi8qKlxuICAqIFNweSBjYWxsc1xuICAqXG4gICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gICogQGF1dGhvciBNYXhpbWlsaWFuIEFudG9uaSAobWFpbEBtYXhhbnRvbmkuZGUpXG4gICogQGxpY2Vuc2UgQlNEXG4gICpcbiAgKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAgKiBDb3B5cmlnaHQgKGMpIDIwMTMgTWF4aW1pbGlhbiBBbnRvbmlcbiAgKi9cbihmdW5jdGlvbiAoc2lub25HbG9iYWwpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIGZ1bmN0aW9uIG1ha2VBcGkoc2lub24pIHtcbiAgICAgICAgZnVuY3Rpb24gdGhyb3dZaWVsZEVycm9yKHByb3h5LCB0ZXh0LCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gc2lub24uZnVuY3Rpb25OYW1lKHByb3h5KSArIHRleHQ7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtc2cgKz0gXCIgUmVjZWl2ZWQgW1wiICsgc2xpY2UuY2FsbChhcmdzKS5qb2luKFwiLCBcIikgKyBcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbGxQcm90byA9IHtcbiAgICAgICAgICAgIGNhbGxlZE9uOiBmdW5jdGlvbiBjYWxsZWRPbih0aGlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2lub24ubWF0Y2ggJiYgc2lub24ubWF0Y2guaXNNYXRjaGVyKHRoaXNWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNWYWx1ZS50ZXN0KHRoaXMudGhpc1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhpc1ZhbHVlID09PSB0aGlzVmFsdWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjYWxsZWRXaXRoOiBmdW5jdGlvbiBjYWxsZWRXaXRoKCkge1xuICAgICAgICAgICAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobCA+IHRoaXMuYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbm9uLmRlZXBFcXVhbChhcmd1bWVudHNbaV0sIHRoaXMuYXJnc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2FsbGVkV2l0aE1hdGNoOiBmdW5jdGlvbiBjYWxsZWRXaXRoTWF0Y2goKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsID4gdGhpcy5hcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3R1YWwgPSB0aGlzLmFyZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBlY3RhdGlvbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaW5vbi5tYXRjaCB8fCAhc2lub24ubWF0Y2goZXhwZWN0YXRpb24pLnRlc3QoYWN0dWFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2FsbGVkV2l0aEV4YWN0bHk6IGZ1bmN0aW9uIGNhbGxlZFdpdGhFeGFjdGx5KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSB0aGlzLmFyZ3MubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGVkV2l0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbm90Q2FsbGVkV2l0aDogZnVuY3Rpb24gbm90Q2FsbGVkV2l0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuY2FsbGVkV2l0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbm90Q2FsbGVkV2l0aE1hdGNoOiBmdW5jdGlvbiBub3RDYWxsZWRXaXRoTWF0Y2goKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmNhbGxlZFdpdGhNYXRjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmV0dXJuZWQ6IGZ1bmN0aW9uIHJldHVybmVkKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbm9uLmRlZXBFcXVhbCh2YWx1ZSwgdGhpcy5yZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0aHJldzogZnVuY3Rpb24gdGhyZXcoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcInVuZGVmaW5lZFwiIHx8ICF0aGlzLmV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLmV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGNlcHRpb24gPT09IGVycm9yIHx8IHRoaXMuZXhjZXB0aW9uLm5hbWUgPT09IGVycm9yO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2FsbGVkV2l0aE5ldzogZnVuY3Rpb24gY2FsbGVkV2l0aE5ldygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm94eS5wcm90b3R5cGUgJiYgdGhpcy50aGlzVmFsdWUgaW5zdGFuY2VvZiB0aGlzLnByb3h5O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2FsbGVkQmVmb3JlOiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxsSWQgPCBvdGhlci5jYWxsSWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjYWxsZWRBZnRlcjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbElkID4gb3RoZXIuY2FsbElkO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2FsbEFyZzogZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJnc1twb3NdKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjYWxsQXJnT246IGZ1bmN0aW9uIChwb3MsIHRoaXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJnc1twb3NdLmFwcGx5KHRoaXNWYWx1ZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjYWxsQXJnV2l0aDogZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEFyZ09uV2l0aC5hcHBseSh0aGlzLCBbcG9zLCBudWxsXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjYWxsQXJnT25XaXRoOiBmdW5jdGlvbiAocG9zLCB0aGlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3NbcG9zXS5hcHBseSh0aGlzVmFsdWUsIGFyZ3MpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgXCJ5aWVsZFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy55aWVsZE9uLmFwcGx5KHRoaXMsIFtudWxsXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB5aWVsZE9uOiBmdW5jdGlvbiAodGhpc1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmdzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tpXS5hcHBseSh0aGlzVmFsdWUsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3dZaWVsZEVycm9yKHRoaXMucHJveHksIFwiIGNhbm5vdCB5aWVsZCBzaW5jZSBubyBjYWxsYmFjayB3YXMgcGFzc2VkLlwiLCBhcmdzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHlpZWxkVG86IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy55aWVsZFRvT24uYXBwbHkodGhpcywgW3Byb3AsIG51bGxdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHlpZWxkVG9PbjogZnVuY3Rpb24gKHByb3AsIHRoaXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5hcmdzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3NbaV0gJiYgdHlwZW9mIGFyZ3NbaV1bcHJvcF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tpXVtwcm9wXS5hcHBseSh0aGlzVmFsdWUsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3dZaWVsZEVycm9yKHRoaXMucHJveHksIFwiIGNhbm5vdCB5aWVsZCB0byAnXCIgKyBwcm9wICtcbiAgICAgICAgICAgICAgICAgICAgXCInIHNpbmNlIG5vIGNhbGxiYWNrIHdhcyBwYXNzZWQuXCIsIGFyZ3MpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0U3RhY2tGcmFtZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBPbWl0IHRoZSBlcnJvciBtZXNzYWdlIGFuZCB0aGUgdHdvIHRvcCBzdGFjayBmcmFtZXMgaW4gc2lub24gaXRzZWxmOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrICYmIHRoaXMuc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsU3RyID0gdGhpcy5wcm94eS50b1N0cmluZygpICsgXCIoXCI7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5hcmdzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goc2lub24uZm9ybWF0KHRoaXMuYXJnc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhbGxTdHIgPSBjYWxsU3RyICsgYXJncy5qb2luKFwiLCBcIikgKyBcIilcIjtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5yZXR1cm5WYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsU3RyICs9IFwiID0+IFwiICsgc2lub24uZm9ybWF0KHRoaXMucmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsU3RyICs9IFwiICFcIiArIHRoaXMuZXhjZXB0aW9uLm5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXhjZXB0aW9uLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxTdHIgKz0gXCIoXCIgKyB0aGlzLmV4Y2VwdGlvbi5tZXNzYWdlICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbFN0ciArPSB0aGlzLmdldFN0YWNrRnJhbWVzKClbMF0ucmVwbGFjZSgvXlxccyooPzphdFxccyt8QCk/LywgXCIgYXQgXCIpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxTdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FsbFByb3RvLmludm9rZUNhbGxiYWNrID0gY2FsbFByb3RvLnlpZWxkO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNweUNhbGwoc3B5LCB0aGlzVmFsdWUsIGFyZ3MsIHJldHVyblZhbHVlLCBleGNlcHRpb24sIGlkLCBzdGFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYWxsIGlkIGlzIG5vdCBhIG51bWJlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm94eUNhbGwgPSBzaW5vbi5jcmVhdGUoY2FsbFByb3RvKTtcbiAgICAgICAgICAgIHByb3h5Q2FsbC5wcm94eSA9IHNweTtcbiAgICAgICAgICAgIHByb3h5Q2FsbC50aGlzVmFsdWUgPSB0aGlzVmFsdWU7XG4gICAgICAgICAgICBwcm94eUNhbGwuYXJncyA9IGFyZ3M7XG4gICAgICAgICAgICBwcm94eUNhbGwucmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIHByb3h5Q2FsbC5leGNlcHRpb24gPSBleGNlcHRpb247XG4gICAgICAgICAgICBwcm94eUNhbGwuY2FsbElkID0gaWQ7XG4gICAgICAgICAgICBwcm94eUNhbGwuc3RhY2sgPSBzdGFjaztcblxuICAgICAgICAgICAgcmV0dXJuIHByb3h5Q2FsbDtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVTcHlDYWxsLnRvU3RyaW5nID0gY2FsbFByb3RvLnRvU3RyaW5nOyAvLyB1c2VkIGJ5IG1vY2tzXG5cbiAgICAgICAgc2lub24uc3B5Q2FsbCA9IGNyZWF0ZVNweUNhbGw7XG4gICAgICAgIHJldHVybiBjcmVhdGVTcHlDYWxsO1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICB2YXIgc2lub24gPSByZXF1aXJlKFwiLi91dGlsL2NvcmVcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL21hdGNoXCIpO1xuICAgICAgICByZXF1aXJlKFwiLi9mb3JtYXRcIik7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZUFwaShzaW5vbik7XG4gICAgfVxuXG4gICAgaWYgKGlzQU1EKSB7XG4gICAgICAgIGRlZmluZShsb2FkRGVwZW5kZW5jaWVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzaW5vbkdsb2JhbCkge1xuICAgICAgICBtYWtlQXBpKHNpbm9uR2xvYmFsKTtcbiAgICB9XG59KFxuICAgIHR5cGVvZiBzaW5vbiA9PT0gXCJvYmplY3RcIiAmJiBzaW5vbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4pKTtcbiIsIi8qKlxuICogQGRlcGVuZCB1dGlsL2NvcmUuanNcbiAqIEBkZXBlbmQgc3B5LmpzXG4gKiBAZGVwZW5kIHN0dWIuanNcbiAqIEBkZXBlbmQgbW9jay5qc1xuICovXG4vKipcbiAqIENvbGxlY3Rpb25zIG9mIHN0dWJzLCBzcGllcyBhbmQgbW9ja3MuXG4gKlxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuKGZ1bmN0aW9uIChzaW5vbkdsb2JhbCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHB1c2ggPSBbXS5wdXNoO1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgICBmdW5jdGlvbiBnZXRGYWtlcyhmYWtlQ29sbGVjdGlvbikge1xuICAgICAgICBpZiAoIWZha2VDb2xsZWN0aW9uLmZha2VzKSB7XG4gICAgICAgICAgICBmYWtlQ29sbGVjdGlvbi5mYWtlcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZha2VDb2xsZWN0aW9uLmZha2VzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhY2goZmFrZUNvbGxlY3Rpb24sIG1ldGhvZCkge1xuICAgICAgICB2YXIgZmFrZXMgPSBnZXRGYWtlcyhmYWtlQ29sbGVjdGlvbik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBmYWtlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmFrZXNbaV1bbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZmFrZXNbaV1bbWV0aG9kXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFjdChmYWtlQ29sbGVjdGlvbikge1xuICAgICAgICB2YXIgZmFrZXMgPSBnZXRGYWtlcyhmYWtlQ29sbGVjdGlvbik7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBmYWtlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZha2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcGkoc2lub24pIHtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSB7XG4gICAgICAgICAgICB2ZXJpZnk6IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgICAgICAgICAgICAgZWFjaCh0aGlzLCBcInZlcmlmeVwiKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlc3RvcmU6IGZ1bmN0aW9uIHJlc3RvcmUoKSB7XG4gICAgICAgICAgICAgICAgZWFjaCh0aGlzLCBcInJlc3RvcmVcIik7XG4gICAgICAgICAgICAgICAgY29tcGFjdCh0aGlzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbiByZXN0b3JlKCkge1xuICAgICAgICAgICAgICAgIGVhY2godGhpcywgXCJyZXNldFwiKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHZlcmlmeUFuZFJlc3RvcmU6IGZ1bmN0aW9uIHZlcmlmeUFuZFJlc3RvcmUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4Y2VwdGlvbjtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5KCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBleGNlcHRpb24gPSBlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZmFrZSkge1xuICAgICAgICAgICAgICAgIHB1c2guY2FsbChnZXRGYWtlcyh0aGlzKSwgZmFrZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZha2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzcHk6IGZ1bmN0aW9uIHNweSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoc2lub24uc3B5LmFwcGx5KHNpbm9uLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHN0dWI6IGZ1bmN0aW9uIHN0dWIob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgc3R1YiBub24tZXhpc3RlbnQgb3duIHByb3BlcnR5IFwiICsgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdG9yZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eSAmJiAhIW9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHViYmVkT2JqID0gc2lub24uc3R1Yi5hcHBseShzaW5vbiwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0dWJiZWRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R1YmJlZE9ialtwcm9wXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoc3R1YmJlZE9ialtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3R1YmJlZE9iajtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoc2lub24uc3R1Yi5hcHBseShzaW5vbiwgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBtb2NrOiBmdW5jdGlvbiBtb2NrKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChzaW5vbi5tb2NrLmFwcGx5KHNpbm9uLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGluamVjdDogZnVuY3Rpb24gaW5qZWN0KG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgb2JqLnNweSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbC5zcHkuYXBwbHkoY29sLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBvYmouc3R1YiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbC5zdHViLmFwcGx5KGNvbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgb2JqLm1vY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2wubW9jay5hcHBseShjb2wsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2lub24uY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICB2YXIgc2lub24gPSByZXF1aXJlKFwiLi91dGlsL2NvcmVcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL21vY2tcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL3NweVwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vc3R1YlwiKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlQXBpKHNpbm9uKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBTUQpIHtcbiAgICAgICAgZGVmaW5lKGxvYWREZXBlbmRlbmNpZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgICBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNpbm9uR2xvYmFsKSB7XG4gICAgICAgIG1ha2VBcGkoc2lub25HbG9iYWwpO1xuICAgIH1cbn0oXG4gICAgdHlwZW9mIHNpbm9uID09PSBcIm9iamVjdFwiICYmIHNpbm9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbikpO1xuIiwiLyoqXG4gKiBAZGVwZW5kIHV0aWwvY29yZS5qc1xuICovXG4oZnVuY3Rpb24gKHNpbm9uR2xvYmFsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiBtYWtlQXBpKHNpbm9uKSB7XG5cbiAgICAgICAgLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRUNNQVNjcmlwdF9Eb250RW51bV9hdHRyaWJ1dGUjSlNjcmlwdF9Eb250RW51bV9CdWdcbiAgICAgICAgdmFyIGhhc0RvbnRFbnVtQnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiMFwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiMVwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsdWVPZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIyXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b0xvY2FsZVN0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIzXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcm90b3R5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiNFwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNQcm90b3R5cGVPZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI1XCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI2XCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI3XCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiOFwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdW5pcXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjlcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqW3Byb3BdKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIlwiKSAhPT0gXCIwMTIzNDU2Nzg5XCI7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgLyogUHVibGljOiBFeHRlbmQgdGFyZ2V0IGluIHBsYWNlIHdpdGggYWxsIChvd24pIHByb3BlcnRpZXMgZnJvbSBzb3VyY2VzIGluLW9yZGVyLiBUaHVzLCBsYXN0IHNvdXJjZSB3aWxsXG4gICAgICAgICAqICAgICAgICAgb3ZlcnJpZGUgcHJvcGVydGllcyBpbiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiB0YXJnZXQgLSBUaGUgT2JqZWN0IHRvIGV4dGVuZFxuICAgICAgICAgKiBzb3VyY2VzIC0gT2JqZWN0cyB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyB0aGUgZXh0ZW5kZWQgdGFyZ2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0IC8qLCBzb3VyY2VzICovKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICB2YXIgc291cmNlLCBpLCBwcm9wO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjb3B5IChvd24pIHRvU3RyaW5nIG1ldGhvZCBldmVuIHdoZW4gaW4gSlNjcmlwdCB3aXRoIERvbnRFbnVtIGJ1Z1xuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0VDTUFTY3JpcHRfRG9udEVudW1fYXR0cmlidXRlI0pTY3JpcHRfRG9udEVudW1fQnVnXG4gICAgICAgICAgICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShcInRvU3RyaW5nXCIpICYmIHNvdXJjZS50b1N0cmluZyAhPT0gdGFyZ2V0LnRvU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC50b1N0cmluZyA9IHNvdXJjZS50b1N0cmluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBzaW5vbi5leHRlbmQgPSBleHRlbmQ7XG4gICAgICAgIHJldHVybiBzaW5vbi5leHRlbmQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICAgICAgdmFyIHNpbm9uID0gcmVxdWlyZShcIi4vdXRpbC9jb3JlXCIpO1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2VBcGkoc2lub24pO1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBpZiAoaXNBTUQpIHtcbiAgICAgICAgZGVmaW5lKGxvYWREZXBlbmRlbmNpZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgICBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNpbm9uR2xvYmFsKSB7XG4gICAgICAgIG1ha2VBcGkoc2lub25HbG9iYWwpO1xuICAgIH1cbn0oXG4gICAgdHlwZW9mIHNpbm9uID09PSBcIm9iamVjdFwiICYmIHNpbm9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbikpO1xuIiwiLyoqXG4gKiBAZGVwZW5kIHV0aWwvY29yZS5qc1xuICovXG4vKipcbiAqIEZvcm1hdCBmdW5jdGlvbnNcbiAqXG4gKiBAYXV0aG9yIENocmlzdGlhbiBKb2hhbnNlbiAoY2hyaXN0aWFuQGNqb2hhbnNlbi5ubylcbiAqIEBsaWNlbnNlIEJTRFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IENocmlzdGlhbiBKb2hhbnNlblxuICovXG4oZnVuY3Rpb24gKHNpbm9uR2xvYmFsLCBmb3JtYXRpbykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gbWFrZUFwaShzaW5vbikge1xuICAgICAgICBmdW5jdGlvbiB2YWx1ZUZvcm1hdHRlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEZvcm1hdGlvRm9ybWF0dGVyKCkge1xuICAgICAgICAgICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdGlvLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlU3RyaW5nczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0Q2hpbGRyZW5Db3VudDogMjUwXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmFzY2lpLmFwcGx5KGZvcm1hdHRlciwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldE5vZGVGb3JtYXR0ZXIoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLyogTm9kZSwgYnV0IG5vIHV0aWwgbW9kdWxlIC0gd291bGQgYmUgdmVyeSBvbGQsIGJ1dCBiZXR0ZXIgc2FmZSB0aGFuIHNvcnJ5ICovXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdCh2KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzT2JqZWN0V2l0aE5hdGl2ZVRvU3RyaW5nID0gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdi50b1N0cmluZyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3RXaXRoTmF0aXZlVG9TdHJpbmcgPyB1dGlsLmluc3BlY3QodikgOiB2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXRpbCA/IGZvcm1hdCA6IHZhbHVlRm9ybWF0dGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzTm9kZSA9IHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgdmFyIGZvcm1hdHRlcjtcblxuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvcm1hdGlvID0gcmVxdWlyZShcImZvcm1hdGlvXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JtYXRpbykge1xuICAgICAgICAgICAgZm9ybWF0dGVyID0gZ2V0Rm9ybWF0aW9Gb3JtYXR0ZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc05vZGUpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlciA9IGdldE5vZGVGb3JtYXR0ZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdHRlciA9IHZhbHVlRm9ybWF0dGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgc2lub24uZm9ybWF0ID0gZm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gc2lub24uZm9ybWF0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWREZXBlbmRlbmNpZXMocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgICAgIHZhciBzaW5vbiA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZVwiKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlQXBpKHNpbm9uKTtcbiAgICB9XG5cbiAgICB2YXIgaXNOb2RlID0gdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIHZhciBpc0FNRCA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gXCJvYmplY3RcIiAmJiBkZWZpbmUuYW1kO1xuXG4gICAgaWYgKGlzQU1EKSB7XG4gICAgICAgIGRlZmluZShsb2FkRGVwZW5kZW5jaWVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzaW5vbkdsb2JhbCkge1xuICAgICAgICBtYWtlQXBpKHNpbm9uR2xvYmFsKTtcbiAgICB9XG59KFxuICAgIHR5cGVvZiBzaW5vbiA9PT0gXCJvYmplY3RcIiAmJiBzaW5vbiwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHR5cGVvZiBmb3JtYXRpbyA9PT0gXCJvYmplY3RcIiAmJiBmb3JtYXRpbyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4pKTtcbiIsIi8qKlxuICogQGRlcGVuZCB1dGlsL2NvcmUuanNcbiAqL1xuLyoqXG4gKiBMb2dzIGVycm9yc1xuICpcbiAqIEBhdXRob3IgQ2hyaXN0aWFuIEpvaGFuc2VuIChjaHJpc3RpYW5AY2pvaGFuc2VuLm5vKVxuICogQGxpY2Vuc2UgQlNEXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgQ2hyaXN0aWFuIEpvaGFuc2VuXG4gKi9cbihmdW5jdGlvbiAoc2lub25HbG9iYWwpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIGNhY2hlIGEgcmVmZXJlbmNlIHRvIHNldFRpbWVvdXQsIHNvIHRoYXQgb3VyIHJlZmVyZW5jZSB3b24ndCBiZSBzdHViYmVkIG91dFxuICAgIC8vIHdoZW4gdXNpbmcgZmFrZSB0aW1lcnMgYW5kIGVycm9ycyB3aWxsIHN0aWxsIGdldCBsb2dnZWRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2pvaGFuc2VuL1Npbm9uLkpTL2lzc3Vlcy8zODFcbiAgICB2YXIgcmVhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gbWFrZUFwaShzaW5vbikge1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvZygpIHt9XG5cbiAgICAgICAgZnVuY3Rpb24gbG9nRXJyb3IobGFiZWwsIGVycikge1xuICAgICAgICAgICAgdmFyIG1zZyA9IGxhYmVsICsgXCIgdGhyZXcgZXhjZXB0aW9uOiBcIjtcblxuICAgICAgICAgICAgc2lub24ubG9nKG1zZyArIFwiW1wiICsgZXJyLm5hbWUgKyBcIl0gXCIgKyBlcnIubWVzc2FnZSk7XG5cbiAgICAgICAgICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgICAgICAgICAgICBzaW5vbi5sb2coZXJyLnN0YWNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG9nRXJyb3Iuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBtc2cgKyBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdyYXAgcmVhbFNldFRpbWVvdXQgd2l0aCBzb21ldGhpbmcgd2UgY2FuIHN0dWIgaW4gdGVzdHNcbiAgICAgICAgbG9nRXJyb3Iuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChmdW5jLCB0aW1lb3V0KSB7XG4gICAgICAgICAgICByZWFsU2V0VGltZW91dChmdW5jLCB0aW1lb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXhwb3J0cyA9IHt9O1xuICAgICAgICBleHBvcnRzLmxvZyA9IHNpbm9uLmxvZyA9IGxvZztcbiAgICAgICAgZXhwb3J0cy5sb2dFcnJvciA9IHNpbm9uLmxvZ0Vycm9yID0gbG9nRXJyb3I7XG5cbiAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICAgICAgdmFyIHNpbm9uID0gcmVxdWlyZShcIi4vdXRpbC9jb3JlXCIpO1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2VBcGkoc2lub24pO1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBpZiAoaXNBTUQpIHtcbiAgICAgICAgZGVmaW5lKGxvYWREZXBlbmRlbmNpZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgICBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNpbm9uR2xvYmFsKSB7XG4gICAgICAgIG1ha2VBcGkoc2lub25HbG9iYWwpO1xuICAgIH1cbn0oXG4gICAgdHlwZW9mIHNpbm9uID09PSBcIm9iamVjdFwiICYmIHNpbm9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbikpO1xuIiwiLyoqXG4gKiBAZGVwZW5kIHV0aWwvY29yZS5qc1xuICogQGRlcGVuZCB0eXBlT2YuanNcbiAqL1xuLypqc2xpbnQgZXFlcWVxOiBmYWxzZSwgb25ldmFyOiBmYWxzZSwgcGx1c3BsdXM6IGZhbHNlKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgc2lub24qL1xuLyoqXG4gKiBNYXRjaCBmdW5jdGlvbnNcbiAqXG4gKiBAYXV0aG9yIE1heGltaWxpYW4gQW50b25pIChtYWlsQG1heGFudG9uaS5kZSlcbiAqIEBsaWNlbnNlIEJTRFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBNYXhpbWlsaWFuIEFudG9uaVxuICovXG4oZnVuY3Rpb24gKHNpbm9uR2xvYmFsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiBtYWtlQXBpKHNpbm9uKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBhY3R1YWwgPSBzaW5vbi50eXBlT2YodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGFjdHVhbCAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB0eXBlIG9mIFwiICsgbmFtZSArIFwiIHRvIGJlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSArIFwiLCBidXQgd2FzIFwiICsgYWN0dWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXRjaGVyID0ge1xuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzTWF0Y2hlcihvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyLmlzUHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoT2JqZWN0KGV4cGVjdGF0aW9uLCBhY3R1YWwpIHtcbiAgICAgICAgICAgIGlmIChhY3R1YWwgPT09IG51bGwgfHwgYWN0dWFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwZWN0YXRpb24uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwID0gZXhwZWN0YXRpb25ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdCA9IGFjdHVhbFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGVyKGV4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhwLnRlc3QoYWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaW5vbi50eXBlT2YoZXhwKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaE9iamVjdChleHAsIGFjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNpbm9uLmRlZXBFcXVhbChleHAsIGFjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWF0Y2goZXhwZWN0YXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBtID0gc2lub24uY3JlYXRlKG1hdGNoZXIpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBzaW5vbi50eXBlT2YoZXhwZWN0YXRpb24pO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBlY3RhdGlvbi50ZXN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbS50ZXN0ID0gZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uLnRlc3QoYWN0dWFsKSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbS5tZXNzYWdlID0gXCJtYXRjaChcIiArIHNpbm9uLmZ1bmN0aW9uTmFtZShleHBlY3RhdGlvbi50ZXN0KSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBleHBlY3RhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwZWN0YXRpb24uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goa2V5ICsgXCI6IFwiICsgZXhwZWN0YXRpb25ba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbS50ZXN0ID0gZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hPYmplY3QoZXhwZWN0YXRpb24sIGFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtLm1lc3NhZ2UgPSBcIm1hdGNoKFwiICsgc3RyLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIG0udGVzdCA9IGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0eXBlIGNvZXJjaW9uIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uID09IGFjdHVhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIG0udGVzdCA9IGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhY3R1YWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0dWFsLmluZGV4T2YoZXhwZWN0YXRpb24pICE9PSAtMTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG0ubWVzc2FnZSA9IFwibWF0Y2goXFxcIlwiICsgZXhwZWN0YXRpb24gKyBcIlxcXCIpXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmVnZXhwXCI6XG4gICAgICAgICAgICAgICAgbS50ZXN0ID0gZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFjdHVhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBlY3RhdGlvbi50ZXN0KGFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIG0udGVzdCA9IGV4cGVjdGF0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIG0ubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbS5tZXNzYWdlID0gXCJtYXRjaChcIiArIHNpbm9uLmZ1bmN0aW9uTmFtZShleHBlY3RhdGlvbikgKyBcIilcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG0udGVzdCA9IGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbm9uLmRlZXBFcXVhbChleHBlY3RhdGlvbiwgYWN0dWFsKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBtLm1lc3NhZ2UgPSBcIm1hdGNoKFwiICsgZXhwZWN0YXRpb24gKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0Y2hlci5vciA9IGZ1bmN0aW9uIChtMikge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1hdGNoZXIgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc01hdGNoZXIobTIpKSB7XG4gICAgICAgICAgICAgICAgbTIgPSBtYXRjaChtMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbTEgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIG9yID0gc2lub24uY3JlYXRlKG1hdGNoZXIpO1xuICAgICAgICAgICAgb3IudGVzdCA9IGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTEudGVzdChhY3R1YWwpIHx8IG0yLnRlc3QoYWN0dWFsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvci5tZXNzYWdlID0gbTEubWVzc2FnZSArIFwiLm9yKFwiICsgbTIubWVzc2FnZSArIFwiKVwiO1xuICAgICAgICAgICAgcmV0dXJuIG9yO1xuICAgICAgICB9O1xuXG4gICAgICAgIG1hdGNoZXIuYW5kID0gZnVuY3Rpb24gKG0yKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWF0Y2hlciBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTWF0Y2hlcihtMikpIHtcbiAgICAgICAgICAgICAgICBtMiA9IG1hdGNoKG0yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtMSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYW5kID0gc2lub24uY3JlYXRlKG1hdGNoZXIpO1xuICAgICAgICAgICAgYW5kLnRlc3QgPSBmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0xLnRlc3QoYWN0dWFsKSAmJiBtMi50ZXN0KGFjdHVhbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYW5kLm1lc3NhZ2UgPSBtMS5tZXNzYWdlICsgXCIuYW5kKFwiICsgbTIubWVzc2FnZSArIFwiKVwiO1xuICAgICAgICAgICAgcmV0dXJuIGFuZDtcbiAgICAgICAgfTtcblxuICAgICAgICBtYXRjaC5pc01hdGNoZXIgPSBpc01hdGNoZXI7XG5cbiAgICAgICAgbWF0Y2guYW55ID0gbWF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sIFwiYW55XCIpO1xuXG4gICAgICAgIG1hdGNoLmRlZmluZWQgPSBtYXRjaChmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0dWFsICE9PSBudWxsICYmIGFjdHVhbCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9LCBcImRlZmluZWRcIik7XG5cbiAgICAgICAgbWF0Y2gudHJ1dGh5ID0gbWF0Y2goZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICAgICAgcmV0dXJuICEhYWN0dWFsO1xuICAgICAgICB9LCBcInRydXRoeVwiKTtcblxuICAgICAgICBtYXRjaC5mYWxzeSA9IG1hdGNoKGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgIHJldHVybiAhYWN0dWFsO1xuICAgICAgICB9LCBcImZhbHN5XCIpO1xuXG4gICAgICAgIG1hdGNoLnNhbWUgPSBmdW5jdGlvbiAoZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaChmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uID09PSBhY3R1YWw7XG4gICAgICAgICAgICB9LCBcInNhbWUoXCIgKyBleHBlY3RhdGlvbiArIFwiKVwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBtYXRjaC50eXBlT2YgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgYXNzZXJ0VHlwZSh0eXBlLCBcInN0cmluZ1wiLCBcInR5cGVcIik7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2goZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaW5vbi50eXBlT2YoYWN0dWFsKSA9PT0gdHlwZTtcbiAgICAgICAgICAgIH0sIFwidHlwZU9mKFxcXCJcIiArIHR5cGUgKyBcIlxcXCIpXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG1hdGNoLmluc3RhbmNlT2YgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgYXNzZXJ0VHlwZSh0eXBlLCBcImZ1bmN0aW9uXCIsIFwidHlwZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaChmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdHVhbCBpbnN0YW5jZW9mIHR5cGU7XG4gICAgICAgICAgICB9LCBcImluc3RhbmNlT2YoXCIgKyBzaW5vbi5mdW5jdGlvbk5hbWUodHlwZSkgKyBcIilcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlNYXRjaGVyKHByb3BlcnR5VGVzdCwgbWVzc2FnZVByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRUeXBlKHByb3BlcnR5LCBcInN0cmluZ1wiLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgICAgICAgIHZhciBvbmx5UHJvcGVydHkgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbWVzc2FnZVByZWZpeCArIFwiKFxcXCJcIiArIHByb3BlcnR5ICsgXCJcXFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKCFvbmx5UHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiwgXCIgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIilcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2goZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0dWFsID09PSB1bmRlZmluZWQgfHwgYWN0dWFsID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXByb3BlcnR5VGVzdChhY3R1YWwsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbmx5UHJvcGVydHkgfHwgc2lub24uZGVlcEVxdWFsKHZhbHVlLCBhY3R1YWxbcHJvcGVydHldKTtcbiAgICAgICAgICAgICAgICB9LCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaC5oYXMgPSBjcmVhdGVQcm9wZXJ0eU1hdGNoZXIoZnVuY3Rpb24gKGFjdHVhbCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0dWFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIGFjdHVhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY3R1YWxbcHJvcGVydHldICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH0sIFwiaGFzXCIpO1xuXG4gICAgICAgIG1hdGNoLmhhc093biA9IGNyZWF0ZVByb3BlcnR5TWF0Y2hlcihmdW5jdGlvbiAoYWN0dWFsLCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjdHVhbC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICAgIH0sIFwiaGFzT3duXCIpO1xuXG4gICAgICAgIG1hdGNoLmJvb2wgPSBtYXRjaC50eXBlT2YoXCJib29sZWFuXCIpO1xuICAgICAgICBtYXRjaC5udW1iZXIgPSBtYXRjaC50eXBlT2YoXCJudW1iZXJcIik7XG4gICAgICAgIG1hdGNoLnN0cmluZyA9IG1hdGNoLnR5cGVPZihcInN0cmluZ1wiKTtcbiAgICAgICAgbWF0Y2gub2JqZWN0ID0gbWF0Y2gudHlwZU9mKFwib2JqZWN0XCIpO1xuICAgICAgICBtYXRjaC5mdW5jID0gbWF0Y2gudHlwZU9mKFwiZnVuY3Rpb25cIik7XG4gICAgICAgIG1hdGNoLmFycmF5ID0gbWF0Y2gudHlwZU9mKFwiYXJyYXlcIik7XG4gICAgICAgIG1hdGNoLnJlZ2V4cCA9IG1hdGNoLnR5cGVPZihcInJlZ2V4cFwiKTtcbiAgICAgICAgbWF0Y2guZGF0ZSA9IG1hdGNoLnR5cGVPZihcImRhdGVcIik7XG5cbiAgICAgICAgc2lub24ubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICB2YXIgc2lub24gPSByZXF1aXJlKFwiLi91dGlsL2NvcmVcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL3R5cGVPZlwiKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlQXBpKHNpbm9uKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBTUQpIHtcbiAgICAgICAgZGVmaW5lKGxvYWREZXBlbmRlbmNpZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgICBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNpbm9uR2xvYmFsKSB7XG4gICAgICAgIG1ha2VBcGkoc2lub25HbG9iYWwpO1xuICAgIH1cbn0oXG4gICAgdHlwZW9mIHNpbm9uID09PSBcIm9iamVjdFwiICYmIHNpbm9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbikpO1xuIiwiLyoqXG4gKiBAZGVwZW5kIHRpbWVzX2luX3dvcmRzLmpzXG4gKiBAZGVwZW5kIHV0aWwvY29yZS5qc1xuICogQGRlcGVuZCBjYWxsLmpzXG4gKiBAZGVwZW5kIGV4dGVuZC5qc1xuICogQGRlcGVuZCBtYXRjaC5qc1xuICogQGRlcGVuZCBzcHkuanNcbiAqIEBkZXBlbmQgc3R1Yi5qc1xuICogQGRlcGVuZCBmb3JtYXQuanNcbiAqL1xuLyoqXG4gKiBNb2NrIGZ1bmN0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIENocmlzdGlhbiBKb2hhbnNlbiAoY2hyaXN0aWFuQGNqb2hhbnNlbi5ubylcbiAqIEBsaWNlbnNlIEJTRFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIENocmlzdGlhbiBKb2hhbnNlblxuICovXG4oZnVuY3Rpb24gKHNpbm9uR2xvYmFsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiBtYWtlQXBpKHNpbm9uKSB7XG4gICAgICAgIHZhciBwdXNoID0gW10ucHVzaDtcbiAgICAgICAgdmFyIG1hdGNoID0gc2lub24ubWF0Y2g7XG5cbiAgICAgICAgZnVuY3Rpb24gbW9jayhvYmplY3QpIHtcbiAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUud2FybihcIm1vY2sgd2lsbCBiZSByZW1vdmVkIGZyb20gU2lub24uSlMgdjIuMFwiKTtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lub24uZXhwZWN0YXRpb24uY3JlYXRlKFwiQW5vbnltb3VzIG1vY2tcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtb2NrLmNyZWF0ZShvYmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZWFjaChjb2xsZWN0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbGxlY3Rpb24ubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY29sbGVjdGlvbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhcnJheUVxdWFscyhhcnIxLCBhcnIyLCBjb21wYXJlTGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoY29tcGFyZUxlbmd0aCAmJiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghc2lub24uZGVlcEVxdWFsKGFycjFbaV0sIGFycjJbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpbm9uLmV4dGVuZChtb2NrLCB7XG4gICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib2JqZWN0IGlzIG51bGxcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG1vY2tPYmplY3QgPSBzaW5vbi5leHRlbmQoe30sIG1vY2spO1xuICAgICAgICAgICAgICAgIG1vY2tPYmplY3Qub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtb2NrT2JqZWN0LmNyZWF0ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBtb2NrT2JqZWN0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZXhwZWN0czogZnVuY3Rpb24gZXhwZWN0cyhtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibWV0aG9kIGlzIGZhbHN5XCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5leHBlY3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RhdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm94aWVzID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmV4cGVjdGF0aW9uc1ttZXRob2RdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0YXRpb25zW21ldGhvZF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vY2tPYmplY3QgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgIHNpbm9uLndyYXBNZXRob2QodGhpcy5vYmplY3QsIG1ldGhvZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vY2tPYmplY3QuaW52b2tlTWV0aG9kKG1ldGhvZCwgdGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcHVzaC5jYWxsKHRoaXMucHJveGllcywgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZXhwZWN0YXRpb24gPSBzaW5vbi5leHBlY3RhdGlvbi5jcmVhdGUobWV0aG9kKTtcbiAgICAgICAgICAgICAgICBwdXNoLmNhbGwodGhpcy5leHBlY3RhdGlvbnNbbWV0aG9kXSwgZXhwZWN0YXRpb24pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVzdG9yZTogZnVuY3Rpb24gcmVzdG9yZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5vYmplY3Q7XG5cbiAgICAgICAgICAgICAgICBlYWNoKHRoaXMucHJveGllcywgZnVuY3Rpb24gKHByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W3Byb3h5XS5yZXN0b3JlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtwcm94eV0ucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB2ZXJpZnk6IGZ1bmN0aW9uIHZlcmlmeSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwZWN0YXRpb25zID0gdGhpcy5leHBlY3RhdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG1ldCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZWFjaCh0aGlzLnByb3hpZXMsIGZ1bmN0aW9uIChwcm94eSkge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKGV4cGVjdGF0aW9uc1twcm94eV0sIGZ1bmN0aW9uIChleHBlY3RhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleHBlY3RhdGlvbi5tZXQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guY2FsbChtZXNzYWdlcywgZXhwZWN0YXRpb24udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guY2FsbChtZXQsIGV4cGVjdGF0aW9uLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2lub24uZXhwZWN0YXRpb24uZmFpbChtZXNzYWdlcy5jb25jYXQobWV0KS5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbm9uLmV4cGVjdGF0aW9uLnBhc3MobWVzc2FnZXMuY29uY2F0KG1ldCkuam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbnZva2VNZXRob2Q6IGZ1bmN0aW9uIGludm9rZU1ldGhvZChtZXRob2QsIHRoaXNWYWx1ZSwgYXJncykge1xuICAgICAgICAgICAgICAgIHZhciBleHBlY3RhdGlvbnMgPSB0aGlzLmV4cGVjdGF0aW9ucyAmJiB0aGlzLmV4cGVjdGF0aW9uc1ttZXRob2RdID8gdGhpcy5leHBlY3RhdGlvbnNbbWV0aG9kXSA6IFtdO1xuICAgICAgICAgICAgICAgIHZhciBleHBlY3RhdGlvbnNXaXRoTWF0Y2hpbmdBcmdzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRBcmdzID0gYXJncyB8fCBbXTtcbiAgICAgICAgICAgICAgICB2YXIgaSwgYXZhaWxhYmxlO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwZWN0ZWRBcmdzID0gZXhwZWN0YXRpb25zW2ldLmV4cGVjdGVkQXJndW1lbnRzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXlFcXVhbHMoZXhwZWN0ZWRBcmdzLCBjdXJyZW50QXJncywgZXhwZWN0YXRpb25zW2ldLmV4cGVjdHNFeGFjdEFyZ0NvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0YXRpb25zV2l0aE1hdGNoaW5nQXJncy5wdXNoKGV4cGVjdGF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwZWN0YXRpb25zV2l0aE1hdGNoaW5nQXJncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4cGVjdGF0aW9uc1dpdGhNYXRjaGluZ0FyZ3NbaV0ubWV0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGF0aW9uc1dpdGhNYXRjaGluZ0FyZ3NbaV0uYWxsb3dzQ2FsbCh0aGlzVmFsdWUsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb25zV2l0aE1hdGNoaW5nQXJnc1tpXS5hcHBseSh0aGlzVmFsdWUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGV4aGF1c3RlZCA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwZWN0YXRpb25zV2l0aE1hdGNoaW5nQXJncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwZWN0YXRpb25zV2l0aE1hdGNoaW5nQXJnc1tpXS5hbGxvd3NDYWxsKHRoaXNWYWx1ZSwgYXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZSA9IGF2YWlsYWJsZSB8fCBleHBlY3RhdGlvbnNXaXRoTWF0Y2hpbmdBcmdzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhoYXVzdGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlICYmIGV4aGF1c3RlZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlLmFwcGx5KHRoaXNWYWx1ZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwobWVzc2FnZXMsIFwiICAgIFwiICsgZXhwZWN0YXRpb25zW2ldLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLnVuc2hpZnQoXCJVbmV4cGVjdGVkIGNhbGw6IFwiICsgc2lub24uc3B5Q2FsbC50b1N0cmluZy5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgcHJveHk6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIHNpbm9uLmV4cGVjdGF0aW9uLmZhaWwobWVzc2FnZXMuam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB0aW1lcyA9IHNpbm9uLnRpbWVzSW5Xb3JkcztcbiAgICAgICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxDb3VudEluV29yZHMoY2FsbENvdW50KSB7XG4gICAgICAgICAgICBpZiAoY2FsbENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibmV2ZXIgY2FsbGVkXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBcImNhbGxlZCBcIiArIHRpbWVzKGNhbGxDb3VudCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBleHBlY3RlZENhbGxDb3VudEluV29yZHMoZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSBleHBlY3RhdGlvbi5taW5DYWxscztcbiAgICAgICAgICAgIHZhciBtYXggPSBleHBlY3RhdGlvbi5tYXhDYWxscztcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtaW4gPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG1heCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSB0aW1lcyhtaW4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1pbiAhPT0gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IFwiYXQgbGVhc3QgXCIgKyBzdHIgKyBcIiBhbmQgYXQgbW9zdCBcIiArIHRpbWVzKG1heCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtaW4gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJhdCBsZWFzdCBcIiArIHRpbWVzKG1pbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBcImF0IG1vc3QgXCIgKyB0aW1lcyhtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVjZWl2ZWRNaW5DYWxscyhleHBlY3RhdGlvbikge1xuICAgICAgICAgICAgdmFyIGhhc01pbkxpbWl0ID0gdHlwZW9mIGV4cGVjdGF0aW9uLm1pbkNhbGxzID09PSBcIm51bWJlclwiO1xuICAgICAgICAgICAgcmV0dXJuICFoYXNNaW5MaW1pdCB8fCBleHBlY3RhdGlvbi5jYWxsQ291bnQgPj0gZXhwZWN0YXRpb24ubWluQ2FsbHM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWNlaXZlZE1heENhbGxzKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cGVjdGF0aW9uLm1heENhbGxzICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb24uY2FsbENvdW50ID09PSBleHBlY3RhdGlvbi5tYXhDYWxscztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHZlcmlmeU1hdGNoZXIocG9zc2libGVNYXRjaGVyLCBhcmcpIHtcbiAgICAgICAgICAgIHZhciBpc01hdGNoZXIgPSBtYXRjaCAmJiBtYXRjaC5pc01hdGNoZXIocG9zc2libGVNYXRjaGVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIGlzTWF0Y2hlciAmJiBwb3NzaWJsZU1hdGNoZXIudGVzdChhcmcpIHx8IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBzaW5vbi5leHBlY3RhdGlvbiA9IHtcbiAgICAgICAgICAgIG1pbkNhbGxzOiAxLFxuICAgICAgICAgICAgbWF4Q2FsbHM6IDEsXG5cbiAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwZWN0YXRpb24gPSBzaW5vbi5leHRlbmQoc2lub24uc3R1Yi5jcmVhdGUoKSwgc2lub24uZXhwZWN0YXRpb24pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBleHBlY3RhdGlvbi5jcmVhdGU7XG4gICAgICAgICAgICAgICAgZXhwZWN0YXRpb24ubWV0aG9kID0gbWV0aG9kTmFtZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBleHBlY3RhdGlvbjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGludm9rZTogZnVuY3Rpb24gaW52b2tlKGZ1bmMsIHRoaXNWYWx1ZSwgYXJncykge1xuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5Q2FsbEFsbG93ZWQodGhpc1ZhbHVlLCBhcmdzKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzaW5vbi5zcHkuaW52b2tlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhdExlYXN0OiBmdW5jdGlvbiBhdExlYXN0KG51bSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInXCIgKyBudW0gKyBcIicgaXMgbm90IG51bWJlclwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGltaXRzU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF4Q2FsbHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0c1NldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5taW5DYWxscyA9IG51bTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYXRNb3N0OiBmdW5jdGlvbiBhdE1vc3QobnVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidcIiArIG51bSArIFwiJyBpcyBub3QgbnVtYmVyXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5saW1pdHNTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5DYWxscyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGltaXRzU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1heENhbGxzID0gbnVtO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBuZXZlcjogZnVuY3Rpb24gbmV2ZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhhY3RseSgwKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uY2U6IGZ1bmN0aW9uIG9uY2UoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhhY3RseSgxKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHR3aWNlOiBmdW5jdGlvbiB0d2ljZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGFjdGx5KDIpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdGhyaWNlOiBmdW5jdGlvbiB0aHJpY2UoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhhY3RseSgzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGV4YWN0bHk6IGZ1bmN0aW9uIGV4YWN0bHkobnVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidcIiArIG51bSArIFwiJyBpcyBub3QgYSBudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5hdExlYXN0KG51bSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRNb3N0KG51bSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBtZXQ6IGZ1bmN0aW9uIG1ldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuZmFpbGVkICYmIHJlY2VpdmVkTWluQ2FsbHModGhpcyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB2ZXJpZnlDYWxsQWxsb3dlZDogZnVuY3Rpb24gdmVyaWZ5Q2FsbEFsbG93ZWQodGhpc1ZhbHVlLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkTWF4Q2FsbHModGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzaW5vbi5leHBlY3RhdGlvbi5mYWlsKHRoaXMubWV0aG9kICsgXCIgYWxyZWFkeSBjYWxsZWQgXCIgKyB0aW1lcyh0aGlzLm1heENhbGxzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKFwiZXhwZWN0ZWRUaGlzXCIgaW4gdGhpcyAmJiB0aGlzLmV4cGVjdGVkVGhpcyAhPT0gdGhpc1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbm9uLmV4cGVjdGF0aW9uLmZhaWwodGhpcy5tZXRob2QgKyBcIiBjYWxsZWQgd2l0aCBcIiArIHRoaXNWYWx1ZSArIFwiIGFzIHRoaXNWYWx1ZSwgZXhwZWN0ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RlZFRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKFwiZXhwZWN0ZWRBcmd1bWVudHNcIiBpbiB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbm9uLmV4cGVjdGF0aW9uLmZhaWwodGhpcy5tZXRob2QgKyBcIiByZWNlaXZlZCBubyBhcmd1bWVudHMsIGV4cGVjdGVkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbm9uLmZvcm1hdCh0aGlzLmV4cGVjdGVkQXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgdGhpcy5leHBlY3RlZEFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lub24uZXhwZWN0YXRpb24uZmFpbCh0aGlzLm1ldGhvZCArIFwiIHJlY2VpdmVkIHRvbyBmZXcgYXJndW1lbnRzIChcIiArIHNpbm9uLmZvcm1hdChhcmdzKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiksIGV4cGVjdGVkIFwiICsgc2lub24uZm9ybWF0KHRoaXMuZXhwZWN0ZWRBcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5leHBlY3RzRXhhY3RBcmdDb3VudCAmJlxuICAgICAgICAgICAgICAgICAgICBhcmdzLmxlbmd0aCAhPT0gdGhpcy5leHBlY3RlZEFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lub24uZXhwZWN0YXRpb24uZmFpbCh0aGlzLm1ldGhvZCArIFwiIHJlY2VpdmVkIHRvbyBtYW55IGFyZ3VtZW50cyAoXCIgKyBzaW5vbi5mb3JtYXQoYXJncykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIpLCBleHBlY3RlZCBcIiArIHNpbm9uLmZvcm1hdCh0aGlzLmV4cGVjdGVkQXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmV4cGVjdGVkQXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmVyaWZ5TWF0Y2hlcih0aGlzLmV4cGVjdGVkQXJndW1lbnRzW2ldLCBhcmdzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lub24uZXhwZWN0YXRpb24uZmFpbCh0aGlzLm1ldGhvZCArIFwiIHJlY2VpdmVkIHdyb25nIGFyZ3VtZW50cyBcIiArIHNpbm9uLmZvcm1hdChhcmdzKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIGRpZG4ndCBtYXRjaCBcIiArIHRoaXMuZXhwZWN0ZWRBcmd1bWVudHMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbm9uLmRlZXBFcXVhbCh0aGlzLmV4cGVjdGVkQXJndW1lbnRzW2ldLCBhcmdzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lub24uZXhwZWN0YXRpb24uZmFpbCh0aGlzLm1ldGhvZCArIFwiIHJlY2VpdmVkIHdyb25nIGFyZ3VtZW50cyBcIiArIHNpbm9uLmZvcm1hdChhcmdzKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIGV4cGVjdGVkIFwiICsgc2lub24uZm9ybWF0KHRoaXMuZXhwZWN0ZWRBcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFsbG93c0NhbGw6IGZ1bmN0aW9uIGFsbG93c0NhbGwodGhpc1ZhbHVlLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWV0KCkgJiYgcmVjZWl2ZWRNYXhDYWxscyh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKFwiZXhwZWN0ZWRUaGlzXCIgaW4gdGhpcyAmJiB0aGlzLmV4cGVjdGVkVGhpcyAhPT0gdGhpc1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIShcImV4cGVjdGVkQXJndW1lbnRzXCIgaW4gdGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MgfHwgW107XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCB0aGlzLmV4cGVjdGVkQXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXhwZWN0c0V4YWN0QXJnQ291bnQgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJncy5sZW5ndGggIT09IHRoaXMuZXhwZWN0ZWRBcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuZXhwZWN0ZWRBcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmVyaWZ5TWF0Y2hlcih0aGlzLmV4cGVjdGVkQXJndW1lbnRzW2ldLCBhcmdzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaW5vbi5kZWVwRXF1YWwodGhpcy5leHBlY3RlZEFyZ3VtZW50c1tpXSwgYXJnc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgd2l0aEFyZ3M6IGZ1bmN0aW9uIHdpdGhBcmdzKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0ZWRBcmd1bWVudHMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB3aXRoRXhhY3RBcmdzOiBmdW5jdGlvbiB3aXRoRXhhY3RBcmdzKCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2l0aEFyZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdHNFeGFjdEFyZ0NvdW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uOiBmdW5jdGlvbiBvbih0aGlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdGVkVGhpcyA9IHRoaXNWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSAodGhpcy5leHBlY3RlZEFyZ3VtZW50cyB8fCBbXSkuc2xpY2UoKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5leHBlY3RzRXhhY3RBcmdDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwoYXJncywgXCJbLi4uXVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FsbFN0ciA9IHNpbm9uLnNweUNhbGwudG9TdHJpbmcuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5OiB0aGlzLm1ldGhvZCB8fCBcImFub255bW91cyBtb2NrIGV4cGVjdGF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gY2FsbFN0ci5yZXBsYWNlKFwiLCBbLi4uXCIsIFwiWywgLi4uXCIpICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZENhbGxDb3VudEluV29yZHModGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFeHBlY3RhdGlvbiBtZXQ6IFwiICsgbWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIG1lc3NhZ2UgKyBcIiAoXCIgK1xuICAgICAgICAgICAgICAgICAgICBjYWxsQ291bnRJbldvcmRzKHRoaXMuY2FsbENvdW50KSArIFwiKVwiO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdmVyaWZ5OiBmdW5jdGlvbiB2ZXJpZnkoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1ldCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbm9uLmV4cGVjdGF0aW9uLmZhaWwodGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaW5vbi5leHBlY3RhdGlvbi5wYXNzKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwYXNzOiBmdW5jdGlvbiBwYXNzKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBzaW5vbi5hc3NlcnQucGFzcyhtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGZhaWw6IGZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciBleGNlcHRpb24gPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uLm5hbWUgPSBcIkV4cGVjdGF0aW9uRXJyb3JcIjtcblxuICAgICAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzaW5vbi5tb2NrID0gbW9jaztcbiAgICAgICAgcmV0dXJuIG1vY2s7XG4gICAgfVxuXG4gICAgdmFyIGlzTm9kZSA9IHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB2YXIgaXNBTUQgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09IFwib2JqZWN0XCIgJiYgZGVmaW5lLmFtZDtcblxuICAgIGZ1bmN0aW9uIGxvYWREZXBlbmRlbmNpZXMocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgICAgIHZhciBzaW5vbiA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZVwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vdGltZXNfaW5fd29yZHNcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL2NhbGxcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL2V4dGVuZFwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vbWF0Y2hcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL3NweVwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vc3R1YlwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZUFwaShzaW5vbik7XG4gICAgfVxuXG4gICAgaWYgKGlzQU1EKSB7XG4gICAgICAgIGRlZmluZShsb2FkRGVwZW5kZW5jaWVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzaW5vbkdsb2JhbCkge1xuICAgICAgICBtYWtlQXBpKHNpbm9uR2xvYmFsKTtcbiAgICB9XG59KFxuICAgIHR5cGVvZiBzaW5vbiA9PT0gXCJvYmplY3RcIiAmJiBzaW5vbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4pKTtcbiIsIi8qKlxuICogQGRlcGVuZCB1dGlsL2NvcmUuanNcbiAqIEBkZXBlbmQgZXh0ZW5kLmpzXG4gKiBAZGVwZW5kIGNvbGxlY3Rpb24uanNcbiAqIEBkZXBlbmQgdXRpbC9mYWtlX3RpbWVycy5qc1xuICogQGRlcGVuZCB1dGlsL2Zha2Vfc2VydmVyX3dpdGhfY2xvY2suanNcbiAqL1xuLyoqXG4gKiBNYW5hZ2VzIGZha2UgY29sbGVjdGlvbnMgYXMgd2VsbCBhcyBmYWtlIHV0aWxpdGllcyBzdWNoIGFzIFNpbm9uJ3NcbiAqIHRpbWVycyBhbmQgZmFrZSBYSFIgaW1wbGVtZW50YXRpb24gaW4gb25lIGNvbnZlbmllbnQgb2JqZWN0LlxuICpcbiAqIEBhdXRob3IgQ2hyaXN0aWFuIEpvaGFuc2VuIChjaHJpc3RpYW5AY2pvaGFuc2VuLm5vKVxuICogQGxpY2Vuc2UgQlNEXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgQ2hyaXN0aWFuIEpvaGFuc2VuXG4gKi9cbihmdW5jdGlvbiAoc2lub25HbG9iYWwpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIG1ha2VBcGkoc2lub24pIHtcbiAgICAgICAgdmFyIHB1c2ggPSBbXS5wdXNoO1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4cG9zZVZhbHVlKHNhbmRib3gsIGNvbmZpZywga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5pbmplY3RJbnRvICYmICEoa2V5IGluIGNvbmZpZy5pbmplY3RJbnRvKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5pbmplY3RJbnRvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzYW5kYm94LmluamVjdGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1c2guY2FsbChzYW5kYm94LmFyZ3MsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByZXBhcmVTYW5kYm94RnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBzYW5kYm94ID0gc2lub24uY3JlYXRlKHNpbm9uLnNhbmRib3gpO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLnVzZUZha2VTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy51c2VGYWtlU2VydmVyID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbmRib3guc2VydmVyUHJvdG90eXBlID0gY29uZmlnLnVzZUZha2VTZXJ2ZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2FuZGJveC51c2VGYWtlU2VydmVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb25maWcudXNlRmFrZVRpbWVycykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnLnVzZUZha2VUaW1lcnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FuZGJveC51c2VGYWtlVGltZXJzLmFwcGx5KHNhbmRib3gsIGNvbmZpZy51c2VGYWtlVGltZXJzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzYW5kYm94LnVzZUZha2VUaW1lcnMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzYW5kYm94O1xuICAgICAgICB9XG5cbiAgICAgICAgc2lub24uc2FuZGJveCA9IHNpbm9uLmV4dGVuZChzaW5vbi5jcmVhdGUoc2lub24uY29sbGVjdGlvbiksIHtcbiAgICAgICAgICAgIHVzZUZha2VUaW1lcnM6IGZ1bmN0aW9uIHVzZUZha2VUaW1lcnMoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9jayA9IHNpbm9uLnVzZUZha2VUaW1lcnMuYXBwbHkoc2lub24sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQodGhpcy5jbG9jayk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXJ2ZXJQcm90b3R5cGU6IHNpbm9uLmZha2VTZXJ2ZXIsXG5cbiAgICAgICAgICAgIHVzZUZha2VTZXJ2ZXI6IGZ1bmN0aW9uIHVzZUZha2VTZXJ2ZXIoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3RvID0gdGhpcy5zZXJ2ZXJQcm90b3R5cGUgfHwgc2lub24uZmFrZVNlcnZlcjtcblxuICAgICAgICAgICAgICAgIGlmICghcHJvdG8gfHwgIXByb3RvLmNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlciA9IHByb3RvLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZCh0aGlzLnNlcnZlcik7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICBzaW5vbi5jb2xsZWN0aW9uLmluamVjdC5jYWxsKHRoaXMsIG9iaik7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBvYmouY2xvY2sgPSB0aGlzLmNsb2NrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICBvYmouc2VydmVyID0gdGhpcy5zZXJ2ZXI7XG4gICAgICAgICAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IHRoaXMuc2VydmVyLnJlcXVlc3RzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai5tYXRjaCA9IHNpbm9uLm1hdGNoO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlc3RvcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzaW5vbi5jb2xsZWN0aW9uLnJlc3RvcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVDb250ZXh0KCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZXN0b3JlQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluamVjdGVkS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuaW5qZWN0ZWRLZXlzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5qZWN0SW50b1t0aGlzLmluamVjdGVkS2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmplY3RlZEtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lub24uY3JlYXRlKHNpbm9uLnNhbmRib3gpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzYW5kYm94ID0gcHJlcGFyZVNhbmRib3hGcm9tQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgc2FuZGJveC5hcmdzID0gc2FuZGJveC5hcmdzIHx8IFtdO1xuICAgICAgICAgICAgICAgIHNhbmRib3guaW5qZWN0ZWRLZXlzID0gW107XG4gICAgICAgICAgICAgICAgc2FuZGJveC5pbmplY3RJbnRvID0gY29uZmlnLmluamVjdEludG87XG4gICAgICAgICAgICAgICAgdmFyIHByb3AsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBleHBvc2VkID0gc2FuZGJveC5pbmplY3Qoe30pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29uZmlnLnByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wID0gY29uZmlnLnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGV4cG9zZWRbcHJvcF0gfHwgcHJvcCA9PT0gXCJzYW5kYm94XCIgJiYgc2FuZGJveDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9zZVZhbHVlKHNhbmRib3gsIGNvbmZpZywgcHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3NlVmFsdWUoc2FuZGJveCwgY29uZmlnLCBcInNhbmRib3hcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzYW5kYm94O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbWF0Y2g6IHNpbm9uLm1hdGNoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNpbm9uLnNhbmRib3gudXNlRmFrZVhNTEh0dHBSZXF1ZXN0ID0gc2lub24uc2FuZGJveC51c2VGYWtlU2VydmVyO1xuXG4gICAgICAgIHJldHVybiBzaW5vbi5zYW5kYm94O1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICB2YXIgc2lub24gPSByZXF1aXJlKFwiLi91dGlsL2NvcmVcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL2V4dGVuZFwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vdXRpbC9mYWtlX3NlcnZlcl93aXRoX2Nsb2NrXCIpO1xuICAgICAgICByZXF1aXJlKFwiLi91dGlsL2Zha2VfdGltZXJzXCIpO1xuICAgICAgICByZXF1aXJlKFwiLi9jb2xsZWN0aW9uXCIpO1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2VBcGkoc2lub24pO1xuICAgIH1cblxuICAgIGlmIChpc0FNRCkge1xuICAgICAgICBkZWZpbmUobG9hZERlcGVuZGVuY2llcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgIGxvYWREZXBlbmRlbmNpZXMocmVxdWlyZSwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2lub25HbG9iYWwpIHtcbiAgICAgICAgbWFrZUFwaShzaW5vbkdsb2JhbCk7XG4gICAgfVxufShcbiAgICB0eXBlb2Ygc2lub24gPT09IFwib2JqZWN0XCIgJiYgc2lub24gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuKSk7XG4iLCIvKipcbiAgKiBAZGVwZW5kIHRpbWVzX2luX3dvcmRzLmpzXG4gICogQGRlcGVuZCB1dGlsL2NvcmUuanNcbiAgKiBAZGVwZW5kIGV4dGVuZC5qc1xuICAqIEBkZXBlbmQgY2FsbC5qc1xuICAqIEBkZXBlbmQgZm9ybWF0LmpzXG4gICovXG4vKipcbiAgKiBTcHkgZnVuY3Rpb25zXG4gICpcbiAgKiBAYXV0aG9yIENocmlzdGlhbiBKb2hhbnNlbiAoY2hyaXN0aWFuQGNqb2hhbnNlbi5ubylcbiAgKiBAbGljZW5zZSBCU0RcbiAgKlxuICAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIENocmlzdGlhbiBKb2hhbnNlblxuICAqL1xuKGZ1bmN0aW9uIChzaW5vbkdsb2JhbCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gbWFrZUFwaShzaW5vbikge1xuICAgICAgICB2YXIgcHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuICAgICAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gICAgICAgIHZhciBjYWxsSWQgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNweShvYmplY3QsIHByb3BlcnR5LCB0eXBlcykge1xuICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eSAmJiB0eXBlb2Ygb2JqZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3B5LmNyZWF0ZShvYmplY3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9iamVjdCAmJiAhcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3B5LmNyZWF0ZShmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kRGVzYyA9IHNpbm9uLmdldFByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZERlc2NbdHlwZXNbaV1dID0gc3B5LmNyZWF0ZShtZXRob2REZXNjW3R5cGVzW2ldXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzaW5vbi53cmFwTWV0aG9kKG9iamVjdCwgcHJvcGVydHksIG1ldGhvZERlc2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2lub24ud3JhcE1ldGhvZChvYmplY3QsIHByb3BlcnR5LCBzcHkuY3JlYXRlKG9iamVjdFtwcm9wZXJ0eV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoaW5nRmFrZShmYWtlcywgYXJncywgc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoIWZha2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBmYWtlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZmFrZXNbaV0ubWF0Y2hlcyhhcmdzLCBzdHJpY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWtlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbmNyZW1lbnRDYWxsQ291bnQoKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNhbGxDb3VudCArPSAxO1xuICAgICAgICAgICAgdGhpcy5ub3RDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGVkT25jZSA9IHRoaXMuY2FsbENvdW50ID09PSAxO1xuICAgICAgICAgICAgdGhpcy5jYWxsZWRUd2ljZSA9IHRoaXMuY2FsbENvdW50ID09PSAyO1xuICAgICAgICAgICAgdGhpcy5jYWxsZWRUaHJpY2UgPSB0aGlzLmNhbGxDb3VudCA9PT0gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbGxQcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgdGhpcy5maXJzdENhbGwgPSB0aGlzLmdldENhbGwoMCk7XG4gICAgICAgICAgICB0aGlzLnNlY29uZENhbGwgPSB0aGlzLmdldENhbGwoMSk7XG4gICAgICAgICAgICB0aGlzLnRoaXJkQ2FsbCA9IHRoaXMuZ2V0Q2FsbCgyKTtcbiAgICAgICAgICAgIHRoaXMubGFzdENhbGwgPSB0aGlzLmdldENhbGwodGhpcy5jYWxsQ291bnQgLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YXJzID0gXCJhLGIsYyxkLGUsZixnLGgsaSxqLGssbFwiO1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVQcm94eShmdW5jLCBwcm94eUxlbmd0aCkge1xuICAgICAgICAgICAgLy8gUmV0YWluIHRoZSBmdW5jdGlvbiBsZW5ndGg6XG4gICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgIGlmIChwcm94eUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGV2YWwoXCJwID0gKGZ1bmN0aW9uIHByb3h5KFwiICsgdmFycy5zdWJzdHJpbmcoMCwgcHJveHlMZW5ndGggKiAyIC0gMSkgKyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcbiAgICAgICAgICAgICAgICAgICAgXCIpIHsgcmV0dXJuIHAuaW52b2tlKGZ1bmMsIHRoaXMsIHNsaWNlLmNhbGwoYXJndW1lbnRzKSk7IH0pO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IGZ1bmN0aW9uIHByb3h5KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5pbnZva2UoZnVuYywgdGhpcywgc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5pc1Npbm9uUHJveHkgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXVpZCA9IDA7XG5cbiAgICAgICAgLy8gUHVibGljIEFQSVxuICAgICAgICB2YXIgc3B5QXBpID0ge1xuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnZva2luZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFwiQ2Fubm90IHJlc2V0IFNpbm9uIGZ1bmN0aW9uIHdoaWxlIGludm9raW5nIGl0LiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNb3ZlIHRoZSBjYWxsIHRvIC5yZXNldCBvdXRzaWRlIG9mIHRoZSBjYWxsYmFjay5cIik7XG4gICAgICAgICAgICAgICAgICAgIGVyci5uYW1lID0gXCJJbnZhbGlkUmVzZXRFeGNlcHRpb25cIjtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGVkT25jZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGVkVHdpY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxlZFRocmljZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0Q2FsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRDYWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnRoaXJkQ2FsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2FsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmdzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnRoaXNWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4Y2VwdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxJZHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZha2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mYWtlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWtlc1tpXS5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShmdW5jLCBzcHlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHNpbm9uLmZ1bmN0aW9uTmFtZShmdW5jKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNweUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzcHlMZW5ndGggPSBmdW5jLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSBjcmVhdGVQcm94eShmdW5jLCBzcHlMZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgc2lub24uZXh0ZW5kKHByb3h5LCBzcHkpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm94eS5jcmVhdGU7XG4gICAgICAgICAgICAgICAgc2lub24uZXh0ZW5kKHByb3h5LCBmdW5jKTtcblxuICAgICAgICAgICAgICAgIHByb3h5LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgcHJveHkucHJvdG90eXBlID0gZnVuYy5wcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgcHJveHkuZGlzcGxheU5hbWUgPSBuYW1lIHx8IFwic3B5XCI7XG4gICAgICAgICAgICAgICAgcHJveHkudG9TdHJpbmcgPSBzaW5vbi5mdW5jdGlvblRvU3RyaW5nO1xuICAgICAgICAgICAgICAgIHByb3h5Lmluc3RhbnRpYXRlRmFrZSA9IHNpbm9uLnNweS5jcmVhdGU7XG4gICAgICAgICAgICAgICAgcHJveHkuaWQgPSBcInNweSNcIiArIHV1aWQrKztcblxuICAgICAgICAgICAgICAgIHJldHVybiBwcm94eTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGludm9rZTogZnVuY3Rpb24gaW52b2tlKGZ1bmMsIHRoaXNWYWx1ZSwgYXJncykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGluZyA9IG1hdGNoaW5nRmFrZSh0aGlzLmZha2VzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhjZXB0aW9uLCByZXR1cm5WYWx1ZTtcblxuICAgICAgICAgICAgICAgIGluY3JlbWVudENhbGxDb3VudC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHB1c2guY2FsbCh0aGlzLnRoaXNWYWx1ZXMsIHRoaXNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcHVzaC5jYWxsKHRoaXMuYXJncywgYXJncyk7XG4gICAgICAgICAgICAgICAgcHVzaC5jYWxsKHRoaXMuY2FsbElkcywgY2FsbElkKyspO1xuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBjYWxsIHByb3BlcnRpZXMgYXZhaWxhYmxlIGZyb20gd2l0aGluIHRoZSBzcGllZCBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICBjcmVhdGVDYWxsUHJvcGVydGllcy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZva2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IG1hdGNoaW5nLmludm9rZShmdW5jLCB0aGlzVmFsdWUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSAodGhpcy5mdW5jIHx8IGZ1bmMpLmFwcGx5KHRoaXNWYWx1ZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc0NhbGwgPSB0aGlzLmdldENhbGwodGhpcy5jYWxsQ291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNDYWxsLmNhbGxlZFdpdGhOZXcoKSAmJiB0eXBlb2YgcmV0dXJuVmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdGhpc1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBleGNlcHRpb24gPSBlO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmludm9raW5nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHB1c2guY2FsbCh0aGlzLmV4Y2VwdGlvbnMsIGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgcHVzaC5jYWxsKHRoaXMucmV0dXJuVmFsdWVzLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgcHVzaC5jYWxsKHRoaXMuc3RhY2tzLCBuZXcgRXJyb3IoKS5zdGFjayk7XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHJldHVybiB2YWx1ZSBhbmQgZXhjZXB0aW9uIGF2YWlsYWJsZSBpbiB0aGUgY2FsbHM6XG4gICAgICAgICAgICAgICAgY3JlYXRlQ2FsbFByb3BlcnRpZXMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGlmIChleGNlcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbmFtZWQ6IGZ1bmN0aW9uIG5hbWVkKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbGw6IGZ1bmN0aW9uIGdldENhbGwoaSkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IHRoaXMuY2FsbENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzaW5vbi5zcHlDYWxsKHRoaXMsIHRoaXMudGhpc1ZhbHVlc1tpXSwgdGhpcy5hcmdzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuVmFsdWVzW2ldLCB0aGlzLmV4Y2VwdGlvbnNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsSWRzW2ldLCB0aGlzLnN0YWNrc1tpXSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDYWxsczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxscyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY2FsbENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbHMucHVzaCh0aGlzLmdldENhbGwoaSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxscztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNhbGxlZEJlZm9yZTogZnVuY3Rpb24gY2FsbGVkQmVmb3JlKHNweUZuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzcHlGbi5jYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbElkc1swXSA8IHNweUZuLmNhbGxJZHNbc3B5Rm4uY2FsbElkcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNhbGxlZEFmdGVyOiBmdW5jdGlvbiBjYWxsZWRBZnRlcihzcHlGbikge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYWxsZWQgfHwgIXNweUZuLmNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbElkc1t0aGlzLmNhbGxDb3VudCAtIDFdID4gc3B5Rm4uY2FsbElkc1tzcHlGbi5jYWxsQ291bnQgLSAxXTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHdpdGhBcmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mYWtlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBtYXRjaGluZ0Zha2UodGhpcy5mYWtlcywgYXJncywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZha2VzID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZmFrZSA9IHRoaXMuaW5zdGFudGlhdGVGYWtlKCk7XG4gICAgICAgICAgICAgICAgZmFrZS5tYXRjaGluZ0FndW1lbnRzID0gYXJncztcbiAgICAgICAgICAgICAgICBmYWtlLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcHVzaC5jYWxsKHRoaXMuZmFrZXMsIGZha2UpO1xuXG4gICAgICAgICAgICAgICAgZmFrZS53aXRoQXJncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLndpdGhBcmdzLmFwcGx5KG9yaWdpbmFsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmFrZS5tYXRjaGVzKHRoaXMuYXJnc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudENhbGxDb3VudC5jYWxsKGZha2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5jYWxsKGZha2UudGhpc1ZhbHVlcywgdGhpcy50aGlzVmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guY2FsbChmYWtlLmFyZ3MsIHRoaXMuYXJnc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwoZmFrZS5yZXR1cm5WYWx1ZXMsIHRoaXMucmV0dXJuVmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guY2FsbChmYWtlLmV4Y2VwdGlvbnMsIHRoaXMuZXhjZXB0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwoZmFrZS5jYWxsSWRzLCB0aGlzLmNhbGxJZHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNyZWF0ZUNhbGxQcm9wZXJ0aWVzLmNhbGwoZmFrZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFrZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG1hdGNoZXM6IGZ1bmN0aW9uIChhcmdzLCBzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFyZ3MgPSB0aGlzLm1hdGNoaW5nQWd1bWVudHM7XG5cbiAgICAgICAgICAgICAgICBpZiAobWFyZ3MubGVuZ3RoIDw9IGFyZ3MubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIHNpbm9uLmRlZXBFcXVhbChtYXJncywgYXJncy5zbGljZSgwLCBtYXJncy5sZW5ndGgpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXN0cmljdCB8fCBtYXJncy5sZW5ndGggPT09IGFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHByaW50ZjogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHZhciBzcHlJbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlcjtcblxuICAgICAgICAgICAgICAgIHJldHVybiAoZm9ybWF0IHx8IFwiXCIpLnJlcGxhY2UoLyUoLikvZywgZnVuY3Rpb24gKG1hdGNoLCBzcGVjaWZ5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyID0gc3B5QXBpLmZvcm1hdHRlcnNbc3BlY2lmeWVyXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmNhbGwobnVsbCwgc3B5SW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihwYXJzZUludChzcGVjaWZ5ZXIsIDEwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW5vbi5mb3JtYXQoYXJnc1tzcGVjaWZ5ZXIgLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIlXCIgKyBzcGVjaWZ5ZXI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZGVsZWdhdGVUb0NhbGxzKG1ldGhvZCwgbWF0Y2hBbnksIGFjdHVhbCwgbm90Q2FsbGVkKSB7XG4gICAgICAgICAgICBzcHlBcGlbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3RDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3RDYWxsZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDYWxsO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5jYWxsQ291bnQ7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENhbGwgPSB0aGlzLmdldENhbGwoaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDYWxsW2FjdHVhbCB8fCBtZXRob2RdLmFwcGx5KGN1cnJlbnRDYWxsLCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzICs9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaEFueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMgPT09IHRoaXMuY2FsbENvdW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGVnYXRlVG9DYWxscyhcImNhbGxlZE9uXCIsIHRydWUpO1xuICAgICAgICBkZWxlZ2F0ZVRvQ2FsbHMoXCJhbHdheXNDYWxsZWRPblwiLCBmYWxzZSwgXCJjYWxsZWRPblwiKTtcbiAgICAgICAgZGVsZWdhdGVUb0NhbGxzKFwiY2FsbGVkV2l0aFwiLCB0cnVlKTtcbiAgICAgICAgZGVsZWdhdGVUb0NhbGxzKFwiY2FsbGVkV2l0aE1hdGNoXCIsIHRydWUpO1xuICAgICAgICBkZWxlZ2F0ZVRvQ2FsbHMoXCJhbHdheXNDYWxsZWRXaXRoXCIsIGZhbHNlLCBcImNhbGxlZFdpdGhcIik7XG4gICAgICAgIGRlbGVnYXRlVG9DYWxscyhcImFsd2F5c0NhbGxlZFdpdGhNYXRjaFwiLCBmYWxzZSwgXCJjYWxsZWRXaXRoTWF0Y2hcIik7XG4gICAgICAgIGRlbGVnYXRlVG9DYWxscyhcImNhbGxlZFdpdGhFeGFjdGx5XCIsIHRydWUpO1xuICAgICAgICBkZWxlZ2F0ZVRvQ2FsbHMoXCJhbHdheXNDYWxsZWRXaXRoRXhhY3RseVwiLCBmYWxzZSwgXCJjYWxsZWRXaXRoRXhhY3RseVwiKTtcbiAgICAgICAgZGVsZWdhdGVUb0NhbGxzKFwibmV2ZXJDYWxsZWRXaXRoXCIsIGZhbHNlLCBcIm5vdENhbGxlZFdpdGhcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxlZ2F0ZVRvQ2FsbHMoXCJuZXZlckNhbGxlZFdpdGhNYXRjaFwiLCBmYWxzZSwgXCJub3RDYWxsZWRXaXRoTWF0Y2hcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxlZ2F0ZVRvQ2FsbHMoXCJ0aHJld1wiLCB0cnVlKTtcbiAgICAgICAgZGVsZWdhdGVUb0NhbGxzKFwiYWx3YXlzVGhyZXdcIiwgZmFsc2UsIFwidGhyZXdcIik7XG4gICAgICAgIGRlbGVnYXRlVG9DYWxscyhcInJldHVybmVkXCIsIHRydWUpO1xuICAgICAgICBkZWxlZ2F0ZVRvQ2FsbHMoXCJhbHdheXNSZXR1cm5lZFwiLCBmYWxzZSwgXCJyZXR1cm5lZFwiKTtcbiAgICAgICAgZGVsZWdhdGVUb0NhbGxzKFwiY2FsbGVkV2l0aE5ld1wiLCB0cnVlKTtcbiAgICAgICAgZGVsZWdhdGVUb0NhbGxzKFwiYWx3YXlzQ2FsbGVkV2l0aE5ld1wiLCBmYWxzZSwgXCJjYWxsZWRXaXRoTmV3XCIpO1xuICAgICAgICBkZWxlZ2F0ZVRvQ2FsbHMoXCJjYWxsQXJnXCIsIGZhbHNlLCBcImNhbGxBcmdXaXRoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLnRvU3RyaW5nKCkgKyBcIiBjYW5ub3QgY2FsbCBhcmcgc2luY2UgaXQgd2FzIG5vdCB5ZXQgaW52b2tlZC5cIik7XG4gICAgICAgIH0pO1xuICAgICAgICBzcHlBcGkuY2FsbEFyZ1dpdGggPSBzcHlBcGkuY2FsbEFyZztcbiAgICAgICAgZGVsZWdhdGVUb0NhbGxzKFwiY2FsbEFyZ09uXCIsIGZhbHNlLCBcImNhbGxBcmdPbldpdGhcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMudG9TdHJpbmcoKSArIFwiIGNhbm5vdCBjYWxsIGFyZyBzaW5jZSBpdCB3YXMgbm90IHlldCBpbnZva2VkLlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNweUFwaS5jYWxsQXJnT25XaXRoID0gc3B5QXBpLmNhbGxBcmdPbjtcbiAgICAgICAgZGVsZWdhdGVUb0NhbGxzKFwieWllbGRcIiwgZmFsc2UsIFwieWllbGRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMudG9TdHJpbmcoKSArIFwiIGNhbm5vdCB5aWVsZCBzaW5jZSBpdCB3YXMgbm90IHlldCBpbnZva2VkLlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFwiaW52b2tlQ2FsbGJhY2tcIiBpcyBhbiBhbGlhcyBmb3IgXCJ5aWVsZFwiIHNpbmNlIFwieWllbGRcIiBpcyBpbnZhbGlkIGluIHN0cmljdCBtb2RlLlxuICAgICAgICBzcHlBcGkuaW52b2tlQ2FsbGJhY2sgPSBzcHlBcGkueWllbGQ7XG4gICAgICAgIGRlbGVnYXRlVG9DYWxscyhcInlpZWxkT25cIiwgZmFsc2UsIFwieWllbGRPblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy50b1N0cmluZygpICsgXCIgY2Fubm90IHlpZWxkIHNpbmNlIGl0IHdhcyBub3QgeWV0IGludm9rZWQuXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZWdhdGVUb0NhbGxzKFwieWllbGRUb1wiLCBmYWxzZSwgXCJ5aWVsZFRvXCIsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMudG9TdHJpbmcoKSArIFwiIGNhbm5vdCB5aWVsZCB0byAnXCIgKyBwcm9wZXJ0eSArXG4gICAgICAgICAgICAgICAgXCInIHNpbmNlIGl0IHdhcyBub3QgeWV0IGludm9rZWQuXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZWdhdGVUb0NhbGxzKFwieWllbGRUb09uXCIsIGZhbHNlLCBcInlpZWxkVG9PblwiLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLnRvU3RyaW5nKCkgKyBcIiBjYW5ub3QgeWllbGQgdG8gJ1wiICsgcHJvcGVydHkgK1xuICAgICAgICAgICAgICAgIFwiJyBzaW5jZSBpdCB3YXMgbm90IHlldCBpbnZva2VkLlwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3B5QXBpLmZvcm1hdHRlcnMgPSB7XG4gICAgICAgICAgICBjOiBmdW5jdGlvbiAoc3B5SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lub24udGltZXNJbldvcmRzKHNweUluc3RhbmNlLmNhbGxDb3VudCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBuOiBmdW5jdGlvbiAoc3B5SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3B5SW5zdGFuY2UudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEM6IGZ1bmN0aW9uIChzcHlJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxscyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzcHlJbnN0YW5jZS5jYWxsQ291bnQ7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmluZ2lmaWVkQ2FsbCA9IFwiICAgIFwiICsgc3B5SW5zdGFuY2UuZ2V0Q2FsbChpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoL1xcbi8udGVzdChjYWxsc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZmllZENhbGwgPSBcIlxcblwiICsgc3RyaW5naWZpZWRDYWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHB1c2guY2FsbChjYWxscywgc3RyaW5naWZpZWRDYWxsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbHMubGVuZ3RoID4gMCA/IFwiXFxuXCIgKyBjYWxscy5qb2luKFwiXFxuXCIpIDogXCJcIjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHQ6IGZ1bmN0aW9uIChzcHlJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNweUluc3RhbmNlLmNhbGxDb3VudDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwob2JqZWN0cywgc2lub24uZm9ybWF0KHNweUluc3RhbmNlLnRoaXNWYWx1ZXNbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0cy5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBcIipcIjogZnVuY3Rpb24gKHNweUluc3RhbmNlLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmdzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwoZm9ybWF0dGVkLCBzaW5vbi5mb3JtYXQoYXJnc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZWQuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNpbm9uLmV4dGVuZChzcHksIHNweUFwaSk7XG5cbiAgICAgICAgc3B5LnNweUNhbGwgPSBzaW5vbi5zcHlDYWxsO1xuICAgICAgICBzaW5vbi5zcHkgPSBzcHk7XG5cbiAgICAgICAgcmV0dXJuIHNweTtcbiAgICB9XG5cbiAgICB2YXIgaXNOb2RlID0gdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIHZhciBpc0FNRCA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gXCJvYmplY3RcIiAmJiBkZWZpbmUuYW1kO1xuXG4gICAgZnVuY3Rpb24gbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICAgICAgdmFyIGNvcmUgPSByZXF1aXJlKFwiLi91dGlsL2NvcmVcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL2NhbGxcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL2V4dGVuZFwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vdGltZXNfaW5fd29yZHNcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlQXBpKGNvcmUpO1xuICAgIH1cblxuICAgIGlmIChpc0FNRCkge1xuICAgICAgICBkZWZpbmUobG9hZERlcGVuZGVuY2llcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgIGxvYWREZXBlbmRlbmNpZXMocmVxdWlyZSwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2lub25HbG9iYWwpIHtcbiAgICAgICAgbWFrZUFwaShzaW5vbkdsb2JhbCk7XG4gICAgfVxufShcbiAgICB0eXBlb2Ygc2lub24gPT09IFwib2JqZWN0XCIgJiYgc2lub24gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuKSk7XG4iLCIvKipcbiAqIEBkZXBlbmQgdXRpbC9jb3JlLmpzXG4gKiBAZGVwZW5kIGV4dGVuZC5qc1xuICogQGRlcGVuZCBzcHkuanNcbiAqIEBkZXBlbmQgYmVoYXZpb3IuanNcbiAqL1xuLyoqXG4gKiBTdHViIGZ1bmN0aW9uc1xuICpcbiAqIEBhdXRob3IgQ2hyaXN0aWFuIEpvaGFuc2VuIChjaHJpc3RpYW5AY2pvaGFuc2VuLm5vKVxuICogQGxpY2Vuc2UgQlNEXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgQ2hyaXN0aWFuIEpvaGFuc2VuXG4gKi9cbihmdW5jdGlvbiAoc2lub25HbG9iYWwpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIG1ha2VBcGkoc2lub24pIHtcbiAgICAgICAgZnVuY3Rpb24gc3R1YihvYmplY3QsIHByb3BlcnR5LCBmdW5jKSB7XG4gICAgICAgICAgICBpZiAoISFmdW5jICYmIHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGZ1bmMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ3VzdG9tIHN0dWIgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb3IgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgd3JhcHBlcixcbiAgICAgICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIgPSBzaW5vbi5zcHkgJiYgc2lub24uc3B5LmNyZWF0ZSA/IHNpbm9uLnNweS5jcmVhdGUoZnVuYykgOiBmdW5jO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIgPSBmdW5jO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lub24uc3B5ICYmIHNpbm9uLnNweS5jcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlcyA9IHNpbm9uLm9iamVjdEtleXMod3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlclt0eXBlc1tpXV0gPSBzaW5vbi5zcHkuY3JlYXRlKHdyYXBwZXJbdHlwZXNbaV1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0dWJMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmplY3RbcHJvcGVydHldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R1Ykxlbmd0aCA9IG9iamVjdFtwcm9wZXJ0eV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cmFwcGVyID0gc3R1Yi5jcmVhdGUoc3R1Ykxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb2JqZWN0ICYmIHR5cGVvZiBwcm9wZXJ0eSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaW5vbi5zdHViLmNyZWF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHByb3AgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2lub24uZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcCkudmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R1YihvYmplY3QsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNpbm9uLndyYXBNZXRob2Qob2JqZWN0LCBwcm9wZXJ0eSwgd3JhcHBlcik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuICAgICAgICBmdW5jdGlvbiBnZXRQYXJlbnRCZWhhdmlvdXIoc3R1Ykluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHN0dWJJbnN0YW5jZS5wYXJlbnQgJiYgZ2V0Q3VycmVudEJlaGF2aW9yKHN0dWJJbnN0YW5jZS5wYXJlbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldERlZmF1bHRCZWhhdmlvcihzdHViSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHViSW5zdGFuY2UuZGVmYXVsdEJlaGF2aW9yIHx8XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcmVudEJlaGF2aW91cihzdHViSW5zdGFuY2UpIHx8XG4gICAgICAgICAgICAgICAgICAgIHNpbm9uLmJlaGF2aW9yLmNyZWF0ZShzdHViSW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q3VycmVudEJlaGF2aW9yKHN0dWJJbnN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIGJlaGF2aW9yID0gc3R1Ykluc3RhbmNlLmJlaGF2aW9yc1tzdHViSW5zdGFuY2UuY2FsbENvdW50IC0gMV07XG4gICAgICAgICAgICByZXR1cm4gYmVoYXZpb3IgJiYgYmVoYXZpb3IuaXNQcmVzZW50KCkgPyBiZWhhdmlvciA6IGdldERlZmF1bHRCZWhhdmlvcihzdHViSW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qZXNsaW50LWVuYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSovXG5cbiAgICAgICAgdmFyIHV1aWQgPSAwO1xuXG4gICAgICAgIHZhciBwcm90byA9IHtcbiAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHN0dWJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25TdHViID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q3VycmVudEJlaGF2aW9yKGZ1bmN0aW9uU3R1YikuaW52b2tlKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uU3R1Yi5pZCA9IFwic3R1YiNcIiArIHV1aWQrKztcbiAgICAgICAgICAgICAgICB2YXIgb3JpZyA9IGZ1bmN0aW9uU3R1YjtcbiAgICAgICAgICAgICAgICBmdW5jdGlvblN0dWIgPSBzaW5vbi5zcHkuY3JlYXRlKGZ1bmN0aW9uU3R1Yiwgc3R1Ykxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25TdHViLmZ1bmMgPSBvcmlnO1xuXG4gICAgICAgICAgICAgICAgc2lub24uZXh0ZW5kKGZ1bmN0aW9uU3R1Yiwgc3R1Yik7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25TdHViLmluc3RhbnRpYXRlRmFrZSA9IHNpbm9uLnN0dWIuY3JlYXRlO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uU3R1Yi5kaXNwbGF5TmFtZSA9IFwic3R1YlwiO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uU3R1Yi50b1N0cmluZyA9IHNpbm9uLmZ1bmN0aW9uVG9TdHJpbmc7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvblN0dWIuZGVmYXVsdEJlaGF2aW9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmdW5jdGlvblN0dWIuYmVoYXZpb3JzID0gW107XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25TdHViO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVzZXRCZWhhdmlvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0QmVoYXZpb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuYmVoYXZpb3JzID0gW107XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZXR1cm5BcmdBdDtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVyblRoaXMgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZha2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmZha2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZha2VzW2ldLnJlc2V0QmVoYXZpb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uQ2FsbDogZnVuY3Rpb24gb25DYWxsKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJlaGF2aW9yc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWhhdmlvcnNbaW5kZXhdID0gc2lub24uYmVoYXZpb3IuY3JlYXRlKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yc1tpbmRleF07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkZpcnN0Q2FsbDogZnVuY3Rpb24gb25GaXJzdENhbGwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25DYWxsKDApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25TZWNvbmRDYWxsOiBmdW5jdGlvbiBvblNlY29uZENhbGwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25DYWxsKDEpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25UaGlyZENhbGw6IGZ1bmN0aW9uIG9uVGhpcmRDYWxsKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uQ2FsbCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVCZWhhdmlvcihiZWhhdmlvck1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRCZWhhdmlvciA9IHRoaXMuZGVmYXVsdEJlaGF2aW9yIHx8IHNpbm9uLmJlaGF2aW9yLmNyZWF0ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRCZWhhdmlvcltiZWhhdmlvck1ldGhvZF0uYXBwbHkodGhpcy5kZWZhdWx0QmVoYXZpb3IsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgbWV0aG9kIGluIHNpbm9uLmJlaGF2aW9yKSB7XG4gICAgICAgICAgICBpZiAoc2lub24uYmVoYXZpb3IuaGFzT3duUHJvcGVydHkobWV0aG9kKSAmJlxuICAgICAgICAgICAgICAgICFwcm90by5oYXNPd25Qcm9wZXJ0eShtZXRob2QpICYmXG4gICAgICAgICAgICAgICAgbWV0aG9kICE9PSBcImNyZWF0ZVwiICYmXG4gICAgICAgICAgICAgICAgbWV0aG9kICE9PSBcIndpdGhBcmdzXCIgJiZcbiAgICAgICAgICAgICAgICBtZXRob2QgIT09IFwiaW52b2tlXCIpIHtcbiAgICAgICAgICAgICAgICBwcm90b1ttZXRob2RdID0gY3JlYXRlQmVoYXZpb3IobWV0aG9kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNpbm9uLmV4dGVuZChzdHViLCBwcm90byk7XG4gICAgICAgIHNpbm9uLnN0dWIgPSBzdHViO1xuXG4gICAgICAgIHJldHVybiBzdHViO1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICB2YXIgY29yZSA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZVwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vYmVoYXZpb3JcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL3NweVwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vZXh0ZW5kXCIpO1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2VBcGkoY29yZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQU1EKSB7XG4gICAgICAgIGRlZmluZShsb2FkRGVwZW5kZW5jaWVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzaW5vbkdsb2JhbCkge1xuICAgICAgICBtYWtlQXBpKHNpbm9uR2xvYmFsKTtcbiAgICB9XG59KFxuICAgIHR5cGVvZiBzaW5vbiA9PT0gXCJvYmplY3RcIiAmJiBzaW5vbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4pKTtcbiIsIi8qKlxuICogQGRlcGVuZCB1dGlsL2NvcmUuanNcbiAqIEBkZXBlbmQgc2FuZGJveC5qc1xuICovXG4vKipcbiAqIFRlc3QgZnVuY3Rpb24sIHNhbmRib3hlcyBmYWtlc1xuICpcbiAqIEBhdXRob3IgQ2hyaXN0aWFuIEpvaGFuc2VuIChjaHJpc3RpYW5AY2pvaGFuc2VuLm5vKVxuICogQGxpY2Vuc2UgQlNEXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgQ2hyaXN0aWFuIEpvaGFuc2VuXG4gKi9cbihmdW5jdGlvbiAoc2lub25HbG9iYWwpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIG1ha2VBcGkoc2lub24pIHtcbiAgICAgICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRlc3QoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGNhbGxiYWNrO1xuXG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNpbm9uLnRlc3QgbmVlZHMgdG8gd3JhcCBhIHRlc3QgZnVuY3Rpb24sIGdvdCBcIiArIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBzaW5vblNhbmRib3hlZFRlc3QoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHNpbm9uLmdldENvbmZpZyhzaW5vbi5jb25maWcpO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5pbmplY3RJbnRvID0gY29uZmlnLmluamVjdEludG9UaGlzICYmIHRoaXMgfHwgY29uZmlnLmluamVjdEludG87XG4gICAgICAgICAgICAgICAgdmFyIHNhbmRib3ggPSBzaW5vbi5zYW5kYm94LmNyZWF0ZShjb25maWcpO1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHZhciBvbGREb25lID0gYXJncy5sZW5ndGggJiYgYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBleGNlcHRpb24sIHJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2xkRG9uZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9IGZ1bmN0aW9uIHNpbm9uRG9uZShyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW5kYm94LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbmRib3gudmVyaWZ5QW5kUmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkRG9uZShyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KHNhbmRib3guYXJncykpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uID0gZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9sZERvbmUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4Y2VwdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FuZGJveC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYW5kYm94LnZlcmlmeUFuZFJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2lub25Bc3luY1NhbmRib3hlZFRlc3QoZG9uZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW5vblNhbmRib3hlZFRlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2lub25TYW5kYm94ZWRUZXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGVzdC5jb25maWcgPSB7XG4gICAgICAgICAgICBpbmplY3RJbnRvVGhpczogdHJ1ZSxcbiAgICAgICAgICAgIGluamVjdEludG86IG51bGwsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXCJzcHlcIiwgXCJzdHViXCIsIFwibW9ja1wiLCBcImNsb2NrXCIsIFwic2VydmVyXCIsIFwicmVxdWVzdHNcIl0sXG4gICAgICAgICAgICB1c2VGYWtlVGltZXJzOiB0cnVlLFxuICAgICAgICAgICAgdXNlRmFrZVNlcnZlcjogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHNpbm9uLnRlc3QgPSB0ZXN0O1xuICAgICAgICByZXR1cm4gdGVzdDtcbiAgICB9XG5cbiAgICB2YXIgaXNOb2RlID0gdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIHZhciBpc0FNRCA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gXCJvYmplY3RcIiAmJiBkZWZpbmUuYW1kO1xuXG4gICAgZnVuY3Rpb24gbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICAgICAgdmFyIGNvcmUgPSByZXF1aXJlKFwiLi91dGlsL2NvcmVcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL3NhbmRib3hcIik7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZUFwaShjb3JlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBTUQpIHtcbiAgICAgICAgZGVmaW5lKGxvYWREZXBlbmRlbmNpZXMpO1xuICAgIH0gZWxzZSBpZiAoaXNOb2RlKSB7XG4gICAgICAgIGxvYWREZXBlbmRlbmNpZXMocmVxdWlyZSwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZSk7XG4gICAgfSBlbHNlIGlmIChzaW5vbkdsb2JhbCkge1xuICAgICAgICBtYWtlQXBpKHNpbm9uR2xvYmFsKTtcbiAgICB9XG59KHR5cGVvZiBzaW5vbiA9PT0gXCJvYmplY3RcIiAmJiBzaW5vbiB8fCBudWxsKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsIi8qKlxuICogQGRlcGVuZCB1dGlsL2NvcmUuanNcbiAqIEBkZXBlbmQgdGVzdC5qc1xuICovXG4vKipcbiAqIFRlc3QgY2FzZSwgc2FuZGJveGVzIGFsbCB0ZXN0IGZ1bmN0aW9uc1xuICpcbiAqIEBhdXRob3IgQ2hyaXN0aWFuIEpvaGFuc2VuIChjaHJpc3RpYW5AY2pvaGFuc2VuLm5vKVxuICogQGxpY2Vuc2UgQlNEXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgQ2hyaXN0aWFuIEpvaGFuc2VuXG4gKi9cbihmdW5jdGlvbiAoc2lub25HbG9iYWwpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRlc3QocHJvcGVydHksIHNldFVwLCB0ZWFyRG93bikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNldFVwKSB7XG4gICAgICAgICAgICAgICAgc2V0VXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGV4Y2VwdGlvbiwgcmVzdWx0O1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb3BlcnR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRlYXJEb3duKSB7XG4gICAgICAgICAgICAgICAgdGVhckRvd24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXBpKHNpbm9uKSB7XG4gICAgICAgIGZ1bmN0aW9uIHRlc3RDYXNlKHRlc3RzLCBwcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICghdGVzdHMgfHwgdHlwZW9mIHRlc3RzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNpbm9uLnRlc3RDYXNlIG5lZWRzIGFuIG9iamVjdCB3aXRoIHRlc3QgZnVuY3Rpb25zXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmVmaXggPSBwcmVmaXggfHwgXCJ0ZXN0XCI7XG4gICAgICAgICAgICB2YXIgclByZWZpeCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBwcmVmaXgpO1xuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSB7fTtcbiAgICAgICAgICAgIHZhciBzZXRVcCA9IHRlc3RzLnNldFVwO1xuICAgICAgICAgICAgdmFyIHRlYXJEb3duID0gdGVzdHMudGVhckRvd247XG4gICAgICAgICAgICB2YXIgdGVzdE5hbWUsXG4gICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgbWV0aG9kO1xuXG4gICAgICAgICAgICBmb3IgKHRlc3ROYW1lIGluIHRlc3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RzLmhhc093blByb3BlcnR5KHRlc3ROYW1lKSAmJiAhL14oc2V0VXB8dGVhckRvd24pJC8udGVzdCh0ZXN0TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSB0ZXN0c1t0ZXN0TmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gXCJmdW5jdGlvblwiICYmIHJQcmVmaXgudGVzdCh0ZXN0TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHByb3BlcnR5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0VXAgfHwgdGVhckRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBjcmVhdGVUZXN0KHByb3BlcnR5LCBzZXRVcCwgdGVhckRvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzW3Rlc3ROYW1lXSA9IHNpbm9uLnRlc3QobWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZHNbdGVzdE5hbWVdID0gdGVzdHNbdGVzdE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcztcbiAgICAgICAgfVxuXG4gICAgICAgIHNpbm9uLnRlc3RDYXNlID0gdGVzdENhc2U7XG4gICAgICAgIHJldHVybiB0ZXN0Q2FzZTtcbiAgICB9XG5cbiAgICB2YXIgaXNOb2RlID0gdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIHZhciBpc0FNRCA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gXCJvYmplY3RcIiAmJiBkZWZpbmUuYW1kO1xuXG4gICAgZnVuY3Rpb24gbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICAgICAgdmFyIGNvcmUgPSByZXF1aXJlKFwiLi91dGlsL2NvcmVcIik7XG4gICAgICAgIHJlcXVpcmUoXCIuL3Rlc3RcIik7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZUFwaShjb3JlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBTUQpIHtcbiAgICAgICAgZGVmaW5lKGxvYWREZXBlbmRlbmNpZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgICBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNpbm9uR2xvYmFsKSB7XG4gICAgICAgIG1ha2VBcGkoc2lub25HbG9iYWwpO1xuICAgIH1cbn0oXG4gICAgdHlwZW9mIHNpbm9uID09PSBcIm9iamVjdFwiICYmIHNpbm9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbikpO1xuIiwiLyoqXG4gKiBAZGVwZW5kIHV0aWwvY29yZS5qc1xuICovXG4oZnVuY3Rpb24gKHNpbm9uR2xvYmFsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiBtYWtlQXBpKHNpbm9uKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gdGltZXNJbldvcmRzKGNvdW50KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvbmNlXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0d2ljZVwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGhyaWNlXCI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjb3VudCB8fCAwKSArIFwiIHRpbWVzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzaW5vbi50aW1lc0luV29yZHMgPSB0aW1lc0luV29yZHM7XG4gICAgICAgIHJldHVybiBzaW5vbi50aW1lc0luV29yZHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICAgICAgdmFyIGNvcmUgPSByZXF1aXJlKFwiLi91dGlsL2NvcmVcIik7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWFrZUFwaShjb3JlKTtcbiAgICB9XG5cbiAgICB2YXIgaXNOb2RlID0gdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIHZhciBpc0FNRCA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gXCJvYmplY3RcIiAmJiBkZWZpbmUuYW1kO1xuXG4gICAgaWYgKGlzQU1EKSB7XG4gICAgICAgIGRlZmluZShsb2FkRGVwZW5kZW5jaWVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzaW5vbkdsb2JhbCkge1xuICAgICAgICBtYWtlQXBpKHNpbm9uR2xvYmFsKTtcbiAgICB9XG59KFxuICAgIHR5cGVvZiBzaW5vbiA9PT0gXCJvYmplY3RcIiAmJiBzaW5vbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4pKTtcbiIsIi8qKlxuICogQGRlcGVuZCB1dGlsL2NvcmUuanNcbiAqL1xuLyoqXG4gKiBGb3JtYXQgZnVuY3Rpb25zXG4gKlxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuKGZ1bmN0aW9uIChzaW5vbkdsb2JhbCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gbWFrZUFwaShzaW5vbikge1xuICAgICAgICBmdW5jdGlvbiB0eXBlT2YodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZyg4LCBzdHJpbmcubGVuZ3RoIC0gMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpbm9uLnR5cGVPZiA9IHR5cGVPZjtcbiAgICAgICAgcmV0dXJuIHNpbm9uLnR5cGVPZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICB2YXIgY29yZSA9IHJlcXVpcmUoXCIuL3V0aWwvY29yZVwiKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlQXBpKGNvcmUpO1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBpZiAoaXNBTUQpIHtcbiAgICAgICAgZGVmaW5lKGxvYWREZXBlbmRlbmNpZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgICBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNpbm9uR2xvYmFsKSB7XG4gICAgICAgIG1ha2VBcGkoc2lub25HbG9iYWwpO1xuICAgIH1cbn0oXG4gICAgdHlwZW9mIHNpbm9uID09PSBcIm9iamVjdFwiICYmIHNpbm9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbikpO1xuIiwiLyoqXG4gKiBAZGVwZW5kIC4uLy4uL3Npbm9uLmpzXG4gKi9cbi8qKlxuICogU2lub24gY29yZSB1dGlsaXRpZXMuIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAYXV0aG9yIENocmlzdGlhbiBKb2hhbnNlbiAoY2hyaXN0aWFuQGNqb2hhbnNlbi5ubylcbiAqIEBsaWNlbnNlIEJTRFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIENocmlzdGlhbiBKb2hhbnNlblxuICovXG4oZnVuY3Rpb24gKHNpbm9uR2xvYmFsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZGl2ID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgICBmdW5jdGlvbiBpc0RPTU5vZGUob2JqKSB7XG4gICAgICAgIHZhciBzdWNjZXNzID0gZmFsc2U7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9iai5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgc3VjY2VzcyA9IGRpdi5wYXJlbnROb2RlID09PSBvYmo7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2JqLnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZhaWxlZCwgbm90IG11Y2ggd2UgY2FuIGRvIGFib3V0IHRoYXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRWxlbWVudChvYmopIHtcbiAgICAgICAgcmV0dXJuIGRpdiAmJiBvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxICYmIGlzRE9NTm9kZShvYmopO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgfHwgISEob2JqICYmIG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY2FsbCAmJiBvYmouYXBwbHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVhbGx5TmFOKHZhbCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBpc05hTih2YWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1pcnJvclByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duLmNhbGwodGFyZ2V0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVzdG9yYWJsZShvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLnJlc3RvcmUgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmoucmVzdG9yZS5zaW5vbjtcbiAgICB9XG5cbiAgICAvLyBDaGVhcCB3YXkgdG8gZGV0ZWN0IGlmIHdlIGhhdmUgRVM1IHN1cHBvcnQuXG4gICAgdmFyIGhhc0VTNVN1cHBvcnQgPSBcImtleXNcIiBpbiBPYmplY3Q7XG5cbiAgICBmdW5jdGlvbiBtYWtlQXBpKHNpbm9uKSB7XG4gICAgICAgIHNpbm9uLndyYXBNZXRob2QgPSBmdW5jdGlvbiB3cmFwTWV0aG9kKG9iamVjdCwgcHJvcGVydHksIG1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU2hvdWxkIHdyYXAgcHJvcGVydHkgb2Ygb2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBtZXRob2QgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWV0aG9kIHdyYXBwZXIgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb3IgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjaGVja1dyYXBwZWRNZXRob2Qod3JhcHBlZE1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvcjtcblxuICAgICAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbih3cmFwcGVkTWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IoXCJBdHRlbXB0ZWQgdG8gd3JhcCBcIiArICh0eXBlb2Ygd3JhcHBlZE1ldGhvZCkgKyBcIiBwcm9wZXJ0eSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgKyBcIiBhcyBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRNZXRob2QucmVzdG9yZSAmJiB3cmFwcGVkTWV0aG9kLnJlc3RvcmUuc2lub24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgVHlwZUVycm9yKFwiQXR0ZW1wdGVkIHRvIHdyYXAgXCIgKyBwcm9wZXJ0eSArIFwiIHdoaWNoIGlzIGFscmVhZHkgd3JhcHBlZFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRNZXRob2QuY2FsbGVkQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJiID0gd3JhcHBlZE1ldGhvZC5yZXR1cm5zID8gXCJzdHViYmVkXCIgOiBcInNwaWVkIG9uXCI7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IFR5cGVFcnJvcihcIkF0dGVtcHRlZCB0byB3cmFwIFwiICsgcHJvcGVydHkgKyBcIiB3aGljaCBpcyBhbHJlYWR5IFwiICsgdmVyYik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3cmFwcGVkTWV0aG9kICYmIHdyYXBwZWRNZXRob2Quc3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc3RhY2sgKz0gXCJcXG4tLS0tLS0tLS0tLS0tLVxcblwiICsgd3JhcHBlZE1ldGhvZC5zdGFja1RyYWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVycm9yLCB3cmFwcGVkTWV0aG9kLCBpO1xuXG4gICAgICAgICAgICAvLyBJRSA4IGRvZXMgbm90IHN1cHBvcnQgaGFzT3duUHJvcGVydHkgb24gdGhlIHdpbmRvdyBvYmplY3QgYW5kIEZpcmVmb3ggaGFzIGEgcHJvYmxlbVxuICAgICAgICAgICAgLy8gd2hlbiB1c2luZyBoYXNPd24uY2FsbCBvbiBvYmplY3RzIGZyb20gb3RoZXIgZnJhbWVzLlxuICAgICAgICAgICAgdmFyIG93bmVkID0gb2JqZWN0Lmhhc093blByb3BlcnR5ID8gb2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSA6IGhhc093bi5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgICBpZiAoaGFzRVM1U3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2REZXNjID0gKHR5cGVvZiBtZXRob2QgPT09IFwiZnVuY3Rpb25cIikgPyB7dmFsdWU6IG1ldGhvZH0gOiBtZXRob2Q7XG4gICAgICAgICAgICAgICAgdmFyIHdyYXBwZWRNZXRob2REZXNjID0gc2lub24uZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF3cmFwcGVkTWV0aG9kRGVzYykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IoXCJBdHRlbXB0ZWQgdG8gd3JhcCBcIiArICh0eXBlb2Ygd3JhcHBlZE1ldGhvZCkgKyBcIiBwcm9wZXJ0eSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgKyBcIiBhcyBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdyYXBwZWRNZXRob2REZXNjLnJlc3RvcmUgJiYgd3JhcHBlZE1ldGhvZERlc2MucmVzdG9yZS5zaW5vbikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IoXCJBdHRlbXB0ZWQgdG8gd3JhcCBcIiArIHByb3BlcnR5ICsgXCIgd2hpY2ggaXMgYWxyZWFkeSB3cmFwcGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdyYXBwZWRNZXRob2REZXNjICYmIHdyYXBwZWRNZXRob2REZXNjLnN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YWNrICs9IFwiXFxuLS0tLS0tLS0tLS0tLS1cXG5cIiArIHdyYXBwZWRNZXRob2REZXNjLnN0YWNrVHJhY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVzID0gc2lub24ub2JqZWN0S2V5cyhtZXRob2REZXNjKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZE1ldGhvZCA9IHdyYXBwZWRNZXRob2REZXNjW3R5cGVzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tXcmFwcGVkTWV0aG9kKHdyYXBwZWRNZXRob2QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1pcnJvclByb3BlcnRpZXMobWV0aG9kRGVzYywgd3JhcHBlZE1ldGhvZERlc2MpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBtaXJyb3JQcm9wZXJ0aWVzKG1ldGhvZERlc2NbdHlwZXNbaV1dLCB3cmFwcGVkTWV0aG9kRGVzY1t0eXBlc1tpXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgbWV0aG9kRGVzYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRNZXRob2QgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGNoZWNrV3JhcHBlZE1ldGhvZCh3cmFwcGVkTWV0aG9kKTtcbiAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gbWV0aG9kO1xuICAgICAgICAgICAgICAgIG1ldGhvZC5kaXNwbGF5TmFtZSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZXRob2QuZGlzcGxheU5hbWUgPSBwcm9wZXJ0eTtcblxuICAgICAgICAgICAgLy8gU2V0IHVwIGEgc3RhY2sgdHJhY2Ugd2hpY2ggY2FuIGJlIHVzZWQgbGF0ZXIgdG8gZmluZCB3aGF0IGxpbmUgb2ZcbiAgICAgICAgICAgIC8vIGNvZGUgdGhlIG9yaWdpbmFsIG1ldGhvZCB3YXMgY3JlYXRlZCBvbi5cbiAgICAgICAgICAgIG1ldGhvZC5zdGFja1RyYWNlID0gKG5ldyBFcnJvcihcIlN0YWNrIFRyYWNlIGZvciBvcmlnaW5hbFwiKSkuc3RhY2s7XG5cbiAgICAgICAgICAgIG1ldGhvZC5yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBwcm90b3R5cGUgcHJvcGVydGllcyB0cnkgdG8gcmVzZXQgYnkgZGVsZXRlIGZpcnN0LlxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgZmFpbHMgKGV4OiBsb2NhbFN0b3JhZ2Ugb24gbW9iaWxlIHNhZmFyaSkgdGhlbiBmb3JjZSBhIHJlc2V0XG4gICAgICAgICAgICAgICAgLy8gdmlhIGRpcmVjdCBhc3NpZ25tZW50LlxuICAgICAgICAgICAgICAgIGlmICghb3duZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyBgZGVsZXRlYCBtYXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBuYXRpdmUgY29kZSBmdW5jdGlvbnMgYGRlbGV0ZWAgZmFpbHMgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBDaHJvbWUgPCA0MywgUGhhbnRvbUpTLCBldGMuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNFUzVTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB3cmFwcGVkTWV0aG9kRGVzYyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXNlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29uIHRvIGNoZWNrIGZhaWx1cmVzIHRoZW4gZm9yY2UgYSByZXNldFxuICAgICAgICAgICAgICAgIC8vIHZpYSBkaXJlY3QgYXNzaWdubWVudC5cbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0W3Byb3BlcnR5XSA9PT0gbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB3cmFwcGVkTWV0aG9kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG1ldGhvZC5yZXN0b3JlLnNpbm9uID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFoYXNFUzVTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgbWlycm9yUHJvcGVydGllcyhtZXRob2QsIHdyYXBwZWRNZXRob2QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpbm9uLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm90bykge1xuICAgICAgICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIEYucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgICAgICByZXR1cm4gbmV3IEYoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzaW5vbi5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICAgICAgICAgICAgaWYgKHNpbm9uLm1hdGNoICYmIHNpbm9uLm1hdGNoLmlzTWF0Y2hlcihhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnRlc3QoYik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1JlYWxseU5hTihhKSAmJiBpc1JlYWxseU5hTihiKSB8fCBhID09PSBiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNFbGVtZW50KGEpIHx8IGlzRWxlbWVudChiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGEgPT09IG51bGwgJiYgYiAhPT0gbnVsbCkgfHwgKGEgIT09IG51bGwgJiYgYiA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgUmVnRXhwICYmIGIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGEuc291cmNlID09PSBiLnNvdXJjZSkgJiYgKGEuZ2xvYmFsID09PSBiLmdsb2JhbCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGEuaWdub3JlQ2FzZSA9PT0gYi5pZ25vcmVDYXNlKSAmJiAoYS5tdWx0aWxpbmUgPT09IGIubXVsdGlsaW5lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk7XG4gICAgICAgICAgICBpZiAoYVN0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYVN0cmluZyA9PT0gXCJbb2JqZWN0IERhdGVdXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJvcDtcbiAgICAgICAgICAgIHZhciBhTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHZhciBiTGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgaWYgKGFTdHJpbmcgPT09IFwiW29iamVjdCBBcnJheV1cIiAmJiBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYUxlbmd0aCArPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHByb3AgaW4gYikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFbcHJvcF0sIGJbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYkxlbmd0aCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFMZW5ndGggPT09IGJMZW5ndGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2lub24uZnVuY3Rpb25OYW1lID0gZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGZ1bmMpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZnVuYy5kaXNwbGF5TmFtZSB8fCBmdW5jLm5hbWU7XG5cbiAgICAgICAgICAgIC8vIFVzZSBmdW5jdGlvbiBkZWNvbXBvc2l0aW9uIGFzIGEgbGFzdCByZXNvcnQgdG8gZ2V0IGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBuYW1lLiBEb2VzIG5vdCByZWx5IG9uIGZ1bmN0aW9uIGRlY29tcG9zaXRpb24gdG8gd29yayAtIGlmIGl0XG4gICAgICAgICAgICAvLyBkb2Vzbid0IGRlYnVnZ2luZyB3aWxsIGJlIHNsaWdodGx5IGxlc3MgaW5mb3JtYXRpdmVcbiAgICAgICAgICAgIC8vIChpLmUuIHRvU3RyaW5nIHdpbGwgc2F5ICdzcHknIHJhdGhlciB0aGFuICdteUZ1bmMnKS5cbiAgICAgICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gZnVuYy50b1N0cmluZygpLm1hdGNoKC9mdW5jdGlvbiAoW15cXHNcXChdKykvKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfTtcblxuICAgICAgICBzaW5vbi5mdW5jdGlvblRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRDYWxsICYmIHRoaXMuY2FsbENvdW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcDtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMuY2FsbENvdW50O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzVmFsdWUgPSB0aGlzLmdldENhbGwoaSkudGhpc1ZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocHJvcCBpbiB0aGlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzVmFsdWVbcHJvcF0gPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheU5hbWUgfHwgXCJzaW5vbiBmYWtlXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2lub24ub2JqZWN0S2V5cyA9IGZ1bmN0aW9uIG9iamVjdEtleXMob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqICE9PSBPYmplY3Qob2JqKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzaW5vbi5vYmplY3RLZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3RcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpbm9uLmdldFByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvcjtcblxuICAgICAgICAgICAgd2hpbGUgKHByb3RvICYmICEoZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIHByb3BlcnR5KSkpIHtcbiAgICAgICAgICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgfTtcblxuICAgICAgICBzaW5vbi5nZXRDb25maWcgPSBmdW5jdGlvbiAoY3VzdG9tKSB7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0ge307XG4gICAgICAgICAgICBjdXN0b20gPSBjdXN0b20gfHwge307XG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBzaW5vbi5kZWZhdWx0Q29uZmlnO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1twcm9wXSA9IGN1c3RvbS5oYXNPd25Qcm9wZXJ0eShwcm9wKSA/IGN1c3RvbVtwcm9wXSA6IGRlZmF1bHRzW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgfTtcblxuICAgICAgICBzaW5vbi5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgaW5qZWN0SW50b1RoaXM6IHRydWUsXG4gICAgICAgICAgICBpbmplY3RJbnRvOiBudWxsLFxuICAgICAgICAgICAgcHJvcGVydGllczogW1wic3B5XCIsIFwic3R1YlwiLCBcIm1vY2tcIiwgXCJjbG9ja1wiLCBcInNlcnZlclwiLCBcInJlcXVlc3RzXCJdLFxuICAgICAgICAgICAgdXNlRmFrZVRpbWVyczogdHJ1ZSxcbiAgICAgICAgICAgIHVzZUZha2VTZXJ2ZXI6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICBzaW5vbi50aW1lc0luV29yZHMgPSBmdW5jdGlvbiB0aW1lc0luV29yZHMoY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3VudCA9PT0gMSAmJiBcIm9uY2VcIiB8fFxuICAgICAgICAgICAgICAgIGNvdW50ID09PSAyICYmIFwidHdpY2VcIiB8fFxuICAgICAgICAgICAgICAgIGNvdW50ID09PSAzICYmIFwidGhyaWNlXCIgfHxcbiAgICAgICAgICAgICAgICAoY291bnQgfHwgMCkgKyBcIiB0aW1lc1wiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpbm9uLmNhbGxlZEluT3JkZXIgPSBmdW5jdGlvbiAoc3BpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gc3BpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcGllc1tpIC0gMV0uY2FsbGVkQmVmb3JlKHNwaWVzW2ldKSB8fCAhc3BpZXNbaV0uY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpbm9uLm9yZGVyQnlGaXJzdENhbGwgPSBmdW5jdGlvbiAoc3BpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGllcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgLy8gdXVpZCwgd29uJ3QgZXZlciBiZSBlcXVhbFxuICAgICAgICAgICAgICAgIHZhciBhQ2FsbCA9IGEuZ2V0Q2FsbCgwKTtcbiAgICAgICAgICAgICAgICB2YXIgYkNhbGwgPSBiLmdldENhbGwoMCk7XG4gICAgICAgICAgICAgICAgdmFyIGFJZCA9IGFDYWxsICYmIGFDYWxsLmNhbGxJZCB8fCAtMTtcbiAgICAgICAgICAgICAgICB2YXIgYklkID0gYkNhbGwgJiYgYkNhbGwuY2FsbElkIHx8IC0xO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFJZCA8IGJJZCA/IC0xIDogMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpbm9uLmNyZWF0ZVN0dWJJbnN0YW5jZSA9IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBjb25zdHJ1Y3RvciBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lub24uc3R1YihzaW5vbi5jcmVhdGUoY29uc3RydWN0b3IucHJvdG90eXBlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2lub24ucmVzdG9yZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RvcmFibGUob2JqZWN0W3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BdLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZXN0b3JhYmxlKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzaW5vbjtcbiAgICB9XG5cbiAgICB2YXIgaXNOb2RlID0gdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIHZhciBpc0FNRCA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gXCJvYmplY3RcIiAmJiBkZWZpbmUuYW1kO1xuXG4gICAgZnVuY3Rpb24gbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgICAgIG1ha2VBcGkoZXhwb3J0cyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQU1EKSB7XG4gICAgICAgIGRlZmluZShsb2FkRGVwZW5kZW5jaWVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzaW5vbkdsb2JhbCkge1xuICAgICAgICBtYWtlQXBpKHNpbm9uR2xvYmFsKTtcbiAgICB9XG59KFxuICAgIHR5cGVvZiBzaW5vbiA9PT0gXCJvYmplY3RcIiAmJiBzaW5vbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4pKTtcbiIsIi8qKlxuICogTWluaW1hbCBFdmVudCBpbnRlcmZhY2UgaW1wbGVtZW50YXRpb25cbiAqXG4gKiBPcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBieSBTdmVuIEZ1Y2hzOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS85OTUwMjhcbiAqIE1vZGlmaWNhdGlvbnMgYW5kIHRlc3RzIGJ5IENocmlzdGlhbiBKb2hhbnNlbi5cbiAqXG4gKiBAYXV0aG9yIFN2ZW4gRnVjaHMgKHN2ZW5mdWNoc0BhcnR3ZWItZGVzaWduLmRlKVxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEgU3ZlbiBGdWNocywgQ2hyaXN0aWFuIEpvaGFuc2VuXG4gKi9cbmlmICh0eXBlb2Ygc2lub24gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aGlzLnNpbm9uID0ge307XG59XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgcHVzaCA9IFtdLnB1c2g7XG5cbiAgICBmdW5jdGlvbiBtYWtlQXBpKHNpbm9uKSB7XG4gICAgICAgIHNpbm9uLkV2ZW50ID0gZnVuY3Rpb24gRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgdGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLmluaXRFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLCB0YXJnZXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpbm9uLkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIGluaXRFdmVudDogZnVuY3Rpb24gKHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5idWJibGVzID0gYnViYmxlcztcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNpbm9uLlByb2dyZXNzRXZlbnQgPSBmdW5jdGlvbiBQcm9ncmVzc0V2ZW50KHR5cGUsIHByb2dyZXNzRXZlbnRSYXcsIHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5pbml0RXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlLCB0YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSBwcm9ncmVzc0V2ZW50UmF3LmxvYWRlZCB8fCBudWxsO1xuICAgICAgICAgICAgdGhpcy50b3RhbCA9IHByb2dyZXNzRXZlbnRSYXcudG90YWwgfHwgbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoQ29tcHV0YWJsZSA9ICEhcHJvZ3Jlc3NFdmVudFJhdy50b3RhbDtcbiAgICAgICAgfTtcblxuICAgICAgICBzaW5vbi5Qcm9ncmVzc0V2ZW50LnByb3RvdHlwZSA9IG5ldyBzaW5vbi5FdmVudCgpO1xuXG4gICAgICAgIHNpbm9uLlByb2dyZXNzRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc2lub24uUHJvZ3Jlc3NFdmVudDtcblxuICAgICAgICBzaW5vbi5DdXN0b21FdmVudCA9IGZ1bmN0aW9uIEN1c3RvbUV2ZW50KHR5cGUsIGN1c3RvbURhdGEsIHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5pbml0RXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlLCB0YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5kZXRhaWwgPSBjdXN0b21EYXRhLmRldGFpbCB8fCBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpbm9uLkN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IG5ldyBzaW5vbi5FdmVudCgpO1xuXG4gICAgICAgIHNpbm9uLkN1c3RvbUV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHNpbm9uLkN1c3RvbUV2ZW50O1xuXG4gICAgICAgIHNpbm9uLkV2ZW50VGFyZ2V0ID0ge1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVycyB8fCB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50XSA9IHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHB1c2guY2FsbCh0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50XSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVycyAmJiB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50XSB8fCBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBldmVudC50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzICYmIHRoaXMuZXZlbnRMaXN0ZW5lcnNbdHlwZV0gfHwgW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyc1tpXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgaXNOb2RlID0gdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIHZhciBpc0FNRCA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gXCJvYmplY3RcIiAmJiBkZWZpbmUuYW1kO1xuXG4gICAgZnVuY3Rpb24gbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlKSB7XG4gICAgICAgIHZhciBzaW5vbiA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG4gICAgICAgIG1ha2VBcGkoc2lub24pO1xuICAgIH1cblxuICAgIGlmIChpc0FNRCkge1xuICAgICAgICBkZWZpbmUobG9hZERlcGVuZGVuY2llcyk7XG4gICAgfSBlbHNlIGlmIChpc05vZGUpIHtcbiAgICAgICAgbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtYWtlQXBpKHNpbm9uKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH1cbn0oKSk7XG4iLCIvKipcbiAqIEBkZXBlbmQgZmFrZV94ZG9tYWluX3JlcXVlc3QuanNcbiAqIEBkZXBlbmQgZmFrZV94bWxfaHR0cF9yZXF1ZXN0LmpzXG4gKiBAZGVwZW5kIC4uL2Zvcm1hdC5qc1xuICogQGRlcGVuZCAuLi9sb2dfZXJyb3IuanNcbiAqL1xuLyoqXG4gKiBUaGUgU2lub24gXCJzZXJ2ZXJcIiBtaW1pY3MgYSB3ZWIgc2VydmVyIHRoYXQgcmVjZWl2ZXMgcmVxdWVzdHMgZnJvbVxuICogc2lub24uRmFrZVhNTEh0dHBSZXF1ZXN0IGFuZCBwcm92aWRlcyBhbiBBUEkgdG8gcmVzcG9uZCB0byB0aG9zZSByZXF1ZXN0cyxcbiAqIGJvdGggc3luY2hyb25vdXNseSBhbmQgYXN5bmNocm9ub3VzbHkuIFRvIHJlc3BvbmQgc3luY2hyb251b3VzbHksIGNhbm5lZFxuICogYW5zd2VycyBoYXZlIHRvIGJlIHByb3ZpZGVkIHVwZnJvbnQuXG4gKlxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBwdXNoID0gW10ucHVzaDtcblxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlQXJyYXkoaGFuZGxlcikge1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSBoYW5kbGVyO1xuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaGFuZGxlcikgIT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBbMjAwLCB7fSwgaGFuZGxlcl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlWzJdICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFrZSBzZXJ2ZXIgcmVzcG9uc2UgYm9keSBzaG91bGQgYmUgc3RyaW5nLCBidXQgd2FzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlc3BvbnNlWzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICB2YXIgd2xvYyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cubG9jYXRpb24gOiB7fTtcbiAgICB2YXIgckN1cnJMb2MgPSBuZXcgUmVnRXhwKFwiXlwiICsgd2xvYy5wcm90b2NvbCArIFwiLy9cIiArIHdsb2MuaG9zdCk7XG5cbiAgICBmdW5jdGlvbiBtYXRjaE9uZShyZXNwb25zZSwgcmVxTWV0aG9kLCByZXFVcmwpIHtcbiAgICAgICAgdmFyIHJtZXRoID0gcmVzcG9uc2UubWV0aG9kO1xuICAgICAgICB2YXIgbWF0Y2hNZXRob2QgPSAhcm1ldGggfHwgcm1ldGgudG9Mb3dlckNhc2UoKSA9PT0gcmVxTWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciB1cmwgPSByZXNwb25zZS51cmw7XG4gICAgICAgIHZhciBtYXRjaFVybCA9ICF1cmwgfHwgdXJsID09PSByZXFVcmwgfHwgKHR5cGVvZiB1cmwudGVzdCA9PT0gXCJmdW5jdGlvblwiICYmIHVybC50ZXN0KHJlcVVybCkpO1xuXG4gICAgICAgIHJldHVybiBtYXRjaE1ldGhvZCAmJiBtYXRjaFVybDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaChyZXNwb25zZSwgcmVxdWVzdCkge1xuICAgICAgICB2YXIgcmVxdWVzdFVybCA9IHJlcXVlc3QudXJsO1xuXG4gICAgICAgIGlmICghL15odHRwcz86XFwvXFwvLy50ZXN0KHJlcXVlc3RVcmwpIHx8IHJDdXJyTG9jLnRlc3QocmVxdWVzdFVybCkpIHtcbiAgICAgICAgICAgIHJlcXVlc3RVcmwgPSByZXF1ZXN0VXJsLnJlcGxhY2UockN1cnJMb2MsIFwiXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoT25lKHJlc3BvbnNlLCB0aGlzLmdldEhUVFBNZXRob2QocmVxdWVzdCksIHJlcXVlc3RVcmwpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLnJlc3BvbnNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcnUgPSByZXNwb25zZS51cmw7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbcmVxdWVzdF0uY29uY2F0KHJ1ICYmIHR5cGVvZiBydS5leGVjID09PSBcImZ1bmN0aW9uXCIgPyBydS5leGVjKHJlcXVlc3RVcmwpLnNsaWNlKDEpIDogW10pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5yZXNwb25zZS5hcHBseShyZXNwb25zZSwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcGkoc2lub24pIHtcbiAgICAgICAgc2lub24uZmFrZVNlcnZlciA9IHtcbiAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXIgPSBzaW5vbi5jcmVhdGUodGhpcyk7XG4gICAgICAgICAgICAgICAgc2VydmVyLmNvbmZpZ3VyZShjb25maWcpO1xuICAgICAgICAgICAgICAgIGlmICghc2lub24ueGhyLnN1cHBvcnRzQ09SUykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnhociA9IHNpbm9uLnVzZUZha2VYRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueGhyID0gc2lub24udXNlRmFrZVhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlcnZlci5yZXF1ZXN0cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdGhpcy54aHIub25DcmVhdGUgPSBmdW5jdGlvbiAoeGhyT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlci5hZGRSZXF1ZXN0KHhock9iaik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJlOiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdoaXRlbGlzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhdXRvUmVzcG9uZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcImF1dG9SZXNwb25kQWZ0ZXJcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJyZXNwb25kSW1tZWRpYXRlbHlcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJmYWtlSFRUUE1ldGhvZHNcIjogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHNldHRpbmc7XG5cbiAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgZm9yIChzZXR0aW5nIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2hpdGVsaXN0Lmhhc093blByb3BlcnR5KHNldHRpbmcpICYmIGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShzZXR0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tzZXR0aW5nXSA9IGNvbmZpZ1tzZXR0aW5nXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRSZXF1ZXN0OiBmdW5jdGlvbiBhZGRSZXF1ZXN0KHhock9iaikge1xuICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXIgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHB1c2guY2FsbCh0aGlzLnJlcXVlc3RzLCB4aHJPYmopO1xuXG4gICAgICAgICAgICAgICAgeGhyT2JqLm9uU2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLmhhbmRsZVJlcXVlc3QodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZlci5yZXNwb25kSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlci5yZXNwb25kKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VydmVyLmF1dG9SZXNwb25kICYmICFzZXJ2ZXIucmVzcG9uZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2VydmVyLmF1dG9SZXNwb25kQWZ0ZXIgfHwgMTApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIucmVzcG9uZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SFRUUE1ldGhvZDogZnVuY3Rpb24gZ2V0SFRUUE1ldGhvZChyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmFrZUhUVFBNZXRob2RzICYmIC9wb3N0L2kudGVzdChyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSAocmVxdWVzdC5yZXF1ZXN0Qm9keSB8fCBcIlwiKS5tYXRjaCgvX21ldGhvZD0oW15cXGI7XSspLyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6IHJlcXVlc3QubWV0aG9kO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0Lm1ldGhvZDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhhbmRsZVJlcXVlc3Q6IGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QoeGhyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHB1c2guY2FsbCh0aGlzLnF1ZXVlLCB4aHIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1JlcXVlc3QoeGhyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uIGxvZyhyZXNwb25zZSwgcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHI7XG5cbiAgICAgICAgICAgICAgICBzdHIgPSBcIlJlcXVlc3Q6XFxuXCIgKyBzaW5vbi5mb3JtYXQocmVxdWVzdCkgKyBcIlxcblxcblwiO1xuICAgICAgICAgICAgICAgIHN0ciArPSBcIlJlc3BvbnNlOlxcblwiICsgc2lub24uZm9ybWF0KHJlc3BvbnNlKSArIFwiXFxuXFxuXCI7XG5cbiAgICAgICAgICAgICAgICBzaW5vbi5sb2coc3RyKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlc3BvbmRXaXRoOiBmdW5jdGlvbiByZXNwb25kV2l0aChtZXRob2QsIHVybCwgYm9keSkge1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBtZXRob2QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2VBcnJheShtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlc3BvbnNlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBtZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IG1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gbWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHB1c2guY2FsbCh0aGlzLnJlc3BvbnNlcywge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB0eXBlb2YgYm9keSA9PT0gXCJmdW5jdGlvblwiID8gYm9keSA6IHJlc3BvbnNlQXJyYXkoYm9keSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlc3BvbmQ6IGZ1bmN0aW9uIHJlc3BvbmQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uZFdpdGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlIHx8IFtdO1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0cyA9IHF1ZXVlLnNwbGljZSgwLCBxdWV1ZS5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NSZXF1ZXN0KHJlcXVlc3RzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwcm9jZXNzUmVxdWVzdDogZnVuY3Rpb24gcHJvY2Vzc1JlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHRoaXMucmVzcG9uc2UgfHwgWzQwNCwge30sIFwiXCJdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3BvbnNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IHRoaXMucmVzcG9uc2VzLmxlbmd0aCwgaSA9IGwgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5jYWxsKHRoaXMsIHRoaXMucmVzcG9uc2VzW2ldLCByZXF1ZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHRoaXMucmVzcG9uc2VzW2ldLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhyZXNwb25zZSwgcmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uZChyZXNwb25zZVswXSwgcmVzcG9uc2VbMV0sIHJlc3BvbnNlWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lub24ubG9nRXJyb3IoXCJGYWtlIHNlcnZlciByZXF1ZXN0IHByb2Nlc3NpbmdcIiwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVzdG9yZTogZnVuY3Rpb24gcmVzdG9yZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy54aHIucmVzdG9yZSAmJiB0aGlzLnhoci5yZXN0b3JlLmFwcGx5KHRoaXMueGhyLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICB2YXIgc2lub24gPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuICAgICAgICByZXF1aXJlKFwiLi9mYWtlX3hkb21haW5fcmVxdWVzdFwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vZmFrZV94bWxfaHR0cF9yZXF1ZXN0XCIpO1xuICAgICAgICByZXF1aXJlKFwiLi4vZm9ybWF0XCIpO1xuICAgICAgICBtYWtlQXBpKHNpbm9uKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzaW5vbjtcbiAgICB9XG5cbiAgICBpZiAoaXNBTUQpIHtcbiAgICAgICAgZGVmaW5lKGxvYWREZXBlbmRlbmNpZXMpO1xuICAgIH0gZWxzZSBpZiAoaXNOb2RlKSB7XG4gICAgICAgIGxvYWREZXBlbmRlbmNpZXMocmVxdWlyZSwgbW9kdWxlLmV4cG9ydHMsIG1vZHVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWFrZUFwaShzaW5vbik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB9XG59KCkpO1xuIiwiLyoqXG4gKiBAZGVwZW5kIGZha2Vfc2VydmVyLmpzXG4gKiBAZGVwZW5kIGZha2VfdGltZXJzLmpzXG4gKi9cbi8qKlxuICogQWRkLW9uIGZvciBzaW5vbi5mYWtlU2VydmVyIHRoYXQgYXV0b21hdGljYWxseSBoYW5kbGVzIGEgZmFrZSB0aW1lciBhbG9uZyB3aXRoXG4gKiB0aGUgRmFrZVhNTEh0dHBSZXF1ZXN0LiBUaGUgZGlyZWN0IGluc3BpcmF0aW9uIGZvciB0aGlzIGFkZC1vbiBpcyBqUXVlcnlcbiAqIDEuMy54LCB3aGljaCBkb2VzIG5vdCB1c2UgeGhyIG9iamVjdCdzIG9ucmVhZHlzdGF0ZWhhbmRsZXIgYXQgYWxsIC0gaW5zdGVhZCxcbiAqIGl0IHBvbGxzIHRoZSBvYmplY3QgZm9yIGNvbXBsZXRpb24gd2l0aCBzZXRJbnRlcnZhbC4gRGlzcGl0ZSB0aGUgZGlyZWN0XG4gKiBtb3RpdmF0aW9uLCB0aGVyZSBpcyBub3RoaW5nIGpRdWVyeS1zcGVjaWZpYyBpbiB0aGlzIGZpbGUsIHNvIGl0IGNhbiBiZSB1c2VkXG4gKiBpbiBhbnkgZW52aXJvbm1lbnQgd2hlcmUgdGhlIGFqYXggaW1wbGVtZW50YXRpb24gZGVwZW5kcyBvbiBzZXRJbnRlcnZhbCBvclxuICogc2V0VGltZW91dC5cbiAqXG4gKiBAYXV0aG9yIENocmlzdGlhbiBKb2hhbnNlbiAoY2hyaXN0aWFuQGNqb2hhbnNlbi5ubylcbiAqIEBsaWNlbnNlIEJTRFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIENocmlzdGlhbiBKb2hhbnNlblxuICovXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gbWFrZUFwaShzaW5vbikge1xuICAgICAgICBmdW5jdGlvbiBTZXJ2ZXIoKSB7fVxuICAgICAgICBTZXJ2ZXIucHJvdG90eXBlID0gc2lub24uZmFrZVNlcnZlcjtcblxuICAgICAgICBzaW5vbi5mYWtlU2VydmVyV2l0aENsb2NrID0gbmV3IFNlcnZlcigpO1xuXG4gICAgICAgIHNpbm9uLmZha2VTZXJ2ZXJXaXRoQ2xvY2suYWRkUmVxdWVzdCA9IGZ1bmN0aW9uIGFkZFJlcXVlc3QoeGhyKSB7XG4gICAgICAgICAgICBpZiAoeGhyLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0LmNsb2NrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvY2sgPSBzZXRUaW1lb3V0LmNsb2NrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvY2sgPSBzaW5vbi51c2VGYWtlVGltZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRDbG9jayA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxvbmdlc3RUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9ja1NldFRpbWVvdXQgPSB0aGlzLmNsb2NrLnNldFRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9ja1NldEludGVydmFsID0gdGhpcy5jbG9jay5zZXRJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcnZlciA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9jay5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKGZuLCB0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIubG9uZ2VzdFRpbWVvdXQgPSBNYXRoLm1heCh0aW1lb3V0LCBzZXJ2ZXIubG9uZ2VzdFRpbWVvdXQgfHwgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9ja1NldFRpbWVvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb2NrLnNldEludGVydmFsID0gZnVuY3Rpb24gKGZuLCB0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIubG9uZ2VzdFRpbWVvdXQgPSBNYXRoLm1heCh0aW1lb3V0LCBzZXJ2ZXIubG9uZ2VzdFRpbWVvdXQgfHwgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9ja1NldEludGVydmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2lub24uZmFrZVNlcnZlci5hZGRSZXF1ZXN0LmNhbGwodGhpcywgeGhyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzaW5vbi5mYWtlU2VydmVyV2l0aENsb2NrLnJlc3BvbmQgPSBmdW5jdGlvbiByZXNwb25kKCkge1xuICAgICAgICAgICAgdmFyIHJldHVyblZhbCA9IHNpbm9uLmZha2VTZXJ2ZXIucmVzcG9uZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jbG9jaykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvY2sudGljayh0aGlzLmxvbmdlc3RUaW1lb3V0IHx8IDApO1xuICAgICAgICAgICAgICAgIHRoaXMubG9uZ2VzdFRpbWVvdXQgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzZXRDbG9jaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb2NrLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldENsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpbm9uLmZha2VTZXJ2ZXJXaXRoQ2xvY2sucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbG9jaykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvY2sucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2lub24uZmFrZVNlcnZlci5yZXN0b3JlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGlzTm9kZSA9IHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB2YXIgaXNBTUQgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09IFwib2JqZWN0XCIgJiYgZGVmaW5lLmFtZDtcblxuICAgIGZ1bmN0aW9uIGxvYWREZXBlbmRlbmNpZXMocmVxdWlyZSkge1xuICAgICAgICB2YXIgc2lub24gPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuICAgICAgICByZXF1aXJlKFwiLi9mYWtlX3NlcnZlclwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4vZmFrZV90aW1lcnNcIik7XG4gICAgICAgIG1ha2VBcGkoc2lub24pO1xuICAgIH1cblxuICAgIGlmIChpc0FNRCkge1xuICAgICAgICBkZWZpbmUobG9hZERlcGVuZGVuY2llcyk7XG4gICAgfSBlbHNlIGlmIChpc05vZGUpIHtcbiAgICAgICAgbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtYWtlQXBpKHNpbm9uKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH1cbn0oKSk7XG4iLCIvKipcbiAqIEZha2UgdGltZXIgQVBJXG4gKiBzZXRUaW1lb3V0XG4gKiBzZXRJbnRlcnZhbFxuICogY2xlYXJUaW1lb3V0XG4gKiBjbGVhckludGVydmFsXG4gKiB0aWNrXG4gKiByZXNldFxuICogRGF0ZVxuICpcbiAqIEluc3BpcmVkIGJ5IGpzVW5pdE1vY2tUaW1lT3V0IGZyb20gSnNVbml0XG4gKlxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIG1ha2VBcGkocywgbG9sKSB7XG4gICAgICAgIC8qZ2xvYmFsIGxvbGV4ICovXG4gICAgICAgIHZhciBsbHggPSB0eXBlb2YgbG9sZXggIT09IFwidW5kZWZpbmVkXCIgPyBsb2xleCA6IGxvbDtcblxuICAgICAgICBzLnVzZUZha2VUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbm93O1xuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZHNbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBub3cgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3cgPSBtZXRob2RzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjbG9jayA9IGxseC5pbnN0YWxsKG5vdyB8fCAwLCBtZXRob2RzKTtcbiAgICAgICAgICAgIGNsb2NrLnJlc3RvcmUgPSBjbG9jay51bmluc3RhbGw7XG4gICAgICAgICAgICByZXR1cm4gY2xvY2s7XG4gICAgICAgIH07XG5cbiAgICAgICAgcy5jbG9jayA9IHtcbiAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKG5vdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsbHguY3JlYXRlQ2xvY2sobm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzLnRpbWVycyA9IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQ6IHNldFRpbWVvdXQsXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQ6IGNsZWFyVGltZW91dCxcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZTogKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09IFwidW5kZWZpbmVkXCIgPyBzZXRJbW1lZGlhdGUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGU6ICh0eXBlb2YgY2xlYXJJbW1lZGlhdGUgIT09IFwidW5kZWZpbmVkXCIgPyBjbGVhckltbWVkaWF0ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICBzZXRJbnRlcnZhbDogc2V0SW50ZXJ2YWwsXG4gICAgICAgICAgICBjbGVhckludGVydmFsOiBjbGVhckludGVydmFsLFxuICAgICAgICAgICAgRGF0ZTogRGF0ZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIGVweG9ydHMsIG1vZHVsZSwgbG9sZXgpIHtcbiAgICAgICAgdmFyIGNvcmUgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuICAgICAgICBtYWtlQXBpKGNvcmUsIGxvbGV4KTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjb3JlO1xuICAgIH1cblxuICAgIGlmIChpc0FNRCkge1xuICAgICAgICBkZWZpbmUobG9hZERlcGVuZGVuY2llcyk7XG4gICAgfSBlbHNlIGlmIChpc05vZGUpIHtcbiAgICAgICAgbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCByZXF1aXJlKFwibG9sZXhcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1ha2VBcGkoc2lub24pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgfVxufSgpKTtcbiIsIi8qKlxuICogQGRlcGVuZCBjb3JlLmpzXG4gKiBAZGVwZW5kIC4uL2V4dGVuZC5qc1xuICogQGRlcGVuZCBldmVudC5qc1xuICogQGRlcGVuZCAuLi9sb2dfZXJyb3IuanNcbiAqL1xuLyoqXG4gKiBGYWtlIFhEb21haW5SZXF1ZXN0IG9iamVjdFxuICovXG5pZiAodHlwZW9mIHNpbm9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhpcy5zaW5vbiA9IHt9O1xufVxuXG4vLyB3cmFwcGVyIGZvciBnbG9iYWxcbihmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgeGRyID0geyBYRG9tYWluUmVxdWVzdDogZ2xvYmFsLlhEb21haW5SZXF1ZXN0IH07XG4gICAgeGRyLkdsb2JhbFhEb21haW5SZXF1ZXN0ID0gZ2xvYmFsLlhEb21haW5SZXF1ZXN0O1xuICAgIHhkci5zdXBwb3J0c1hEUiA9IHR5cGVvZiB4ZHIuR2xvYmFsWERvbWFpblJlcXVlc3QgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgeGRyLndvcmtpbmdYRFIgPSB4ZHIuc3VwcG9ydHNYRFIgPyB4ZHIuR2xvYmFsWERvbWFpblJlcXVlc3QgOiBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIG1ha2VBcGkoc2lub24pIHtcbiAgICAgICAgc2lub24ueGRyID0geGRyO1xuXG4gICAgICAgIGZ1bmN0aW9uIEZha2VYRG9tYWluUmVxdWVzdCgpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IEZha2VYRG9tYWluUmVxdWVzdC5VTlNFTlQ7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RCb2R5ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gMDtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRmFrZVhEb21haW5SZXF1ZXN0Lm9uQ3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBGYWtlWERvbWFpblJlcXVlc3Qub25DcmVhdGUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB2ZXJpZnlTdGF0ZSh4KSB7XG4gICAgICAgICAgICBpZiAoeC5yZWFkeVN0YXRlICE9PSBGYWtlWERvbWFpblJlcXVlc3QuT1BFTkVEKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9TVEFURV9FUlJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4LnNlbmRGbGFnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9TVEFURV9FUlJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB2ZXJpZnlSZXF1ZXN0U2VudCh4KSB7XG4gICAgICAgICAgICBpZiAoeC5yZWFkeVN0YXRlID09PSBGYWtlWERvbWFpblJlcXVlc3QuVU5TRU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdCBub3Qgc2VudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4LnJlYWR5U3RhdGUgPT09IEZha2VYRG9tYWluUmVxdWVzdC5ET05FKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdCBkb25lXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdmVyaWZ5UmVzcG9uc2VCb2R5VHlwZShib2R5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJvZHkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVzcG9uZCB0byBmYWtlIFhEb21haW5SZXF1ZXN0IHdpdGggXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keSArIFwiLCB3aGljaCBpcyBub3QgYSBzdHJpbmcuXCIpO1xuICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkludmFsaWRCb2R5RXhjZXB0aW9uXCI7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzaW5vbi5leHRlbmQoRmFrZVhEb21haW5SZXF1ZXN0LnByb3RvdHlwZSwgc2lub24uRXZlbnRUYXJnZXQsIHtcbiAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uIG9wZW4obWV0aG9kLCB1cmwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgICAgICAgICB0aGlzLnVybCA9IHVybDtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRGbGFnID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGVDaGFuZ2UoRmFrZVhEb21haW5SZXF1ZXN0Lk9QRU5FRCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZWFkeVN0YXRlQ2hhbmdlOiBmdW5jdGlvbiByZWFkeVN0YXRlQ2hhbmdlKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEZha2VYRG9tYWluUmVxdWVzdC5VTlNFTlQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRmFrZVhEb21haW5SZXF1ZXN0Lk9QRU5FRDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBGYWtlWERvbWFpblJlcXVlc3QuTE9BRElORzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VuZEZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmFpc2UgdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSBcIm9ucHJvZ3Jlc3NcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEZha2VYRG9tYWluUmVxdWVzdC5ET05FOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IFwib250aW1lb3V0XCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5lcnJvckZsYWcgfHwgKHRoaXMuc3RhdHVzIDwgMjAwIHx8IHRoaXMuc3RhdHVzID4gMjk5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gXCJvbmVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSBcIm9ubG9hZFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJhaXNpbmcgZXZlbnQgKGlmIGRlZmluZWQpXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbZXZlbnROYW1lXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZXZlbnROYW1lXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbm9uLmxvZ0Vycm9yKFwiRmFrZSBYSFIgXCIgKyBldmVudE5hbWUgKyBcIiBoYW5kbGVyXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24gc2VuZChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmVyaWZ5U3RhdGUodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIS9eKGdldHxoZWFkKSQvaS50ZXN0KHRoaXMubWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RCb2R5ID0gZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwidGV4dC9wbGFpbjtjaGFyc2V0PXV0Zi04XCI7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZUNoYW5nZShGYWtlWERvbWFpblJlcXVlc3QuT1BFTkVEKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vblNlbmQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2VuZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvckZsYWcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IHNpbm9uLkZha2VYRG9tYWluUmVxdWVzdC5VTlNFTlQgJiYgdGhpcy5zZW5kRmxhZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGVDaGFuZ2Uoc2lub24uRmFrZVhEb21haW5SZXF1ZXN0LkRPTkUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0UmVzcG9uc2VCb2R5OiBmdW5jdGlvbiBzZXRSZXNwb25zZUJvZHkoYm9keSkge1xuICAgICAgICAgICAgICAgIHZlcmlmeVJlcXVlc3RTZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIHZlcmlmeVJlc3BvbnNlQm9keVR5cGUoYm9keSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtTaXplID0gdGhpcy5jaHVua1NpemUgfHwgMTA7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZUNoYW5nZShGYWtlWERvbWFpblJlcXVlc3QuTE9BRElORyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ICs9IGJvZHkuc3Vic3RyaW5nKGluZGV4LCBpbmRleCArIGNodW5rU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IGNodW5rU2l6ZTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChpbmRleCA8IGJvZHkubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZUNoYW5nZShGYWtlWERvbWFpblJlcXVlc3QuRE9ORSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZXNwb25kOiBmdW5jdGlvbiByZXNwb25kKHN0YXR1cywgY29udGVudFR5cGUsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb250ZW50LXR5cGUgaWdub3JlZCwgc2luY2UgWERvbWFpblJlcXVlc3QgZG9lcyBub3QgY2FycnkgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHdlIGtlZXAgdGhlIHNhbWUgc3ludGF4IGZvciByZXNwb25kKC4uLikgYXMgZm9yIEZha2VYTUxIdHRwUmVxdWVzdCB0byBlYXNlXG4gICAgICAgICAgICAgICAgLy8gdGVzdCBpbnRlZ3JhdGlvbiBhY3Jvc3MgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHR5cGVvZiBzdGF0dXMgPT09IFwibnVtYmVyXCIgPyBzdGF0dXMgOiAyMDA7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSZXNwb25zZUJvZHkoYm9keSB8fCBcIlwiKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNpbXVsYXRldGltZW91dDogZnVuY3Rpb24gc2ltdWxhdGV0aW1lb3V0KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmlzVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gQWNjZXNzIHRvIHRoaXMgc2hvdWxkIGFjdHVhbGx5IHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlQ2hhbmdlKEZha2VYRG9tYWluUmVxdWVzdC5ET05FKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2lub24uZXh0ZW5kKEZha2VYRG9tYWluUmVxdWVzdCwge1xuICAgICAgICAgICAgVU5TRU5UOiAwLFxuICAgICAgICAgICAgT1BFTkVEOiAxLFxuICAgICAgICAgICAgTE9BRElORzogMyxcbiAgICAgICAgICAgIERPTkU6IDRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2lub24udXNlRmFrZVhEb21haW5SZXF1ZXN0ID0gZnVuY3Rpb24gdXNlRmFrZVhEb21haW5SZXF1ZXN0KCkge1xuICAgICAgICAgICAgc2lub24uRmFrZVhEb21haW5SZXF1ZXN0LnJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKGtlZXBPbkNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICh4ZHIuc3VwcG9ydHNYRFIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLlhEb21haW5SZXF1ZXN0ID0geGRyLkdsb2JhbFhEb21haW5SZXF1ZXN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzaW5vbi5GYWtlWERvbWFpblJlcXVlc3QucmVzdG9yZTtcblxuICAgICAgICAgICAgICAgIGlmIChrZWVwT25DcmVhdGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNpbm9uLkZha2VYRG9tYWluUmVxdWVzdC5vbkNyZWF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHhkci5zdXBwb3J0c1hEUikge1xuICAgICAgICAgICAgICAgIGdsb2JhbC5YRG9tYWluUmVxdWVzdCA9IHNpbm9uLkZha2VYRG9tYWluUmVxdWVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaW5vbi5GYWtlWERvbWFpblJlcXVlc3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2lub24uRmFrZVhEb21haW5SZXF1ZXN0ID0gRmFrZVhEb21haW5SZXF1ZXN0O1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICB2YXIgc2lub24gPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuICAgICAgICByZXF1aXJlKFwiLi4vZXh0ZW5kXCIpO1xuICAgICAgICByZXF1aXJlKFwiLi9ldmVudFwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4uL2xvZ19lcnJvclwiKTtcbiAgICAgICAgbWFrZUFwaShzaW5vbik7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gc2lub247XG4gICAgfVxuXG4gICAgaWYgKGlzQU1EKSB7XG4gICAgICAgIGRlZmluZShsb2FkRGVwZW5kZW5jaWVzKTtcbiAgICB9IGVsc2UgaWYgKGlzTm9kZSkge1xuICAgICAgICBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIG1vZHVsZS5leHBvcnRzLCBtb2R1bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1ha2VBcGkoc2lub24pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgfVxufSkodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHNlbGYpO1xuIiwiLyoqXG4gKiBAZGVwZW5kIGNvcmUuanNcbiAqIEBkZXBlbmQgLi4vZXh0ZW5kLmpzXG4gKiBAZGVwZW5kIGV2ZW50LmpzXG4gKiBAZGVwZW5kIC4uL2xvZ19lcnJvci5qc1xuICovXG4vKipcbiAqIEZha2UgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0XG4gKlxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuKGZ1bmN0aW9uIChzaW5vbkdsb2JhbCwgZ2xvYmFsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiBnZXRXb3JraW5nWEhSKGdsb2JhbFNjb3BlKSB7XG4gICAgICAgIHZhciBzdXBwb3J0c1hIUiA9IHR5cGVvZiBnbG9iYWxTY29wZS5YTUxIdHRwUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgaWYgKHN1cHBvcnRzWEhSKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsU2NvcGUuWE1MSHR0cFJlcXVlc3Q7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3VwcG9ydHNBY3RpdmVYID0gdHlwZW9mIGdsb2JhbFNjb3BlLkFjdGl2ZVhPYmplY3QgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICAgIGlmIChzdXBwb3J0c0FjdGl2ZVgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWxTY29wZS5BY3RpdmVYT2JqZWN0KFwiTVNYTUwyLlhNTEhUVFAuMy4wXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc3VwcG9ydHNQcm9ncmVzcyA9IHR5cGVvZiBQcm9ncmVzc0V2ZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBzdXBwb3J0c0N1c3RvbUV2ZW50ID0gdHlwZW9mIEN1c3RvbUV2ZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBzdXBwb3J0c0Zvcm1EYXRhID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBzaW5vblhociA9IHsgWE1MSHR0cFJlcXVlc3Q6IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCB9O1xuICAgIHNpbm9uWGhyLkdsb2JhbFhNTEh0dHBSZXF1ZXN0ID0gZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0O1xuICAgIHNpbm9uWGhyLkdsb2JhbEFjdGl2ZVhPYmplY3QgPSBnbG9iYWwuQWN0aXZlWE9iamVjdDtcbiAgICBzaW5vblhoci5zdXBwb3J0c0FjdGl2ZVggPSB0eXBlb2Ygc2lub25YaHIuR2xvYmFsQWN0aXZlWE9iamVjdCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICBzaW5vblhoci5zdXBwb3J0c1hIUiA9IHR5cGVvZiBzaW5vblhoci5HbG9iYWxYTUxIdHRwUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICBzaW5vblhoci53b3JraW5nWEhSID0gZ2V0V29ya2luZ1hIUihnbG9iYWwpO1xuICAgIHNpbm9uWGhyLnN1cHBvcnRzQ09SUyA9IHNpbm9uWGhyLnN1cHBvcnRzWEhSICYmIFwid2l0aENyZWRlbnRpYWxzXCIgaW4gKG5ldyBzaW5vblhoci5HbG9iYWxYTUxIdHRwUmVxdWVzdCgpKTtcblxuICAgIHZhciB1bnNhZmVIZWFkZXJzID0ge1xuICAgICAgICBcIkFjY2VwdC1DaGFyc2V0XCI6IHRydWUsXG4gICAgICAgIFwiQWNjZXB0LUVuY29kaW5nXCI6IHRydWUsXG4gICAgICAgIENvbm5lY3Rpb246IHRydWUsXG4gICAgICAgIFwiQ29udGVudC1MZW5ndGhcIjogdHJ1ZSxcbiAgICAgICAgQ29va2llOiB0cnVlLFxuICAgICAgICBDb29raWUyOiB0cnVlLFxuICAgICAgICBcIkNvbnRlbnQtVHJhbnNmZXItRW5jb2RpbmdcIjogdHJ1ZSxcbiAgICAgICAgRGF0ZTogdHJ1ZSxcbiAgICAgICAgRXhwZWN0OiB0cnVlLFxuICAgICAgICBIb3N0OiB0cnVlLFxuICAgICAgICBcIktlZXAtQWxpdmVcIjogdHJ1ZSxcbiAgICAgICAgUmVmZXJlcjogdHJ1ZSxcbiAgICAgICAgVEU6IHRydWUsXG4gICAgICAgIFRyYWlsZXI6IHRydWUsXG4gICAgICAgIFwiVHJhbnNmZXItRW5jb2RpbmdcIjogdHJ1ZSxcbiAgICAgICAgVXBncmFkZTogdHJ1ZSxcbiAgICAgICAgXCJVc2VyLUFnZW50XCI6IHRydWUsXG4gICAgICAgIFZpYTogdHJ1ZVxuICAgIH07XG5cbiAgICAvLyBBbiB1cGxvYWQgb2JqZWN0IGlzIGNyZWF0ZWQgZm9yIGVhY2hcbiAgICAvLyBGYWtlWE1MSHR0cFJlcXVlc3QgYW5kIGFsbG93cyB1cGxvYWRcbiAgICAvLyBldmVudHMgdG8gYmUgc2ltdWxhdGVkIHVzaW5nIHVwbG9hZFByb2dyZXNzXG4gICAgLy8gYW5kIHVwbG9hZEVycm9yLlxuICAgIGZ1bmN0aW9uIFVwbG9hZFByb2dyZXNzKCkge1xuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgcHJvZ3Jlc3M6IFtdLFxuICAgICAgICAgICAgbG9hZDogW10sXG4gICAgICAgICAgICBhYm9ydDogW10sXG4gICAgICAgICAgICBlcnJvcjogW11cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBVcGxvYWRQcm9ncmVzcy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnRdLnB1c2gobGlzdGVuZXIpO1xuICAgIH07XG5cbiAgICBVcGxvYWRQcm9ncmVzcy5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50XSB8fCBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVXBsb2FkUHJvZ3Jlc3MucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50LnR5cGVdIHx8IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ZW5lcjsgKGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldKSAhPSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBOb3RlIHRoYXQgZm9yIEZha2VYTUxIdHRwUmVxdWVzdCB0byB3b3JrIHByZSBFUzVcbiAgICAvLyB3ZSBsb3NlIHNvbWUgb2YgdGhlIGFsaWdubWVudCB3aXRoIHRoZSBzcGVjLlxuICAgIC8vIFRvIGVuc3VyZSBhcyBjbG9zZSBhIG1hdGNoIGFzIHBvc3NpYmxlLFxuICAgIC8vIHNldCByZXNwb25zZVR5cGUgYmVmb3JlIGNhbGxpbmcgb3Blbiwgc2VuZCBvciByZXNwb25kO1xuICAgIGZ1bmN0aW9uIEZha2VYTUxIdHRwUmVxdWVzdCgpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gRmFrZVhNTEh0dHBSZXF1ZXN0LlVOU0VOVDtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IHt9O1xuICAgICAgICB0aGlzLnJlcXVlc3RCb2R5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAwO1xuICAgICAgICB0aGlzLnN0YXR1c1RleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLnVwbG9hZCA9IG5ldyBVcGxvYWRQcm9ncmVzcygpO1xuICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IFwiXCI7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSBcIlwiO1xuICAgICAgICBpZiAoc2lub25YaHIuc3VwcG9ydHNDT1JTKSB7XG4gICAgICAgICAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhociA9IHRoaXM7XG4gICAgICAgIHZhciBldmVudHMgPSBbXCJsb2Fkc3RhcnRcIiwgXCJsb2FkXCIsIFwiYWJvcnRcIiwgXCJsb2FkZW5kXCJdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHhocltcIm9uXCIgKyBldmVudE5hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyICYmIHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGV2ZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBGYWtlWE1MSHR0cFJlcXVlc3Qub25DcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgRmFrZVhNTEh0dHBSZXF1ZXN0Lm9uQ3JlYXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmVyaWZ5U3RhdGUoeGhyKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gRmFrZVhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9TVEFURV9FUlJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeGhyLnNlbmRGbGFnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEX1NUQVRFX0VSUlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEhlYWRlcihoZWFkZXJzLCBoZWFkZXIpIHtcbiAgICAgICAgaGVhZGVyID0gaGVhZGVyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaCBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoaC50b0xvd2VyQ2FzZSgpID09PSBoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGZpbHRlcmluZyB0byBlbmFibGUgYSB3aGl0ZS1saXN0IHZlcnNpb24gb2YgU2lub24gRmFrZVhocixcbiAgICAvLyB3aGVyZSB3aGl0ZWxpc3RlZCByZXF1ZXN0cyBhcmUgcGFzc2VkIHRocm91Z2ggdG8gcmVhbCBYSFJcbiAgICBmdW5jdGlvbiBlYWNoKGNvbGxlY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb2xsZWN0aW9uLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSkge1xuICAgICAgICAgICAgY2FsbGJhY2soY29sbGVjdGlvbltpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY29sbGVjdGlvbi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGxhcmdlc3QgYXJpdHkgaW4gWEhSIGlzIDUgLSBYSFIjb3BlblxuICAgIHZhciBhcHBseSA9IGZ1bmN0aW9uIChvYmosIG1ldGhvZCwgYXJncykge1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG9ialttZXRob2RdKCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIG9ialttZXRob2RdKGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBvYmpbbWV0aG9kXShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gb2JqW21ldGhvZF0oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIG9ialttZXRob2RdKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICBjYXNlIDU6IHJldHVybiBvYmpbbWV0aG9kXShhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBGYWtlWE1MSHR0cFJlcXVlc3QuZmlsdGVycyA9IFtdO1xuICAgIEZha2VYTUxIdHRwUmVxdWVzdC5hZGRGaWx0ZXIgPSBmdW5jdGlvbiBhZGRGaWx0ZXIoZm4pIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnB1c2goZm4pO1xuICAgIH07XG4gICAgdmFyIElFNlJlID0gL01TSUUgNi87XG4gICAgRmFrZVhNTEh0dHBSZXF1ZXN0LmRlZmFrZSA9IGZ1bmN0aW9uIGRlZmFrZShmYWtlWGhyLCB4aHJBcmdzKSB7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgc2lub25YaHIud29ya2luZ1hIUigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcblxuICAgICAgICBlYWNoKFtcbiAgICAgICAgICAgIFwib3BlblwiLFxuICAgICAgICAgICAgXCJzZXRSZXF1ZXN0SGVhZGVyXCIsXG4gICAgICAgICAgICBcInNlbmRcIixcbiAgICAgICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgICAgIFwiZ2V0UmVzcG9uc2VIZWFkZXJcIixcbiAgICAgICAgICAgIFwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzXCIsXG4gICAgICAgICAgICBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICAgICAgICAgIFwib3ZlcnJpZGVNaW1lVHlwZVwiLFxuICAgICAgICAgICAgXCJyZW1vdmVFdmVudExpc3RlbmVyXCJcbiAgICAgICAgXSwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgZmFrZVhoclttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh4aHIsIG1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjb3B5QXR0cnMgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgZWFjaChhcmdzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZha2VYaHJbYXR0cl0gPSB4aHJbYXR0cl07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUlFNlJlLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiBzdGF0ZUNoYW5nZSgpIHtcbiAgICAgICAgICAgIGZha2VYaHIucmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID49IEZha2VYTUxIdHRwUmVxdWVzdC5IRUFERVJTX1JFQ0VJVkVEKSB7XG4gICAgICAgICAgICAgICAgY29weUF0dHJzKFtcInN0YXR1c1wiLCBcInN0YXR1c1RleHRcIl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID49IEZha2VYTUxIdHRwUmVxdWVzdC5MT0FESU5HKSB7XG4gICAgICAgICAgICAgICAgY29weUF0dHJzKFtcInJlc3BvbnNlVGV4dFwiLCBcInJlc3BvbnNlXCJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gRmFrZVhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgICAgICAgICBjb3B5QXR0cnMoW1wicmVzcG9uc2VYTUxcIl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZha2VYaHIub25yZWFkeXN0YXRlY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgZmFrZVhoci5vbnJlYWR5c3RhdGVjaGFuZ2UuY2FsbChmYWtlWGhyLCB7IHRhcmdldDogZmFrZVhociB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoeGhyLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGV2ZW50IGluIGZha2VYaHIuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmFrZVhoci5ldmVudExpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAvKmVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyovXG4gICAgICAgICAgICAgICAgICAgIGVhY2goZmFrZVhoci5ldmVudExpc3RlbmVyc1tldmVudF0sIGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvKmVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIiwgc3RhdGVDaGFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHN0YXRlQ2hhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGFwcGx5KHhociwgXCJvcGVuXCIsIHhockFyZ3MpO1xuICAgIH07XG4gICAgRmFrZVhNTEh0dHBSZXF1ZXN0LnVzZUZpbHRlcnMgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHZlcmlmeVJlcXVlc3RPcGVuZWQoeGhyKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gRmFrZVhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9TVEFURV9FUlIgLSBcIiArIHhoci5yZWFkeVN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZlcmlmeVJlcXVlc3RTZW50KHhocikge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IEZha2VYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGRvbmVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2ZXJpZnlIZWFkZXJzUmVjZWl2ZWQoeGhyKSB7XG4gICAgICAgIGlmICh4aHIuYXN5bmMgJiYgeGhyLnJlYWR5U3RhdGUgIT09IEZha2VYTUxIdHRwUmVxdWVzdC5IRUFERVJTX1JFQ0VJVkVEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBoZWFkZXJzIHJlY2VpdmVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmVyaWZ5UmVzcG9uc2VCb2R5VHlwZShib2R5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHJlc3BvbmQgdG8gZmFrZSBYTUxIdHRwUmVxdWVzdCB3aXRoIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgKyBcIiwgd2hpY2ggaXMgbm90IGEgc3RyaW5nLlwiKTtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkludmFsaWRCb2R5RXhjZXB0aW9uXCI7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEZha2VYTUxIdHRwUmVxdWVzdC5wYXJzZVhNTCA9IGZ1bmN0aW9uIHBhcnNlWE1MKHRleHQpIHtcbiAgICAgICAgdmFyIHhtbERvYztcblxuICAgICAgICBpZiAodHlwZW9mIERPTVBhcnNlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgICAgIHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgXCJ0ZXh0L3htbFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhtbERvYyA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG4gICAgICAgICAgICB4bWxEb2MuYXN5bmMgPSBcImZhbHNlXCI7XG4gICAgICAgICAgICB4bWxEb2MubG9hZFhNTCh0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4bWxEb2M7XG4gICAgfTtcblxuICAgIEZha2VYTUxIdHRwUmVxdWVzdC5zdGF0dXNDb2RlcyA9IHtcbiAgICAgICAgMTAwOiBcIkNvbnRpbnVlXCIsXG4gICAgICAgIDEwMTogXCJTd2l0Y2hpbmcgUHJvdG9jb2xzXCIsXG4gICAgICAgIDIwMDogXCJPS1wiLFxuICAgICAgICAyMDE6IFwiQ3JlYXRlZFwiLFxuICAgICAgICAyMDI6IFwiQWNjZXB0ZWRcIixcbiAgICAgICAgMjAzOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gICAgICAgIDIwNDogXCJObyBDb250ZW50XCIsXG4gICAgICAgIDIwNTogXCJSZXNldCBDb250ZW50XCIsXG4gICAgICAgIDIwNjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgICAgICAgMjA3OiBcIk11bHRpLVN0YXR1c1wiLFxuICAgICAgICAzMDA6IFwiTXVsdGlwbGUgQ2hvaWNlXCIsXG4gICAgICAgIDMwMTogXCJNb3ZlZCBQZXJtYW5lbnRseVwiLFxuICAgICAgICAzMDI6IFwiRm91bmRcIixcbiAgICAgICAgMzAzOiBcIlNlZSBPdGhlclwiLFxuICAgICAgICAzMDQ6IFwiTm90IE1vZGlmaWVkXCIsXG4gICAgICAgIDMwNTogXCJVc2UgUHJveHlcIixcbiAgICAgICAgMzA3OiBcIlRlbXBvcmFyeSBSZWRpcmVjdFwiLFxuICAgICAgICA0MDA6IFwiQmFkIFJlcXVlc3RcIixcbiAgICAgICAgNDAxOiBcIlVuYXV0aG9yaXplZFwiLFxuICAgICAgICA0MDI6IFwiUGF5bWVudCBSZXF1aXJlZFwiLFxuICAgICAgICA0MDM6IFwiRm9yYmlkZGVuXCIsXG4gICAgICAgIDQwNDogXCJOb3QgRm91bmRcIixcbiAgICAgICAgNDA1OiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLFxuICAgICAgICA0MDY6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgICAgICAgNDA3OiBcIlByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCIsXG4gICAgICAgIDQwODogXCJSZXF1ZXN0IFRpbWVvdXRcIixcbiAgICAgICAgNDA5OiBcIkNvbmZsaWN0XCIsXG4gICAgICAgIDQxMDogXCJHb25lXCIsXG4gICAgICAgIDQxMTogXCJMZW5ndGggUmVxdWlyZWRcIixcbiAgICAgICAgNDEyOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgICAgICAgNDEzOiBcIlJlcXVlc3QgRW50aXR5IFRvbyBMYXJnZVwiLFxuICAgICAgICA0MTQ6IFwiUmVxdWVzdC1VUkkgVG9vIExvbmdcIixcbiAgICAgICAgNDE1OiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgICAgICAgNDE2OiBcIlJlcXVlc3RlZCBSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgICAgICAgNDE3OiBcIkV4cGVjdGF0aW9uIEZhaWxlZFwiLFxuICAgICAgICA0MjI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgICAgICAgNTAwOiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiLFxuICAgICAgICA1MDE6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gICAgICAgIDUwMjogXCJCYWQgR2F0ZXdheVwiLFxuICAgICAgICA1MDM6IFwiU2VydmljZSBVbmF2YWlsYWJsZVwiLFxuICAgICAgICA1MDQ6IFwiR2F0ZXdheSBUaW1lb3V0XCIsXG4gICAgICAgIDUwNTogXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VBcGkoc2lub24pIHtcbiAgICAgICAgc2lub24ueGhyID0gc2lub25YaHI7XG5cbiAgICAgICAgc2lub24uZXh0ZW5kKEZha2VYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUsIHNpbm9uLkV2ZW50VGFyZ2V0LCB7XG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcblxuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gb3BlbihtZXRob2QsIHVybCwgYXN5bmMsIHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICAgICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICAgICAgICAgIHRoaXMuYXN5bmMgPSB0eXBlb2YgYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXN5bmMgOiB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VybmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gXCJqc29uXCIgPyBudWxsIDogXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlWE1MID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RIZWFkZXJzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kRmxhZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKEZha2VYTUxIdHRwUmVxdWVzdC51c2VGaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4aHJBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYWtlID0gc29tZShGYWtlWE1MSHR0cFJlcXVlc3QuZmlsdGVycywgZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlci5hcHBseSh0aGlzLCB4aHJBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZha2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWtlWE1MSHR0cFJlcXVlc3QuZGVmYWtlKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlQ2hhbmdlKEZha2VYTUxIdHRwUmVxdWVzdC5PUEVORUQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVhZHlTdGF0ZUNoYW5nZTogZnVuY3Rpb24gcmVhZHlTdGF0ZUNoYW5nZShzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IHN0YXRlO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlYWR5U3RhdGVDaGFuZ2VFdmVudCA9IG5ldyBzaW5vbi5FdmVudChcInJlYWR5c3RhdGVjaGFuZ2VcIiwgZmFsc2UsIGZhbHNlLCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UocmVhZHlTdGF0ZUNoYW5nZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lub24ubG9nRXJyb3IoXCJGYWtlIFhIUiBvbnJlYWR5c3RhdGVjaGFuZ2UgaGFuZGxlclwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRmFrZVhNTEh0dHBSZXF1ZXN0LkRPTkU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBsb2FkLmRpc3BhdGNoRXZlbnQobmV3IHNpbm9uLlByb2dyZXNzRXZlbnQoXCJwcm9ncmVzc1wiLCB7bG9hZGVkOiAxMDAsIHRvdGFsOiAxMDB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBzaW5vbi5Qcm9ncmVzc0V2ZW50KFwicHJvZ3Jlc3NcIiwge2xvYWRlZDogMTAwLCB0b3RhbDogMTAwfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGxvYWQuZGlzcGF0Y2hFdmVudChuZXcgc2lub24uRXZlbnQoXCJsb2FkXCIsIGZhbHNlLCBmYWxzZSwgdGhpcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBzaW5vbi5FdmVudChcImxvYWRcIiwgZmFsc2UsIGZhbHNlLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IHNpbm9uLkV2ZW50KFwibG9hZGVuZFwiLCBmYWxzZSwgZmFsc2UsIHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChyZWFkeVN0YXRlQ2hhbmdlRXZlbnQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmVyaWZ5U3RhdGUodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodW5zYWZlSGVhZGVyc1toZWFkZXJdIHx8IC9eKFNlYy18UHJveHktKS8udGVzdChoZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZnVzZWQgdG8gc2V0IHVuc2FmZSBoZWFkZXIgXFxcIlwiICsgaGVhZGVyICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcXVlc3RIZWFkZXJzW2hlYWRlcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVyc1toZWFkZXJdICs9IFwiLFwiICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gSGVscHMgdGVzdGluZ1xuICAgICAgICAgICAgc2V0UmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbiBzZXRSZXNwb25zZUhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICAgICAgICAgIHZlcmlmeVJlcXVlc3RPcGVuZWQodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSB7fTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzW2hlYWRlcl0gPSBoZWFkZXJzW2hlYWRlcl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGVDaGFuZ2UoRmFrZVhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IEZha2VYTUxIdHRwUmVxdWVzdC5IRUFERVJTX1JFQ0VJVkVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEN1cnJlbnRseSB0cmVhdHMgQUxMIGRhdGEgYXMgYSBET01TdHJpbmcgKGkuZS4gbm8gRG9jdW1lbnQpXG4gICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiBzZW5kKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2ZXJpZnlTdGF0ZSh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGlmICghL14oZ2V0fGhlYWQpJC9pLnRlc3QodGhpcy5tZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IGdldEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVxdWVzdEhlYWRlcnNbY29udGVudFR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnJlcXVlc3RIZWFkZXJzW2NvbnRlbnRUeXBlXS5zcGxpdChcIjtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RIZWFkZXJzW2NvbnRlbnRUeXBlXSA9IHZhbHVlWzBdICsgXCI7Y2hhcnNldD11dGYtOFwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnRzRm9ybURhdGEgJiYgIShkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9dXRmLThcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEJvZHkgPSBkYXRhO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kRmxhZyA9IHRoaXMuYXN5bmM7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHRoaXMucmVzcG9uc2VUeXBlID09PSBcImpzb25cIiA/IG51bGwgOiBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZUNoYW5nZShGYWtlWE1MSHR0cFJlcXVlc3QuT1BFTkVEKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vblNlbmQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2VuZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IHNpbm9uLkV2ZW50KFwibG9hZHN0YXJ0XCIsIGZhbHNlLCBmYWxzZSwgdGhpcykpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gXCJqc29uXCIgPyBudWxsIDogXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gRmFrZVhNTEh0dHBSZXF1ZXN0LlVOU0VOVCAmJiB0aGlzLnNlbmRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZUNoYW5nZShGYWtlWE1MSHR0cFJlcXVlc3QuRE9ORSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZEZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBGYWtlWE1MSHR0cFJlcXVlc3QuVU5TRU5UO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBzaW5vbi5FdmVudChcImFib3J0XCIsIGZhbHNlLCBmYWxzZSwgdGhpcykpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy51cGxvYWQuZGlzcGF0Y2hFdmVudChuZXcgc2lub24uRXZlbnQoXCJhYm9ydFwiLCBmYWxzZSwgZmFsc2UsIHRoaXMpKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbmVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uIGdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPCBGYWtlWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoL15TZXQtQ29va2llMj8kL2kudGVzdChoZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGhlYWRlciA9IGdldEhlYWRlcih0aGlzLnJlc3BvbnNlSGVhZGVycywgaGVhZGVyKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlSGVhZGVyc1toZWFkZXJdIHx8IG51bGw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uIGdldEFsbFJlc3BvbnNlSGVhZGVycygpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlIDwgRmFrZVhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaGVhZGVyIGluIHRoaXMucmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3BvbnNlSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoZWFkZXIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhL15TZXQtQ29va2llMj8kL2kudGVzdChoZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzICs9IGhlYWRlciArIFwiOiBcIiArIHRoaXMucmVzcG9uc2VIZWFkZXJzW2hlYWRlcl0gKyBcIlxcclxcblwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRSZXNwb25zZUJvZHk6IGZ1bmN0aW9uIHNldFJlc3BvbnNlQm9keShib2R5KSB7XG4gICAgICAgICAgICAgICAgdmVyaWZ5UmVxdWVzdFNlbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgdmVyaWZ5SGVhZGVyc1JlY2VpdmVkKHRoaXMpO1xuICAgICAgICAgICAgICAgIHZlcmlmeVJlc3BvbnNlQm9keVR5cGUoYm9keSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtTaXplID0gdGhpcy5jaHVua1NpemUgfHwgMTA7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGVDaGFuZ2UoRmFrZVhNTEh0dHBSZXF1ZXN0LkxPQURJTkcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgKz0gYm9keS5zdWJzdHJpbmcoaW5kZXgsIGluZGV4ICsgY2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gY2h1bmtTaXplO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGluZGV4IDwgYm9keS5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzcG9uc2VUZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgICghdHlwZSB8fCAvKHRleHRcXC94bWwpfChhcHBsaWNhdGlvblxcL3htbCl8KFxcK3htbCkvLnRlc3QodHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlWE1MID0gRmFrZVhNTEh0dHBSZXF1ZXN0LnBhcnNlWE1MKHRoaXMucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5hYmxlIHRvIHBhcnNlIFhNTCAtIG5vIGJpZ2dpZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHRoaXMucmVzcG9uc2VUeXBlID09PSBcImpzb25cIiA/IEpTT04ucGFyc2UodGhpcy5yZXNwb25zZVRleHQpIDogdGhpcy5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlQ2hhbmdlKEZha2VYTUxIdHRwUmVxdWVzdC5ET05FKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlc3BvbmQ6IGZ1bmN0aW9uIHJlc3BvbmQoc3RhdHVzLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSB0eXBlb2Ygc3RhdHVzID09PSBcIm51bWJlclwiID8gc3RhdHVzIDogMjAwO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9IEZha2VYTUxIdHRwUmVxdWVzdC5zdGF0dXNDb2Rlc1t0aGlzLnN0YXR1c107XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSZXNwb25zZUhlYWRlcnMoaGVhZGVycyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSZXNwb25zZUJvZHkoYm9keSB8fCBcIlwiKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHVwbG9hZFByb2dyZXNzOiBmdW5jdGlvbiB1cGxvYWRQcm9ncmVzcyhwcm9ncmVzc0V2ZW50UmF3KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGxvYWQuZGlzcGF0Y2hFdmVudChuZXcgc2lub24uUHJvZ3Jlc3NFdmVudChcInByb2dyZXNzXCIsIHByb2dyZXNzRXZlbnRSYXcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkb3dubG9hZFByb2dyZXNzOiBmdW5jdGlvbiBkb3dubG9hZFByb2dyZXNzKHByb2dyZXNzRXZlbnRSYXcpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IHNpbm9uLlByb2dyZXNzRXZlbnQoXCJwcm9ncmVzc1wiLCBwcm9ncmVzc0V2ZW50UmF3KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdXBsb2FkRXJyb3I6IGZ1bmN0aW9uIHVwbG9hZEVycm9yKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGxvYWQuZGlzcGF0Y2hFdmVudChuZXcgc2lub24uQ3VzdG9tRXZlbnQoXCJlcnJvclwiLCB7ZGV0YWlsOiBlcnJvcn0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNpbm9uLmV4dGVuZChGYWtlWE1MSHR0cFJlcXVlc3QsIHtcbiAgICAgICAgICAgIFVOU0VOVDogMCxcbiAgICAgICAgICAgIE9QRU5FRDogMSxcbiAgICAgICAgICAgIEhFQURFUlNfUkVDRUlWRUQ6IDIsXG4gICAgICAgICAgICBMT0FESU5HOiAzLFxuICAgICAgICAgICAgRE9ORTogNFxuICAgICAgICB9KTtcblxuICAgICAgICBzaW5vbi51c2VGYWtlWE1MSHR0cFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBGYWtlWE1MSHR0cFJlcXVlc3QucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoa2VlcE9uQ3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpbm9uWGhyLnN1cHBvcnRzWEhSKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbC5YTUxIdHRwUmVxdWVzdCA9IHNpbm9uWGhyLkdsb2JhbFhNTEh0dHBSZXF1ZXN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzaW5vblhoci5zdXBwb3J0c0FjdGl2ZVgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLkFjdGl2ZVhPYmplY3QgPSBzaW5vblhoci5HbG9iYWxBY3RpdmVYT2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBGYWtlWE1MSHR0cFJlcXVlc3QucmVzdG9yZTtcblxuICAgICAgICAgICAgICAgIGlmIChrZWVwT25DcmVhdGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIEZha2VYTUxIdHRwUmVxdWVzdC5vbkNyZWF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHNpbm9uWGhyLnN1cHBvcnRzWEhSKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0ID0gRmFrZVhNTEh0dHBSZXF1ZXN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2lub25YaHIuc3VwcG9ydHNBY3RpdmVYKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsLkFjdGl2ZVhPYmplY3QgPSBmdW5jdGlvbiBBY3RpdmVYT2JqZWN0KG9iaklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpJZCA9PT0gXCJNaWNyb3NvZnQuWE1MSFRUUFwiIHx8IC9eTXN4bWwyXFwuWE1MSFRUUC9pLnRlc3Qob2JqSWQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFrZVhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHNpbm9uWGhyLkdsb2JhbEFjdGl2ZVhPYmplY3Qob2JqSWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBGYWtlWE1MSHR0cFJlcXVlc3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2lub24uRmFrZVhNTEh0dHBSZXF1ZXN0ID0gRmFrZVhNTEh0dHBSZXF1ZXN0O1xuICAgIH1cblxuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgdmFyIGlzQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQ7XG5cbiAgICBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICB2YXIgc2lub24gPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuICAgICAgICByZXF1aXJlKFwiLi4vZXh0ZW5kXCIpO1xuICAgICAgICByZXF1aXJlKFwiLi9ldmVudFwiKTtcbiAgICAgICAgcmVxdWlyZShcIi4uL2xvZ19lcnJvclwiKTtcbiAgICAgICAgbWFrZUFwaShzaW5vbik7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gc2lub247XG4gICAgfVxuXG4gICAgaWYgKGlzQU1EKSB7XG4gICAgICAgIGRlZmluZShsb2FkRGVwZW5kZW5jaWVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgbG9hZERlcGVuZGVuY2llcyhyZXF1aXJlLCBtb2R1bGUuZXhwb3J0cywgbW9kdWxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzaW5vbkdsb2JhbCkge1xuICAgICAgICBtYWtlQXBpKHNpbm9uR2xvYmFsKTtcbiAgICB9XG59KFxuICAgIHR5cGVvZiBzaW5vbiA9PT0gXCJvYmplY3RcIiAmJiBzaW5vbiwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiBzZWxmXG4pKTtcbiIsIigodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgJiYgZnVuY3Rpb24gKG0pIHtcbiAgICBkZWZpbmUoXCJmb3JtYXRpb1wiLCBbXCJzYW1zYW1cIl0sIG0pO1xufSkgfHwgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgZnVuY3Rpb24gKG0pIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG0ocmVxdWlyZShcInNhbXNhbVwiKSk7XG59KSB8fCBmdW5jdGlvbiAobSkgeyB0aGlzLmZvcm1hdGlvID0gbSh0aGlzLnNhbXNhbSk7IH1cbikoZnVuY3Rpb24gKHNhbXNhbSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZvcm1hdGlvID0ge1xuICAgICAgICBleGNsdWRlQ29uc3RydWN0b3JzOiBbXCJPYmplY3RcIiwgL14uJC9dLFxuICAgICAgICBxdW90ZVN0cmluZ3M6IHRydWUsXG4gICAgICAgIGxpbWl0Q2hpbGRyZW5Db3VudDogMFxuICAgIH07XG5cbiAgICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIHZhciBzcGVjaWFsT2JqZWN0cyA9IFtdO1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNwZWNpYWxPYmplY3RzLnB1c2goeyBvYmplY3Q6IGdsb2JhbCwgdmFsdWU6IFwiW29iamVjdCBnbG9iYWxdXCIgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc3BlY2lhbE9iamVjdHMucHVzaCh7XG4gICAgICAgICAgICBvYmplY3Q6IGRvY3VtZW50LFxuICAgICAgICAgICAgdmFsdWU6IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNwZWNpYWxPYmplY3RzLnB1c2goeyBvYmplY3Q6IHdpbmRvdywgdmFsdWU6IFwiW29iamVjdCBXaW5kb3ddXCIgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGZ1bmMpIHtcbiAgICAgICAgaWYgKCFmdW5jKSB7IHJldHVybiBcIlwiOyB9XG4gICAgICAgIGlmIChmdW5jLmRpc3BsYXlOYW1lKSB7IHJldHVybiBmdW5jLmRpc3BsYXlOYW1lOyB9XG4gICAgICAgIGlmIChmdW5jLm5hbWUpIHsgcmV0dXJuIGZ1bmMubmFtZTsgfVxuICAgICAgICB2YXIgbWF0Y2hlcyA9IGZ1bmMudG9TdHJpbmcoKS5tYXRjaCgvZnVuY3Rpb25cXHMrKFteXFwoXSspL20pO1xuICAgICAgICByZXR1cm4gKG1hdGNoZXMgJiYgbWF0Y2hlc1sxXSkgfHwgXCJcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3Rvck5hbWUoZiwgb2JqZWN0KSB7XG4gICAgICAgIHZhciBuYW1lID0gZnVuY3Rpb25OYW1lKG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IpO1xuICAgICAgICB2YXIgZXhjbHVkZXMgPSBmLmV4Y2x1ZGVDb25zdHJ1Y3RvcnMgfHxcbiAgICAgICAgICAgICAgICBmb3JtYXRpby5leGNsdWRlQ29uc3RydWN0b3JzIHx8IFtdO1xuXG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXhjbHVkZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4Y2x1ZGVzW2ldID09PSBcInN0cmluZ1wiICYmIGV4Y2x1ZGVzW2ldID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4Y2x1ZGVzW2ldLnRlc3QgJiYgZXhjbHVkZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDaXJjdWxhcihvYmplY3QsIG9iamVjdHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3RzW2ldID09PSBvYmplY3QpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNjaWkoZiwgb2JqZWN0LCBwcm9jZXNzZWQsIGluZGVudCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIHFzID0gZi5xdW90ZVN0cmluZ3M7XG4gICAgICAgICAgICB2YXIgcXVvdGUgPSB0eXBlb2YgcXMgIT09IFwiYm9vbGVhblwiIHx8IHFzO1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NlZCB8fCBxdW90ZSA/ICdcIicgKyBvYmplY3QgKyAnXCInIDogb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwiZnVuY3Rpb25cIiAmJiAhKG9iamVjdCBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhc2NpaS5mdW5jKG9iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzZWQgPSBwcm9jZXNzZWQgfHwgW107XG5cbiAgICAgICAgaWYgKGlzQ2lyY3VsYXIob2JqZWN0LCBwcm9jZXNzZWQpKSB7IHJldHVybiBcIltDaXJjdWxhcl1cIjsgfVxuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYXNjaWkuYXJyYXkuY2FsbChmLCBvYmplY3QsIHByb2Nlc3NlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9iamVjdCkgeyByZXR1cm4gU3RyaW5nKCgxL29iamVjdCkgPT09IC1JbmZpbml0eSA/IFwiLTBcIiA6IG9iamVjdCk7IH1cbiAgICAgICAgaWYgKHNhbXNhbS5pc0VsZW1lbnQob2JqZWN0KSkgeyByZXR1cm4gYXNjaWkuZWxlbWVudChvYmplY3QpOyB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudG9TdHJpbmcgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIG9iamVjdC50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBzcGVjaWFsT2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgPT09IHNwZWNpYWxPYmplY3RzW2ldLm9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjaWFsT2JqZWN0c1tpXS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhc2NpaS5vYmplY3QuY2FsbChmLCBvYmplY3QsIHByb2Nlc3NlZCwgaW5kZW50KTtcbiAgICB9XG5cbiAgICBhc2NpaS5mdW5jID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb24gXCIgKyBmdW5jdGlvbk5hbWUoZnVuYykgKyBcIigpIHt9XCI7XG4gICAgfTtcblxuICAgIGFzY2lpLmFycmF5ID0gZnVuY3Rpb24gKGFycmF5LCBwcm9jZXNzZWQpIHtcbiAgICAgICAgcHJvY2Vzc2VkID0gcHJvY2Vzc2VkIHx8IFtdO1xuICAgICAgICBwcm9jZXNzZWQucHVzaChhcnJheSk7XG4gICAgICAgIHZhciBwaWVjZXMgPSBbXTtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGwgPSAodGhpcy5saW1pdENoaWxkcmVuQ291bnQgPiAwKSA/IFxuICAgICAgICAgICAgTWF0aC5taW4odGhpcy5saW1pdENoaWxkcmVuQ291bnQsIGFycmF5Lmxlbmd0aCkgOiBhcnJheS5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgcGllY2VzLnB1c2goYXNjaWkodGhpcywgYXJyYXlbaV0sIHByb2Nlc3NlZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobCA8IGFycmF5Lmxlbmd0aClcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKFwiWy4uLiBcIiArIChhcnJheS5sZW5ndGggLSBsKSArIFwiIG1vcmUgZWxlbWVudHNdXCIpO1xuXG4gICAgICAgIHJldHVybiBcIltcIiArIHBpZWNlcy5qb2luKFwiLCBcIikgKyBcIl1cIjtcbiAgICB9O1xuXG4gICAgYXNjaWkub2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvY2Vzc2VkLCBpbmRlbnQpIHtcbiAgICAgICAgcHJvY2Vzc2VkID0gcHJvY2Vzc2VkIHx8IFtdO1xuICAgICAgICBwcm9jZXNzZWQucHVzaChvYmplY3QpO1xuICAgICAgICBpbmRlbnQgPSBpbmRlbnQgfHwgMDtcbiAgICAgICAgdmFyIHBpZWNlcyA9IFtdLCBwcm9wZXJ0aWVzID0gc2Ftc2FtLmtleXMob2JqZWN0KS5zb3J0KCk7XG4gICAgICAgIHZhciBsZW5ndGggPSAzO1xuICAgICAgICB2YXIgcHJvcCwgc3RyLCBvYmosIGksIGssIGw7XG4gICAgICAgIGwgPSAodGhpcy5saW1pdENoaWxkcmVuQ291bnQgPiAwKSA/IFxuICAgICAgICAgICAgTWF0aC5taW4odGhpcy5saW1pdENoaWxkcmVuQ291bnQsIHByb3BlcnRpZXMubGVuZ3RoKSA6IHByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHByb3AgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgb2JqID0gb2JqZWN0W3Byb3BdO1xuXG4gICAgICAgICAgICBpZiAoaXNDaXJjdWxhcihvYmosIHByb2Nlc3NlZCkpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBcIltDaXJjdWxhcl1cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyID0gYXNjaWkodGhpcywgb2JqLCBwcm9jZXNzZWQsIGluZGVudCArIDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHIgPSAoL1xccy8udGVzdChwcm9wKSA/ICdcIicgKyBwcm9wICsgJ1wiJyA6IHByb3ApICsgXCI6IFwiICsgc3RyO1xuICAgICAgICAgICAgbGVuZ3RoICs9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgICBwaWVjZXMucHVzaChzdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnMgPSBjb25zdHJ1Y3Rvck5hbWUodGhpcywgb2JqZWN0KTtcbiAgICAgICAgdmFyIHByZWZpeCA9IGNvbnMgPyBcIltcIiArIGNvbnMgKyBcIl0gXCIgOiBcIlwiO1xuICAgICAgICB2YXIgaXMgPSBcIlwiO1xuICAgICAgICBmb3IgKGkgPSAwLCBrID0gaW5kZW50OyBpIDwgazsgKytpKSB7IGlzICs9IFwiIFwiOyB9XG5cbiAgICAgICAgaWYobCA8IHByb3BlcnRpZXMubGVuZ3RoKVxuICAgICAgICAgICAgcGllY2VzLnB1c2goXCJbLi4uIFwiICsgKHByb3BlcnRpZXMubGVuZ3RoIC0gbCkgKyBcIiBtb3JlIGVsZW1lbnRzXVwiKTtcblxuICAgICAgICBpZiAobGVuZ3RoICsgaW5kZW50ID4gODApIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBcIntcXG4gIFwiICsgaXMgKyBwaWVjZXMuam9pbihcIixcXG4gIFwiICsgaXMpICsgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgaXMgKyBcIn1cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlZml4ICsgXCJ7IFwiICsgcGllY2VzLmpvaW4oXCIsIFwiKSArIFwiIH1cIjtcbiAgICB9O1xuXG4gICAgYXNjaWkuZWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBhdHRycyA9IGVsZW1lbnQuYXR0cmlidXRlcywgYXR0ciwgcGFpcnMgPSBbXSwgYXR0ck5hbWUsIGksIGwsIHZhbDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBhdHRyID0gYXR0cnMuaXRlbShpKTtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoXCJodG1sOlwiLCBcIlwiKTtcbiAgICAgICAgICAgIHZhbCA9IGF0dHIubm9kZVZhbHVlO1xuICAgICAgICAgICAgaWYgKGF0dHJOYW1lICE9PSBcImNvbnRlbnRlZGl0YWJsZVwiIHx8IHZhbCAhPT0gXCJpbmhlcml0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoISF2YWwpIHsgcGFpcnMucHVzaChhdHRyTmFtZSArIFwiPVxcXCJcIiArIHZhbCArIFwiXFxcIlwiKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZvcm1hdHRlZCA9IFwiPFwiICsgdGFnTmFtZSArIChwYWlycy5sZW5ndGggPiAwID8gXCIgXCIgOiBcIlwiKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBlbGVtZW50LmlubmVySFRNTDtcblxuICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc3Vic3RyKDAsIDIwKSArIFwiWy4uLl1cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXMgPSBmb3JtYXR0ZWQgKyBwYWlycy5qb2luKFwiIFwiKSArIFwiPlwiICsgY29udGVudCArXG4gICAgICAgICAgICAgICAgXCI8L1wiICsgdGFnTmFtZSArIFwiPlwiO1xuXG4gICAgICAgIHJldHVybiByZXMucmVwbGFjZSgvIGNvbnRlbnRFZGl0YWJsZT1cImluaGVyaXRcIi8sIFwiXCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBGb3JtYXRpbyhvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzW29wdF0gPSBvcHRpb25zW29wdF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBGb3JtYXRpby5wcm90b3R5cGUgPSB7XG4gICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuXG4gICAgICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0aW8ob3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29uc3RydWN0b3JOYW1lOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc3RydWN0b3JOYW1lKHRoaXMsIG9iamVjdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXNjaWk6IGZ1bmN0aW9uIChvYmplY3QsIHByb2Nlc3NlZCwgaW5kZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYXNjaWkodGhpcywgb2JqZWN0LCBwcm9jZXNzZWQsIGluZGVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEZvcm1hdGlvLnByb3RvdHlwZTtcbn0pO1xuIiwiLypnbG9iYWwgZ2xvYmFsLCB3aW5kb3cqL1xuLyoqXG4gKiBAYXV0aG9yIENocmlzdGlhbiBKb2hhbnNlbiAoY2hyaXN0aWFuQGNqb2hhbnNlbi5ubykgYW5kIGNvbnRyaWJ1dG9yc1xuICogQGxpY2Vuc2UgQlNEXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgQ2hyaXN0aWFuIEpvaGFuc2VuXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIE1ha2UgcHJvcGVydGllcyB3cml0YWJsZSBpbiBJRSwgYXMgcGVyXG4gICAgLy8gaHR0cDovL3d3dy5hZGVxdWF0ZWx5Z29vZC5jb20vUmVwbGFjaW5nLXNldFRpbWVvdXQtR2xvYmFsbHkuaHRtbFxuICAgIC8vIEpTTGludCBiZWluZyBhbmFsXG4gICAgdmFyIGdsYmwgPSBnbG9iYWw7XG5cbiAgICBnbG9iYWwuc2V0VGltZW91dCA9IGdsYmwuc2V0VGltZW91dDtcbiAgICBnbG9iYWwuY2xlYXJUaW1lb3V0ID0gZ2xibC5jbGVhclRpbWVvdXQ7XG4gICAgZ2xvYmFsLnNldEltbWVkaWF0ZSA9IGdsYmwuc2V0SW1tZWRpYXRlO1xuICAgIGdsb2JhbC5jbGVhckltbWVkaWF0ZSA9IGdsYmwuY2xlYXJJbW1lZGlhdGU7XG4gICAgZ2xvYmFsLnNldEludGVydmFsID0gZ2xibC5zZXRJbnRlcnZhbDtcbiAgICBnbG9iYWwuY2xlYXJJbnRlcnZhbCA9IGdsYmwuY2xlYXJJbnRlcnZhbDtcbiAgICBnbG9iYWwuRGF0ZSA9IGdsYmwuRGF0ZTtcblxuICAgIC8vIG5vZGUgZXhwZWN0cyBzZXRUaW1lb3V0L3NldEludGVydmFsIHRvIHJldHVybiBhIGZuIG9iamVjdCB3LyAucmVmKCkvLnVucmVmKClcbiAgICAvLyBicm93c2VycywgYSBudW1iZXIuXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jam9oYW5zZW4vU2lub24uSlMvcHVsbC80MzZcblxuICAgIHZhciBOT09QID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9O1xuICAgIHZhciB0aW1lb3V0UmVzdWx0ID0gc2V0VGltZW91dChOT09QLCAwKTtcbiAgICB2YXIgYWRkVGltZXJSZXR1cm5zT2JqZWN0ID0gdHlwZW9mIHRpbWVvdXRSZXN1bHQgPT09IFwib2JqZWN0XCI7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZXN1bHQpO1xuXG4gICAgdmFyIE5hdGl2ZURhdGUgPSBEYXRlO1xuICAgIHZhciB1bmlxdWVUaW1lcklkID0gMTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHN0cmluZ3MgbGlrZSBcIjAxOjEwOjAwXCIgKG1lYW5pbmcgMSBob3VyLCAxMCBtaW51dGVzLCAwIHNlY29uZHMpIGludG9cbiAgICAgKiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLiBUaGlzIGlzIHVzZWQgdG8gc3VwcG9ydCBodW1hbi1yZWFkYWJsZSBzdHJpbmdzIHBhc3NlZFxuICAgICAqIHRvIGNsb2NrLnRpY2soKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlVGltZShzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cmluZ3MgPSBzdHIuc3BsaXQoXCI6XCIpO1xuICAgICAgICB2YXIgbCA9IHN0cmluZ3MubGVuZ3RoLCBpID0gbDtcbiAgICAgICAgdmFyIG1zID0gMCwgcGFyc2VkO1xuXG4gICAgICAgIGlmIChsID4gMyB8fCAhL14oXFxkXFxkOil7MCwyfVxcZFxcZD8kLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRpY2sgb25seSB1bmRlcnN0YW5kcyBudW1iZXJzIGFuZCAnaDptOnMnXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nc1tpXSwgMTApO1xuXG4gICAgICAgICAgICBpZiAocGFyc2VkID49IDYwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0aW1lIFwiICsgc3RyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXMgKz0gcGFyc2VkICogTWF0aC5wb3coNjAsIChsIC0gaSAtIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtcyAqIDEwMDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBncm9rIHRoZSBgbm93YCBwYXJhbWV0ZXIgdG8gY3JlYXRlQ2xvY2suXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RXBvY2goZXBvY2gpIHtcbiAgICAgICAgaWYgKCFlcG9jaCkgeyByZXR1cm4gMDsgfVxuICAgICAgICBpZiAodHlwZW9mIGVwb2NoLmdldFRpbWUgPT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4gZXBvY2guZ2V0VGltZSgpOyB9XG4gICAgICAgIGlmICh0eXBlb2YgZXBvY2ggPT09IFwibnVtYmVyXCIpIHsgcmV0dXJuIGVwb2NoOyB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJub3cgc2hvdWxkIGJlIG1pbGxpc2Vjb25kcyBzaW5jZSBVTklYIGVwb2NoXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluUmFuZ2UoZnJvbSwgdG8sIHRpbWVyKSB7XG4gICAgICAgIHJldHVybiB0aW1lciAmJiB0aW1lci5jYWxsQXQgPj0gZnJvbSAmJiB0aW1lci5jYWxsQXQgPD0gdG87XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWlycm9yRGF0ZVByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc3BlY2lhbCBub3cgaW1wbGVtZW50YXRpb25cbiAgICAgICAgaWYgKHNvdXJjZS5ub3cpIHtcbiAgICAgICAgICAgIHRhcmdldC5ub3cgPSBmdW5jdGlvbiBub3coKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5jbG9jay5ub3c7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldC5ub3c7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc3BlY2lhbCB0b1NvdXJjZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpZiAoc291cmNlLnRvU291cmNlKSB7XG4gICAgICAgICAgICB0YXJnZXQudG9Tb3VyY2UgPSBmdW5jdGlvbiB0b1NvdXJjZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLnRvU291cmNlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldC50b1NvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBzcGVjaWFsIHRvU3RyaW5nIGltcGxlbWVudGF0aW9uXG4gICAgICAgIHRhcmdldC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS50b1N0cmluZygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRhcmdldC5wcm90b3R5cGUgPSBzb3VyY2UucHJvdG90eXBlO1xuICAgICAgICB0YXJnZXQucGFyc2UgPSBzb3VyY2UucGFyc2U7XG4gICAgICAgIHRhcmdldC5VVEMgPSBzb3VyY2UuVVRDO1xuICAgICAgICB0YXJnZXQucHJvdG90eXBlLnRvVVRDU3RyaW5nID0gc291cmNlLnByb3RvdHlwZS50b1VUQ1N0cmluZztcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENsb2NrRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1zKSB7XG4gICAgICAgICAgICAvLyBEZWZlbnNpdmUgYW5kIHZlcmJvc2UgdG8gYXZvaWQgcG90ZW50aWFsIGhhcm0gaW4gcGFzc2luZ1xuICAgICAgICAgICAgLy8gZXhwbGljaXQgdW5kZWZpbmVkIHdoZW4gdXNlciBkb2VzIG5vdCBwYXNzIGFyZ3VtZW50XG4gICAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZURhdGUoQ2xvY2tEYXRlLmNsb2NrLm5vdyk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVEYXRlKHllYXIpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlRGF0ZSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVEYXRlKHllYXIsIG1vbnRoLCBkYXRlKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZURhdGUoeWVhciwgbW9udGgsIGRhdGUsIGhvdXIpO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSwgaG91ciwgbWludXRlKTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZURhdGUoeWVhciwgbW9udGgsIGRhdGUsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVEYXRlKHllYXIsIG1vbnRoLCBkYXRlLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1pcnJvckRhdGVQcm9wZXJ0aWVzKENsb2NrRGF0ZSwgTmF0aXZlRGF0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZXIoY2xvY2ssIHRpbWVyKSB7XG4gICAgICAgIGlmICh0aW1lci5mdW5jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIG11c3QgYmUgcHJvdmlkZWQgdG8gdGltZXIgY2FsbHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNsb2NrLnRpbWVycykge1xuICAgICAgICAgICAgY2xvY2sudGltZXJzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lci5pZCA9IHVuaXF1ZVRpbWVySWQrKztcbiAgICAgICAgdGltZXIuY3JlYXRlZEF0ID0gY2xvY2subm93O1xuICAgICAgICB0aW1lci5jYWxsQXQgPSBjbG9jay5ub3cgKyAodGltZXIuZGVsYXkgfHwgKGNsb2NrLmR1cmluZ1RpY2sgPyAxIDogMCkpO1xuXG4gICAgICAgIGNsb2NrLnRpbWVyc1t0aW1lci5pZF0gPSB0aW1lcjtcblxuICAgICAgICBpZiAoYWRkVGltZXJSZXR1cm5zT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiB0aW1lci5pZCxcbiAgICAgICAgICAgICAgICByZWY6IE5PT1AsXG4gICAgICAgICAgICAgICAgdW5yZWY6IE5PT1BcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGltZXIuaWQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb21wYXJlVGltZXJzKGEsIGIpIHtcbiAgICAgICAgLy8gU29ydCBmaXJzdCBieSBhYnNvbHV0ZSB0aW1pbmdcbiAgICAgICAgaWYgKGEuY2FsbEF0IDwgYi5jYWxsQXQpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5jYWxsQXQgPiBiLmNhbGxBdCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb3J0IG5leHQgYnkgaW1tZWRpYXRlLCBpbW1lZGlhdGUgdGltZXJzIHRha2UgcHJlY2VkZW5jZVxuICAgICAgICBpZiAoYS5pbW1lZGlhdGUgJiYgIWIuaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhLmltbWVkaWF0ZSAmJiBiLmltbWVkaWF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb3J0IG5leHQgYnkgY3JlYXRpb24gdGltZSwgZWFybGllci1jcmVhdGVkIHRpbWVycyB0YWtlIHByZWNlZGVuY2VcbiAgICAgICAgaWYgKGEuY3JlYXRlZEF0IDwgYi5jcmVhdGVkQXQpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5jcmVhdGVkQXQgPiBiLmNyZWF0ZWRBdCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb3J0IG5leHQgYnkgaWQsIGxvd2VyLWlkIHRpbWVycyB0YWtlIHByZWNlZGVuY2VcbiAgICAgICAgaWYgKGEuaWQgPCBiLmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuaWQgPiBiLmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFzIHRpbWVyIGlkcyBhcmUgdW5pcXVlLCBubyBmYWxsYmFjayBgMGAgaXMgbmVjZXNzYXJ5XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlyc3RUaW1lckluUmFuZ2UoY2xvY2ssIGZyb20sIHRvKSB7XG4gICAgICAgIHZhciB0aW1lcnMgPSBjbG9jay50aW1lcnMsXG4gICAgICAgICAgICB0aW1lciA9IG51bGwsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGlzSW5SYW5nZTtcblxuICAgICAgICBmb3IgKGlkIGluIHRpbWVycykge1xuICAgICAgICAgICAgaWYgKHRpbWVycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICBpc0luUmFuZ2UgPSBpblJhbmdlKGZyb20sIHRvLCB0aW1lcnNbaWRdKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0luUmFuZ2UgJiYgKCF0aW1lciB8fCBjb21wYXJlVGltZXJzKHRpbWVyLCB0aW1lcnNbaWRdKSA9PT0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIgPSB0aW1lcnNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aW1lcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsVGltZXIoY2xvY2ssIHRpbWVyKSB7XG4gICAgICAgIHZhciBleGNlcHRpb247XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lci5pbnRlcnZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY2xvY2sudGltZXJzW3RpbWVyLmlkXS5jYWxsQXQgKz0gdGltZXIuaW50ZXJ2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgY2xvY2sudGltZXJzW3RpbWVyLmlkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRpbWVyLmZ1bmMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRpbWVyLmZ1bmMuYXBwbHkobnVsbCwgdGltZXIuYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2YWwodGltZXIuZnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNsb2NrLnRpbWVyc1t0aW1lci5pZF0pIHtcbiAgICAgICAgICAgIGlmIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aW1lclR5cGUodGltZXIpIHtcbiAgICAgICAgaWYgKHRpbWVyLmltbWVkaWF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiSW1tZWRpYXRlXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRpbWVyLmludGVydmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJbnRlcnZhbFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiVGltZW91dFwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJUaW1lcihjbG9jaywgdGltZXJJZCwgdHR5cGUpIHtcbiAgICAgICAgaWYgKCF0aW1lcklkKSB7XG4gICAgICAgICAgICAvLyBudWxsIGFwcGVhcnMgdG8gYmUgYWxsb3dlZCBpbiBtb3N0IGJyb3dzZXJzLCBhbmQgYXBwZWFycyB0byBiZVxuICAgICAgICAgICAgLy8gcmVsaWVkIHVwb24gYnkgc29tZSBsaWJyYXJpZXMsIGxpa2UgQm9vdHN0cmFwIGNhcm91c2VsXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNsb2NrLnRpbWVycykge1xuICAgICAgICAgICAgY2xvY2sudGltZXJzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbiBOb2RlLCB0aW1lcklkIGlzIGFuIG9iamVjdCB3aXRoIC5yZWYoKS8udW5yZWYoKSwgYW5kXG4gICAgICAgIC8vIGl0cyAuaWQgZmllbGQgaXMgdGhlIGFjdHVhbCB0aW1lciBpZC5cbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lcklkID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aW1lcklkID0gdGltZXJJZC5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9jay50aW1lcnMuaGFzT3duUHJvcGVydHkodGltZXJJZCkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgdGhlIElEIG1hdGNoZXMgYSB0aW1lciBvZiB0aGUgY29ycmVjdCB0eXBlXG4gICAgICAgICAgICB2YXIgdGltZXIgPSBjbG9jay50aW1lcnNbdGltZXJJZF07XG4gICAgICAgICAgICBpZiAodGltZXJUeXBlKHRpbWVyKSA9PT0gdHR5cGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2xvY2sudGltZXJzW3RpbWVySWRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNsZWFyIHRpbWVyOiB0aW1lciBjcmVhdGVkIHdpdGggc2V0XCIgKyB0dHlwZSArIFwiKCkgYnV0IGNsZWFyZWQgd2l0aCBjbGVhclwiICsgdGltZXJUeXBlKHRpbWVyKSArIFwiKClcIik7XG5cdFx0XHR9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmluc3RhbGwoY2xvY2ssIHRhcmdldCkge1xuICAgICAgICB2YXIgbWV0aG9kLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGw7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGNsb2NrLm1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBjbG9jay5tZXRob2RzW2ldO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0W21ldGhvZF0uaGFkT3duUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbWV0aG9kXSA9IGNsb2NrW1wiX1wiICsgbWV0aG9kXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldFttZXRob2RdO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgZXhlY3V0aW9ucyB3aGljaCB3aWxsIGNvbXBsZXRlbHkgcmVtb3ZlIHRoZXNlIHByb3BzXG4gICAgICAgIGNsb2NrLm1ldGhvZHMgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoaWphY2tNZXRob2QodGFyZ2V0LCBtZXRob2QsIGNsb2NrKSB7XG4gICAgICAgIHZhciBwcm9wO1xuXG4gICAgICAgIGNsb2NrW21ldGhvZF0uaGFkT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBtZXRob2QpO1xuICAgICAgICBjbG9ja1tcIl9cIiArIG1ldGhvZF0gPSB0YXJnZXRbbWV0aG9kXTtcblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIkRhdGVcIikge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBtaXJyb3JEYXRlUHJvcGVydGllcyhjbG9ja1ttZXRob2RdLCB0YXJnZXRbbWV0aG9kXSk7XG4gICAgICAgICAgICB0YXJnZXRbbWV0aG9kXSA9IGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvY2tbbWV0aG9kXS5hcHBseShjbG9jaywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBjbG9ja1ttZXRob2RdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsb2NrW21ldGhvZF0uaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W21ldGhvZF1bcHJvcF0gPSBjbG9ja1ttZXRob2RdW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldFttZXRob2RdLmNsb2NrID0gY2xvY2s7XG4gICAgfVxuXG4gICAgdmFyIHRpbWVycyA9IHtcbiAgICAgICAgc2V0VGltZW91dDogc2V0VGltZW91dCxcbiAgICAgICAgY2xlYXJUaW1lb3V0OiBjbGVhclRpbWVvdXQsXG4gICAgICAgIHNldEltbWVkaWF0ZTogZ2xvYmFsLnNldEltbWVkaWF0ZSxcbiAgICAgICAgY2xlYXJJbW1lZGlhdGU6IGdsb2JhbC5jbGVhckltbWVkaWF0ZSxcbiAgICAgICAgc2V0SW50ZXJ2YWw6IHNldEludGVydmFsLFxuICAgICAgICBjbGVhckludGVydmFsOiBjbGVhckludGVydmFsLFxuICAgICAgICBEYXRlOiBEYXRlXG4gICAgfTtcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIga3MgPSBbXSxcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGtzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrcztcbiAgICB9O1xuXG4gICAgZXhwb3J0cy50aW1lcnMgPSB0aW1lcnM7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDbG9jayhub3cpIHtcbiAgICAgICAgdmFyIGNsb2NrID0ge1xuICAgICAgICAgICAgbm93OiBnZXRFcG9jaChub3cpLFxuICAgICAgICAgICAgdGltZW91dHM6IHt9LFxuICAgICAgICAgICAgRGF0ZTogY3JlYXRlRGF0ZSgpXG4gICAgICAgIH07XG5cbiAgICAgICAgY2xvY2suRGF0ZS5jbG9jayA9IGNsb2NrO1xuXG4gICAgICAgIGNsb2NrLnNldFRpbWVvdXQgPSBmdW5jdGlvbiBzZXRUaW1lb3V0KGZ1bmMsIHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRUaW1lcihjbG9jaywge1xuICAgICAgICAgICAgICAgIGZ1bmM6IGZ1bmMsXG4gICAgICAgICAgICAgICAgYXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICAgICAgICBkZWxheTogdGltZW91dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xvY2suY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gY2xlYXJUaW1lb3V0KHRpbWVySWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhclRpbWVyKGNsb2NrLCB0aW1lcklkLCBcIlRpbWVvdXRcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xvY2suc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiBzZXRJbnRlcnZhbChmdW5jLCB0aW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkVGltZXIoY2xvY2ssIHtcbiAgICAgICAgICAgICAgICBmdW5jOiBmdW5jLFxuICAgICAgICAgICAgICAgIGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgICAgICAgZGVsYXk6IHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IHRpbWVvdXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsb2NrLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiBjbGVhckludGVydmFsKHRpbWVySWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhclRpbWVyKGNsb2NrLCB0aW1lcklkLCBcIkludGVydmFsXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsb2NrLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkVGltZXIoY2xvY2ssIHtcbiAgICAgICAgICAgICAgICBmdW5jOiBmdW5jLFxuICAgICAgICAgICAgICAgIGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICAgICAgaW1tZWRpYXRlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBjbG9jay5jbGVhckltbWVkaWF0ZSA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKHRpbWVySWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhclRpbWVyKGNsb2NrLCB0aW1lcklkLCBcIkltbWVkaWF0ZVwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjbG9jay50aWNrID0gZnVuY3Rpb24gdGljayhtcykge1xuICAgICAgICAgICAgbXMgPSB0eXBlb2YgbXMgPT09IFwibnVtYmVyXCIgPyBtcyA6IHBhcnNlVGltZShtcyk7XG4gICAgICAgICAgICB2YXIgdGlja0Zyb20gPSBjbG9jay5ub3csIHRpY2tUbyA9IGNsb2NrLm5vdyArIG1zLCBwcmV2aW91cyA9IGNsb2NrLm5vdztcbiAgICAgICAgICAgIHZhciB0aW1lciA9IGZpcnN0VGltZXJJblJhbmdlKGNsb2NrLCB0aWNrRnJvbSwgdGlja1RvKTtcbiAgICAgICAgICAgIHZhciBvbGROb3c7XG5cbiAgICAgICAgICAgIGNsb2NrLmR1cmluZ1RpY2sgPSB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgZmlyc3RFeGNlcHRpb247XG4gICAgICAgICAgICB3aGlsZSAodGltZXIgJiYgdGlja0Zyb20gPD0gdGlja1RvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsb2NrLnRpbWVyc1t0aW1lci5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGlja0Zyb20gPSBjbG9jay5ub3cgPSB0aW1lci5jYWxsQXQ7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGROb3cgPSBjbG9jay5ub3c7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsVGltZXIoY2xvY2ssIHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBlbnNhdGUgZm9yIGFueSBzZXRTeXN0ZW1UaW1lKCkgY2FsbCBkdXJpbmcgdGltZXIgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGROb3cgIT09IGNsb2NrLm5vdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tGcm9tICs9IGNsb2NrLm5vdyAtIG9sZE5vdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWNrVG8gKz0gY2xvY2subm93IC0gb2xkTm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzICs9IGNsb2NrLm5vdyAtIG9sZE5vdztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RFeGNlcHRpb24gPSBmaXJzdEV4Y2VwdGlvbiB8fCBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGltZXIgPSBmaXJzdFRpbWVySW5SYW5nZShjbG9jaywgcHJldmlvdXMsIHRpY2tUbyk7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSB0aWNrRnJvbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xvY2suZHVyaW5nVGljayA9IGZhbHNlO1xuICAgICAgICAgICAgY2xvY2subm93ID0gdGlja1RvO1xuXG4gICAgICAgICAgICBpZiAoZmlyc3RFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBmaXJzdEV4Y2VwdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNsb2NrLm5vdztcbiAgICAgICAgfTtcblxuICAgICAgICBjbG9jay5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgY2xvY2sudGltZXJzID0ge307XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xvY2suc2V0U3lzdGVtVGltZSA9IGZ1bmN0aW9uIHNldFN5c3RlbVRpbWUobm93KSB7XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGltZSBkaWZmZXJlbmNlXG4gICAgICAgICAgICB2YXIgbmV3Tm93ID0gZ2V0RXBvY2gobm93KTtcbiAgICAgICAgICAgIHZhciBkaWZmZXJlbmNlID0gbmV3Tm93IC0gY2xvY2subm93O1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgJ3N5c3RlbSBjbG9jaydcbiAgICAgICAgICAgIGNsb2NrLm5vdyA9IG5ld05vdztcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHRpbWVycyBhbmQgaW50ZXJ2YWxzIHRvIGtlZXAgdGhlbSBzdGFibGVcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIGNsb2NrLnRpbWVycykge1xuICAgICAgICAgICAgICAgIGlmIChjbG9jay50aW1lcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lciA9IGNsb2NrLnRpbWVyc1tpZF07XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyLmNyZWF0ZWRBdCArPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICB0aW1lci5jYWxsQXQgKz0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGNsb2NrO1xuICAgIH1cbiAgICBleHBvcnRzLmNyZWF0ZUNsb2NrID0gY3JlYXRlQ2xvY2s7XG5cbiAgICBleHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbiBpbnN0YWxsKHRhcmdldCwgbm93LCB0b0Zha2UpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0b0Zha2UgPSBub3c7XG4gICAgICAgICAgICBub3cgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0YXJnZXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGdsb2JhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjbG9jayA9IGNyZWF0ZUNsb2NrKG5vdyk7XG5cbiAgICAgICAgY2xvY2sudW5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdW5pbnN0YWxsKGNsb2NrLCB0YXJnZXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNsb2NrLm1ldGhvZHMgPSB0b0Zha2UgfHwgW107XG5cbiAgICAgICAgaWYgKGNsb2NrLm1ldGhvZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjbG9jay5tZXRob2RzID0ga2V5cyh0aW1lcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGNsb2NrLm1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBoaWphY2tNZXRob2QodGFyZ2V0LCBjbG9jay5tZXRob2RzW2ldLCBjbG9jayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvY2s7XG4gICAgfTtcblxufShnbG9iYWwgfHwgdGhpcykpO1xuIiwiKCh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCAmJiBmdW5jdGlvbiAobSkgeyBkZWZpbmUoXCJzYW1zYW1cIiwgbSk7IH0pIHx8XG4gKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgIGZ1bmN0aW9uIChtKSB7IG1vZHVsZS5leHBvcnRzID0gbSgpOyB9KSB8fCAvLyBOb2RlXG4gZnVuY3Rpb24gKG0pIHsgdGhpcy5zYW1zYW0gPSBtKCk7IH0gLy8gQnJvd3NlciBnbG9iYWxzXG4pKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgdmFyIGRpdiA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgICAgLy8gVW5saWtlIGdsb2JhbCBpc05hTiwgdGhpcyBhdm9pZHMgdHlwZSBjb2VyY2lvblxuICAgICAgICAvLyB0eXBlb2YgY2hlY2sgYXZvaWRzIElFIGhvc3Qgb2JqZWN0IGlzc3VlcywgaGF0IHRpcCB0b1xuICAgICAgICAvLyBsb2Rhc2hcbiAgICAgICAgdmFyIHZhbCA9IHZhbHVlOyAvLyBKc0xpbnQgdGhpbmtzIHZhbHVlICE9PSB2YWx1ZSBpcyBcIndlaXJkXCJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSAhPT0gdmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENsYXNzKHZhbHVlKSB7XG4gICAgICAgIC8vIFJldHVybnMgdGhlIGludGVybmFsIFtbQ2xhc3NdXSBieSBjYWxsaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUgYXMgdGhpcy4gUmV0dXJuIHZhbHVlIGlzIGEgc3RyaW5nLCBuYW1pbmcgdGhlXG4gICAgICAgIC8vIGludGVybmFsIGNsYXNzLCBlLmcuIFwiQXJyYXlcIlxuICAgICAgICByZXR1cm4gby50b1N0cmluZy5jYWxsKHZhbHVlKS5zcGxpdCgvWyBcXF1dLylbMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc2Ftc2FtLmlzQXJndW1lbnRzXG4gICAgICogQHBhcmFtIE9iamVjdCBvYmplY3RcbiAgICAgKlxuICAgICAqIFJldHVybnMgYGB0cnVlYGAgaWYgYGBvYmplY3RgYCBpcyBhbiBgYGFyZ3VtZW50c2BgIG9iamVjdCxcbiAgICAgKiBgYGZhbHNlYGAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICAgICAgICBpZiAoZ2V0Q2xhc3Mob2JqZWN0KSA9PT0gJ0FyZ3VtZW50cycpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iamVjdC5sZW5ndGggIT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgICAgICBnZXRDbGFzcyhvYmplY3QpID09PSBcIkFycmF5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jYWxsZWUgPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvYmplY3Rbb2JqZWN0Lmxlbmd0aF0gPSA2O1xuICAgICAgICAgICAgZGVsZXRlIG9iamVjdFtvYmplY3QubGVuZ3RoXTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHNhbXNhbS5pc0VsZW1lbnRcbiAgICAgKiBAcGFyYW0gT2JqZWN0IG9iamVjdFxuICAgICAqXG4gICAgICogUmV0dXJucyBgYHRydWVgYCBpZiBgYG9iamVjdGBgIGlzIGEgRE9NIGVsZW1lbnQgbm9kZS4gVW5saWtlXG4gICAgICogVW5kZXJzY29yZS5qcy9sb2Rhc2gsIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYGBmYWxzZWBgIGlmIGBgb2JqZWN0YGBcbiAgICAgKiBpcyBhbiAqZWxlbWVudC1saWtlKiBvYmplY3QsIGkuZS4gYSByZWd1bGFyIG9iamVjdCB3aXRoIGEgYGBub2RlVHlwZWBgXG4gICAgICogcHJvcGVydHkgdGhhdCBob2xkcyB0aGUgdmFsdWUgYGAxYGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICAgICAgICBpZiAoIW9iamVjdCB8fCBvYmplY3Qubm9kZVR5cGUgIT09IDEgfHwgIWRpdikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9iamVjdC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgb2JqZWN0LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBzYW1zYW0ua2V5c1xuICAgICAqIEBwYXJhbSBPYmplY3Qgb2JqZWN0XG4gICAgICpcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygb3duIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICAgIHZhciBrcyA9IFtdLCBwcm9wO1xuICAgICAgICBmb3IgKHByb3AgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcCkpIHsga3MucHVzaChwcm9wKTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBzYW1zYW0uaXNEYXRlXG4gICAgICogQHBhcmFtIE9iamVjdCB2YWx1ZVxuICAgICAqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBgYERhdGVgYCwgb3IgKmRhdGUtbGlrZSouIER1Y2sgdHlwaW5nXG4gICAgICogb2YgZGF0ZSBvYmplY3RzIHdvcmsgYnkgY2hlY2tpbmcgdGhhdCB0aGUgb2JqZWN0IGhhcyBhIGBgZ2V0VGltZWBgXG4gICAgICogZnVuY3Rpb24gd2hvc2UgcmV0dXJuIHZhbHVlIGVxdWFscyB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIG9iamVjdCdzXG4gICAgICogYGB2YWx1ZU9mYGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUuZ2V0VGltZSA9PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHZhbHVlLmdldFRpbWUoKSA9PSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc2Ftc2FtLmlzTmVnWmVyb1xuICAgICAqIEBwYXJhbSBPYmplY3QgdmFsdWVcbiAgICAgKlxuICAgICAqIFJldHVybnMgYGB0cnVlYGAgaWYgYGB2YWx1ZWBgIGlzIGBgLTBgYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05lZ1plcm8odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA9PT0gLUluZmluaXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHNhbXNhbS5lcXVhbFxuICAgICAqIEBwYXJhbSBPYmplY3Qgb2JqMVxuICAgICAqIEBwYXJhbSBPYmplY3Qgb2JqMlxuICAgICAqXG4gICAgICogUmV0dXJucyBgYHRydWVgYCBpZiB0d28gb2JqZWN0cyBhcmUgc3RyaWN0bHkgZXF1YWwuIENvbXBhcmVkIHRvXG4gICAgICogYGA9PT1gYCB0aGVyZSBhcmUgdHdvIGV4Y2VwdGlvbnM6XG4gICAgICpcbiAgICAgKiAgIC0gTmFOIGlzIGNvbnNpZGVyZWQgZXF1YWwgdG8gTmFOXG4gICAgICogICAtIC0wIGFuZCArMCBhcmUgbm90IGNvbnNpZGVyZWQgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGljYWwob2JqMSwgb2JqMikge1xuICAgICAgICBpZiAob2JqMSA9PT0gb2JqMiB8fCAoaXNOYU4ob2JqMSkgJiYgaXNOYU4ob2JqMikpKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqMSAhPT0gMCB8fCBpc05lZ1plcm8ob2JqMSkgPT09IGlzTmVnWmVybyhvYmoyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc2Ftc2FtLmRlZXBFcXVhbFxuICAgICAqIEBwYXJhbSBPYmplY3Qgb2JqMVxuICAgICAqIEBwYXJhbSBPYmplY3Qgb2JqMlxuICAgICAqXG4gICAgICogRGVlcCBlcXVhbCBjb21wYXJpc29uLiBUd28gdmFsdWVzIGFyZSBcImRlZXAgZXF1YWxcIiBpZjpcbiAgICAgKlxuICAgICAqICAgLSBUaGV5IGFyZSBlcXVhbCwgYWNjb3JkaW5nIHRvIHNhbXNhbS5pZGVudGljYWxcbiAgICAgKiAgIC0gVGhleSBhcmUgYm90aCBkYXRlIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBzYW1lIHRpbWVcbiAgICAgKiAgIC0gVGhleSBhcmUgYm90aCBhcnJheXMgY29udGFpbmluZyBlbGVtZW50cyB0aGF0IGFyZSBhbGwgZGVlcEVxdWFsXG4gICAgICogICAtIFRoZXkgYXJlIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBzZXQgb2YgcHJvcGVydGllcywgYW5kIGVhY2ggcHJvcGVydHlcbiAgICAgKiAgICAgaW4gYGBvYmoxYGAgaXMgZGVlcEVxdWFsIHRvIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IGluIGBgb2JqMmBgXG4gICAgICpcbiAgICAgKiBTdXBwb3J0cyBjeWNsaWMgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWVwRXF1YWxDeWNsaWMob2JqMSwgb2JqMikge1xuXG4gICAgICAgIC8vIHVzZWQgZm9yIGN5Y2xpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIGNvbnRhaW4gYWxyZWFkeSB2aXNpdGVkIG9iamVjdHNcbiAgICAgICAgdmFyIG9iamVjdHMxID0gW10sXG4gICAgICAgICAgICBvYmplY3RzMiA9IFtdLFxuICAgICAgICAvLyBjb250YWluIHBhdGhlcyAocG9zaXRpb24gaW4gdGhlIG9iamVjdCBzdHJ1Y3R1cmUpXG4gICAgICAgIC8vIG9mIHRoZSBhbHJlYWR5IHZpc2l0ZWQgb2JqZWN0c1xuICAgICAgICAvLyBpbmRleGVzIHNhbWUgYXMgaW4gb2JqZWN0cyBhcnJheXNcbiAgICAgICAgICAgIHBhdGhzMSA9IFtdLFxuICAgICAgICAgICAgcGF0aHMyID0gW10sXG4gICAgICAgIC8vIGNvbnRhaW5zIGNvbWJpbmF0aW9ucyBvZiBhbHJlYWR5IGNvbXBhcmVkIG9iamVjdHNcbiAgICAgICAgLy8gaW4gdGhlIG1hbm5lcjogeyBcIiQxWydyZWYnXSQyWydyZWYnXVwiOiB0cnVlIH1cbiAgICAgICAgICAgIGNvbXBhcmVkID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVzZWQgdG8gY2hlY2ssIGlmIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGlzIGFuIG9iamVjdFxuICAgICAgICAgKiAoY3ljbGljIGxvZ2ljIGlzIG9ubHkgbmVlZGVkIGZvciBvYmplY3RzKVxuICAgICAgICAgKiBvbmx5IG5lZWRlZCBmb3IgY3ljbGljIGxvZ2ljXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikgJiZcbiAgICAgICAgICAgICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICAgICYmXG4gICAgICAgICAgICAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICAmJlxuICAgICAgICAgICAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSAgJiZcbiAgICAgICAgICAgICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIG9iamVjdCBpbiB0aGVcbiAgICAgICAgICogZ2l2ZW4gb2JqZWN0cyBhcnJheSwgLTEgaWYgbm90IGNvbnRhaW5lZFxuICAgICAgICAgKiBvbmx5IG5lZWRlZCBmb3IgY3ljbGljIGxvZ2ljXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRJbmRleChvYmplY3RzLCBvYmopIHtcblxuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RzW2ldID09PSBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkb2VzIHRoZSByZWN1cnNpb24gZm9yIHRoZSBkZWVwIGVxdWFsIGNoZWNrXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gZGVlcEVxdWFsKG9iajEsIG9iajIsIHBhdGgxLCBwYXRoMikge1xuICAgICAgICAgICAgdmFyIHR5cGUxID0gdHlwZW9mIG9iajE7XG4gICAgICAgICAgICB2YXIgdHlwZTIgPSB0eXBlb2Ygb2JqMjtcblxuICAgICAgICAgICAgLy8gPT0gbnVsbCBhbHNvIG1hdGNoZXMgdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAob2JqMSA9PT0gb2JqMiB8fFxuICAgICAgICAgICAgICAgICAgICBpc05hTihvYmoxKSB8fCBpc05hTihvYmoyKSB8fFxuICAgICAgICAgICAgICAgICAgICBvYmoxID09IG51bGwgfHwgb2JqMiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGUxICE9PSBcIm9iamVjdFwiIHx8IHR5cGUyICE9PSBcIm9iamVjdFwiKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaWRlbnRpY2FsKG9iajEsIG9iajIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbGVtZW50cyBhcmUgb25seSBlcXVhbCBpZiBpZGVudGljYWwoZXhwZWN0ZWQsIGFjdHVhbClcbiAgICAgICAgICAgIGlmIChpc0VsZW1lbnQob2JqMSkgfHwgaXNFbGVtZW50KG9iajIpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgICAgICB2YXIgaXNEYXRlMSA9IGlzRGF0ZShvYmoxKSwgaXNEYXRlMiA9IGlzRGF0ZShvYmoyKTtcbiAgICAgICAgICAgIGlmIChpc0RhdGUxIHx8IGlzRGF0ZTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGF0ZTEgfHwgIWlzRGF0ZTIgfHwgb2JqMS5nZXRUaW1lKCkgIT09IG9iajIuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvYmoxIGluc3RhbmNlb2YgUmVnRXhwICYmIG9iajIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqMS50b1N0cmluZygpICE9PSBvYmoyLnRvU3RyaW5nKCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjbGFzczEgPSBnZXRDbGFzcyhvYmoxKTtcbiAgICAgICAgICAgIHZhciBjbGFzczIgPSBnZXRDbGFzcyhvYmoyKTtcbiAgICAgICAgICAgIHZhciBrZXlzMSA9IGtleXMob2JqMSk7XG4gICAgICAgICAgICB2YXIga2V5czIgPSBrZXlzKG9iajIpO1xuXG4gICAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqMSkgfHwgaXNBcmd1bWVudHMob2JqMikpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZTEgIT09IHR5cGUyIHx8IGNsYXNzMSAhPT0gY2xhc3MyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIga2V5LCBpLCBsLFxuICAgICAgICAgICAgICAgIC8vIGZvbGxvd2luZyB2YXJzIGFyZSB1c2VkIGZvciB0aGUgY3ljbGljIGxvZ2ljXG4gICAgICAgICAgICAgICAgdmFsdWUxLCB2YWx1ZTIsXG4gICAgICAgICAgICAgICAgaXNPYmplY3QxLCBpc09iamVjdDIsXG4gICAgICAgICAgICAgICAgaW5kZXgxLCBpbmRleDIsXG4gICAgICAgICAgICAgICAgbmV3UGF0aDEsIG5ld1BhdGgyO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0ga2V5czEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5czFbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFvLmhhc093blByb3BlcnR5LmNhbGwob2JqMiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgb2YgdGhlIGN5Y2xpYyBsb2dpY1xuXG4gICAgICAgICAgICAgICAgdmFsdWUxID0gb2JqMVtrZXldO1xuICAgICAgICAgICAgICAgIHZhbHVlMiA9IG9iajJba2V5XTtcblxuICAgICAgICAgICAgICAgIGlzT2JqZWN0MSA9IGlzT2JqZWN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgICAgaXNPYmplY3QyID0gaXNPYmplY3QodmFsdWUyKTtcblxuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSwgaWYgdGhlIG9iamVjdHMgd2VyZSBhbHJlYWR5IHZpc2l0ZWRcbiAgICAgICAgICAgICAgICAvLyAoaXQncyBmYXN0ZXIgdG8gY2hlY2sgZm9yIGlzT2JqZWN0IGZpcnN0LCB0aGFuIHRvXG4gICAgICAgICAgICAgICAgLy8gZ2V0IC0xIGZyb20gZ2V0SW5kZXggZm9yIG5vbiBvYmplY3RzKVxuICAgICAgICAgICAgICAgIGluZGV4MSA9IGlzT2JqZWN0MSA/IGdldEluZGV4KG9iamVjdHMxLCB2YWx1ZTEpIDogLTE7XG4gICAgICAgICAgICAgICAgaW5kZXgyID0gaXNPYmplY3QyID8gZ2V0SW5kZXgob2JqZWN0czIsIHZhbHVlMikgOiAtMTtcblxuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgbmV3IHBhdGhlcyBvZiB0aGUgb2JqZWN0c1xuICAgICAgICAgICAgICAgIC8vIC0gZm9yIG5vbiBjeWNsaWMgb2JqZWN0cyB0aGUgY3VycmVudCBwYXRoIHdpbGwgYmUgZXh0ZW5kZWRcbiAgICAgICAgICAgICAgICAvLyAgIGJ5IGN1cnJlbnQgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgIC8vIC0gZm9yIGN5Y2xpYyBvYmplY3RzIHRoZSBzdG9yZWQgcGF0aCBpcyB0YWtlblxuICAgICAgICAgICAgICAgIG5ld1BhdGgxID0gaW5kZXgxICE9PSAtMVxuICAgICAgICAgICAgICAgICAgICA/IHBhdGhzMVtpbmRleDFdXG4gICAgICAgICAgICAgICAgICAgIDogcGF0aDEgKyAnWycgKyBKU09OLnN0cmluZ2lmeShrZXkpICsgJ10nO1xuICAgICAgICAgICAgICAgIG5ld1BhdGgyID0gaW5kZXgyICE9PSAtMVxuICAgICAgICAgICAgICAgICAgICA/IHBhdGhzMltpbmRleDJdXG4gICAgICAgICAgICAgICAgICAgIDogcGF0aDIgKyAnWycgKyBKU09OLnN0cmluZ2lmeShrZXkpICsgJ10nO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RvcCByZWN1cnNpb24gaWYgY3VycmVudCBvYmplY3RzIGFyZSBhbHJlYWR5IGNvbXBhcmVkXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVkW25ld1BhdGgxICsgbmV3UGF0aDJdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBjdXJyZW50IG9iamVjdHMgYW5kIHRoZWlyIHBhdGhlc1xuICAgICAgICAgICAgICAgIGlmIChpbmRleDEgPT09IC0xICYmIGlzT2JqZWN0MSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RzMS5wdXNoKHZhbHVlMSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhzMS5wdXNoKG5ld1BhdGgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4MiA9PT0gLTEgJiYgaXNPYmplY3QyKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdHMyLnB1c2godmFsdWUyKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMyLnB1c2gobmV3UGF0aDIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoYXQgdGhlIGN1cnJlbnQgb2JqZWN0cyBhcmUgYWxyZWFkeSBjb21wYXJlZFxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdDEgJiYgaXNPYmplY3QyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmVkW25ld1BhdGgxICsgbmV3UGF0aDJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBFbmQgb2YgY3ljbGljIGxvZ2ljXG5cbiAgICAgICAgICAgICAgICAvLyBuZWl0aGVyIHZhbHVlMSBub3IgdmFsdWUyIGlzIGEgY3ljbGVcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSB3aXRoIG5leHQgbGV2ZWxcbiAgICAgICAgICAgICAgICBpZiAoIWRlZXBFcXVhbCh2YWx1ZTEsIHZhbHVlMiwgbmV3UGF0aDEsIG5ld1BhdGgyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9KG9iajEsIG9iajIsICckMScsICckMicpKTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2g7XG5cbiAgICBmdW5jdGlvbiBhcnJheUNvbnRhaW5zKGFycmF5LCBzdWJzZXQpIHtcbiAgICAgICAgaWYgKHN1YnNldC5sZW5ndGggPT09IDApIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgdmFyIGksIGwsIGosIGs7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaChhcnJheVtpXSwgc3Vic2V0WzBdKSkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGsgPSBzdWJzZXQubGVuZ3RoOyBqIDwgazsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2goYXJyYXlbaSArIGpdLCBzdWJzZXRbal0pKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc2Ftc2FtLm1hdGNoXG4gICAgICogQHBhcmFtIE9iamVjdCBvYmplY3RcbiAgICAgKiBAcGFyYW0gT2JqZWN0IG1hdGNoZXJcbiAgICAgKlxuICAgICAqIENvbXBhcmUgYXJiaXRyYXJ5IHZhbHVlIGBgb2JqZWN0YGAgd2l0aCBtYXRjaGVyLlxuICAgICAqL1xuICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gob2JqZWN0LCBtYXRjaGVyKSB7XG4gICAgICAgIGlmIChtYXRjaGVyICYmIHR5cGVvZiBtYXRjaGVyLnRlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIudGVzdChvYmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyKG9iamVjdCkgPT09IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1hdGNoZXIgPSBtYXRjaGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgbm90TnVsbCA9IHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIgfHwgISFvYmplY3Q7XG4gICAgICAgICAgICByZXR1cm4gbm90TnVsbCAmJlxuICAgICAgICAgICAgICAgIChTdHJpbmcob2JqZWN0KSkudG9Mb3dlckNhc2UoKS5pbmRleE9mKG1hdGNoZXIpID49IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyID09PSBvYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlciA9PT0gb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihtYXRjaGVyKSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZihvYmplY3QpID09PSBcInVuZGVmaW5lZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2V0Q2xhc3Mob2JqZWN0KSA9PT0gXCJBcnJheVwiICYmIGdldENsYXNzKG1hdGNoZXIpID09PSBcIkFycmF5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheUNvbnRhaW5zKG9iamVjdCwgbWF0Y2hlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hlciAmJiB0eXBlb2YgbWF0Y2hlciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXIgPT09IG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb3A7XG4gICAgICAgICAgICBmb3IgKHByb3AgaW4gbWF0Y2hlcikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb2JqZWN0LmdldEF0dHJpYnV0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0LmdldEF0dHJpYnV0ZShwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXJbcHJvcF0gPT09IG51bGwgfHwgdHlwZW9mIG1hdGNoZXJbcHJvcF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbWF0Y2hlcltwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8ICFtYXRjaCh2YWx1ZSwgbWF0Y2hlcltwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWF0Y2hlciB3YXMgbm90IGEgc3RyaW5nLCBhIG51bWJlciwgYSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uLCBhIGJvb2xlYW4gb3IgYW4gb2JqZWN0XCIpO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpc0FyZ3VtZW50czogaXNBcmd1bWVudHMsXG4gICAgICAgIGlzRWxlbWVudDogaXNFbGVtZW50LFxuICAgICAgICBpc0RhdGU6IGlzRGF0ZSxcbiAgICAgICAgaXNOZWdaZXJvOiBpc05lZ1plcm8sXG4gICAgICAgIGlkZW50aWNhbDogaWRlbnRpY2FsLFxuICAgICAgICBkZWVwRXF1YWw6IGRlZXBFcXVhbEN5Y2xpYyxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBrZXlzOiBrZXlzXG4gICAgfTtcbn0pO1xuIiwiLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4yLjBcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTUtMDQtMTBcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcblx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXHRyZXNjYXBlID0gLyd8XFxcXC9nLFxuXG5cdC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cblx0XHRcdFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmVzY2FwZSwgXCJcXFxcJCZcIiApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiW2lkPSdcIiArIG5pZCArIFwiJ10gXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBkaXYgYW5kIGV4cGVjdHMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBkaXYgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGRpdi5wYXJlbnROb2RlICkge1xuXHRcdFx0ZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGRpdiA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdCggfmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICkgLVxuXHRcdFx0KCB+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKTtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgcGFyZW50LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTFcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHQvLyBMaW1pdCB0aGUgZml4IHRvIElFIHdpdGggZG9jdW1lbnQuZG9jdW1lbnRNb2RlIGFuZCBJRSA+PTkgd2l0aCBkb2N1bWVudC5kZWZhdWx0Vmlld1xuXHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSAmJiAocGFyZW50ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHBhcmVudC50b3AgIT09IHBhcmVudCApIHtcblx0XHQvLyBTdXBwb3J0OiBJRSAxMVxuXHRcdGlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggcGFyZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0cGFyZW50LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZGl2LmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmluZCBhbmQgZmlsdGVyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gbSA/IFsgbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2liaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRkaXYucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGRpdiwgXCJkaXZcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGRpdiwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRcImRpc2FibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGRpciBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgZGlyIF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0c3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYxICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRyZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gRVhQT1NFXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBTaXp6bGU7IH0pO1xuLy8gU2l6emxlIHJlcXVpcmVzIHRoYXQgdGhlcmUgYmUgYSBnbG9iYWwgd2luZG93IGluIENvbW1vbi1KUyBsaWtlIGVudmlyb25tZW50c1xufSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyApIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBTaXp6bGU7XG59IGVsc2Uge1xuXHR3aW5kb3cuU2l6emxlID0gU2l6emxlO1xufVxuLy8gRVhQT1NFXG5cbn0pKCB3aW5kb3cgKTtcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy92b29tJyk7XG5cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfYXJnc1wiOiBbXG4gICAgW1xuICAgICAge1xuICAgICAgICBcInJhd1wiOiBcInZvb21AXjEuMC44XCIsXG4gICAgICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICAgICAgXCJlc2NhcGVkTmFtZVwiOiBcInZvb21cIixcbiAgICAgICAgXCJuYW1lXCI6IFwidm9vbVwiLFxuICAgICAgICBcInJhd1NwZWNcIjogXCJeMS4wLjhcIixcbiAgICAgICAgXCJzcGVjXCI6IFwiPj0xLjAuOCA8Mi4wLjBcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwicmFuZ2VcIlxuICAgICAgfSxcbiAgICAgIFwiL1VzZXJzL1J1c3MvU2l0ZXMvbml0cm8teG1wcC1jbGllbnQtY29ubmVjdGlvblwiXG4gICAgXVxuICBdLFxuICBcIl9mcm9tXCI6IFwidm9vbUA+PTEuMC44IDwyLjAuMFwiLFxuICBcIl9pZFwiOiBcInZvb21AMS4wLjhcIixcbiAgXCJfaW5DYWNoZVwiOiB0cnVlLFxuICBcIl9pbnN0YWxsYWJsZVwiOiB0cnVlLFxuICBcIl9sb2NhdGlvblwiOiBcIi92b29tXCIsXG4gIFwiX25vZGVWZXJzaW9uXCI6IFwiNS4yLjBcIixcbiAgXCJfbnBtT3BlcmF0aW9uYWxJbnRlcm5hbFwiOiB7XG4gICAgXCJob3N0XCI6IFwicGFja2FnZXMtMTItd2VzdC5pbnRlcm5hbC5ucG1qcy5jb21cIixcbiAgICBcInRtcFwiOiBcInRtcC92b29tLTEuMC44LnRnel8xNDc1Njk2OTI5MTkyXzAuMjk0NTUyNDMyMzczMTY2MVwiXG4gIH0sXG4gIFwiX25wbVVzZXJcIjoge1xuICAgIFwibmFtZVwiOiBcInRyYWdsZVwiLFxuICAgIFwiZW1haWxcIjogXCJ0cmFnbGVAZ21haWwuY29tXCJcbiAgfSxcbiAgXCJfbnBtVmVyc2lvblwiOiBcIjMuMy4xMlwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJyYXdcIjogXCJ2b29tQF4xLjAuOFwiLFxuICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICBcImVzY2FwZWROYW1lXCI6IFwidm9vbVwiLFxuICAgIFwibmFtZVwiOiBcInZvb21cIixcbiAgICBcInJhd1NwZWNcIjogXCJeMS4wLjhcIixcbiAgICBcInNwZWNcIjogXCI+PTEuMC44IDwyLjAuMFwiLFxuICAgIFwidHlwZVwiOiBcInJhbmdlXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvXCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy92b29tLy0vdm9vbS0xLjAuOC50Z3pcIixcbiAgXCJfc2hhc3VtXCI6IFwiZTJjZjhjYWI2NWNkYmZjZTUxMWE5Y2E5YmNkNjNlZDU0M2NmMDRlNlwiLFxuICBcIl9zaHJpbmt3cmFwXCI6IG51bGwsXG4gIFwiX3NwZWNcIjogXCJ2b29tQF4xLjAuOFwiLFxuICBcIl93aGVyZVwiOiBcIi9Vc2Vycy9SdXNzL1NpdGVzL25pdHJvLXhtcHAtY2xpZW50LWNvbm5lY3Rpb25cIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIlRvbSBSYWdsZVwiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhZ2xlL3Zvb20vaXNzdWVzXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwicGtnaW5mb1wiOiBcIl4wLjQuMFwiXG4gIH0sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJ2YWx1ZSBvcmllbnRlZCBvYmplY3QgbWFwXCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImNoYWlcIjogXCJeMy41LjBcIixcbiAgICBcIm1vY2hhXCI6IFwiXjMuMC4yXCJcbiAgfSxcbiAgXCJkaXJlY3Rvcmllc1wiOiB7fSxcbiAgXCJkaXN0XCI6IHtcbiAgICBcInNoYXN1bVwiOiBcImUyY2Y4Y2FiNjVjZGJmY2U1MTFhOWNhOWJjZDYzZWQ1NDNjZjA0ZTZcIixcbiAgICBcInRhcmJhbGxcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy92b29tLy0vdm9vbS0xLjAuOC50Z3pcIlxuICB9LFxuICBcImdpdEhlYWRcIjogXCIzYmU2OWI2Yzg2MGI4ODRlYWMzZDM5MDM5MTdlYTliZjkxZTA1NTVmXCIsXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhZ2xlL3Zvb20jcmVhZG1lXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJpbmRleC5qc1wiLFxuICBcIm1haW50YWluZXJzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJ0cmFnbGVcIixcbiAgICAgIFwiZW1haWxcIjogXCJ0cmFnbGVAZ21haWwuY29tXCJcbiAgICB9XG4gIF0sXG4gIFwibmFtZVwiOiBcInZvb21cIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7fSxcbiAgXCJyZWFkbWVcIjogXCJFUlJPUjogTm8gUkVBRE1FIGRhdGEgZm91bmQhXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYWdsZS92b29tLmdpdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwibW9jaGEgLS1yZXBvcnRlciBzcGVjXCJcbiAgfSxcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4wLjhcIlxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFthcnJheV0sIFthcnJheV0gLT4gQm9vbFxudmFyIGFycmF5c0FyZUVxdWFsID0gZXhwb3J0cy5hcnJheXNBcmVFcXVhbCA9IGZ1bmN0aW9uIChhcnJheUEsIGFycmF5Qikge1xuICBpZiAoYXJyYXlBLmxlbmd0aCAhPT0gYXJyYXlCLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5QS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJheUFbaV0gIT09IGFycmF5QltpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8ge29ian0gLT4ge29ian1cbnZhciBjbG9uZSA9IGV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGZ1bmN0aW9uIHZpc2l0KG9iaiwgY29weSkge1xuICAgIGZvciAodmFyIG4gaW4gb2JqKSB7XG4gICAgICBpZiAoaXNPYmplY3Qob2JqW25dKSkge1xuICAgICAgICBjb3B5W25dID0ge307XG4gICAgICAgIHZpc2l0KG9ialtuXSwgY29weVtuXSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW25dKSkge1xuICAgICAgICBjb3B5W25dID0gb2JqW25dLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGl0ZW0pKSByZXR1cm4gY2xvbmUoaXRlbSk7XG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weVtuXSA9IG9ialtuXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cbiAgcmV0dXJuIHZpc2l0KG9iaiwge30pO1xufTtcblxuLy8gZm4gLT4gZm4oW2FycmF5XSlcbnZhciBjb2xsZWN0b3IgPSBleHBvcnRzLmNvbGxlY3RvciA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXSwgcmVzO1xuICAgIGlmICghaXNBcnJheShhcnJheSkpIHJldHVybiByZXN1bHRzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcyA9IGZuKGFycmF5W2ldKTtcbiAgICAgIGlmICghaXNOdWxsKHJlcykgJiYgIWlzVW5kZWZpbmVkKHJlcykpIHJlc3VsdHMucHVzaChyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcbn07XG5cbi8vIGZuIC0+IGRlbGF5ZWQoKSAtPiBmblxudmFyIGRlbGF5ID0gZXhwb3J0cy5kZWxheSA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZGVsYXllZCAoKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG59O1xuXG4vLyBbc291cmNlXSwgW3RhcmdldF0sIGZuIC0+IFtyZXN1bHRzXVxudmFyIGRpc3RyaWJ1dGUgPSBleHBvcnRzLmRpc3RyaWJ1dGUgPSBmdW5jdGlvbiAoc291cmNlLCB0YXJnZXQsIGZuKSB7XG4gIHZhciBmYWN0b3IgPSBzb3VyY2UubGVuZ3RoIC8gdGFyZ2V0Lmxlbmd0aCxcbiAgICByZXN1bHRzID0gW107XG4gIGZuID0gZm4gfHwgZnVuY3Rpb24gKGEsIGIpIHtyZXR1cm4gW2EsIGJdO307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KGZuKHNvdXJjZVtNYXRoLmZsb29yKGkgKiBmYWN0b3IpXSwgdGFyZ2V0W2ldKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBbbGlzdF0sIHByZWQgLT4gYm9vbFxudmFyIGV2ZXJ5ID0gZXhwb3J0cy5ldmVyeSA9IGZ1bmN0aW9uIChsaXN0LCBwcmVkKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghcHJlZChsaXN0W2ldKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyB7fSwgdmFsIC0+IFtwYXRoXVxudmFyIGZpbmRQYXRoID0gZXhwb3J0cy5maW5kUGF0aCA9IGZ1bmN0aW9uIChvYmosIHZhbCwgaW5jbHVkZUFycmF5cykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB2YWwgPSBpc0Z1bmN0aW9uKHZhbCkgPyB2YWwubmFtZSA6IHZhbDtcbiAgZnVuY3Rpb24gdmlzaXQoc291cmNlKSB7XG4gICAgZm9yICh2YXIgbiBpbiBzb3VyY2UpIHtcbiAgICAgIHZhciBzb3VyY2VOYW1lID0gaXNGdW5jdGlvbihzb3VyY2Vbbl0pID8gc291cmNlW25dLm5hbWUgOiBzb3VyY2Vbbl07XG4gICAgICBwYXRoLnB1c2gobik7XG4gICAgICBpZiAoc291cmNlTmFtZSA9PT0gdmFsKSByZXR1cm4gdHJ1ZTsgXG4gICAgICBpZiAoaXNPYmplY3Qoc291cmNlTmFtZSkpIFxuICAgICAgICBpZiAodmlzaXQoc291cmNlTmFtZSkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGluY2x1ZGVBcnJheXMgJiYgaXNBcnJheShzb3VyY2VOYW1lKSlcbiAgICAgICAgaWYgKHZpc2l0KHNvdXJjZU5hbWUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHBhdGgucG9wKCk7XG4gICAgfVxuICB9XG4gIHZpc2l0KG9iaik7XG4gIHJldHVybiBwYXRoO1xufTtcblxuLy8gdmFsIC0+IGlucHV0IC0+IHZhbCB8IHZvaWRcbnZhciBnYXRlID0gZXhwb3J0cy5nYXRlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlucHV0ID09PSB2YWwpIHJldHVybiB2YWw7XG4gIH1cbn07XG5cbi8vIFtbYXJyYXlzXV0gLT4gW1tncm91cHNdXVxudmFyIGdyb3VwQXJyYXlzID0gZXhwb3J0cy5ncm91cEFycmF5cyA9IGZ1bmN0aW9uIChhcnJheXMpIHtcbiAgdmFyIGdyb3VwcyA9IFtdO1xuICBhcnJheXMgPSBhcnJheXMuc2xpY2UoMCk7XG5cbiAgd2hpbGUgKGFycmF5cy5sZW5ndGgpIHtcbiAgICB2YXIgYXJyYXkgPSBhcnJheXMucG9wKCk7XG4gICAgaWYgKCFncm91cHMubGVuZ3RoKSB7XG4gICAgICBncm91cHMucHVzaChbYXJyYXldKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGZvciAodmFyIGkgaW4gZ3JvdXBzKSB7XG4gICAgICBpZiAoYXJyYXlzQXJlRXF1YWwoYXJyYXksIGdyb3Vwc1tpXVswXSkpIHtcbiAgICAgICAgZ3JvdXBzW2ldLnB1c2goYXJyYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXBzLnB1c2goW2FycmF5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBncm91cHM7XG59O1xuXG4vLyB2YWwgLT4gdmFsIFxudmFyIGlkZW50aXR5ID0gZXhwb3J0cy5pZGVudGl0eSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8vIHZhbCAtPiBCb29sXG52YXIgaXNBcnJheSA9IGV4cG9ydHMuaXNBcnJheSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKTtcbn07XG5cbi8vIHZhbCAtPiBCb29sXG52YXIgaXNFbXB0eSA9IGV4cG9ydHMuaXNFbXB0eSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICFpc1ZhbHVlKHZhbCkgfHwgISEodmFsLmxlbmd0aCA9PT0gMCk7XG59O1xuXG4vLyB2YWwgLT4gQm9vbFxudmFyIGlzRnVuY3Rpb24gPSBleHBvcnRzLmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xufTtcblxuLy8gdmFsIC0+IEJvb2xcbnZhciBpc051bGwgPSBleHBvcnRzLmlzTnVsbCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gbnVsbDtcbn07XG5cbi8vIHZhbCAtPiBCb29sXG52YXIgaXNPYmplY3QgPSBleHBvcnRzLmlzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gISF2YWwgJiYgdmFsLmNvbnN0cnVjdG9yICYmIHZhbC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcblxuLy8gdmFsIC0+IEJvb2xcbnZhciBpc1ByaW1pdGl2ZSA9IGV4cG9ydHMuaXNQcmltaXRpdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiBpc1ZhbHVlKHZhbCkgJiYgIWlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNGdW5jdGlvbih2YWwpO1xufTtcblxuLy8gdmFsIC0+IEJvb2xcbnZhciBpc1VuZGVmaW5lZCA9IGV4cG9ydHMuaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IHZvaWQgMDtcbn07XG5cbi8vIHZhbCAtPiBCb29sXG52YXIgaXNWYWx1ZSA9IGV4cG9ydHMuaXNWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICFpc051bGwodmFsKSAmJiAhaXNVbmRlZmluZWQodmFsKTtcbn07XG5cbi8vIFthcnJheV0sIG4gLT4gW2FycmF5XVxudmFyIGxhc3QgPSBleHBvcnRzLmxhc3QgPSBmdW5jdGlvbiAoYXJyYXksIG4pIHtcbiAgaWYgKCFhcnJheS5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGxlbiA9IG4gPyBhcnJheS5sZW5ndGggLSBuIDogYXJyYXkubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5LCBsZW4sIGFycmF5Lmxlbmd0aClcbn07XG5cbi8vIHtvYmp9IC0+IHtvYmp9XG52YXIgbnVsbGlmeSA9IGV4cG9ydHMubnVsbGlmeSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdHJhdmVyc2Uob2JqLCBmdW5jdGlvbihfb2JqLCBuKSB7XG4gICAgX29ialtuXSA9IGlzQXJyYXkoX29ialtuXSkgPyBbXSA6IG51bGw7XG4gIH0pO1xuICByZXR1cm4gb2JqXG59O1xuXG4vLyBmbnMgLT4gZm5cbnZhciBwaXBlID0gZXhwb3J0cy5waXBlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBhcmd1bWVudHNbMF07XG4gIHZhciBmbnMgPSBhcmd1bWVudHM7XG4gIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB4ID0gZm5zW2ldKHgpO1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfVxufTtcblxuLy8ge29ian0sIFtwYXRoXSAgLT4gdmFsdWVcbnZhciByZWFkUGF0aCA9IGV4cG9ydHMucmVhZFBhdGggPSBmdW5jdGlvbiAob2JqLCBwYXRoKSB7XG4gIGlmICghcGF0aC5sZW5ndGgpIHJldHVybjtcbiAgaWYgKHBhdGgubGVuZ3RoID4gMSkgcmV0dXJuIHJlYWRQYXRoKG9ialtwYXRoWzBdXSwgcGF0aC5zbGljZSgxKSk7XG4gIHJldHVybiBvYmpbcGF0aFswXV07XG59O1xuXG4vLyB2YWwgLT4gW3ZhbF1cbnZhciB0b0FycmF5ID0gZXhwb3J0cy50b0FycmF5ID0gZnVuY3Rpb24gKHZhbCkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsKSB8fCBpc051bGwodmFsKSkgcmV0dXJuIFtdO1xuICBpZiAoaXNBcnJheSh2YWwpKSByZXR1cm4gdmFsO1xuICByZXR1cm4gW3ZhbF07XG59O1xuXG4vLyB7c291cmNlfSwgZm4oe3NvdXJjZX0sIHt0YXJnZXR9LCBuLCBbcGF0aF0pLCB7dGFyZ2V0fSAtPiB2b2lkIFxudmFyIHRyYXZlcnNlID0gZXhwb3J0cy50cmF2ZXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZuLCB0YXJnZXQpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgZnVuY3Rpb24gdmlzaXQgKHNvdXJjZSwgdGFyZ2V0LCBmbikge1xuICAgIGZvciAodmFyIG4gaW4gc291cmNlKSB7XG4gICAgICBwYXRoLnB1c2gobik7XG4gICAgICBpZiAoaXNPYmplY3Qoc291cmNlW25dKSkge1xuICAgICAgICB2aXNpdChzb3VyY2Vbbl0sIHRhcmdldCwgZm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4oc291cmNlLCBuLCB0YXJnZXQsIHBhdGguc2xpY2UoMCkpO1xuICAgICAgfVxuICAgICAgcGF0aC5wb3AoKTtcbiAgICB9XG4gIH1cbiAgdmlzaXQoc291cmNlLCB0YXJnZXQsIGZuKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8vIHZhbCAtPiBpbnB1dCAtPiB2YWxcbnZhciB2YWx1ZSA9IGV4cG9ydHMudmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoaXNWYWx1ZSh2YWwpICYmIGlzVmFsdWUoaW5wdXQpKSByZXR1cm4gdmFsO1xuICB9XG59O1xuXG5cblxuXG4iLCJ2YXIgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG52YXIgbGliID0gcmVxdWlyZSgnLi9saWIuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtSW5kZXggKG9iaikge1xuICAgIHZhciBpbmRleCA9IHt9O1xuICAgIGxpYi50cmF2ZXJzZSAob2JqLCBmdW5jdGlvbiAoX29iaiwgbikge1xuICAgICAgdmFyIHBhdGggPSBsaWIuZmluZFBhdGgocmVhZGVyLCBfb2JqW25dKSxcbiAgICAgICAgZm4gPSBsaWIuaXNGdW5jdGlvbihfb2JqW25dKSA/IF9vYmpbbl0gOiBsaWIuaWRlbnRpdHk7XG4gICAgICBpbmRleFtwYXRoVG9LZXkocGF0aCldID0gZm47IFxuICAgIH0pO1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRyYW5zZm9ybSAoc291cmNlcywga2V5KSB7XG4gICAgaWYgKCFzb3VyY2VzIHx8ICFzb3VyY2VzLmxlbmd0aCkgcmV0dXJuIGxpYi5pZGVudGl0eTtcbiAgICBpZiAoIWxpYi5pc0FycmF5KHNvdXJjZXMpKSByZXR1cm47XG4gICAgdmFyIGZucyA9IHNvdXJjZXMubWFwKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgaWYgKGxpYi5pc0Z1bmN0aW9uKHNvdXJjZSkpIHJldHVybiBzb3VyY2U7XG4gICAgICBpZiAobGliLmlzT2JqZWN0KHNvdXJjZSkpIHJldHVybiBsaWIuaXNGdW5jdGlvbihzb3VyY2Vba2V5XSkgPyBzb3VyY2Vba2V5XSA6IGxpYi5pZGVudGl0eTtcbiAgICAgIHJldHVybiBmKHNvdXJjZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpYi5waXBlLmFwcGx5KG51bGwsIGZucyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBc3NpZ25lciAob2JqLCBrZXksIHRyYW5zZm9ybXMpIHtcbiAgICB0cmFuc2Zvcm1zID0gdHJhbnNmb3JtcyB8fCBbXTtcbiAgICBpZiAobGliLmlzRnVuY3Rpb24ob2JqW2tleV0pKSB0cmFuc2Zvcm1zLnB1c2gob2JqW2tleV0pO1xuICAgIHZhciBmbiA9IGdldFRyYW5zZm9ybSh0cmFuc2Zvcm1zLCBrZXkpO1xuICAgIGZuID0gbGliLmlzRnVuY3Rpb24oZm4pID8gZm4gOiBsaWIuaWRlbnRpdHk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIG9ialtrZXldID0gZm4odmFsLCBvYmosIGtleSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGhUb0tleSAocGF0aCkge1xuICAgIHJldHVybiBwYXRoLmpvaW4oJzo6fHwnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleVRvUGF0aCAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5zcGxpdCgnOjp8fCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGF0aHNGb3JPYmogKHJlYWRlciwgb2JqKSB7XG4gICAgdmFyIHBhdGhzID0ge307XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgIHZhciB2YWwgPSBvYmpba10gO1xuICAgICAgaWYgKGxpYi5pc09iamVjdCh2YWwpKSBcbiAgICAgICAgcmV0dXJuIGdldFBhdGhzRm9yT2JqKHJlYWRlciwgdmFsKTtcbiAgICAgIGlmIChsaWIuaXNGdW5jdGlvbih2YWwpKSB2YWwgPSB2YWwubmFtZTtcbiAgICAgIHBhdGhzW3ZhbF0gPSBsaWIuZmluZFBhdGgocmVhZGVyLCB2YWwsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aHM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXRocyAocmVhZGVyLCBvYmopIHtcbiAgICB2YXIgdGFyZ2V0UGF0aHMgPSBnZXRQYXRoc0Zvck9iaihyZWFkZXIsIG9iaiksXG4gICAgICByZXN1bHQgPSB7YXJyYXlzOiBbXSwgbm9uQXJyYXlzOiBbXX07XG4gICAgZm9yICh2YXIgdG4gaW4gdGFyZ2V0UGF0aHMpIHtcbiAgICAgIHZhciBkZXB0aCA9IHRhcmdldFBhdGhzW3RuXS5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPT09IFwiMFwiO1xuICAgICAgfSkubGVuZ3RoO1xuICAgICAgaWYgKGRlcHRoID09PSAwKSByZXN1bHQubm9uQXJyYXlzLnB1c2godGFyZ2V0UGF0aHNbdG5dKTtcbiAgICAgIGlmIChkZXB0aCA9PT0gMSkgcmVzdWx0LmFycmF5cy5wdXNoKHRhcmdldFBhdGhzW3RuXS5zbGljZSgwLCB0YXJnZXRQYXRoc1t0bl0uaW5kZXhPZihcIjBcIikpKTtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHRocm93IG5ldyBFcnJvciAoXCJVbmFibGUgdG8gbWFwIG5lc3RlZCBhcnJheXNcIiwgXCJ2b29tLmpzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXhBcnJheU1hcCAoaW5kZXgsIGluZGV4S2V5LCB3cml0ZXIsIHdyaXRlcktleSwgcmVhZGVyTm9kZSwgd3JpdGVyQXJyYXkpIHtcbiAgICBpbmRleFtpbmRleEtleV0gPSBnZXRBc3NpZ25lcih3cml0ZXIsIHdyaXRlcktleSwgW2YocmVhZGVyTm9kZSwgd3JpdGVyQXJyYXkpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmRleEFycmF5TWVyZ2VzIChpbmRleCwgcGF0aHMsIHNvdXJjZSwgbiwgcmVhZGVyLCB3cml0ZXIsIHRyYW5zZm9ybXMpIHtcbiAgICBmb3IgKHZhciBpIGluIHBhdGhzKSB7XG4gICAgICBpZiAocGF0aHNbaV0ubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZWFkZXJWYWwgPSBsaWIucmVhZFBhdGgocmVhZGVyLCBwYXRoc1tpXSlbMF07XG4gICAgICAgIHZhciBtYXBGbiA9IGYocmVhZGVyVmFsLCBzb3VyY2Vbbl1bMF0pO1xuICAgICAgICB2YXIgbWVyZ2VGbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICAgIHZhciBuZXdPYmogPSBtYXBGbihsZWZ0KTtcbiAgICAgICAgICByZXR1cm4gbGliLnRyYXZlcnNlKG5ld09iaiwgZnVuY3Rpb24oX25ld09iaiwgbiwgdGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoIWxpYi5pc051bGwoX25ld09ialtuXSkpIHRhcmdldFtuXSA9IF9uZXdPYmpbbl07XG4gICAgICAgICAgfSwgcmlnaHQpO1xuICAgICAgICB9O1xuICAgICAgICBpbmRleFtwYXRoVG9LZXkocGF0aHNbaV1bMF0pXSA9IGxpYi5kZWxheShnZXRBc3NpZ25lcihzb3VyY2UsIG4sIFxuICAgICAgICAgIFtmdW5jdGlvbihyZWFkZXJDb2xsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGliLmRpc3RyaWJ1dGUocmVhZGVyQ29sbCwgc291cmNlW25dLCBtZXJnZUZuKTtcbiAgICAgICAgICB9XSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluZGV4Tm9uQXJyYXlNYXBzIChpbmRleCwgcGF0aHMsIF93cml0ZXIsIG4sIHJlYWRlciwgd3JpdGVyLCB0cmFuc2Zvcm1zKSB7XG4gICAgZm9yICh2YXIgbmEgaW4gcGF0aHMpIHtcbiAgICAgIHZhciBub25BcnJheVBhdGggPSBwYXRoc1tuYV07XG4gICAgICB2YXIgcmVhZGVyVmFsID0gbGliLnJlYWRQYXRoKHJlYWRlciwgbm9uQXJyYXlQYXRoKTtcbiAgICAgIHZhciBrZXlUb1dyaXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHNuIGluIF93cml0ZXJbbl1bMF0pIHtcbiAgICAgICAgICBpZiAoX3dyaXRlcltuXVswXVtzbl0gPT09IHJlYWRlclZhbCkgcmV0dXJuIHNuO1xuICAgICAgICB9XG4gICAgICB9KCk7XG4gICAgICB2YXIgbWFwRm4gPSBmdW5jdGlvbiAodmFsLCBvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gb2JqW2tleV0ubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICBpZiAobGliLmlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtW2tleVRvV3JpdGVdID0gdmFsO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB2YXIgYXNzaWduZXIgPSBsaWIuZGVsYXkoZ2V0QXNzaWduZXIoX3dyaXRlciwgbiwgW21hcEZuXSkpO1xuICAgICAgaW5kZXhbcGF0aFRvS2V5KG5vbkFycmF5UGF0aCldID0gYXNzaWduZXI7XG4gICAgfSBcbiAgfVxuXG4gIGZ1bmN0aW9uIGluZGV4Q29sbGVjdGlvbiAoaW5kZXgsIF93cml0ZXIsIG4sIHJlYWRlciwgd3JpdGVyLCB0cmFuc2Zvcm1zKSB7XG4gICAgdmFyIHBhdGhzID0gZ2V0UGF0aHMocmVhZGVyLCBfd3JpdGVyW25dKSxcbiAgICAgIGFycmF5UGF0aHMgPSBwYXRocy5hcnJheXMsXG4gICAgICBub25BcnJheVBhdGhzID0gcGF0aHMubm9uQXJyYXlzLFxuICAgICAgcGF0aEdyb3VwcyA9IGxpYi5ncm91cEFycmF5cyhhcnJheVBhdGhzKS5zb3J0KGZ1bmN0aW9uIChhLGIpe1xuICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgIH0pO1xuICAgIGlmIChwYXRoR3JvdXBzLmxlbmd0aCkge1xuICAgICAgdmFyIHRvcFBhdGggPSBwYXRoR3JvdXBzWzBdLCBcbiAgICAgICAgb3RoZXJQYXRocyA9IHBhdGhHcm91cHMuc2xpY2UoMSk7XG4gICAgICBpZiAodG9wUGF0aC5sZW5ndGgpIFxuICAgICAgICBpbmRleEFycmF5TWFwKGluZGV4LCBwYXRoVG9LZXkodG9wUGF0aFswXSksIF93cml0ZXIsIG4sIGxpYi5yZWFkUGF0aChyZWFkZXIsIHRvcFBhdGhbMF0pLCBfd3JpdGVyW25dKTtcbiAgICAgIGlmIChvdGhlclBhdGhzLmxlbmd0aClcbiAgICAgICAgaW5kZXhBcnJheU1lcmdlcyhpbmRleCwgb3RoZXJQYXRocywgX3dyaXRlciwgbiwgcmVhZGVyLCB3cml0ZXIsIHRyYW5zZm9ybXMpO1xuICAgIH1cbiAgICBpZiAobm9uQXJyYXlQYXRocy5sZW5ndGgpIHtcbiAgICAgIGluZGV4Tm9uQXJyYXlNYXBzIChpbmRleCwgbm9uQXJyYXlQYXRocywgX3dyaXRlciwgbiwgcmVhZGVyLCB3cml0ZXIsIHRyYW5zZm9ybXMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1hcEluZGV4IChyZWFkZXIsIHdyaXRlciwgdHJhbnNmb3Jtcykge1xuICAgIHRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zIHx8IFtdO1xuICAgIHJldHVybiBsaWIudHJhdmVyc2UgKHdyaXRlciwgZnVuY3Rpb24gKF93cml0ZXIsIG4sIGluZGV4KSB7XG4gICAgICBpZiAobGliLmlzQXJyYXkoX3dyaXRlcltuXSkpIHtcbiAgICAgICAgaWYgKGxpYi5pc09iamVjdChfd3JpdGVyW25dWzBdKSkge1xuICAgICAgICAgIGluZGV4Q29sbGVjdGlvbihpbmRleCwgX3dyaXRlciwgbiwgcmVhZGVyLCB3cml0ZXIsIHRyYW5zZm9ybXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGF0aCA9IGxpYi5maW5kUGF0aChyZWFkZXIsIF93cml0ZXJbbl0pO1xuICAgICAgICB2YXIgcmVhZGVyVmFsID0gbGliLnJlYWRQYXRoKHJlYWRlciwgcGF0aCk7XG4gICAgICAgIGlmIChwYXRoICYmIHJlYWRlclZhbCkge1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBsaWIuaXNGdW5jdGlvbihyZWFkZXJWYWwpID8gcmVhZGVyVmFsIDogW107XG4gICAgICAgICAgaW5kZXhbcGF0aFRvS2V5KHBhdGgpXSA9IGdldEFzc2lnbmVyKF93cml0ZXIsIG4sIHRyYW5zZm9ybXMuY29uY2F0KHRyYW5zZm9ybSkpO1xuICAgICAgICB9IFxuICAgICAgfVxuICAgIH0sIHt9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcHBlciAocmVhZGVyLCB3cml0ZXIsIHRyYW5zZm9ybXMpIHtcbiAgICB2YXIgaW5kZXggPSBnZXRNYXBJbmRleCAocmVhZGVyLCB3cml0ZXIsIHRyYW5zZm9ybXMpIHx8IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgIHdyaXRlciA9IGxpYi5udWxsaWZ5KHdyaXRlcik7XG4gICAgICBsaWIudHJhdmVyc2UoaW5kZXgsIGZ1bmN0aW9uKF9pbmRleCwgbikge1xuICAgICAgICB2YXIgd3JpdGVGbiA9IF9pbmRleFtuXTtcbiAgICAgICAgdmFyIHZhbCA9IGxpYi5yZWFkUGF0aChvYmosIGtleVRvUGF0aChuKSk7XG4gICAgICAgIGlmIChsaWIuaXNGdW5jdGlvbih3cml0ZUZuKSAmJiB3cml0ZUZuLm5hbWUgPT09ICdkZWxheWVkJylcbiAgICAgICAgICBxdWV1ZS5wdXNoKHdyaXRlRm4sIHZhbCk7XG4gICAgICAgIGlmIChsaWIuaXNGdW5jdGlvbih3cml0ZUZuKSkgd3JpdGVGbih2YWwpO1xuICAgICAgfSwgd3JpdGVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKz0yKVxuICAgICAgICBxdWV1ZVtpXSgpLmNhbGwobnVsbCwgcXVldWVbaSsxXSk7XG4gICAgICByZXR1cm4gbGliLmNsb25lKHdyaXRlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGlmICghYXJncy5sZW5ndGgpIHJldHVybiBsaWIuaWRlbnRpdHk7XG4gICAgdmFyIHJlYWRlciA9IGFyZ3NbMF0sIFxuICAgICAgd3JpdGVyID0gYXJncy5sZW5ndGggPiAxID8gbGliLmxhc3QoYXJncywgMSlbMF0gOiBudWxsLFxuICAgICAgdHJhbnNmb3JtcyA9IGFyZ3MubGVuZ3RoID4gMiA/IGFyZ3Muc2xpY2UoMSwgYXJncy5sZW5ndGggLSAxKSA6IFtdO1xuICAgIGlmIChsaWIuaXNPYmplY3Qod3JpdGVyKSkgd3JpdGVyID0gbGliLmNsb25lKHdyaXRlcilcblxuICAgIGlmIChsaWIuaXNGdW5jdGlvbihyZWFkZXIpICYmIGFyZ3MubGVuZ3RoID09PSAxKSBcbiAgICAgIHJldHVybiByZWFkZXI7XG5cbiAgICBpZiAobGliLmV2ZXJ5KGFyZ3MsIGxpYi5pc0Z1bmN0aW9uLmJpbmQobGliKSkpXG4gICAgICByZXR1cm4gbGliLnBpcGUocmVhZGVyLCBnZXRUcmFuc2Zvcm0odHJhbnNmb3JtcyksIHdyaXRlcik7XG5cbiAgICBpZiAobGliLmlzRnVuY3Rpb24od3JpdGVyKSlcbiAgICAgIHJldHVybiBsaWIucGlwZShmLmFwcGx5KG51bGwsIGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKSksIHdyaXRlcik7XG5cbiAgICBpZiAobGliLmlzRnVuY3Rpb24ocmVhZGVyKSlcbiAgICAgIHJldHVybiBsaWIucGlwZShyZWFkZXIsIGYuYXBwbHkobnVsbCwgYXJncy5zbGljZSgxKSkpO1xuXG4gICAgaWYgKGxpYi5pc09iamVjdChyZWFkZXIpICYmIGFyZ3MubGVuZ3RoID09PSAxKSBcbiAgICAgIHJldHVybiBtYXBwZXIocmVhZGVyLCByZWFkZXIpO1xuXG4gICAgaWYgKGxpYi5pc09iamVjdChyZWFkZXIpICYmIGxpYi5pc09iamVjdCh3cml0ZXIpKSBcbiAgICAgIHJldHVybiBtYXBwZXIocmVhZGVyLCB3cml0ZXIsIHRyYW5zZm9ybXMpO1xuXG4gICAgaWYgKGxpYi5pc09iamVjdChyZWFkZXIpICYmIGxpYi5pc0FycmF5KHdyaXRlcikpIFxuICAgICAgcmV0dXJuIGxpYi5waXBlKGxpYi50b0FycmF5LCBmKFtyZWFkZXJdLCB3cml0ZXIpKTtcblxuICAgIGlmIChsaWIuaXNBcnJheShyZWFkZXIpICYmIGFyZ3MubGVuZ3RoID09PSAxKSBcbiAgICAgIHJldHVybiBsaWIuY29sbGVjdG9yKGYocmVhZGVyWzBdLCByZWFkZXJbMF0pKTtcblxuICAgIGlmIChsaWIuaXNBcnJheShyZWFkZXIpICYmIGxpYi5pc0FycmF5KHdyaXRlcikpIFxuICAgICAgcmV0dXJuIGxpYi5jb2xsZWN0b3IoZihyZWFkZXJbMF0sIHdyaXRlclswXSkpO1xuXG4gICAgaWYgKGxpYi5pc1ByaW1pdGl2ZShyZWFkZXIpICYmIGFyZ3MubGVuZ3RoID09PSAxKSBcbiAgICAgIHJldHVybiBsaWIuZ2F0ZShyZWFkZXIpO1xuXG4gICAgaWYgKGxpYi5pc1ByaW1pdGl2ZShyZWFkZXIpICYmIGxpYi5pc1ByaW1pdGl2ZSh3cml0ZXIpKSBcbiAgICAgIHJldHVybiBsaWIucGlwZShsaWIuZ2F0ZShyZWFkZXIpLCBnZXRUcmFuc2Zvcm0odHJhbnNmb3JtcyksIGxpYi52YWx1ZSh3cml0ZXIpKTtcblxuICAgIHRocm93IG5ldyBFcnJvciAoXCJJbnZhbGlkIGFyZ3VtZW50c1wiLCBcInZvb20uanNcIik7XG5cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZjogZixcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uXG4gIH07XG5cbn0oKTtcblxuIiwiLypcbiBDb3B5cmlnaHQgMjAxMS0yMDEzIEFiZHVsbGEgQWJkdXJha2htYW5vdlxuIE9yaWdpbmFsIHNvdXJjZXMgYXJlIGF2YWlsYWJsZSBhdCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3gyanMvXG5cbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogTW9kaWZpZWQgYnkgSmVrYU1vcm96IGZvciBucG0gdXNhZ2VcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFgySlMoY29uZmlnKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFZFUlNJT04gPSBcIjEuMS44XCI7XG5cbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgaW5pdENvbmZpZ0RlZmF1bHRzKCk7XG4gICAgaW5pdFJlcXVpcmVkUG9seWZpbGxzKCk7XG5cbiAgICBmdW5jdGlvbiBpbml0Q29uZmlnRGVmYXVsdHMoKSB7XG4gICAgICAgIGlmKGNvbmZpZy5lc2NhcGVNb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5lc2NhcGVNb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuYXR0cmlidXRlUHJlZml4ID0gY29uZmlnLmF0dHJpYnV0ZVByZWZpeCB8fCBcIl9cIjtcbiAgICAgICAgY29uZmlnLmFycmF5QWNjZXNzRm9ybSA9IGNvbmZpZy5hcnJheUFjY2Vzc0Zvcm0gfHwgXCJub25lXCI7XG4gICAgICAgIGNvbmZpZy5lbXB0eU5vZGVGb3JtID0gY29uZmlnLmVtcHR5Tm9kZUZvcm0gfHwgXCJ0ZXh0XCI7XG4gICAgICAgIGlmKGNvbmZpZy5lbmFibGVUb1N0cmluZ0Z1bmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uZmlnLmVuYWJsZVRvU3RyaW5nRnVuYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLmFycmF5QWNjZXNzRm9ybVBhdGhzID0gY29uZmlnLmFycmF5QWNjZXNzRm9ybVBhdGhzIHx8IFtdO1xuICAgICAgICBpZihjb25maWcuc2tpcEVtcHR5VGV4dE5vZGVzRm9yT2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5za2lwRW1wdHlUZXh0Tm9kZXNGb3JPYmogPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKGNvbmZpZy5zdHJpcFdoaXRlc3BhY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5zdHJpcFdoaXRlc3BhY2VzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuZGF0ZXRpbWVBY2Nlc3NGb3JtUGF0aHMgPSBjb25maWcuZGF0ZXRpbWVBY2Nlc3NGb3JtUGF0aHMgfHwgW107XG4gICAgfVxuXG4gICAgdmFyIERPTU5vZGVUeXBlcyA9IHtcbiAgICAgICAgRUxFTUVOVF9OT0RFIFx0ICAgOiAxLFxuICAgICAgICBURVhUX05PREUgICAgXHQgICA6IDMsXG4gICAgICAgIENEQVRBX1NFQ1RJT05fTk9ERSA6IDQsXG4gICAgICAgIENPTU1FTlRfTk9ERVx0ICAgOiA4LFxuICAgICAgICBET0NVTUVOVF9OT0RFIFx0ICAgOiA5XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGluaXRSZXF1aXJlZFBvbHlmaWxscygpIHtcbiAgICAgICAgZnVuY3Rpb24gcGFkKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIHIgPSBTdHJpbmcobnVtYmVyKTtcbiAgICAgICAgICAgIGlmICggci5sZW5ndGggPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgciA9ICcwJyArIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIZWxsbyBJRTgtXG4gICAgICAgIGlmKHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRyaW0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoL15cXHMrfF5cXG4rfChcXHN8XFxuKSskL2csICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih0eXBlb2YgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEltcGxlbWVudGF0aW9uIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTczNTIxL2hvdy1kby1pLW91dHB1dC1hbi1pc28tODYwMS1mb3JtYXR0ZWQtc3RyaW5nLWluLWphdmFzY3JpcHRcbiAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKVxuICAgICAgICAgICAgICAgICAgICArICctJyArIHBhZCggdGhpcy5nZXRVVENNb250aCgpICsgMSApXG4gICAgICAgICAgICAgICAgICAgICsgJy0nICsgcGFkKCB0aGlzLmdldFVUQ0RhdGUoKSApXG4gICAgICAgICAgICAgICAgICAgICsgJ1QnICsgcGFkKCB0aGlzLmdldFVUQ0hvdXJzKCkgKVxuICAgICAgICAgICAgICAgICAgICArICc6JyArIHBhZCggdGhpcy5nZXRVVENNaW51dGVzKCkgKVxuICAgICAgICAgICAgICAgICAgICArICc6JyArIHBhZCggdGhpcy5nZXRVVENTZWNvbmRzKCkgKVxuICAgICAgICAgICAgICAgICAgICArICcuJyArIFN0cmluZyggKHRoaXMuZ2V0VVRDTWlsbGlzZWNvbmRzKCkvMTAwMCkudG9GaXhlZCgzKSApLnNsaWNlKCAyLCA1IClcbiAgICAgICAgICAgICAgICAgICAgKyAnWic7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Tm9kZUxvY2FsTmFtZSggbm9kZSApIHtcbiAgICAgICAgdmFyIG5vZGVMb2NhbE5hbWUgPSBub2RlLmxvY2FsTmFtZTtcbiAgICAgICAgaWYobm9kZUxvY2FsTmFtZSA9PSBudWxsKSAvLyBZZWFoLCB0aGlzIGlzIElFISFcbiAgICAgICAgICAgIG5vZGVMb2NhbE5hbWUgPSBub2RlLmJhc2VOYW1lO1xuICAgICAgICBpZihub2RlTG9jYWxOYW1lID09IG51bGwgfHwgbm9kZUxvY2FsTmFtZT09XCJcIikgLy8gPT1cIlwiIGlzIElFIHRvb1xuICAgICAgICAgICAgbm9kZUxvY2FsTmFtZSA9IG5vZGUubm9kZU5hbWU7XG4gICAgICAgIHJldHVybiBub2RlTG9jYWxOYW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE5vZGVQcmVmaXgobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5wcmVmaXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlWG1sQ2hhcnMoc3RyKSB7XG4gICAgICAgIGlmKHR5cGVvZihzdHIpID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykucmVwbGFjZSgvJy9nLCAnJiN4Mjc7JykucmVwbGFjZSgvXFwvL2csICcmI3gyRjsnKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmVzY2FwZVhtbENoYXJzKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyZhbXA7L2csICcmJykucmVwbGFjZSgvJmx0Oy9nLCAnPCcpLnJlcGxhY2UoLyZndDsvZywgJz4nKS5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJykucmVwbGFjZSgvJiN4Mjc7L2csIFwiJ1wiKS5yZXBsYWNlKC8mI3gyRjsvZywgJ1xcLycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXlBY2Nlc3NGb3JtKG9iaiwgY2hpbGROYW1lLCBwYXRoKSB7XG4gICAgICAgIHN3aXRjaChjb25maWcuYXJyYXlBY2Nlc3NGb3JtKSB7XG4gICAgICAgICAgICBjYXNlIFwicHJvcGVydHlcIjpcbiAgICAgICAgICAgICAgICBpZighKG9ialtjaGlsZE5hbWVdIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgICAgICAgICAgICAgICBvYmpbY2hpbGROYW1lK1wiX2FzQXJyYXlcIl0gPSBbb2JqW2NoaWxkTmFtZV1dO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqW2NoaWxkTmFtZStcIl9hc0FycmF5XCJdID0gb2JqW2NoaWxkTmFtZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKmNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICAgYnJlYWs7Ki9cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCEob2JqW2NoaWxkTmFtZV0gaW5zdGFuY2VvZiBBcnJheSkgJiYgY29uZmlnLmFycmF5QWNjZXNzRm9ybVBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICAgICAgZm9yKDsgaWR4IDwgY29uZmlnLmFycmF5QWNjZXNzRm9ybVBhdGhzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlQYXRoID0gY29uZmlnLmFycmF5QWNjZXNzRm9ybVBhdGhzW2lkeF07XG4gICAgICAgICAgICAgICAgaWYoIHR5cGVvZiBhcnJheVBhdGggPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFycmF5UGF0aCA9PSBwYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpZiggYXJyYXlQYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFycmF5UGF0aC50ZXN0KHBhdGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpZiggdHlwZW9mIGFycmF5UGF0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFycmF5UGF0aChvYmosIGNoaWxkTmFtZSwgcGF0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihpZHghPWNvbmZpZy5hcnJheUFjY2Vzc0Zvcm1QYXRocy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmpbY2hpbGROYW1lXSA9IFtvYmpbY2hpbGROYW1lXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tWG1sRGF0ZVRpbWUocHJvcCkge1xuICAgICAgICAvLyBJbXBsZW1lbnRhdGlvbiBiYXNlZCB1cCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzgxNzg1OTgveG1sLWRhdGV0aW1lLXRvLWphdmFzY3JpcHQtZGF0ZS1vYmplY3RcbiAgICAgICAgLy8gSW1wcm92ZWQgdG8gc3VwcG9ydCBmdWxsIHNwZWMgYW5kIG9wdGlvbmFsIHBhcnRzXG4gICAgICAgIHZhciBiaXRzID0gcHJvcC5zcGxpdCgvWy1UOitaXS9nKTtcblxuICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKGJpdHNbMF0sIGJpdHNbMV0tMSwgYml0c1syXSk7XG4gICAgICAgIHZhciBzZWNvbmRCaXRzID0gYml0c1s1XS5zcGxpdChcIlxcLlwiKTtcbiAgICAgICAgZC5zZXRIb3VycyhiaXRzWzNdLCBiaXRzWzRdLCBzZWNvbmRCaXRzWzBdKTtcbiAgICAgICAgaWYoc2Vjb25kQml0cy5sZW5ndGg+MSlcbiAgICAgICAgICAgIGQuc2V0TWlsbGlzZWNvbmRzKHNlY29uZEJpdHNbMV0pO1xuXG4gICAgICAgIC8vIEdldCBzdXBwbGllZCB0aW1lIHpvbmUgb2Zmc2V0IGluIG1pbnV0ZXNcbiAgICAgICAgaWYoYml0c1s2XSAmJiBiaXRzWzddKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0TWludXRlcyA9IGJpdHNbNl0gKiA2MCArIE51bWJlcihiaXRzWzddKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gL1xcZFxcZC1cXGRcXGQ6XFxkXFxkJC8udGVzdChwcm9wKT8gJy0nIDogJysnO1xuXG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgc2lnblxuICAgICAgICAgICAgb2Zmc2V0TWludXRlcyA9IDAgKyAoc2lnbiA9PSAnLSc/IC0xICogb2Zmc2V0TWludXRlcyA6IG9mZnNldE1pbnV0ZXMpO1xuXG4gICAgICAgICAgICAvLyBBcHBseSBvZmZzZXQgYW5kIGxvY2FsIHRpbWV6b25lXG4gICAgICAgICAgICBkLnNldE1pbnV0ZXMoZC5nZXRNaW51dGVzKCkgLSBvZmZzZXRNaW51dGVzIC0gZC5nZXRUaW1lem9uZU9mZnNldCgpKVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgaWYocHJvcC5pbmRleE9mKFwiWlwiLCBwcm9wLmxlbmd0aCAtIDEpICE9PSAtMSkge1xuICAgICAgICAgICAgZCA9IG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSwgZC5nZXRIb3VycygpLCBkLmdldE1pbnV0ZXMoKSwgZC5nZXRTZWNvbmRzKCksIGQuZ2V0TWlsbGlzZWNvbmRzKCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGQgaXMgbm93IGEgbG9jYWwgdGltZSBlcXVpdmFsZW50IHRvIHRoZSBzdXBwbGllZCB0aW1lXG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrRnJvbVhtbERhdGVUaW1lUGF0aHModmFsdWUsIGNoaWxkTmFtZSwgZnVsbFBhdGgpIHtcbiAgICAgICAgaWYoY29uZmlnLmRhdGV0aW1lQWNjZXNzRm9ybVBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gZnVsbFBhdGguc3BsaXQoXCJcXC4jXCIpWzBdO1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICBmb3IoOyBpZHggPCBjb25maWcuZGF0ZXRpbWVBY2Nlc3NGb3JtUGF0aHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHZhciBkdFBhdGggPSBjb25maWcuZGF0ZXRpbWVBY2Nlc3NGb3JtUGF0aHNbaWR4XTtcbiAgICAgICAgICAgICAgICBpZiggdHlwZW9mIGR0UGF0aCA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZHRQYXRoID09IHBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGlmKCBkdFBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZHRQYXRoLnRlc3QocGF0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGlmKCB0eXBlb2YgZHRQYXRoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZHRQYXRoKG9iaiwgY2hpbGROYW1lLCBwYXRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGlkeCE9Y29uZmlnLmRhdGV0aW1lQWNjZXNzRm9ybVBhdGhzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tWG1sRGF0ZVRpbWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VET01DaGlsZHJlbiggbm9kZSwgcGF0aCApIHtcbiAgICAgICAgaWYobm9kZS5ub2RlVHlwZSA9PSBET01Ob2RlVHlwZXMuRE9DVU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBPYmplY3Q7XG4gICAgICAgICAgICB2YXIgbm9kZUNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgLy8gQWx0ZXJuYXRpdmUgZm9yIGZpcnN0RWxlbWVudENoaWxkIHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gc29tZSBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgIGZvcih2YXIgY2lkeD0wOyBjaWR4IDxub2RlQ2hpbGRyZW4ubGVuZ3RoOyBjaWR4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlQ2hpbGRyZW4uaXRlbShjaWR4KTtcbiAgICAgICAgICAgICAgICBpZihjaGlsZC5ub2RlVHlwZSA9PSBET01Ob2RlVHlwZXMuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZE5hbWUgPSBnZXROb2RlTG9jYWxOYW1lKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2NoaWxkTmFtZV0gPSBwYXJzZURPTUNoaWxkcmVuKGNoaWxkLCBjaGlsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICBpZihub2RlLm5vZGVUeXBlID09IERPTU5vZGVUeXBlcy5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgT2JqZWN0O1xuICAgICAgICAgICAgcmVzdWx0Ll9fY250PTA7XG5cbiAgICAgICAgICAgIHZhciBub2RlQ2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICAgIC8vIENoaWxkcmVuIG5vZGVzXG4gICAgICAgICAgICBmb3IodmFyIGNpZHg9MDsgY2lkeCA8bm9kZUNoaWxkcmVuLmxlbmd0aDsgY2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZUNoaWxkcmVuLml0ZW0oY2lkeCk7IC8vIG5vZGVDaGlsZHJlbltjaWR4XTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROYW1lID0gZ2V0Tm9kZUxvY2FsTmFtZShjaGlsZCk7XG5cbiAgICAgICAgICAgICAgICBpZihjaGlsZC5ub2RlVHlwZSE9IERPTU5vZGVUeXBlcy5DT01NRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Ll9fY250Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdFtjaGlsZE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjaGlsZE5hbWVdID0gcGFyc2VET01DaGlsZHJlbihjaGlsZCwgcGF0aCtcIi5cIitjaGlsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9BcnJheUFjY2Vzc0Zvcm0ocmVzdWx0LCBjaGlsZE5hbWUsIHBhdGgrXCIuXCIrY2hpbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdFtjaGlsZE5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiggIShyZXN1bHRbY2hpbGROYW1lXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbY2hpbGROYW1lXSA9IFtyZXN1bHRbY2hpbGROYW1lXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvQXJyYXlBY2Nlc3NGb3JtKHJlc3VsdCwgY2hpbGROYW1lLCBwYXRoK1wiLlwiK2NoaWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3VsdFtjaGlsZE5hbWVdKVtyZXN1bHRbY2hpbGROYW1lXS5sZW5ndGhdID0gcGFyc2VET01DaGlsZHJlbihjaGlsZCwgcGF0aCtcIi5cIitjaGlsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdHRyaWJ1dGVzXG4gICAgICAgICAgICBmb3IodmFyIGFpZHg9MDsgYWlkeCA8bm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgYWlkeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXMuaXRlbShhaWR4KTsgLy8gW2FpZHhdO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5fX2NudCsrO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtjb25maWcuYXR0cmlidXRlUHJlZml4K2F0dHIubmFtZV09YXR0ci52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm9kZSBuYW1lc3BhY2UgcHJlZml4XG4gICAgICAgICAgICB2YXIgbm9kZVByZWZpeCA9IGdldE5vZGVQcmVmaXgobm9kZSk7XG4gICAgICAgICAgICBpZihub2RlUHJlZml4IT1udWxsICYmIG5vZGVQcmVmaXghPVwiXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuX19jbnQrKztcbiAgICAgICAgICAgICAgICByZXN1bHQuX19wcmVmaXg9bm9kZVByZWZpeDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYocmVzdWx0W1wiI3RleHRcIl0hPW51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuX190ZXh0ID0gcmVzdWx0W1wiI3RleHRcIl07XG4gICAgICAgICAgICAgICAgaWYocmVzdWx0Ll9fdGV4dCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5fX3RleHQgPSByZXN1bHQuX190ZXh0LmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGNvbmZpZy5lc2NhcGVNb2RlKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuX190ZXh0ID0gdW5lc2NhcGVYbWxDaGFycyhyZXN1bHQuX190ZXh0KTtcbiAgICAgICAgICAgICAgICBpZihjb25maWcuc3RyaXBXaGl0ZXNwYWNlcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Ll9fdGV4dCA9IHJlc3VsdC5fX3RleHQudHJpbSgpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbXCIjdGV4dFwiXTtcbiAgICAgICAgICAgICAgICBpZihjb25maWcuYXJyYXlBY2Nlc3NGb3JtPT1cInByb3BlcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbXCIjdGV4dF9hc0FycmF5XCJdO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5fX3RleHQgPSBjaGVja0Zyb21YbWxEYXRlVGltZVBhdGhzKHJlc3VsdC5fX3RleHQsIGNoaWxkTmFtZSwgcGF0aCtcIi5cIitjaGlsZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYocmVzdWx0W1wiI2NkYXRhLXNlY3Rpb25cIl0hPW51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuX19jZGF0YSA9IHJlc3VsdFtcIiNjZGF0YS1zZWN0aW9uXCJdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbXCIjY2RhdGEtc2VjdGlvblwiXTtcbiAgICAgICAgICAgICAgICBpZihjb25maWcuYXJyYXlBY2Nlc3NGb3JtPT1cInByb3BlcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbXCIjY2RhdGEtc2VjdGlvbl9hc0FycmF5XCJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggcmVzdWx0Ll9fY250ID09IDEgJiYgcmVzdWx0Ll9fdGV4dCE9bnVsbCAgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Ll9fdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmKCByZXN1bHQuX19jbnQgPT0gMCAmJiBjb25maWcuZW1wdHlOb2RlRm9ybT09XCJ0ZXh0XCIgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiAoIHJlc3VsdC5fX2NudCA+IDEgJiYgcmVzdWx0Ll9fdGV4dCE9bnVsbCAmJiBjb25maWcuc2tpcEVtcHR5VGV4dE5vZGVzRm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgaWYoIChjb25maWcuc3RyaXBXaGl0ZXNwYWNlcyAmJiByZXN1bHQuX190ZXh0PT1cIlwiKSB8fCAocmVzdWx0Ll9fdGV4dC50cmltKCk9PVwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQuX190ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQuX19jbnQ7XG5cbiAgICAgICAgICAgIGlmKCBjb25maWcuZW5hYmxlVG9TdHJpbmdGdW5jICYmIChyZXN1bHQuX190ZXh0IT1udWxsIHx8IHJlc3VsdC5fX2NkYXRhIT1udWxsICkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9fdGV4dCE9bnVsbD8gdGhpcy5fX3RleHQ6JycpKyggdGhpcy5fX2NkYXRhIT1udWxsID8gdGhpcy5fX2NkYXRhOicnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgaWYobm9kZS5ub2RlVHlwZSA9PSBET01Ob2RlVHlwZXMuVEVYVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT0gRE9NTm9kZVR5cGVzLkNEQVRBX1NFQ1RJT05fTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubm9kZVZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRUYWcoanNvbk9iaiwgZWxlbWVudCwgYXR0ckxpc3QsIGNsb3NlZCkge1xuICAgICAgICB2YXIgcmVzdWx0U3RyID0gXCI8XCIrICggKGpzb25PYmohPW51bGwgJiYganNvbk9iai5fX3ByZWZpeCE9bnVsbCk/IChqc29uT2JqLl9fcHJlZml4K1wiOlwiKTpcIlwiKSArIGVsZW1lbnQ7XG4gICAgICAgIGlmKGF0dHJMaXN0IT1udWxsKSB7XG4gICAgICAgICAgICBmb3IodmFyIGFpZHggPSAwOyBhaWR4IDwgYXR0ckxpc3QubGVuZ3RoOyBhaWR4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSBhdHRyTGlzdFthaWR4XTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0clZhbCA9IGpzb25PYmpbYXR0ck5hbWVdO1xuICAgICAgICAgICAgICAgIGlmKGNvbmZpZy5lc2NhcGVNb2RlKVxuICAgICAgICAgICAgICAgICAgICBhdHRyVmFsPWVzY2FwZVhtbENoYXJzKGF0dHJWYWwpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cis9XCIgXCIrYXR0ck5hbWUuc3Vic3RyKGNvbmZpZy5hdHRyaWJ1dGVQcmVmaXgubGVuZ3RoKStcIj0nXCIrYXR0clZhbCtcIidcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZighY2xvc2VkKVxuICAgICAgICAgICAgcmVzdWx0U3RyKz1cIj5cIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzdWx0U3RyKz1cIi8+XCI7XG4gICAgICAgIHJldHVybiByZXN1bHRTdHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kVGFnKGpzb25PYmosZWxlbWVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFwiPC9cIisgKGpzb25PYmouX19wcmVmaXghPW51bGw/IChqc29uT2JqLl9fcHJlZml4K1wiOlwiKTpcIlwiKStlbGVtZW50TmFtZStcIj5cIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHIsIHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2Yoc3VmZml4LCBzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGpzb25YbWxTcGVjaWFsRWxlbSAoIGpzb25PYmosIGpzb25PYmpGaWVsZCApIHtcbiAgICAgICAgaWYoKGNvbmZpZy5hcnJheUFjY2Vzc0Zvcm09PVwicHJvcGVydHlcIiAmJiBlbmRzV2l0aChqc29uT2JqRmllbGQudG9TdHJpbmcoKSwoXCJfYXNBcnJheVwiKSkpXG4gICAgICAgICAgICB8fCBqc29uT2JqRmllbGQudG9TdHJpbmcoKS5pbmRleE9mKGNvbmZpZy5hdHRyaWJ1dGVQcmVmaXgpPT0wXG4gICAgICAgICAgICB8fCBqc29uT2JqRmllbGQudG9TdHJpbmcoKS5pbmRleE9mKFwiX19cIik9PTBcbiAgICAgICAgICAgIHx8IChqc29uT2JqW2pzb25PYmpGaWVsZF0gaW5zdGFuY2VvZiBGdW5jdGlvbikgKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqc29uWG1sRWxlbUNvdW50ICgganNvbk9iaiApIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzQ250ID0gMDtcbiAgICAgICAgaWYoanNvbk9iaiBpbnN0YW5jZW9mIE9iamVjdCApIHtcbiAgICAgICAgICAgIGZvciggdmFyIGl0IGluIGpzb25PYmogICkge1xuICAgICAgICAgICAgICAgIGlmKGpzb25YbWxTcGVjaWFsRWxlbSAoIGpzb25PYmosIGl0KSApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzQ250Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzQ250O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSlNPTkF0dHJpYnV0ZXMgKCBqc29uT2JqICkge1xuICAgICAgICB2YXIgYXR0ckxpc3QgPSBbXTtcbiAgICAgICAgaWYoanNvbk9iaiBpbnN0YW5jZW9mIE9iamVjdCApIHtcbiAgICAgICAgICAgIGZvciggdmFyIGFpdCBpbiBqc29uT2JqICApIHtcbiAgICAgICAgICAgICAgICBpZihhaXQudG9TdHJpbmcoKS5pbmRleE9mKFwiX19cIik9PSAtMSAmJiBhaXQudG9TdHJpbmcoKS5pbmRleE9mKGNvbmZpZy5hdHRyaWJ1dGVQcmVmaXgpPT0wKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJMaXN0LnB1c2goYWl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJMaXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSlNPTlRleHRBdHRycyAoIGpzb25UeHRPYmogKSB7XG4gICAgICAgIHZhciByZXN1bHQgPVwiXCI7XG5cbiAgICAgICAgaWYoanNvblR4dE9iai5fX2NkYXRhIT1udWxsKSB7XG4gICAgICAgICAgICByZXN1bHQrPVwiPCFbQ0RBVEFbXCIranNvblR4dE9iai5fX2NkYXRhK1wiXV0+XCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZihqc29uVHh0T2JqLl9fdGV4dCE9bnVsbCkge1xuICAgICAgICAgICAgaWYoY29uZmlnLmVzY2FwZU1vZGUpXG4gICAgICAgICAgICAgICAgcmVzdWx0Kz1lc2NhcGVYbWxDaGFycyhqc29uVHh0T2JqLl9fdGV4dCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVzdWx0Kz1qc29uVHh0T2JqLl9fdGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSlNPTlRleHRPYmplY3QgKCBqc29uVHh0T2JqICkge1xuICAgICAgICB2YXIgcmVzdWx0ID1cIlwiO1xuXG4gICAgICAgIGlmKCBqc29uVHh0T2JqIGluc3RhbmNlb2YgT2JqZWN0ICkge1xuICAgICAgICAgICAgcmVzdWx0Kz1wYXJzZUpTT05UZXh0QXR0cnMgKCBqc29uVHh0T2JqICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICBpZihqc29uVHh0T2JqIT1udWxsKSB7XG4gICAgICAgICAgICBpZihjb25maWcuZXNjYXBlTW9kZSlcbiAgICAgICAgICAgICAgICByZXN1bHQrPWVzY2FwZVhtbENoYXJzKGpzb25UeHRPYmopO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlc3VsdCs9anNvblR4dE9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VKU09OQXJyYXkgKCBqc29uQXJyUm9vdCwganNvbkFyck9iaiwgYXR0ckxpc3QgKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICBpZihqc29uQXJyUm9vdC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0Kz1zdGFydFRhZyhqc29uQXJyUm9vdCwganNvbkFyck9iaiwgYXR0ckxpc3QsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yKHZhciBhcklkeCA9IDA7IGFySWR4IDwganNvbkFyclJvb3QubGVuZ3RoOyBhcklkeCsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Kz1zdGFydFRhZyhqc29uQXJyUm9vdFthcklkeF0sIGpzb25BcnJPYmosIHBhcnNlSlNPTkF0dHJpYnV0ZXMoanNvbkFyclJvb3RbYXJJZHhdKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCs9cGFyc2VKU09OT2JqZWN0KGpzb25BcnJSb290W2FySWR4XSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Kz1lbmRUYWcoanNvbkFyclJvb3RbYXJJZHhdLGpzb25BcnJPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VKU09OT2JqZWN0ICgganNvbk9iaiApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzQ250ID0ganNvblhtbEVsZW1Db3VudCAoIGpzb25PYmogKTtcblxuICAgICAgICBpZihlbGVtZW50c0NudCA+IDApIHtcbiAgICAgICAgICAgIGZvciggdmFyIGl0IGluIGpzb25PYmogKSB7XG5cbiAgICAgICAgICAgICAgICBpZihqc29uWG1sU3BlY2lhbEVsZW0gKCBqc29uT2JqLCBpdCkgKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHZhciBzdWJPYmogPSBqc29uT2JqW2l0XTtcblxuICAgICAgICAgICAgICAgIHZhciBhdHRyTGlzdCA9IHBhcnNlSlNPTkF0dHJpYnV0ZXMoIHN1Yk9iaiApXG5cbiAgICAgICAgICAgICAgICBpZihzdWJPYmogPT0gbnVsbCB8fCBzdWJPYmogPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCs9c3RhcnRUYWcoc3ViT2JqLCBpdCwgYXR0ckxpc3QsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaWYoc3ViT2JqIGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoc3ViT2JqIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCs9cGFyc2VKU09OQXJyYXkoIHN1Yk9iaiwgaXQsIGF0dHJMaXN0ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzdWJPYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQrPXN0YXJ0VGFnKHN1Yk9iaiwgaXQsIGF0dHJMaXN0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQrPXN1Yk9iai50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Kz1lbmRUYWcoc3ViT2JqLGl0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJPYmpFbGVtZW50c0NudCA9IGpzb25YbWxFbGVtQ291bnQgKCBzdWJPYmogKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN1Yk9iakVsZW1lbnRzQ250ID4gMCB8fCBzdWJPYmouX190ZXh0IT1udWxsIHx8IHN1Yk9iai5fX2NkYXRhIT1udWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Kz1zdGFydFRhZyhzdWJPYmosIGl0LCBhdHRyTGlzdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCs9cGFyc2VKU09OT2JqZWN0KHN1Yk9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Kz1lbmRUYWcoc3ViT2JqLGl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCs9c3RhcnRUYWcoc3ViT2JqLCBpdCwgYXR0ckxpc3QsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQrPXN0YXJ0VGFnKHN1Yk9iaiwgaXQsIGF0dHJMaXN0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCs9cGFyc2VKU09OVGV4dE9iamVjdChzdWJPYmopO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQrPWVuZFRhZyhzdWJPYmosaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQrPXBhcnNlSlNPTlRleHRPYmplY3QoanNvbk9iaik7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB0aGlzLnBhcnNlWG1sU3RyaW5nID0gZnVuY3Rpb24oeG1sRG9jU3RyKSB7XG4gICAgICAgIHZhciBpc0lFUGFyc2VyID0gd2luZG93LkFjdGl2ZVhPYmplY3QgfHwgXCJBY3RpdmVYT2JqZWN0XCIgaW4gd2luZG93O1xuICAgICAgICBpZiAoeG1sRG9jU3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4bWxEb2M7XG4gICAgICAgIGlmICh3aW5kb3cuRE9NUGFyc2VyKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VyPW5ldyB3aW5kb3cuRE9NUGFyc2VyKCk7XG4gICAgICAgICAgICB2YXIgcGFyc2VyZXJyb3JOUyA9IG51bGw7XG4gICAgICAgICAgICAvLyBJRTkrIG5vdyBpcyBoZXJlXG4gICAgICAgICAgICBpZighaXNJRVBhcnNlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcmVycm9yTlMgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKFwiSU5WQUxJRFwiLCBcInRleHQveG1sXCIpLmNoaWxkTm9kZXNbMF0ubmFtZXNwYWNlVVJJO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyZXJyb3JOUyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKCB4bWxEb2NTdHIsIFwidGV4dC94bWxcIiApO1xuICAgICAgICAgICAgICAgIGlmKCBwYXJzZXJlcnJvck5TIT0gbnVsbCAmJiB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUyhwYXJzZXJlcnJvck5TLCBcInBhcnNlcmVycm9yXCIpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHBhcnNpbmcgWE1MOiAnK3htbERvY1N0cik7XG4gICAgICAgICAgICAgICAgICAgIHhtbERvYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgeG1sRG9jID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElFIDooXG4gICAgICAgICAgICBpZih4bWxEb2NTdHIuaW5kZXhPZihcIjw/XCIpPT0wKSB7XG4gICAgICAgICAgICAgICAgeG1sRG9jU3RyID0geG1sRG9jU3RyLnN1YnN0ciggeG1sRG9jU3RyLmluZGV4T2YoXCI/PlwiKSArIDIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhtbERvYz1uZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG4gICAgICAgICAgICB4bWxEb2MuYXN5bmM9XCJmYWxzZVwiO1xuICAgICAgICAgICAgeG1sRG9jLmxvYWRYTUwoeG1sRG9jU3RyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geG1sRG9jO1xuICAgIH07XG5cbiAgICB0aGlzLmFzQXJyYXkgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIGlmKHByb3AgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gW3Byb3BdO1xuICAgIH07XG5cbiAgICB0aGlzLnRvWG1sRGF0ZVRpbWUgPSBmdW5jdGlvbihkdCkge1xuICAgICAgICBpZihkdCBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgICAgICByZXR1cm4gZHQudG9JU09TdHJpbmcoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICBpZih0eXBlb2YoZHQpID09PSAnbnVtYmVyJyApXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZHQpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICB0aGlzLmFzRGF0ZVRpbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIGlmKHR5cGVvZihwcm9wKSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbVhtbERhdGVUaW1lKHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgIH07XG5cbiAgICB0aGlzLnhtbDJqc29uID0gZnVuY3Rpb24gKHhtbERvYykge1xuICAgICAgICByZXR1cm4gcGFyc2VET01DaGlsZHJlbiAoIHhtbERvYyApO1xuICAgIH07XG5cbiAgICB0aGlzLnhtbF9zdHIyanNvbiA9IGZ1bmN0aW9uICh4bWxEb2NTdHIpIHtcbiAgICAgICAgdmFyIHhtbERvYyA9IHRoaXMucGFyc2VYbWxTdHJpbmcoeG1sRG9jU3RyKTtcbiAgICAgICAgaWYoeG1sRG9jIT1udWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueG1sMmpzb24oeG1sRG9jKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHRoaXMuanNvbjJ4bWxfc3RyID0gZnVuY3Rpb24gKGpzb25PYmopIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSlNPTk9iamVjdCAoIGpzb25PYmogKTtcbiAgICB9O1xuXG4gICAgdGhpcy5qc29uMnhtbCA9IGZ1bmN0aW9uIChqc29uT2JqKSB7XG4gICAgICAgIHZhciB4bWxEb2NTdHIgPSB0aGlzLmpzb24yeG1sX3N0ciAoanNvbk9iaik7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlWG1sU3RyaW5nKHhtbERvY1N0cik7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0VmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgfTtcblxufVxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5YMkpTID0gcmVxdWlyZSAneG1sLWpzb24tcGFyc2VyJ1xuUHJlc2VuY2VUeXBlID0gcmVxdWlyZSAnZW51bS9wcmVzZW5jZV90eXBlJ1xuUHJlc2VuY2VTaG93ID0gcmVxdWlyZSAnZW51bS9wcmVzZW5jZV9zaG93J1xuWE1QUFByZXNlbmNlID0gcmVxdWlyZSAnZW51bS94bXBwX3ByZXNlbmNlJ1xuXG54MmpzID0gbmV3IFgySlMoKVxuXG4jIENvbnZlcnQgWE1MIGRhdGEgdG8gYSBKYXZhU2NyaXB0IE9iamVjdCB1c2luZyB0aGUgWDJKUyBsaWJyYXJ5IGFuZCBjb252ZXJ0XG4jICAgZWFjaCBlbGVtZW50J3MgYXR0cmlidXRlcyB0byBhbiAnYXR0cmlidXRlcycgcHJvcGVydHkgd2hpY2ggaXMgYW4gb2JqZWN0XG4jICAgb2YgYXR0cmlidXRlc1xuI1xuIyBAcGFyYW0gZGF0YSBbT2JqZWN0LCBBcnJheTxPYmplY3Q+XSB0aGUgb2JqZWN0IHRvIHByb2Nlc3NcbiNcbiMgQHJldHVybiBbT2JqZWN0XSB0aGUgbW9kaWZpZWQgb2JqZWN0XG5leHBvcnRzLmNvbnZlcnRUb0pTT04gPSBfLmJpbmQgKGRhdGEpIC0+XG4gIEBqc29uQXR0cnMgQHhtbFRvSlNPTiBkYXRhXG4sIHRoaXNcblxuIyBDb252ZXJ0IFhNTCBkYXRhIHRvIGEgSmF2YVNjcmlwdCBPYmplY3QgdXNpbmcgdGhlIFgySlMgbGlicmFyeVxuI1xuIyBAcGFyYW0gb2JqIFtPYmplY3QsIEFycmF5PE9iamVjdD5dIHRoZSBvYmplY3QgdG8gcHJvY2Vzc1xuI1xuIyBAcmV0dXJuIFtPYmplY3RdIHRoZSBtb2RpZmllZCBvYmplY3RcbmV4cG9ydHMueG1sVG9KU09OID0gKGRhdGEpIC0+XG4gIHgyanMueG1sMmpzb24gZGF0YVxuXG4jIFdhbGsgdGhyb3VnaCBhbiBvYmplY3QncyBwcm9wZXJ0aWVzIGFuZCBmb3IgcHJvcGVydGllcyB3aG9zZSBrZXlzIGJlZ2luXG4jICAgd2l0aCBhIHNpbmdsZSAnXycsIG1vdmUgdGhvc2UgdG8gYSBuZXcgJ2F0dHJpYnV0ZXMnIHByb3BlcnR5XG4jXG4jIEBwYXJhbSBvYmogW09iamVjdCwgQXJyYXldIHRoZSBvYmplY3QgdG8gcHJvY2Vzc1xuIyBAcGFyYW0gb3B0aW9ucyBbT2JqZWN0XSBhbiBvYmplY3Qgb2Ygb3B0aW9uc1xuIyBAb3B0aW9uIGF0dHJPYmplY3ROYW1lIG9wdGlvbnMgW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG5ldyBvYmplY3QgdG8gaG9sZCBhdHRyaWJ1dGVzLlxuIyAgIERlZmF1bHRzIGlzICdhdHRyaWJ1dGVzJ1xuIyBAb3B0aW9uIHJlZ2V4cCBvcHRpb25zIFtSZWdFeHBdIGFueSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggcHJvcGVydHkga2V5cyxcbiMgICBpZGVudGlmeWluZyB0aGVtIGFzIGNhbmRpZGF0ZXMgdG8gcmVncm91cCBhcyBcImF0dHJpYnV0ZXNcIlxuIyBAb3B0aW9uIHRleHRScmVnZXhwIG9wdGlvbnMgW1JlZ0V4cF0gYW55IHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBwcm9wZXJ0eSBrZXlzLFxuIyAgIGlkZW50aWZ5aW5nIGl0IGFzIHRoZSBob2xkZXIgb2YgdGhlIGVsZW1lbnQncyB0ZXh0IHZhbHVlXG4jIEBvcHRpb24gbmFtZVRyYW5zZm9ybSBvcHRpb25zIFtGdW5jdGlvbl0gYSBjdXN0b20gZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHRoZSBuYW1lXG4jICAgd2hlbiBzZXR0aW5nIGF0dHJpYnV0ZXMgb24gdGhlIG5ld2x5IGZvcm1lZCBhdHRyaWJ1dGVzIG9iamVjdFxuI1xuIyBAcmV0dXJuIFtPYmplY3RdIHRoZSBtb2RpZmllZCBvYmplY3RcbiMgZXhwb3J0cy5qc29uQXR0cnMgPSAoZGF0YSwgYXR0ck9iamVjdE5hbWUgPSAnYXR0cmlidXRlcycsIHJlZ2V4cCA9IC9eXy8pIC0+XG5leHBvcnRzLmpzb25BdHRycyA9IChkYXRhLCBvcHRpb25zID0ge30pIC0+XG4gIHthdHRyT2JqZWN0TmFtZSwgdGV4dFByb3BlcnR5TmFtZSwgcmVnZXhwLCB0ZXh0UmVnZXhwLCBuYW1lVHJhbnNmb3JtfSA9IF8uZGVmYXVsdHMgb3B0aW9ucyxcbiAgICBhdHRyT2JqZWN0TmFtZTogJ2F0dHJpYnV0ZXMnXG4gICAgdGV4dFByb3BlcnR5TmFtZTogJ3RleHQnXG4gICAgcmVnZXhwOiAvXl8vXG4gICAgdGV4dFJlZ2V4cDogL15fX3RleHQvXG4gICAgbmFtZVRyYW5zZm9ybTogKG5hbWUpIC0+IG5hbWUuc2xpY2UgMVxuXG4gICMgQ2FsbCB0aGlzIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5IHdoaWxlIHdhbGtpbmcgdGhlIG9iamVjdCB0cmVlXG4gIHByb2Nlc3NBdHRycyA9IChvYmopIC0+XG4gICAgcmV0dXJuIG9iaiB1bmxlc3MgaGFzUHJvcHMgb2JqXG4gICAgaWYgXy5pc0FycmF5IG9ialxuICAgICAgcHJvY2Vzc0F0dHJzIGVsIGZvciBlbCBpbiBvYmpcbiAgICBlbHNlXG4gICAgICBhdHRycyA9IHt9XG4gICAgICB0ZXh0ID0gJydcbiAgICAgIGZvciBvd24ga2V5LCB2YWx1ZSBvZiBvYmpcbiAgICAgICAgIyBrZXkgcmVjb2duaXplZCBhcyBcIl9fdGV4dFwiXG4gICAgICAgIGlmIGtleS5tYXRjaCB0ZXh0UmVnZXhwXG4gICAgICAgICAgdGV4dCA9IHZhbHVlXG4gICAgICAgICAgZGVsZXRlIG9ialtrZXldXG4gICAgICAgICMga2V5IHJlY29nbml6ZWQgYXMgXCJfYXR0cmlidXRlTmFtZVwiXG4gICAgICAgIGVsc2UgaWYga2V5Lm1hdGNoIHJlZ2V4cFxuICAgICAgICAgICMgYWRkIHRvIGF0dHJpYnV0ZXMsIHJlbW92ZSBsZWFkaW5nICdfJyBuYW1lXG4gICAgICAgICAgYXR0cnNbbmFtZVRyYW5zZm9ybShrZXkpXSA9IHZhbHVlXG4gICAgICAgICAgZGVsZXRlIG9ialtrZXldXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAjIHJlY3Vyc2l2ZWx5IHByb2Nlc3MgYW55IHByb3BlcnR5IHZhbHVlICh0aGF0IG1pZ2h0IGJlIGFuIG9iamVjdClcbiAgICAgICAgICBwcm9jZXNzQXR0cnMgdmFsdWVcbiAgICAgICMgQWRkIHRoZSBhdHRyaWJ1dGVzIG9iamVjdCB0byBhIHByb3BlcnR5XG4gICAgICBvYmpbYXR0ck9iamVjdE5hbWVdID0gYXR0cnMgdW5sZXNzIF8uaXNFbXB0eSBhdHRyc1xuICAgICAgIyBBZGQgdGhlIHRleHQgcHJvcGVydHkgaWYgdGhlcmUgd2FzIGFueSB0ZXh0XG4gICAgICBpZiB0ZXh0IHRoZW4gb2JqW3RleHRQcm9wZXJ0eU5hbWVdID0gdGV4dFxuICAgIG9ialxuICBwcm9jZXNzQXR0cnMgZGF0YVxuXG4jIENvbnZlcnQgWE1MIGRhdGEgdG8gSlNPTlxuI1xuIyBAcGFyYW0gZGF0YSBbWE1MLCBPYmplY3RdIFRoZSBYTUwgb3IgSlNPTiBwcmVzZW5jZSBvYmplY3RcbiNcbiMgQHJldHVybiBbT2JqZWN0XVxuZXhwb3J0cy5jb252ZXJ0VG9KU09OID0gXy5iaW5kIChkYXRhKSAtPlxuICBAanNvbkF0dHJzIEB4bWxUb0pTT04oZGF0YSkgb3IgZGF0YVxuLCB0aGlzXG5cbiMgUGFyc2UgaW5jb21pbmcgcHJlc2VuY2UgZGF0YSwgWE1MIG9yIEpTT04sIGFuZCBvdXRwdXQgYW4gb2JqZWN0IHdpdGhcbiMgY29udGFjdCwgcHJlc2VuY2UsIGFuZCBzdGF0dXMgdmFsdWVzXG4jXG4jIEBwYXJhbSBkYXRhIFtYTUwsIE9iamVjdF0gVGhlIFhNTCBvciBKU09OIHByZXNlbmNlIG9iamVjdFxuI1xuIyBAcmV0dXJuIFtPYmplY3RdIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgJ2ppZCcsICdlbWFpbCcsIHByZXNlbmNlJyAnc3RhdHVzJyxcbiMgICBhbGwgb2Ygd2hpY2ggYXJlIHN0cmluZ3NcbiNcbiMgQHNlZSBYTVBQUHJlc2VuY2VcbmV4cG9ydHMucGFyc2VYTVBQUHJlc2VuY2UgPSBfLmJpbmQgKGRhdGEpIC0+XG4gIGRhdGEgPSBAY29udmVydFRvSlNPTiBkYXRhXG4gIHthdHRyaWJ1dGVzLCBzaG93fSA9IEBjb252ZXJ0VG9KU09OIGRhdGFcbiAgdHlwZSA9IGF0dHJpYnV0ZXM/LnR5cGVcblxuICAjIFJldHVybiBhbiBvYmplY3RcbiAgamlkOiBTdHJvcGhlLmdldEJhcmVKaWRGcm9tSmlkIGRhdGEuYXR0cmlidXRlcy5mcm9tXG4gIGVtYWlsOiBkYXRhLmF0dHJpYnV0ZXMuZW1haWwgb3IgXCJcIlxuICBwcmVzZW5jZTogcHJlc2VuY2VUb1N0YXR1cyB0eXBlLCBzaG93XG4gIHN0YXR1czogXCJcIlxuLCB0aGlzXG5cbiMgU3dpdGNoIG9uIHByZXNlbmNlICd0eXBlJyBvciAnc2hvdycgYW5kIHJldHVybiBhIHByZXNlbmNlIHN0cmluZ1xuI1xuIyBAcGFyYW0gdHlwZSBbU3RyaW5nXSB0aGUgdHlwZSBhcyBkZWZpbmVkIGJ5IHRoZSBpbmNvbWluZyBYTUwgc3RhbnphXG4jIEBwYXJhbSBzaG93IFtTdHJpbmddIHRoZSBzaG93IGFzIGRlZmluZWQgYnkgdGhlIGluY29taW5nIFhNTCBzdGFuemFcbiNcbiMgQHJldHVybiBbU3RyaW5nXSBhbiBYTVBQIHByZXNlbmNlIHN0YXR1c1xucHJlc2VuY2VUb1N0YXR1cyA9ICh0eXBlLCBzaG93KSAtPlxuICBpZiB0eXBlIGlzIFByZXNlbmNlVHlwZS5VTkFWQUlMQUJMRVxuICAgIFhNUFBQcmVzZW5jZS5VTkFWQUlMQUJMRVxuICBlbHNlIGlmIHNob3dcbiAgICBwcmVzZW5jZVNob3dUb1N0YXR1cyBzaG93XG4gIGVsc2VcbiAgICBYTVBQUHJlc2VuY2UuQVZBSUxBQkxFXG5cbiMgQ29udmVydCBhIFByZXNlbmNlU2hvdyBlbnVtIHRvIGEgY29ycmVzcG9uZGluZyBYTVBQUHJlc2VuY2UgZW11bVxuI1xuIyBAcGFyYW0gc2hvdyBbU3RyaW5nXSB0aGUgUHJlc2VuY2VTaG93IGVudW0gdG8gY29udmVydFxuI1xuIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBhcHBsaWNhdGlvbi1mcmllbmRseSBwcmVzZW5jZSBzdGF0dXMsIGZyb20gWE1QUFByZXNlbmNlIGVudW1zXG4jXG4jIEBzZWUgWE1QUFByZXNlbmNlXG5wcmVzZW5jZVNob3dUb1N0YXR1cyA9IChzaG93KSAtPlxuICBzd2l0Y2ggc2hvd1xuICAgIHdoZW4gUHJlc2VuY2VTaG93LkFXQVksIFByZXNlbmNlU2hvdy5FWFRFTkRFRF9BV0FZLCBQcmVzZW5jZVNob3cuRE5EXG4gICAgICBzaG93XG4gICAgZWxzZVxuICAgICAgWE1QUFByZXNlbmNlLkFWQUlMQUJMRVxuXG4jIERldGVybWluZSBpZiBhbiBPYmplY3Qgb3IgQXJyYXkgaGFzIG1lbWJlcnNcbiNcbiMgQHBhcmFtIG9iaiBbT2JqZWN0LCBBcnJheV0gdGhlIG9iamVjdCB0byBpbnNwZWN0XG4jXG4jIEByZXR1cm4gW0Jvb2xlYW5dIHJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYW4gb2JqZWN0IG9yIGFuIGFycmF5LCB3aXRoIG1lbWJlcnNcbmhhc1Byb3BzID0gKG9iaiA9IHt9KSAtPlxuICBfLmlzT2JqZWN0KG9iaikgYW5kIG5vdCBfLmlzRW1wdHkgb2JqXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1xuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5hZGFwdGVycyA9IHJlcXVpcmUgJ2FkYXB0ZXJzL2FkYXB0ZXJzJ1xuXG5tb2R1bGUuZXhwb3J0cy5nZXREYXRhID0gKHN0YW56YSkgLT5cbiAge2NvbnZlcnRUb0pTT059ID0gYWRhcHRlcnNcbiAgYWRhcHRlckZ1bmN0aW9ucyA9IF8uZXh0ZW5kIHt9LCBhZGFwdGVycywgZ2V0U3Ryb3BoZUFkYXB0ZXJzKClcbiAgcmV0dXJuIHt9IHVubGVzcyBzdGFuemFcblxuICB4bWw6IHN0YW56YVxuICBqc29uOiBjb252ZXJ0VG9KU09OIHN0YW56YVxuICBhZGFwdGVyczogYWRhcHRlckZ1bmN0aW9uc1xuXG5nZXRTdHJvcGhlQWRhcHRlcnMgPSAtPlxuICBnZXRCYXJlSklEOiBTdHJvcGhlLmdldEJhcmVKaWRGcm9tSmlkXG4gIGdldFJlc291cmNlOiAoamlkKSAtPlxuICAgIFN0cm9waGUuZ2V0UmVzb3VyY2VGcm9tSmlkKGppZCkgb3IgXCJcIlxuIiwidm9vbSA9IHJlcXVpcmUgJ3Zvb20nXG5YMkpTID0gcmVxdWlyZSAneG1sLWpzb24tcGFyc2VyJ1xuXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5cbmYgPSB2b29tLmZcbngyanMgPSBuZXcgWDJKUygpXG4gIFxuIyBWYWxpZGF0ZSBib29sZWFuLCBjb2VyY2luZyBzdHJpbmdzIGlmIHBvc3NpYmxlXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW0Jvb2xlYW4sIFVuZGVmaW5lZF1cbnZhbGlkQm9vbCA9IChkYXRhKSAtPlxuICBpZiBfLmlzQm9vbGVhbiBkYXRhXG4gICAgcmV0dXJuIGRhdGFcbiAgaWYgXy5pc1N0cmluZyBkYXRhXG4gICAgaWYgZGF0YSBpcyAndHJ1ZSdcbiAgICAgIHJldHVybiB0cnVlXG4gICAgaWYgZGF0YSBpcyAnZmFsc2UnXG4gICAgICByZXR1cm4gZmFsc2VcbiAgY29uc29sZS53YXJuICdbUHJlZmVyZW5jZXNdIEludmFsaWQgYm9vbGVhbiBhdCcsIHZhbGlkQm9vbD8uY2FsbGVyPy5uYW1lLCAnOicsIGRhdGFcblxuIyBWYWxpZGF0ZSBudW1iZXIsIGNvZXJjaW5nIHN0cmluZ3MgaWYgcG9zc2libGVcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbTnVtYmVyLCBVbmRlZmluZWRdXG52YWxpZE51bWJlciA9IChkYXRhKSAtPlxuICBpZiBfLmlzTnVtYmVyIGRhdGFcbiAgICByZXR1cm4gZGF0YVxuICBpZiBfLmlzU3RyaW5nIGRhdGFcbiAgICByZXR1cm4gK2RhdGFcbiAgY29uc29sZS53YXJuICdbUHJlZmVyZW5jZXNdIEludmFsaWQgbnVtYmVyIGF0JywgdmFsaWROdW1iZXI/LmNhbGxlcj8ubmFtZSwgJzonLCBkYXRhXG5cbiMgVmFsaWRhdGUgc3RyaW5nXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW1N0cmluZywgVW5kZWZpbmVkXVxudmFsaWRTdHJpbmcgPSAoZGF0YSkgLT5cbiAgaWYgXy5pc1N0cmluZyBkYXRhXG4gICAgcmV0dXJuIGRhdGFcbiAgY29uc29sZS53YXJuICdbUHJlZmVyZW5jZXNdIEludmFsaWQgc3RyaW5nIGF0JywgdmFsaWRTdHJpbmc/LmNhbGxlcj8ubmFtZSwgJzonLCBkYXRhXG5cbiMgVmFsaWRhdGUgcHJpbWl0aXZlIHZhbHVlXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW051bWJlciwgU3RyaW5nLCBCb29sZWFuLCBVbmRlZmluZWRdXG52YWxpZFByaW1pdGl2ZSA9IChkYXRhKSAtPlxuICB1bmxlc3MgXy5pc09iamVjdCBkYXRhXG4gICAgcmV0dXJuIGRhdGFcbiAgY29uc29sZS53YXJuICdbUHJlZmVyZW5jZXNdIEludmFsaWQgcHJpbWl0aXZlIGF0JywgdmFsaWRQcmltaXRpdmU/LmNhbGxlcj8ubmFtZSwgJzonLCBkYXRhXG5cbiMgR2V0IGEgdmFsaWRhdG9yIGZ1bmN0aW9uIHRvIGNoZWNrIHZhbHVlc1xuIyBAcHJpdmF0ZVxuI1xuIyBAcmV0dXJuIFtGdW5jdGlvbl1cbnZhbGlkVmFsdWUgPSAtPlxuICBsb2NhdGlvbiA9IHZhbGlkVmFsdWU/LmNhbGxlcj8ubmFtZVxuICB2YWxzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwgYXJndW1lbnRzXG4gIChkYXRhKSAtPlxuICAgIHVubGVzcyBfLmNvbnRhaW5zIHZhbHMsIGRhdGFcbiAgICAgIGNvbnNvbGUud2FybiAnW1ByZWZlcmVuY2VzXSBJbnZhbGlkIHZhbHVlIGF0JywgbG9jYXRpb24sICc6JywgZGF0YSwgJ25vdCBpbicsIHZhbHMudG9TdHJpbmcoKVxuICAgIGRhdGFcblxuIyBHZXQgYSB2YWxpZGF0b3IgZnVuY3Rpb24gdG8gY2hlY2sgbGltaXRzXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW0Z1bmN0aW9uXVxudmFsaWRMaW1pdCA9IChudW0sIG9wdGlvbnMgPSB7fSkgLT5cbiAge3RyaW0sIGxvY2F0aW9ufSA9IF8uZGVmYXVsdHMgb3B0aW9ucyxcbiAgICB0cmltOiB0cnVlXG4gICAgbG9jYXRpb246IHZhbGlkTGltaXQ/LmNhbGxlcj8ubmFtZVxuICAoZGF0YSkgLT5cbiAgICBpZiBfLmlzQXJyYXkoZGF0YSkgYW5kIChkYXRhLmxlbmd0aCA+IG51bSlcbiAgICAgIGNvbnNvbGUud2FybiAnW1ByZWZlcmVuY2VzXSBEYXRhIGV4Y2VlZHMgbGltaXQgYXQnLCBsb2NhdGlvbiwgJzonLCBkYXRhLmxlbmd0aCwgJz4nLCBudW1cbiAgICAgIGlmIHRyaW0gdGhlbiBkYXRhID0gZGF0YS5zbGljZSgwLCBudW0pXG4gICAgZGF0YVxuXG4jIFRyYW5zZm9ybSBmb3IgQ29udmVyc2F0aW9uIGlkXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW1N0cmluZywgVW5kZWZpbmVkXVxuQWN0aXZlQ29udmVyc2F0aW9uSWQgPSAoZGF0YSkgLT5cbiAgdmFsaWRTdHJpbmcgZGF0YVxuXG4jIFRyYW5zZm9ybSBmb3IgQ29udmVyc2F0aW9uIG5hbWVcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbU3RyaW5nLCBVbmRlZmluZWRdXG5BY3RpdmVDb252ZXJzYXRpb25OYW1lID0gKGRhdGEpIC0+XG4gIHZhbGlkU3RyaW5nIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIENvbnZlcnNhdGlvbiB0eXBlXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW1N0cmluZ11cbkFjdGl2ZUNvbnZlcnNhdGlvblR5cGUgPSAoZGF0YSkgLT5cbiAgdmFsaWRWYWx1ZSgnY2hhdCcsICdtYW5hZ2VkY2hhdCcsICdiaWxhdGVyYWwnLCAnbXVsdGlwYXJ0eScsICdibGFzdCcsICdtZXJnZWRjaGF0JykoZGF0YSlcblxuIyBUcmFuc2Zvcm0gZm9yIEFjdGl2aXR5TW9uaXRvcldpZHRoXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW051bWJlciwgVW5kZWZpbmVkXVxuQWN0aXZpdHlNb25pdG9yV0ludCA9IChkYXRhKSAtPlxuICB2YWxpZE51bWJlciBkYXRhXG5cbiMgVHJhbnNmb3JtIGZvciBBbGxvd1VucmVhZENoYXRyb29tSW5kaWNhdG9yXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW0Jvb2xlYW4sIFVuZGVmaW5lZF1cbkFsbG93VW5yZWFkQm9vbCA9IChkYXRhKSAtPlxuICB2YWxpZEJvb2wgZGF0YVxuXG4jIFRyYW5zZm9ybSBmb3IgQ2hhdENvbnZvWFxuIyBAcHJpdmF0ZVxuI1xuIyBAcmV0dXJuIFtOdW1iZXIsIFVuZGVmaW5lZF1cbkNoYXRDb252b1hJbnQgPSAoZGF0YSkgLT5cbiAgdmFsaWROdW1iZXIgZGF0YVxuXG4jIFRyYW5zZm9ybSBmb3IgQ2xvc2VQYXJ0aWNpcGFudHNcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbQm9vbGVhbiwgVW5kZWZpbmVkXVxuQ2xvc2VQYXJ0aWNpcGFudHNCb29sID0gKGRhdGEpIC0+XG4gIHZhbGlkQm9vbCBkYXRhXG5cbiMgVHJhbnNmb3JtIGZvciBDbG9zZVNpZGViYXJcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbQm9vbGVhbiwgVW5kZWZpbmVkXVxuQ2xvc2VTaWRlYmFyQm9vbCA9IChkYXRhKSAtPlxuICB2YWxpZEJvb2wgZGF0YVxuXG4jIFRyYW5zZm9ybSBmb3IgQ29udmVyc2F0aW9uIGNvbnRhY3RJZHNcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbTnVtYmVyXVxuQ29udGFjdElkcyA9IChkYXRhKSAtPlxuICB2YWxpZExpbWl0KDEwMCkoZGF0YSlcblxuIyBUcmFuc2Zvcm0gZm9yIE1haW5Db250ZW50Q29udGFpbmVyV2lkdGhcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbTnVtYmVyLCBVbmRlZmluZWRdXG5Db250YWluZXJXSW50ID0gKGRhdGEpIC0+XG4gIHZhbGlkTnVtYmVyIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIENvbnZlcnNhdGlvblByZXZpZXdMaW5lc1xuIyBAcHJpdmF0ZVxuI1xuIyBAcmV0dXJuIFtOdW1iZXIsIFVuZGVmaW5lZF1cbkNvbnZQcmV2SW50ID0gKGRhdGEpIC0+XG4gIHZhbGlkTnVtYmVyIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIENvbnZlcnNhdGlvbkRlZmF1bHRDb2xvcnMgdGhlbWVcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbU3RyaW5nLCBVbmRlZmluZWRdXG5EZWZhdWx0Q29sb3JUaGVtZVN0ciA9IChkYXRhKSAtPlxuICB2YWxpZFN0cmluZyBkYXRhXG5cbiMgVHJhbnNmb3JtIGZvciBDb252ZXJzYXRpb25EZWZhdWx0Q29sb3JzIGJhY2tncm91bmQgY29sb3JcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbU3RyaW5nLCBVbmRlZmluZWRdXG5EZWZhdWx0QmdDb2xvciA9IChkYXRhKSAtPlxuICB2YWxpZFN0cmluZyBkYXRhXG5cbiMgVHJhbnNmb3JtIGZvciBDb252ZXJzYXRpb25EZWZhdWx0Q29sb3JzIHRleHQgY29sb3JcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbU3RyaW5nLCBVbmRlZmluZWRdXG5EZWZhdWx0VGV4dENvbG9yID0gKGRhdGEpIC0+XG4gIHZhbGlkU3RyaW5nIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIEVuYWJsZUludGVybmF0aW9uYWxLZXlib2FyZFxuIyBAcHJpdmF0ZVxuI1xuIyBAcmV0dXJuIFtCb29sZWFuLCBVbmRlZmluZWRdXG5FbmFibGVJbnRubEtiQm9vbCA9IChkYXRhKSAtPlxuICB2YWxpZEJvb2wgZGF0YVxuICBcbiMgVHJhbnNmb3JtIGZvciBGb2N1c2VkQ29udmVyc2F0aW9uXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW1N0cmluZywgVW5kZWZpbmVkXVxuRm9jdXNlZENvbnZlcnNhdGlvbklkID0gKGRhdGEpIC0+XG4gIHZhbGlkU3RyaW5nIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIEZvbnRTaXplXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW1N0cmluZ11cbkZvbnRTaXplU3RyID0gKGRhdGEpIC0+XG4gIHZhbGlkVmFsdWUoJ3NtJywgJ21lZCcsICdsZycsICd4bCcpKGRhdGEpXG5cbiMgVHJhbnNmb3JtIGZvciBGb250U3R5bGVcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbU3RyaW5nXVxuRm9udFN0eWxlU3RyID0gKGRhdGEpIC0+XG4gIHZhbGlkVmFsdWUoJ2FyaWFsJywgJ3RpbWVzJywgJ2NvdXJpZXInLCAndmVyZGFuYScsICdnZW9yZ2lhJykoZGF0YSlcblxuIyBUcmFuc2Zvcm0gZm9yIEdyb3VwIGNvbGxhcHNlZFxuIyBAcHJpdmF0ZVxuI1xuIyBAcmV0dXJuIFtCb29sZWFuLCBVbmRlZmluZWRdXG5Hcm91cENvbGxhcHNlZEJvb2wgPSAoZGF0YSkgLT5cbiAgdmFsaWRCb29sIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIEdyb3VwIGlkXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW051bWJlciwgU3RyaW5nLCBCb29sZWFuLCBVbmRlZmluZWRdXG5Hcm91cElkID0gKGRhdGEpIC0+XG4gIHZhbGlkUHJpbWl0aXZlIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIEdyb3VwIGlkXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW1N0cmluZywgVW5kZWZpbmVkXVxuR3JvdXBOYW1lID0gKGRhdGEpIC0+XG4gIHZhbGlkU3RyaW5nIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIEhpZGVPZmZsaW5lQ29udGFjdHNcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbQm9vbGVhbiwgVW5kZWZpbmVkXVxuSGlkZU9mZmxpbmVDb250YWN0c0Jvb2wgPSAoZGF0YSkgLT5cbiAgdmFsaWRCb29sIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIFN0b3JlZElkbGVUaW1lSW5NaW51dGVzXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW051bWJlciwgVW5kZWZpbmVkXVxuSWRsZVRpbWVJbnQgPSAoZGF0YSkgLT5cbiAgdmFsaWROdW1iZXIgZGF0YVxuXG4jIFRyYW5zZm9ybSBmb3IgTWFpbkNvbnRlbnRSaWdodFxuIyBAcHJpdmF0ZVxuI1xuIyBAcmV0dXJuIFtOdW1iZXIsIFVuZGVmaW5lZF1cbk1haW5Db250ZW50UnRJbnQgPSAoZGF0YSkgLT5cbiAgdmFsaWROdW1iZXIgZGF0YVxuXG4jIFRyYW5zZm9ybSBmb3IgTWFpbkNvbnRlbnRXaWR0aFxuIyBAcHJpdmF0ZVxuI1xuIyBAcmV0dXJuIFtOdW1iZXIsIFVuZGVmaW5lZF1cbk1haW5Db250ZW50V0ludCA9IChkYXRhKSAtPlxuICB2YWxpZE51bWJlciBkYXRhXG5cbiMgVHJhbnNmb3JtIGZvciBNZXNzYWdlVGhlbWVcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbU3RyaW5nXVxuTWVzc2FnZVRoZW1lU3RyID0gKGRhdGEpIC0+XG4gIHZhbGlkVmFsdWUoJ2NvbXBhY3QnLCAnZXhwYW5kZWQnKShkYXRhKVxuXG4jIFRyYW5zZm9ybSBmb3IgUGFydGljaXBhbnRzV2lkdGhcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbTnVtYmVyLCBVbmRlZmluZWRdXG5QYXJ0aWNpcGFudHNXSW50ID0gKGRhdGEpIC0+XG4gIHZhbGlkTnVtYmVyIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIFBhcnRpY2lwYW50Vmlld1NvcnRcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbU3RyaW5nXVxuUGFydGljaXBhbnRWaWV3U29ydFN0ciA9IChkYXRhKSAtPlxuICB2YWxpZFZhbHVlKCdmaXJzdF9uYW1lJywgJ2xhc3RfbmFtZScsICdjb21wYW55JykoZGF0YSlcblxuIyBUcmFuc2Zvcm0gZm9yIE1lc3NhZ2VUaGVtZSBzaG93Q29tcGFueVxuIyBAcHJpdmF0ZVxuI1xuIyBAcmV0dXJuIFtCb29sZWFuLCBVbmRlZmluZWRdXG5TaG93Q29tcGFueUJvb2wgPSAoZGF0YSkgLT5cbiAgdmFsaWRCb29sIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIFNpZGViYXJXaWR0aFxuIyBAcHJpdmF0ZVxuI1xuIyBAcmV0dXJuIFtOdW1iZXIsIFVuZGVmaW5lZF1cblNpZGViYXJXSW50ID0gKGRhdGEpIC0+XG4gIHZhbGlkTnVtYmVyIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIFBhcnRpY2lwYW50c1dpZHRoIFVJIHNldHRpbmdcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbTnVtYmVyLCBVbmRlZmluZWRdXG5VSVBhcnRpY2lwYW50c1dJbnQgPSAoZGF0YSkgLT5cbiAgdmFsaWROdW1iZXIgZGF0YVxuXG4jIFRyYW5zZm9ybSBmb3IgV2luZG93V2lkdGhcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbTnVtYmVyLCBVbmRlZmluZWRdXG5XaW5kb3dXSW50ID0gKGRhdGEpIC0+XG4gIHZhbGlkTnVtYmVyIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIFlhaG9vQXV0b0xvZ2luXG4jIEBwcml2YXRlXG4jXG4jIEByZXR1cm4gW0Jvb2xlYW4sIFVuZGVmaW5lZF1cbllhaG9vRW5hYmxlZEJvb2wgPSAoZGF0YSkgLT5cbiAgdmFsaWRCb29sIGRhdGFcblxuIyBUcmFuc2Zvcm0gZm9yIFlhaG9vVXNlck5hbWVcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbU3RyaW5nLCBVbmRlZmluZWRdXG5ZYWhvb1VzZXJTdHIgPSAoZGF0YSkgLT5cbiAgdmFsaWRTdHJpbmcgZGF0YVxuXG4jIEBwcm9wZXJ0eSBbT2JqZWN0XSBTY2hlbWEgZm9yIGdsb2JhbCBidWNrZXRcbiMgQHByaXZhdGVcbmdsb2JhbFNjaGVtYSA9XG4gICdQcmVmZXJlbmNlcyc6XG4gICAgJ0ZvY3VzZWRDb252ZXJzYXRpb24nOiBGb2N1c2VkQ29udmVyc2F0aW9uSWRcblxuIyBAcHJvcGVydHkgW09iamVjdF0gU2NoZW1hIGZvciBlbSBidWNrZXRcbiMgQHByaXZhdGVcbmVtU2NoZW1hID1cbiAgJ1ByZWZlcmVuY2VzJzpcbiAgICAnQWxsb3dVbnJlYWRDaGF0cm9vbUluZGljYXRvcic6IHtcbiAgICAgICdfZW5hYmxlZCc6IEFsbG93VW5yZWFkQm9vbFxuICAgIH0sXG4gICAgJ0Nsb3NlUGFydGljaXBhbnRzJzpcbiAgICAgICdfZW5hYmxlZCc6IENsb3NlUGFydGljaXBhbnRzQm9vbFxuICAgICxcbiAgICAnQ2xvc2VTaWRlYmFyJzpcbiAgICAgICdfZW5hYmxlZCc6IENsb3NlU2lkZWJhckJvb2xcbiAgICAsXG4gICAgJ0NvbnZlcnNhdGlvbkRlZmF1bHRDb2xvcnMnOiB7XG4gICAgICAnX3RoZW1lJzogRGVmYXVsdENvbG9yVGhlbWVTdHIsXG4gICAgICAnX2JhY2tncm91bmRDb2xvcic6IERlZmF1bHRCZ0NvbG9yLFxuICAgICAgJ190ZXh0Q29sb3InOiBEZWZhdWx0VGV4dENvbG9yXG4gICAgfSxcbiAgICAnQ29udmVyc2F0aW9uUHJldmlld0xpbmVzJzogQ29udlByZXZJbnQsXG4gICAgJ0VuYWJsZUludGVybmF0aW9uYWxLZXlib2FyZCc6XG4gICAgICAnX2VuYWJsZWQnOiBFbmFibGVJbnRubEtiQm9vbFxuICAgICxcbiAgICAnRm9udFNpemUnOiBGb250U2l6ZVN0cixcbiAgICAnRm9udFN0eWxlJzogRm9udFN0eWxlU3RyLFxuICAgICdHcm91cHMnOlxuICAgICAgJ0dyb3VwJzogW1xuICAgICAgICAnX2lkJzogR3JvdXBJZCxcbiAgICAgICAgJ19uYW1lJzogR3JvdXBOYW1lLFxuICAgICAgICAnX2NvbGxhcHNlZCc6IEdyb3VwQ29sbGFwc2VkQm9vbFxuICAgICAgXVxuICAgICxcbiAgICAnSGlkZU9mZmxpbmVDb250YWN0cyc6XG4gICAgICAnX2VuYWJsZWQnOiBIaWRlT2ZmbGluZUNvbnRhY3RzQm9vbFxuICAgICxcbiAgICAnSGlnaGxpZ2h0V29yZHMnOiAnSGlnaGxpZ2h0V29yZHNQYXJzZXInLFxuICAgICdNZXNzYWdlVGhlbWUnOlxuICAgICAgJ19zaG93Q29tcGFueSc6IFNob3dDb21wYW55Qm9vbCxcbiAgICAgICdfX3RleHQnOiBNZXNzYWdlVGhlbWVTdHJcbiAgICAsXG4gICAgJ1BhcnRpY2lwYW50c1dpZHRoJzogUGFydGljaXBhbnRzV0ludCxcbiAgICAnUGFydGljaXBhbnRWaWV3U29ydCc6IFBhcnRpY2lwYW50Vmlld1NvcnRTdHIsXG4gICAgJ1N0b3JlZElkbGVUaW1lSW5NaW51dGVzJzogSWRsZVRpbWVJbnQsXG4gICAgJ1VJU2l6ZXMnOlxuICAgICAgJ0FjdGl2aXR5TW9uaXRvcldpZHRoJzogQWN0aXZpdHlNb25pdG9yV0ludCxcbiAgICAgICdDaGF0Q29udm9YJzogQ2hhdENvbnZvWEludCxcbiAgICAgICdNYWluQ29udGVudENvbnRhaW5lcldpZHRoJzogQ29udGFpbmVyV0ludCxcbiAgICAgICdNYWluQ29udGVudFJpZ2h0JzogTWFpbkNvbnRlbnRSdEludCxcbiAgICAgICdNYWluQ29udGVudFdpZHRoJzogTWFpbkNvbnRlbnRXSW50LFxuICAgICAgJ1BhcnRpY2lwYW50c1dpZHRoJzogVUlQYXJ0aWNpcGFudHNXSW50LFxuICAgICAgJ1NpZGViYXJXaWR0aCc6IFNpZGViYXJXSW50LFxuICAgICAgJ1dpbmRvd1dpZHRoJzogV2luZG93V0ludFxuICAgICxcbiAgICAnWWFob29BdXRvTG9naW4nOlxuICAgICAgJ19lbmFibGVkJzogWWFob29FbmFibGVkQm9vbFxuICAgICxcbiAgICAnWWFob29Vc2VyTmFtZSc6IFlhaG9vVXNlclN0clxuXG4jIEBwcm9wZXJ0eSBbT2JqZWN0XSBTY2hlbWEgZm9yIGFsZXJ0cyBidWNrZXRcbiMgQHByaXZhdGVcbmFsZXJ0c1NjaGVtYSA9XG4gICdQcmVmZXJlbmNlcyc6XG4gICAgJ1BlcnNvbmFsQWxlcnRzJzogJ1BlcnNvbmFsQWxlcnRzUGFyc2VyJyxcbiAgICAnR2xvYmFsQWxlcnRzJzogJ0dsb2JhbEFsZXJ0c1BhcnNlcidcblxuIyBAcHJvcGVydHkgW09iamVjdF0gU2NoZW1hIGZvciBjb252ZXJzYXRpb25zIGJ1Y2tldFxuIyBAcHJpdmF0ZVxuY29udmVyc2F0aW9uc1NjaGVtYSA9XG4gICdQcmVmZXJlbmNlcyc6IHtcbiAgICAnQWN0aXZlQ29udmVyc2F0aW9ucyc6IHtcbiAgICAgICdDb252ZXJzYXRpb24nOiBbXG4gICAgICAgICdfaWQnOiBBY3RpdmVDb252ZXJzYXRpb25JZCxcbiAgICAgICAgJ19uYW1lJzogQWN0aXZlQ29udmVyc2F0aW9uTmFtZSxcbiAgICAgICAgJ190eXBlJzogQWN0aXZlQ29udmVyc2F0aW9uVHlwZSxcbiAgICAgICAgJ19jb250YWN0SWRzJzogQ29udGFjdElkc1xuICAgICAgXVxuICAgIH1cbiAgfVxuXG4jIEBwcm9wZXJ0eSBbT2JqZWN0XSBTY2hlbWEgZm9yIGJsYXN0cyBidWNrZXRcbiMgQHByaXZhdGVcbmJsYXN0c1NjaGVtYSA9XG4gICdQcmVmZXJlbmNlcyc6XG4gICAgJ0FnZ3JlZ2F0ZUNvbnZlcnNhdGlvbnMnOlxuICAgICAgJ0FnZ3JlZ2F0ZUNvbnZlcnNhdGlvbic6IFtcbiAgICAgICAgJ19pZCc6ICdBY3RpdmVDb252ZXJzYXRpb25JZCcsXG4gICAgICAgICdfbmFtZSc6ICdBY3RpdmVDb252ZXJzYXRpb25OYW1lJyxcbiAgICAgICAgJ190eXBlJzogJ0FjdGl2ZUNvbnZlcnNhdGlvblR5cGUnLFxuICAgICAgICAnUmVjaXBpZW50SWQnOiAnQ29udGFjdElkcydcbiAgICAgIF1cblxuIyBBcHBseSBoYXJkIG51bWVyaWMgYm91bmRzIHRvIGNvbnZlcnRlZCBwcmVmZXJlbmNlcyBvYmplY3RcbiMgQHByaXZhdGVcbiNcbiMgQHJldHVybiBbT2JqZWN0XVxuaGFyZFRyaW0gPSAoZGF0YSkgLT5cbiAgaWYgXy5pc0FycmF5IChncm91cHMgPSBkYXRhPy5QcmVmZXJlbmNlcz8uR3JvdXBzPy5Hcm91cClcbiAgICBkYXRhLlByZWZlcmVuY2VzLkdyb3Vwcy5Hcm91cCA9IHZhbGlkTGltaXQoNjQsIHtsb2NhdGlvbjogJ0dyb3Vwcyd9KShncm91cHMpXG4gIGlmIF8uaXNBcnJheSAoY29udnMgPSBkYXRhPy5QcmVmZXJlbmNlcz8uQWN0aXZlQ29udmVyc2F0aW9ucz8uQ29udmVyc2F0aW9uKVxuICAgIGRhdGEuUHJlZmVyZW5jZXMuQWN0aXZlQ29udmVyc2F0aW9ucy5Db252ZXJzYXRpb24gPVxuICAgICAgdmFsaWRMaW1pdCg1MCwge2xvY2F0aW9uOiAnQWN0aXZlQ29udmVyc2F0aW9ucyd9KShjb252cylcbiAgaWYgXy5pc0FycmF5IChhbGVydHMgPSBkYXRhPy5QcmVmZXJlbmNlcz8uUGVyc29uYWxBbGVydHM/LkFsZXJ0KVxuICAgIGRhdGEuUHJlZmVyZW5jZXMuUGVyc29uYWxBbGVydHMuQWxlcnQgPVxuICAgICAgdmFsaWRMaW1pdCg3MDAsIHtsb2NhdGlvbjogJ1BlcnNvbmFsQWxlcnRzJ30pKGFsZXJ0cylcbiAgZGF0YVxuICAgIFxuIyBSZWZlcmVuY2UgdG8geDJqcy5qc29uMnhtbFxuIyBAcHJpdmF0ZVxudG9YTUwgPSB4MmpzLmpzb24yeG1sLmJpbmQoeDJqcylcblxuIyBSZWZlcmVuY2UgdG8geDJqcy54bWxfc3RyMmpzb25cbiMgQHByaXZhdGVcbnRvSlNPTiA9IHgyanMueG1sX3N0cjJqc29uLmJpbmQoeDJqcylcblxuIyBHZXQgYSBmdW5jdGlvbiB0byBjb252ZXJ0IHByZWZlcmVuY2VzIHRvIE5pdHJvIHNjaGVtYVxuI1xuIyBAcmV0dXJuIFtGdW5jdGlvbl1cbmV4cG9ydHMudG9OaXRybyA9IChzY2hlbWEsIHRyYW5zZm9ybXMuLi4pIC0+XG4gIGlkZW50aXR5ID0gKHgpIC0+IHhcbiAgb25seUJsYXN0cyA9IChkYXRhKSAtPlxuICAgIGNvbnZzID0gXy5hcnJheSBkYXRhPy5QcmVmZXJlbmNlcz8uQWdncmVnYXRlQ29udmVyc2F0aW9ucz8uQWdncmVnYXRlQ29udmVyc2F0aW9uXG4gICAgYmxhc3RzID0gY29udnMuZmlsdGVyIChjb252KSAtPiBjb252Ll90eXBlIGlzICdibGFzdCdcbiAgICAnUHJlZmVyZW5jZXMnOlxuICAgICAgJ0FnZ3JlZ2F0ZUNvbnZlcnNhdGlvbnMnOlxuICAgICAgICAnQWdncmVnYXRlQ29udmVyc2F0aW9uJzogYmxhc3RzXG4gIGlmIHRyYW5zZm9ybXMubGVuZ3RoXG4gICAgcG9zdCA9IHZvb20uZi5hcHBseSBudWxsLCB0cmFuc2Zvcm1zXG4gIGVsc2VcbiAgICBwb3N0ID0gaWRlbnRpdHlcbiAgY29udmVydEdsb2JhbCA9IGYgc2NoZW1hLCBnbG9iYWxTY2hlbWEsIHBvc3QsIGhhcmRUcmltXG4gIGNvbnZlcnRDb252cyA9IGYgc2NoZW1hLCBjb252ZXJzYXRpb25zU2NoZW1hLCBwb3N0LCBoYXJkVHJpbVxuICBjb252ZXJ0RU0gPSBmIHNjaGVtYSwgZW1TY2hlbWEsIHBvc3QsIGhhcmRUcmltXG4gIGNvbnZlcnRBbGVydHMgPSBmIHNjaGVtYSwgYWxlcnRzU2NoZW1hLCBwb3N0LCBoYXJkVHJpbVxuICBjb252ZXJ0Qmxhc3RzID0gZiBjb252ZXJzYXRpb25zU2NoZW1hLCBibGFzdHNTY2hlbWEsIG9ubHlCbGFzdHMsIHBvc3QsIGhhcmRUcmltXG4gIChkYXRhKSAtPlxuICAgIGNvbnZlcnRlZENvbnZzID0gY29udmVydENvbnZzIGRhdGFcbiAgICAnZ2xvYmFsJzogdG9YTUwgY29udmVydEdsb2JhbCBkYXRhXG4gICAgJ2NvbnZlcnNhdGlvbnMnOiB0b1hNTCBjb252ZXJ0ZWRDb252c1xuICAgICdlbSc6IHRvWE1MIGNvbnZlcnRFTSBkYXRhXG4gICAgJ2FsZXJ0cyc6IHRvWE1MIGNvbnZlcnRBbGVydHMgZGF0YVxuICAgICdibGFzdHMnOiB0b1hNTCBjb252ZXJ0Qmxhc3RzIGNvbnZlcnRlZENvbnZzXG5cbiMgR2V0IGEgZnVuY3Rpb24gdG8gY29udmVydCBwcmVmZXJlbmNlcyB0byBOaXRybyBzY2hlbWFcbiNcbiMgQHJldHVybiBbRnVuY3Rpb25dXG5leHBvcnRzLmZyb21OaXRybyA9IChzY2hlbWFzLCB0cmFuc2Zvcm1zLi4uKSAtPlxuICBpZGVudGl0eSA9ICh4KSAtPiB4XG4gIGlmIHRyYW5zZm9ybXMubGVuZ3RoXG4gICAgcHJlID0gdm9vbS5mLmFwcGx5IG51bGwsIHRyYW5zZm9ybXNcbiAgZWxzZVxuICAgIHByZSA9IGlkZW50aXR5XG4gIGNvbnZlcnRHbG9iYWwgPSBmIHRvSlNPTiwgcHJlLCBnbG9iYWxTY2hlbWEsIChzY2hlbWFzLmdsb2JhbCA/IHNjaGVtYXMpXG4gIGNvbnZlcnRDb252cyA9IGYgdG9KU09OLCBwcmUsIGNvbnZlcnNhdGlvbnNTY2hlbWEsIChzY2hlbWFzLmNvbnZlcnNhdGlvbnMgPyBzY2hlbWFzKVxuICBjb252ZXJ0RU0gPSBmIHRvSlNPTiwgcHJlLCBlbVNjaGVtYSwgKHNjaGVtYXMuZW0gPyBzY2hlbWFzKVxuICBjb252ZXJ0QWxlcnRzID0gZiB0b0pTT04sIHByZSwgYWxlcnRzU2NoZW1hLCAoc2NoZW1hcy5hbGVydHMgPyBzY2hlbWFzKVxuICAoZGF0YSA9IHt9KSAtPlxuICAgIGdsb2JhbCA9IGlmIGRhdGEuZ2xvYmFsIHRoZW4gY29udmVydEdsb2JhbChkYXRhLmdsb2JhbCkgZWxzZSAnJ1xuICAgIGNvbnZlcnNhdGlvbnMgPSBpZiBkYXRhLmNvbnZlcnNhdGlvbnMgdGhlbiBjb252ZXJ0Q29udnMoZGF0YS5jb252ZXJzYXRpb25zKSBlbHNlICcnXG4gICAgZW0gPSBpZiBkYXRhLmVtIHRoZW4gY29udmVydEVNKGRhdGEuZW0pIGVsc2UgJydcbiAgICBhbGVydHMgPSBpZiBkYXRhLmFsZXJ0cyB0aGVuIGNvbnZlcnRBbGVydHMoZGF0YS5hbGVydHMpIGVsc2UgJydcbiAgICBibGFzdHMgPSAnJ1xuICAgICdnbG9iYWwnOiBnbG9iYWxcbiAgICAnY29udmVyc2F0aW9ucyc6IGNvbnZlcnNhdGlvbnNcbiAgICAnZW0nOiBlbVxuICAgICdhbGVydHMnOiBhbGVydHNcbiAgICAnYmxhc3RzJzogYmxhc3RzXG5cbiMgQ29udmVydCBKU09OIHRvIFhNTFxuI1xuIyBAcmV0dXJuIFtYTUxEb2N1bWVudF1cbmV4cG9ydHMudG9YTUwgPSB0b1hNTFxuXG4jIENvbnZlcnQgWE1MIHRvIEpTT05cbiNcbiMgQHJldHVybiBbU3RyaW5nXVxuZXhwb3J0cy50b0pTT04gPSB0b0pTT05cblxuZXhwb3J0cy5mID0gdm9vbS5mXG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbl8ubWl4aW4gcmVxdWlyZSAndXRpbC9yZXRyeWVyJ1xuVXRpbHMgPSByZXF1aXJlICd1dGlsL3V0aWxzJ1xuUSA9IHJlcXVpcmUgJ3EnXG5OaXRyb1Byb21pc2UgPSByZXF1aXJlICd1dGlsL3Byb21pc2UnXG5zdHJvcGhlQmxvY2tsaXN0ID0gcmVxdWlyZSAnc3Ryb3BoZS9zdHJvcGhlX2Jsb2NrbGlzdCdcbmFkYXB0ZXJzID0gcmVxdWlyZSAnYWRhcHRlcnMvYWRhcHRlcnMnXG5cbiMgVGhpcyBjbGFzcyBoYXMgdmlydHVhbCBtZXRob2RzLCB0aGF0IGFyZSBhdmFpbGFibGUgb24gdGhlIHNpbmdsZXRvbiBpbnN0YW5jZVxuIyByZXR1cm5lZCBieSB0aGUgc3RhdGljICNnZXQoKSBtZXRob2QuXG4jXG4jIEBtZXRob2QgI2dldEJsb2NrbGlzdCgpXG4jICAgUmV0cmlldmUgdGhlIGJsb2NrbGlzdGwgZnJvbSBOaXRyb1xuI1xuIyAgIEByZXR1cm4gW1EuUHJvbWlzZV1cbiNcbiMgICBAZXhhbXBsZSBIYW5kbGluZyBzdWNjZXNzZnVsIGFuZCBmYWlsZWQgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3RcbiMgICAgIC8vIEltcG9ydCBvcHRpb25hbCBhZGFwdGVycyB0byBwcm9jZXNzIGluY29taW5nIFhNTCBkYXRhXG4jICAgICBhZGFwdGVycyA9IHJlcXVpcmUgJ2FkYXB0ZXJzL2FkYXB0ZXJzJ1xuI1xuIyAgICAgdmFyIGNvbm5lY3Rpb24gPSBOaXRyby5nZXRDb25uZWN0aW9uKCk7XG4jICAgICB2YXIgYmxvY2tsaXN0ID0gY29ubmVjdGlvbi5nZXRDb21wb25lbnQoTml0cm8uQkxPQ0tMSVNUKTtcbiNcbiMgICAgIC8vIFJvc3RlciBkYXRhIHdpbGwgYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHkgKG5vIG5lZWQgdG8gd2FpdCBmb3IgYSBwdXNoIGV2ZW50KVxuIyAgICAgYmxvY2tsaXN0LmdldEJsb2NrbGlzdCgpXG4jICAgICAgIC8vIGFkYXB0ZXJzIGFzIHN1Y2Nlc3NzIGhhbmRsZXJzIGZvciB0aGUgcmVxdWVzdCB0byBOaXRyb1xuIyAgICAgICAudGhlbihhZGFwdGVycy5jb252ZXJ0VG9KU09OKVxuIyAgICAgICAudGhlbihmdW5jdGlvbihkYXRhKXtcbiMgICAgICAgICAvLyBhZGRpdGlvbmFsIHN1Y2Nlc3MgaGFuZGxlciAob3B0aW9uYWwpXG4jICAgICAgICAgcmV0dXJuIGRhdGE7XG4jICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiMgICAgICAgICAvLyBmYWlsdXJlIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4jICAgICAgfSk7XG4jXG4jIEBtZXRob2QgI2Jsb2NrKGppZHMgPSBbXSlcbiMgICBCbG9jayBhIGxpc3Qgb2YgY29udGFjdHMgYnkgdXNlciBKSURcbiNcbiMgICBAcGFyYW0gamlkcyBbQXJyYXk8U3RyaW5nPl0gbGlzdCBvZiBjb250YWN0IGppZHMgdG8gYmxvY2tcbiNcbiMgICBAcmV0dXJuIFtRLlByb21pc2VdXG4jXG4jICAgQGV4YW1wbGUgSGFuZGxpbmcgc3VjY2Vzc2Z1bCBhbmQgZmFpbGVkIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XG4jICAgICBibG9ja2xpc3QuYmxvY2soXCJ1c2VyamlkXCIpXG4jICAgICAgIC50aGVuIGZ1bmN0aW9uKGRhdGEpe1xuIyAgICAgICAgIC8vIHN1Y2Nlc3NzIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4jICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiMgICAgICAgICAvLyBmYWlsdXJlIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4jICAgICAgfSk7XG4jXG4jICAgQGV4YW1wbGUgUmVnaXN0ZXJpbmcgZm9yIHB1c2ggbm90aWZpY2F0aW9ucyB0byBjb25maXJtIHJlcXVlc3RzXG4jICAgICBjb25uZWN0aW9uLmV2ZW50TWFuYWdlci5saXN0ZW4oRXZlbnRzLkJMT0NLTElTVF9CTE9DSywgZnVuY3Rpb24oZGF0YSkge1xuIyAgICAgICAvLyBSZWNlaXZlIGFjdHVhbCBwdXNoIGNvbmZpcm1hdGlvbiAob3IgYW55IGZ1dHVyZSB1cGRhdGVzKVxuIyAgICAgICAvLyBmcm9tIE5pdHJvIHdoZW4gY29udGFjdChzKSBhcmUgYmxvY2tlZC5cbiMgICAgIH0pO1xuI1xuIyAgIEBzZWUgRXZlbnRzLkJMT0NLTElTVF9CTE9DS1xuI1xuIyBAbWV0aG9kICN1bmJsb2NrKGppZHMgPSBbXSlcbiMgICBVbmJsb2NrIGEgbGlzdCBvZiBjb250YWN0cyBieSB1c2VyIEpJRFxuI1xuIyAgIEBwYXJhbSBqaWRzIFtBcnJheTxTdHJpbmc+XSBsaXN0IG9mIGNvbnRhY3QgamlkcyB0byB1bmJsb2NrXG4jXG4jICAgQHJldHVybiBbUS5Qcm9taXNlXVxuI1xuIyAgIEBleGFtcGxlIEhhbmRsaW5nIHN1Y2Nlc3NmdWwgYW5kIGZhaWxlZCBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxuIyAgICAgYmxvY2tsaXN0LnVuYmxvY2soXCJ1c2VyamlkXCIpXG4jICAgICAgIC50aGVuIGZ1bmN0aW9uKGRhdGEpe1xuIyAgICAgICAgIC8vIHN1Y2Nlc3NzIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4jICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiMgICAgICAgICAvLyBmYWlsdXJlIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4jICAgICAgfSk7XG4jXG4jICAgQGV4YW1wbGUgUmVnaXN0ZXJpbmcgZm9yIHB1c2ggbm90aWZpY2F0aW9ucyB0byBjb25maXJtIHJlcXVlc3RzXG4jICAgICBjb25uZWN0aW9uLmV2ZW50TWFuYWdlci5saXN0ZW4oRXZlbnRzLkJMT0NLTElTVF9VTkJMT0NLLCBmdW5jdGlvbihkYXRhKSB7XG4jICAgICAgIC8vIFJlY2VpdmUgYWN0dWFsIHB1c2ggY29uZmlybWF0aW9uIChvciBhbnkgZnV0dXJlIHVwZGF0ZXMpXG4jICAgICAgIC8vIGZyb20gTml0cm8gd2hlbiBjb250YWN0KHMpIGFyZSB1bmJsb2NrZWQuXG4jICAgICB9KTtcbiNcbiMgICBAc2VlIEV2ZW50cy5CTE9DS0xJU1RfVU5CTE9DS1xuI1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBCbG9ja2xpc3RcblxuICAjIEBwcm9wZXJ0eSBbU3RyaW5nXSBwdWJsaWMgbmFtZSBmb3IgdGhpcyBjb21wb25lbnRcbiAgQE5BTUU6ICdjb21wb25lbnQuYmxvY2tsaXN0J1xuXG4gICMgQHByb3BlcnR5IHByaXZhdGUgaW5zdGFuY2Ugb2YgUHJpdmF0ZVN0b3JhZ2VcbiAgIyBAcHJpdmF0ZVxuICBpbnN0YW5jZSA9IG51bGxcblxuICAjIFJldHJpZXZlIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBQcml2YXRlU3RvcmFnZSBjbGFzc1xuICAjXG4gICMgQHJldHVybiBbUHJpdmF0ZVN0b3JhZ2VdIHNpbmdsZXRvbiBpbnN0YW5jZVxuICBAZ2V0OiAob3B0aW9ucyA9IHt9KSAtPlxuICAgIGNyZWF0ZUluc3RhbmNlID0gLT5cbiAgICAgIG5ldyBQcml2YXRlQmxvY2tsaXN0IG9wdGlvbnNcbiAgICBpbnN0YW5jZSA/PSBjcmVhdGVJbnN0YW5jZSgpXG5cbiAgIyBEZXN0cm95IHRoZSBzaW5nbGV0b24gaW5zdGFuY2UsIG9ubHkgZm9yIHVuaXQgdGVzdGluZ1xuICAjXG4gICMgQHJldHVybiBbQm9vbGVhbl0gdHJ1ZSBpZiB0aGUgc2luZ2xldG9uIHdhcyBkZXN0cm95ZWQsIG90aGVyd2lzZSBmYWxzZVxuICBAZGVzdHJveTogVXRpbHMucmV0dXJuQm9vbCAtPlxuICAgIGluc3RhbmNlID0gbnVsbFxuICAgIFxuICBjbGFzcyBQcml2YXRlQmxvY2tsaXN0XG5cbiAgICAjIEBwcm9wZXJ0eSBbT2JqZWN0XSBoZWxwZXIgb2JqZWN0IHdpdGggbWV0aG9kcyBmb3IgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YXNcbiAgICBoZWxwZXI6IG51bGxcblxuICAgICMgQHByb3BlcnR5IFtGdW5jdGlvbl0gbG9jYWwgcmVmZXJlbmNlIHRvIGFuIGluamVjdGVkICdzZW5kSVEnIGZ1bmN0aW9uXG4gICAgIyBAcHJpdmF0ZVxuICAgIHNlbmRJUSA9IG51bGxcblxuICAgICMgQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIFByaXZhdGVTdG9yYWdlXG4gICAgI1xuICAgICMgQHBhcmFtIG9wdGlvbnMgW09iamVjdF0gYW4gb2JqZWN0IG9mIG9wdGlvbnNcbiAgICAjIEBvcHRpb24gb3B0aW9ucyBzZW5kSVEgW0Z1bmN0aW9uXSBtZXRob2Qgd3JhcHBpbmcgU3Ryb3BoZSdzICdzZW5kSVEnXG4gICAgI1xuICAgICMgQHJldHVybiBbUHJpdmF0ZVJvc3Rlcl1cbiAgICBjb25zdHJ1Y3RvcjogKG9wdGlvbnMgPSB7fSkgLT5cbiAgICAgIHtAaGVscGVyLCBzZW5kSVF9ID0gXy5kZWZhdWx0cyBvcHRpb25zLFxuICAgICAgICBoZWxwZXI6IHN0cm9waGVCbG9ja2xpc3RcblxuICAgICMgUmV0cmlldmUgdGhlIGJsb2NrbGlzdGwgZnJvbSBOaXRybyBhbmQgcmVwbGFjZSB0aGUgbG9jYWxseSBzdG9yZWQgbGlzdFxuICAgICMgICBvZiBibG9ja2VkIGNvbnRhY3QgSklEcyB3aXRoIGEgZnJlc2ggbGlzdCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gICAgI1xuICAgICMgQGV4YW1wbGUgSGFuZGxpbmcgc3VjY2Vzc2Z1bCBhbmQgZmFpbGVkIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgIyAgIC8vIEltcG9ydCBvcHRpb25hbCBhZGFwdGVycyB0byBwcm9jZXNzIGluY29taW5nIFhNTCBkYXRhXG4gICAgIyAgIGFkYXB0ZXJzID0gcmVxdWlyZSAnYWRhcHRlcnMvYWRhcHRlcnMnXG4gICAgI1xuICAgICMgICB2YXIgY29ubmVjdGlvbiA9IE5pdHJvLmdldENvbm5lY3Rpb24oKTtcbiAgICAjICAgdmFyIGJsb2NrbGlzdCA9IGNvbm5lY3Rpb24uZ2V0Q29tcG9uZW50KE5pdHJvLkJMT0NLTElTVCk7XG4gICAgI1xuICAgICMgICAvLyBSb3N0ZXIgZGF0YSB3aWxsIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5IChubyBuZWVkIHRvIHdhaXQgZm9yIGEgcHVzaCBldmVudClcbiAgICAjICAgYmxvY2tsaXN0LmdldEJsb2NrbGlzdCgpXG4gICAgIyAgICAgLy8gYWRhcHRlcnMgYXMgc3VjY2Vzc3MgaGFuZGxlcnMgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4gICAgIyAgICAgLnRoZW4oYWRhcHRlcnMuY29udmVydFRvSlNPTilcbiAgICAjICAgICAudGhlbihmdW5jdGlvbihkYXRhKXtcbiAgICAjICAgICAgIC8vIGFkZGl0aW9uYWwgc3VjY2VzcyBoYW5kbGVyIChvcHRpb25hbClcbiAgICAjICAgICAgIHJldHVybiBkYXRhO1xuICAgICMgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAjICAgICAgIC8vIGZhaWx1cmUgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiAgICAjICAgIH0pXG4gICAgZ2V0QmxvY2tsaXN0OiAtPlxuICAgICAgIyBDcmVhdGUgbG9jYWwgdmFyIHRvIGF2b2lkIHVzaW5nIEAgKGNvbnRleHQgaXMgbG9zdCkgaW4gdGhlIGRvbmUgaGFuZGxlclxuICAgICAgc3RhbnphID0gQGhlbHBlci5nZXRCbG9ja2xpc3RTdGFuemEoKVxuICAgICAgc2VuZEJsb2NrbGlzdElRIHN0YW56YVxuXG4gICAgIyBCbG9jayBhIGxpc3Qgb2YgY29udGFjdHMgYnkgdXNlciBKSURcbiAgICAjXG4gICAgIyBAcGFyYW0gamlkcyBbQXJyYXk8U3RyaW5nPl0gbGlzdCBvZiBjb250YWN0IGppZHMgdG8gYmxvY2tcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gICAgI1xuICAgICMgQGV4YW1wbGUgSGFuZGxpbmcgc3VjY2Vzc2Z1bCBhbmQgZmFpbGVkIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgIyAgIGJsb2NrbGlzdC5ibG9jayhcInVzZXJqaWRcIilcbiAgICAjICAgICAudGhlbiBmdW5jdGlvbihkYXRhKXtcbiAgICAjICAgICAgIC8vIHN1Y2Nlc3NzIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4gICAgIyAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICMgICAgICAgLy8gZmFpbHVyZSBoYW5kbGVyIGZvciB0aGUgcmVxdWVzdCB0byBOaXRyb1xuICAgICMgICAgfSk7XG4gICAgI1xuICAgICMgQGV4YW1wbGUgUmVnaXN0ZXJpbmcgZm9yIHB1c2ggbm90aWZpY2F0aW9ucyB0byBjb25maXJtIHJlcXVlc3RzXG4gICAgIyAgIGNvbm5lY3Rpb24uZXZlbnRNYW5hZ2VyLmxpc3RlbihFdmVudHMuQkxPQ0tMSVNUX0JMT0NLLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgIyAgICAgLy8gUmVjZWl2ZSBhY3R1YWwgcHVzaCBjb25maXJtYXRpb24gKG9yIGFueSBmdXR1cmUgdXBkYXRlcylcbiAgICAjICAgICAvLyBmcm9tIE5pdHJvIHdoZW4gY29udGFjdChzKSBhcmUgYmxvY2tlZC5cbiAgICAjICAgfSk7XG4gICAgI1xuICAgICMgQHNlZSBFdmVudHMuQkxPQ0tMSVNUX0JMT0NLXG4gICAgYmxvY2s6IChqaWRzID0gW10pIC0+XG4gICAgICBqaWRzID0gVXRpbHMuYXJyYXkgamlkc1xuICAgICAgc3RhbnphID0gQGhlbHBlci5nZXRCbG9ja1N0YW56YSBqaWRzXG4gICAgICBzZW5kQmxvY2tsaXN0SVEgc3RhbnphXG5cbiAgICAjIFVuYmxvY2sgYSBsaXN0IG9mIGNvbnRhY3RzIGJ5IHVzZXIgSklEXG4gICAgI1xuICAgICMgQHBhcmFtIGppZHMgW0FycmF5PFN0cmluZz5dIGxpc3Qgb2YgY29udGFjdCBqaWRzIHRvIHVuYmxvY2tcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gICAgI1xuICAgICMgQGV4YW1wbGUgSGFuZGxpbmcgc3VjY2Vzc2Z1bCBhbmQgZmFpbGVkIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgIyAgIGJsb2NrbGlzdC51bmJsb2NrKFwidXNlcmppZFwiKVxuICAgICMgICAgIC50aGVuIGZ1bmN0aW9uKGRhdGEpe1xuICAgICMgICAgICAgLy8gc3VjY2Vzc3MgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiAgICAjICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgIyAgICAgICAvLyBmYWlsdXJlIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4gICAgIyAgICB9KTtcbiAgICAjXG4gICAgIyBAZXhhbXBsZSBSZWdpc3RlcmluZyBmb3IgcHVzaCBub3RpZmljYXRpb25zIHRvIGNvbmZpcm0gcmVxdWVzdHNcbiAgICAjICAgY29ubmVjdGlvbi5ldmVudE1hbmFnZXIubGlzdGVuKEV2ZW50cy5CTE9DS0xJU1RfVU5CTE9DSywgZnVuY3Rpb24oZGF0YSkge1xuICAgICMgICAgIC8vIFJlY2VpdmUgYWN0dWFsIHB1c2ggY29uZmlybWF0aW9uIChvciBhbnkgZnV0dXJlIHVwZGF0ZXMpXG4gICAgIyAgICAgLy8gZnJvbSBOaXRybyB3aGVuIGNvbnRhY3QocykgYXJlIHVuYmxvY2tlZC5cbiAgICAjICAgfSk7XG4gICAgI1xuICAgICMgQHNlZSBFdmVudHMuQkxPQ0tMSVNUX1VOQkxPQ0tcbiAgICB1bmJsb2NrOiAoamlkcyA9IFtdKSAtPlxuICAgICAgamlkcyA9IFV0aWxzLmFycmF5IGppZHNcbiAgICAgIHN0YW56YSA9IEBoZWxwZXIuZ2V0VW5ibG9ja1N0YW56YSBqaWRzXG4gICAgICBzZW5kQmxvY2tsaXN0SVEgc3RhbnphXG5cbiAgICAjIFNlbmQgYmxvY2tsaXN0IHJlcXVlc3QgdmlhIHNlbmRJUVxuICAgICMgQHByaXZhdGVcbiAgICAjXG4gICAgIyBAcGFyYW0gW1N0cm9waGUuQnVpbGRlcl0gZGF0YSBvYmplY3QgZm9yIHN0b3JhZ2VcbiAgICAjIEBvcHRpb25zIFtPYmplY3RdIG9iamVjdCBvZiBvcHRpb25zXG4gICAgIyBAb3B0aW9uIG9wdGlvbnMgYXR0ZW1wdCBbSW50ZWdlcl0gdGhlIGN1cnJlbnQgYXR0ZW1wdCBudW1iZXIgd2hlbiByZXRyeWluZ1xuICAgICNcbiAgICAjIEByZXR1cm4gW1Byb21pc2VdIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgYnkgc2VuZElRXG4gICAgc2VuZEJsb2NrbGlzdElRID0gKHN0YW56YSwgb3B0aW9ucyA9IHt9KSAtPlxuICAgICAgTml0cm9Qcm9taXNlIChyZXNvbHZlLCByZWplY3QpIC0+XG4gICAgICAgIHNlbmRJUVxuICAgICAgICAgIGVsZW1lbnQ6IHN0YW56YVxuICAgICAgICAgIHJlc29sdmU6IHJlc29sdmVcbiAgICAgICAgICByZWplY3Q6IHJlamVjdFxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5RID0gcmVxdWlyZSAncSdcblByZXNlbmNlVHlwZSA9IHJlcXVpcmUgJ2VudW0vcHJlc2VuY2VfdHlwZSdcblhNUFBQcmVzZW5jZSA9IHJlcXVpcmUgICdlbnVtL3htcHBfcHJlc2VuY2UnXG5HYXRld2F5U3RhdGUgPSByZXF1aXJlICdlbnVtL2dhdGV3YXlfc3RhdGUnXG5HYXRld2F5RXJyb3IgPSByZXF1aXJlICdlbnVtL2dhdGV3YXlfZXJyb3InXG5YTVBQVXRpbHMgPSByZXF1aXJlICd1dGlsL3htcHBfdXRpbHMnXG5OaXRyb1Byb21pc2UgPSByZXF1aXJlICd1dGlsL3Byb21pc2UnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgR2F0ZXdheVxuXG4gIGppZDogbnVsbFxuXG4gICMgQHByb3BlcnR5IFtPYmplY3RdIGhlbHBlciBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBTdHJvcGhlLkJ1aWxkZXIgc3Rhbnphc1xuICBoZWxwZXI6IG51bGxcblxuICAjIEBwcm9wZXJ0eSBbRGVmZXJyZWRdIHRyYWNrcyBnYXRld2F5IHJlZ2lzdHJhdGlvbiBwcm9ncmVzc1xuICAjIEBwcml2YXRlXG4gIF9yZWdpc3RlckRmZDogbnVsbFxuXG4gICMgQHByb3BlcnR5IFtEZWZlcnJlZF0gdHJhY2tzIGdhdGV3YXkgdW5yZWdpc3RyYXRpb24gcHJvZ3Jlc3NcbiAgIyBAcHJpdmF0ZVxuICBfdW5yZWdpc3RlckRmZDogbnVsbFxuXG4gICMgQHByb3BlcnR5IFtGdW5jdGlvbl0gbG9jYWwgcmVmZXJlbmNlIHRvIGFuIGluamVjdGVkICdzZW5kJyBmdW5jdGlvblxuICAjIEBwcml2YXRlXG4gIHNlbmQgPSBudWxsXG5cbiAgIyBAcHJvcGVydHkgW0Z1bmN0aW9uXSBsb2NhbCByZWZlcmVuY2UgdG8gYW4gaW5qZWN0ZWQgJ3NlbmRJUScgZnVuY3Rpb25cbiAgIyBAcHJpdmF0ZVxuICBzZW5kSVEgPSBudWxsXG5cbiAgIyBAcHJvcGVydHkgW0Z1bmN0aW9uXSBwbGFjZWhvbGRlciBmb3IgYSByYXRlIGxpbWl0ZWQgdmVyc2lvbiBvZiBzZW5kSVFcbiAgbGltaXRlZFJlZ2lzdHJhdGlvblNlbmRJUSA9IG51bGxcblxuICBjb25zdHJ1Y3RvcjogKG9wdGlvbnMpIC0+XG4gICAge0BoZWxwZXIsIHNlbmQsIHNlbmRJUX0gPSBvcHRpb25zXG5cbiAgICAjIFJhdGUgbGltaXQgdGhlIHNlbmRcbiAgICBsaW1pdGVkUmVnaXN0cmF0aW9uU2VuZElRID0gXy5saW1pdCBzZW5kSVEsXG4gICAgICBtYXg6IDVcbiAgICAgIHRpbWU6IDYwICogMTAwMFxuICAgICAgY29udGV4dDogdGhpc1xuXG4gICMgUmVnaXN0ZXIgd2l0aCB0aGUgZ2F0ZXdheSB3aGljaCBpcyBsaWtlIGxvZ2dpbmcgaW5cbiAgI1xuICAjIEBwYXJhbSBvcHRpb25zIFtPYmplY3RdIGFuIG9iamVjdCBvZiBvcHRpb25zXG4gICMgQG9wdGlvbiBvcHRpb25zIHVzZXJuYW1lIFtTdHJpbmddIGEgdW5pcXVlIHVzZXJuYW1lIGZvciB0aGUgZ2F0ZXdheSB1c2VyXG4gICMgQG9wdGlvbiBvcHRpb25zIHBhc3N3b3JkIFtTdHJpbmddIHRoZSB1c2VyJ3MgZ2F0ZXdheSBwYXNzd29yZFxuICAjXG4gICMgQHJldHVybiBbUS5Qcm9taXNlXSBwcm9taXNlIG9iamVjdCBvZiB0aGUgZGVmZXJyZWQgdXNlZCB0byBhdHRlbXB0IHJlZ2lzdHJhdGlvblxuICByZWdpc3RlcjogKG9wdGlvbnMgPSB7fSkgLT5cbiAgICAjIFByb21pc2UgaXNQZW5kaW5nKCkgc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gZm9yICdpbi1wcm9ncmVzcycgc3RhdHVzZXNcbiAgICBpZiBAX3JlZ2lzdGVyRGZkXG4gICAgICBwcm9taXNlID0gQF9yZWdpc3RlckRmZC5wcm9taXNlXG5cbiAgICAgIGlmIHByb21pc2UuaXNQZW5kaW5nKClcbiAgICAgICAgcGVuZGluZ01zZyA9IGdldFBlbmRpbmdNZXNzYWdlIEBzdGF0dXNcbiAgICAgICAgQF9yZWdpc3RlckRmZC5ub3RpZnkgc3RhdHVzLCBwZW5kaW5nTXNnXG4gICAgICAgIHJldHVybiBwcm9taXNlXG5cbiAgICBhdHRlbXB0UmVnaXN0cmF0aW9uLmNhbGwgdGhpcywgb3B0aW9uc1xuXG4gICMgVW5yZWdpc3RlciB3aXRoIHRoZSBnYXRld2F5XG4gICNcbiAgIyBAcGFyYW0gcmVhc29uIFtTdHJpbmddIG9wdGlvbmFsIG1lc3NhZ2UgZGVzY3JpYmluZyB3aHkgd2UgYXJlIHVucmVnaXN0ZXJpbmdcbiAgI1xuICAjIEByZXR1cm4gW1EuUHJvbWlzZV0gcHJvbWlzZSBvYmplY3Qgb2YgdGhlIGRlZmVycmVkIHVzZWQgdG8gYXR0ZW1wdCByZWdpc3RyYXRpb25cbiAgdW5yZWdpc3RlcjogKHJlYXNvbikgLT5cbiAgICAjIFByb21pc2UgaXNQZW5kaW5nKCkgc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gZm9yICdpbi1wcm9ncmVzcycgc3RhdHVzZXNcbiAgICBpZiBAX3VucmVnaXN0ZXJEZmRcbiAgICAgIHByb21pc2UgPSBAX3VucmVnaXN0ZXJEZmQucHJvbWlzZVxuXG4gICAgICBpZiBwcm9taXNlLmlzUGVuZGluZygpXG4gICAgICAgIHBlbmRpbmdNc2cgPSBnZXRQZW5kaW5nTWVzc2FnZSBAc3RhdHVzXG4gICAgICAgIEBfdW5yZWdpc3RlckRmZC5ub3RpZnkgc3RhdHVzLCBwZW5kaW5nTXNnXG4gICAgICAgIHJldHVybiBwcm9taXNlXG5cbiAgICBhdHRlbXB0VW5yZWdpc3RyYXRpb24uY2FsbCB0aGlzLCByZWFzb25cblxuICAjIFNlbmQgcHJlc2VuY2Ugc3RhbnphIGNvbmZpZ3VyZWQgd2l0aCAnb3B0aW9ucycgdG8gZ2F0ZXdheSBvciB0byB1c2VyLlxuICAjXG4gICMgQHBhcmFtIG9wdGlvbnMgW09iamVjdF0gb3B0aW9ucyBmb3Igc3RhbnphIGJ1aWxkaW5nXG4gICMgQG9wdGlvbiBvcHRpb25zIGppZCBbU3RyaW5nXSBkZWZhdWx0cyB0byBnYXRld2F5IGppZFxuICAjIEBvcHRpb24gb3B0aW9ucyB0eXBlIFtTdHJpbmddIG9wdGlvbmFsXG4gICMgQG9wdGlvbiBvcHRpb25zIHByZXNlbmNlIFtYTVBQUHJlc2VuY2VdIG9wdGlvbmFsLCBidXQgaWYgcHJvdmlkZWQgc2hvdWxkIGJlXG4gICMgICB2YWxpZCBYTVBQUHJlc2VuY2UuXG4gIHNldFByZXNlbmNlOiAob3B0aW9ucyA9IHt9KSAtPlxuICAgIHtqaWQsIHR5cGUsIHByZXNlbmNlfSA9IF8uZGVmYXVsdHMgb3B0aW9ucyxcbiAgICAgIGppZDogQGppZFxuICAgICAgdHlwZTogWE1QUFV0aWxzLnhtcHBQcmVzZW5jZVRvVHlwZSBwcmVzZW5jZVxuICBcbiAgICBOaXRyb1Byb21pc2UgKHJlc29sdmUsIHJlamVjdCwgcHJvZ3Jlc3MpID0+XG4gICAgICBzaG93ID0gWE1QUFV0aWxzLnhtcHBQcmVzZW5jZVRvU2hvdyBwcmVzZW5jZVxuICAgICAgc3RhbnphID0gQGhlbHBlci5nZXRTdWJzY3JpcHRpb25TdGFuemEgamlkLCB0eXBlLCBzaG93XG4gICAgICBzZW5kIGVsZW1lbnQ6IHN0YW56YSwgcmVzb2x2ZTogcmVzb2x2ZVxuXG4gICMgUmVjZWl2ZSBub3RpZmljYXRpb24gb2YgYSBjaGFuZ2UgaW4gdGhlIGNvbm5lY3Rpb24ncyBzdGF0dXMgYmV0d2VlblxuICAjICAgQ09OTkVDVEVEIGFuZCBESVNDT05ORUNURURcbiAgI1xuICAjIEBwYXJhbSBuaXRyb0Nvbm5lY3RlZCBbQm9vbGVhbl0gaW5kaWNhdGVzIG5pdHJvIGlzIGNvbm5lY3RlZC9kaXNjb25uZWN0ZWRcbiAgIyBAcGFyYW0gc2VsZkpJRCBbU3RyaW5nXSBzZWxmJ3MgSklEXG4gICNcbiAgIyBAcmV0dXJuIFtHYXRld2F5XSB0aGlzXG4gIHRvZ2dsZUNvbm5lY3Rpb246IChAbml0cm9Db25uZWN0ZWQsIHNlbGZKSUQgPSAnJykgLT5cbiAgICBpZiBAbml0cm9Db25uZWN0ZWRcbiAgICAgIGJhcmVKSUQgPSBTdHJvcGhlLmdldEJhcmVKaWRGcm9tSmlkIHNlbGZKSURcbiAgICAgIGRvbWFpbiA9IFhNUFBVdGlscy5nZXRYTVBQRG9tYWluIGJhcmVKSURcbiAgICAgIEBqaWQgPSBcInlhaG9vLiN7ZG9tYWlufVwiXG4gICAgZWxzZVxuICAgICAgQHN0YXR1cyA9IEdhdGV3YXlTdGF0ZS5VTlJFR0lTVEVSRURcbiAgICAgIEBqaWQgPSBudWxsXG5cbiAgICByZXR1cm4gdGhpc1xuXG4gICMgQWRkIGEgY29udGFjdCB0byB0aGUgUm9zdGVyXG4gICNcbiAgIyBAcGFyYW0gY29udGFjdCBbU3RyaW5nLCBPYmplY3RdIGNvbnRhY3Qgb2JqZWN0IG9yIGppZCBzdHJpbmcgZm9yIGEgY29udGFjdFxuICAjIEBwYXJhbSBvcHRpb25zIFtPYmplY3RdIG9iamVjdCBvZiBvcHRpb25zXG4gICMgQG9wdGlvbiBvcHRpb25zIGhlbHBlciBbT2JqZWN0XSBvYmplY3Qgd2l0aCBmdW5jdGlvbnMgZm9yIGdldHRpbmcgU3Ryb3BoZSBzdGFuemFzXG4gICNcbiAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gIGFkZENvbnRhY3Q6IChjb250YWN0KSAtPlxuICAgIGlmIHR5cGVvZiBjb250YWN0IGlzICdzdHJpbmcnXG4gICAgICBjb250YWN0ID0gamlkOiBjb250YWN0XG5cbiAgICB7amlkLCBuYW1lLCBncm91cHN9ID0gXy5kZWZhdWx0cyBjb250YWN0LFxuICAgICAgamlkOiAnJ1xuICAgICAgbmFtZTogXCJcIlxuICAgICAgZ3JvdXBzOiBbXVxuXG4gICAgcHJvbWlzZSA9IE5pdHJvUHJvbWlzZSAocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgcmV0dXJuIHJlamVjdCBcIkF0dGVtcHRpbmcgdG8gYWRkIGFuIGludmFsaWQgY29udGFjdCB0byB0aGUgUm9zdGVyXCIgdW5sZXNzIGppZFxuICAgICAgc2VuZFxuICAgICAgICBlbGVtZW50OiBAaGVscGVyLmdldEFkZENvbnRhY3RTdGFuemEgamlkXG4gICAgICAgIHJlc29sdmU6IHJlc29sdmVcbiAgICAgICAgcmVqZWN0OiByZWplY3RcblxuICAjIEFjY2VwdCBhIGNvbnRhY3QgaW52aXRlIGZyb20gZ2F0ZXdheS5cbiAgI1xuICAjIEBwYXJhbSBjb250YWN0IFtTdHJpbmcsIE9iamVjdF0gY29udGFjdCBvYmplY3Qgb3IgamlkIHN0cmluZyBmb3IgYSBjb250YWN0XG4gICMgQHBhcmFtIG9wdGlvbnMgW09iamVjdF0gb2JqZWN0IG9mIG9wdGlvbnNcbiAgIyBAb3B0aW9uIG9wdGlvbnMgaGVscGVyIFtPYmplY3RdIG9iamVjdCB3aXRoIGZ1bmN0aW9ucyBmb3IgZ2V0dGluZyBTdHJvcGhlIHN0YW56YXNcbiAgI1xuICAjIEByZXR1cm4gW1EuUHJvbWlzZV1cbiAgYWNjZXB0SW52aXRlOiAoY29udGFjdCkgLT5cbiAgICBpZiB0eXBlb2YgY29udGFjdCBpcyAnc3RyaW5nJ1xuICAgICAgY29udGFjdCA9IGppZDogY29udGFjdFxuXG4gICAge2ppZCwgbmFtZSwgZ3JvdXBzfSA9IF8uZGVmYXVsdHMgY29udGFjdCxcbiAgICAgIGppZDogJydcbiAgICAgIG5hbWU6IFwiXCJcbiAgICAgIGdyb3VwczogW11cblxuICAgIHByb21pc2UgPSBOaXRyb1Byb21pc2UgKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgIHJldHVybiByZWplY3QgXCJBdHRlbXB0aW5nIHRvIGFkZCBhbiBpbnZhbGlkIGNvbnRhY3QgdG8gdGhlIFJvc3RlclwiIHVubGVzcyBqaWRcbiAgICAgIHNlbmRcbiAgICAgICAgZWxlbWVudDogQGhlbHBlci5nZXRBbGxvd0NvbnRhY3RTdGFuemEgamlkXG4gICAgICAgIHJlc29sdmU6IHJlc29sdmVcbiAgICAgICAgcmVqZWN0OiByZWplY3RcblxuICAjIFJlbW92ZSBhIGNvbnRhY3QgdmlhIFlhaG9vISBHYXRld2F5XG4gICNcbiAgIyBAcGFyYW0gamlkIFtTdHJpbmddIHVzZXIgdG8gcmVtb3ZlXG4gICNcbiAgIyBAcmV0dXJuIFtQcm9taXNlXSBwcm9taXNlIG9iamVjdCBvZiB0aGUgZGVmZXJyZWQgdXNlZCB0byByZW1vdmUgY29udGFjdFxuICByZW1vdmVDb250YWN0OiAoamlkKSAtPlxuICAgIE5pdHJvUHJvbWlzZSAocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgc2VuZFxuICAgICAgICBlbGVtZW50OiBAaGVscGVyLmdldFJlbW92ZUNvbnRhY3RTdGFuemEgamlkXG4gICAgICAgIHJlc29sdmU6IHJlc29sdmVcbiAgICAgICAgcmVqZWN0OiByZWplY3RcblxuICAjIFBlcmZvcm0gd29yayBvZiBhY3R1YWxseSByZWdpc3RlcmluZyB3aXRoIHRoZSBSZW1vdGUgR2F0ZXdheVN0YXRlLiAgU2VuZHMgSVFcbiAgIyBmb3JtIHdpdGggPHVzZXJuYW1lLz4gYW5kIDxwYXNzd29yZC8+IGZpZWxkIHN0YW56YXMuXG4gICNcbiAgIyBAcGFyYW0gb3B0aW9ucyBbT2JqZWN0XSBhbiBvYmplY3Qgb2Ygb3B0aW9uc1xuICAjIEBvcHRpb24gb3B0aW9ucyB1c2VybmFtZSBbU3RyaW5nXSBhIHVuaXF1ZSB1c2VybmFtZSBmb3IgdGhlIGdhdGV3YXkgdXNlclxuICAjIEBvcHRpb24gb3B0aW9ucyBwYXNzd29yZCBbU3RyaW5nXSB0aGUgdXNlcidzIGdhdGV3YXkgcGFzc3dvcmRcbiAgI1xuICAjIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2Ugb2JqZWN0IG9mIHRoZSBkZWZlcnJlZCB1c2VkIHRvIGF0dGVtcHQgcmVnaXN0cmF0aW9uXG4gIGF0dGVtcHRSZWdpc3RyYXRpb24gPSAob3B0aW9ucyA9IHt9KSAtPlxuICAgIEBfcmVnaXN0ZXJEZmQgPSBRLmRlZmVyKClcbiAgICB7dXNlcm5hbWUsIHBhc3N3b3JkLCBhdXRvTG9naW59ID0gb3B0aW9uc1xuXG4gICAgIyBlbnN1cmUgd2UncmUgc3VibWl0dGluZyBhY3R1YWwgdXNlcm5hbWUvcGFzc3dvcmQgY29tYm9cbiAgICB1bmxlc3MgdXNlcm5hbWUgYW5kIChwYXNzd29yZCBvciBhdXRvTG9naW4pXG4gICAgICBAX3JlZ2lzdGVyRGZkLnJlamVjdCBHYXRld2F5RXJyb3IuSU5WQUxJRF9DUkVERU5USUFMU1xuICAgICAgcmV0dXJuIEBfcmVnaXN0ZXJEZmQucHJvbWlzZVxuXG4gICAgIyBtYWtlIHN1cmUgd2UgY2FuIHRhbGsgdG8gZ2F0ZXdheSBhdCBhbGwuXG4gICAgdW5sZXNzIEBuaXRyb0Nvbm5lY3RlZFxuICAgICAgQF9yZWdpc3RlckRmZC5yZWplY3QgR2F0ZXdheUVycm9yLk5PX05JVFJPX0NPTk5FQ1RJT05cbiAgICAgIHJldHVybiBAX3JlZ2lzdGVyRGZkLnByb21pc2VcblxuICAgIGVsZW1lbnQgPSBAaGVscGVyLmdldFJlZ2lzdGVyU3RhbnphIEBqaWQsIHVzZXJuYW1lLCBwYXNzd29yZCwgYXV0b0xvZ2luXG4gICAgbGltaXRFcnJvciA9IGxpbWl0ZWRSZWdpc3RyYXRpb25TZW5kSVFcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgIHJlc29sdmU6IEBfcmVnaXN0ZXJEZmQucmVzb2x2ZVxuICAgICAgcmVqZWN0OiBAX3JlZ2lzdGVyRGZkLnJlamVjdFxuXG4gICAgaWYgbGltaXRFcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICBjb25zb2xlLmVycm9yIFwiW0dhdGV3YXldXCIsIGxpbWl0RXJyb3IubWVzc2FnZVxuICAgICAgQF9yZWdpc3RlckRmZC5yZWplY3RcbiAgICAgICAganNvbjogZXJyb3I6IGxpbWl0RXJyb3IubWVzc2FnZVxuXG4gICAgQF9yZWdpc3RlckRmZC5wcm9taXNlXG5cbiAgIyBVbnJlZ2lzdGVyIHdpdGggdGhlIFJlbW90ZSBHYXRld2F5IGJ5IHNlbmRpbmcgdGhlIHByb3BlciBJUSBzdGFuemFcbiAgI1xuICAjIEBwYXJhbSByZWFzb24gW1N0cmluZ10gb3B0aW9uYWwgbWVzc2FnZSBkZXNjcmliaW5nIHdoeSB3ZSBhcmUgdW5yZWdpc3RlcmluZ1xuICAjXG4gICMgQHJldHVybiBbUHJvbWlzZV0gcHJvbWlzZSBvYmplY3Qgb2YgdGhlIGRlZmVycmVkIHVzZWQgdG8gYXR0ZW1wdCByZWdpc3RyYXRpb25cbiAgYXR0ZW1wdFVucmVnaXN0cmF0aW9uID0gKHJlYXNvbikgLT5cbiAgICBAX3JlZ2lzdGVyRGZkID0gUS5kZWZlcigpXG4gICAgc3RhbnphID0gQGhlbHBlci5nZXRVbnJlZ2lzdGVyU3RhbnphIEBqaWRcblxuICAgIHNlbmRJUVxuICAgICAgZWxlbWVudDogc3RhbnphXG4gICAgICByZXNvbHZlOiBAX3JlZ2lzdGVyRGZkLnJlc29sdmVcbiAgICAgIHJlamVjdDogQF9yZWdpc3RlckRmZC5yZWplY3RcblxuICAgIEBfcmVnaXN0ZXJEZmQucHJvbWlzZVxuXG4gICMgQHByaXZhdGVcbiAgIyBSZXRyaWV2ZSBhIG1lc3NhZ2UgaW5kaWNhdGluZyB0byB0aGUgdXNlciB0aGF0IGEgY29ubmVjdGlvbiBhdHRlbXB0IGlzXG4gICMgICAncGVuZGluZycsIGUuZy4gQ09OTkVDVElORywgQVVUSEVOVElDQVRJTkcsIG9yIERJU0NPTk5FQ1RJTkdcbiAgI1xuICAjIEBwYXJhbSBzdGF0dXMgW1N0cmluZ11cbiAgI1xuICAjIEByZXR1cm4gW1N0cmluZ10gVUkgbWVzc2FnZSBpbmZvcm1pbmcgdGhlIHVzZXIgb2YgdGhlIHR5cGUgb2YgcGVuZGluZ1xuICAjICAgY29ubmVjdGlvbiBzdGF0dXNcbiAgZ2V0UGVuZGluZ01lc3NhZ2UgPSAoc3RhdHVzKSAtPlxuICAgIHN3aXRjaCBzdGF0dXNcbiAgICAgIHdoZW4gR2F0ZXdheVN0YXRlLlJFR0lTVEVSSU5HXG4gICAgICAgIEdhdGV3YXlFcnJvci5BTFJFQURZX1JFR0lTVEVSSU5HXG4gICAgICB3aGVuIENvbm5lY3Rpb24uU1VCU0NSSUJJTkdcbiAgICAgICAgR2F0ZXdheUVycm9yLkFMUkVBRFlfU1VCU0NSSUJJTkdcbiAgICAgIHdoZW4gR2F0ZXdheVN0YXRlLlVOUkVHSVNURVJJTkdcbiAgICAgICAgR2F0ZXdheUVycm9yLkFMUkVBRFlfVU5SRUdJU1RFUklOR1xuICAgICAgd2hlbiBDb25uZWN0aW9uLlVOU1VCU0NSSUJJTkdcbiAgICAgICAgR2F0ZXdheUVycm9yLkFMUkVBRFlfVU5TVUJTQ1JJQklOR1xuICAgICAgZWxzZVxuICAgICAgICBcIlwiXG4iLCJRID0gcmVxdWlyZSAnUSdcbk5pdHJvUHJvbWlzZSA9IHJlcXVpcmUgJ3V0aWwvcHJvbWlzZSdcbl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xuVXRpbHMgPSByZXF1aXJlICd1dGlsL3V0aWxzJ1xuTWF0Y2hlcnMgPSByZXF1aXJlICd1dGlsL21hdGNoZXJzJ1xuc3Ryb3BoZU1lc3NhZ2luZyA9IHJlcXVpcmUgJ3N0cm9waGUvc3Ryb3BoZV9tZXNzYWdpbmcnXG5cbiMgVGhpcyBjbGFzcyBoYXMgdmlydHVhbCBtZXRob2RzLCB0aGF0IGFyZSBhdmFpbGFibGUgb24gdGhlIHNpbmdsZXRvbiBpbnN0YW5jZVxuIyByZXR1cm5lZCBieSB0aGUgc3RhdGljICNnZXQoKSBtZXRob2QuXG4jXG4jIEBtZXRob2QgI3NlbmQobWVzc2FnZSA9IHt9KVxuIyAgIFNlbmQgYSBtZXNzYWdlIHRvIGEgY29udmVyc2F0aW9uIGF0IGEgc3BlY2lmaWVkIGppZFxuI1xuIyAgIEBwYXJhbSBtZXNzYWdlIFtPYmplY3RdXG4jICAgQG9wdGlvbiBtZXNzYWdlIGppZCBbU3RyaW5nXSBqaWQgb2YgdGhlIGNvbnZlcnNhdGlvblxuIyAgIEBvcHRpb24gbWVzc2FnZSB0eXBlIFtTdHJpbmddIHR5cGUgb2YgdGhlIG1lc3NhZ2VcbiMgICBAb3B0aW9uIG1lc3NhZ2UgYm9keSBbU3RyaW5nXSBtZXNzYWdlIGJvZHkgdGV4dFxuI1xuIyAgIEBleGFtcGxlXG4jICAgICB2YXIgY29ubmVjdGlvbiA9IE5pdHJvLmdldENvbm5lY3Rpb24oKTtcbiMgICAgIHZhciBtZXNzYWdpbmcgPSBjb25uZWN0aW9uLmdldENvbXBvbmVudChOaXRyby5NRVNTQUdJTkcpO1xuIyAgICAgdmFyIG1lc3NhZ2UgPSB7XG4jICAgICAgIHR5cGU6ICdncm91cGNoYXQnLFxuIyAgICAgICBqaWQ6ICdzb21lLm11Yy5pLmFtLmluQGNvbmZlcmVuY2UucmV1dGVycy5uZXQnLFxuIyAgICAgICBib2R5OiAnSGVsbG8gR3JvdXBjaGF0LidcbiMgICAgIH1cbiMgICAgIG1lc3NhZ2luZy5zZW5kKG1lc3NhZ2UpO1xuY2xhc3MgTWVzc2FnaW5nXG5cbiAgIyBAcHJvcGVydHkgW1N0cmluZ10gcHVibGljIG5hbWUgZm9yIHRoaXMgY29tcG9uZW50XG4gIEBOQU1FOiAnY29tcG9uZW50Lm1lc3NhZ2luZydcblxuICAjIEBwcm9wZXJ0eSBwcml2YXRlIGluc3RhbmNlIG9mIFByaXZhdGVNZXNzYWdpbmdcbiAgIyBAcHJpdmF0ZVxuICBpbnN0YW5jZSA9IG51bGxcblxuICAjIFJldHJpZXZlIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBQcml2YXRlTWVzc2FnZXMgY2xhc3NcbiAgI1xuICAjIEByZXR1cm4gW1ByaXZhdGVNZXNzYWdlc10gc2luZ2xldG9uIGluc3RhbmNlXG4gIEBnZXQ6IChvcHRpb25zKSAtPlxuICAgIGNyZWF0ZUluc3RhbmNlID0gLT5cbiAgICAgIG5ldyBQcml2YXRlTWVzc2FnaW5nIG9wdGlvbnNcbiAgICBpbnN0YW5jZSA/PSBjcmVhdGVJbnN0YW5jZSgpXG5cbiAgIyBEZXN0cm95IHRoZSBzaW5nbGV0b24gaW5zdGFuY2UsIG9ubHkgZm9yIHVuaXQgdGVzdGluZ1xuICAjXG4gICMgQHJldHVybiBbQm9vbGVhbl0gdHJ1ZSBpZiB0aGUgc2luZ2xldG9uIHdhcyBkZXN0cm95ZWQsIG90aGVyd2lzZSBmYWxzZVxuICAjIEBub2RvY1xuICBAZGVzdHJveTogVXRpbHMucmV0dXJuQm9vbCAtPlxuICAgIGluc3RhbmNlID0gbnVsbFxuXG4gIGNsYXNzIFByaXZhdGVNZXNzYWdpbmdcblxuICAgICMgQHByb3BlcnR5IGxvY2FsIHJlZmVyZW5jZSB0byBhbiBpbmplY3RlZCAnc2VuZCcgZnVuY3Rpb25cbiAgICAjIEBwcml2YXRlXG4gICAgc2VuZCA9IG51bGxcblxuICAgICMgQHByb3BlcnR5IGxvY2FsIHJlZmVyZW5jZSB0byBhbiBpbmplY3RlZCAnc2VuZElRJyBmdW5jdGlvblxuICAgICMgQHByaXZhdGVcbiAgICBzZW5kSVEgPSBudWxsXG5cbiAgICAjIENvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBQcml2YXRlTWVzc2FnaW5nXG4gICAgI1xuICAgICMgQHBhcmFtIG9wdGlvbnMgW09iamVjdF0gYW4gb2JqZWN0IG9mIG9wdGlvbnNcbiAgICAjIEBvcHRpb24gb3B0aW9ucyBzZW5kIFtGdW5jdGlvbl0gbWV0aG9kIHdyYXBwaW5nIFN0cm9waGUncyAnc2VuZCdcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtQcml2YXRlTWVzc2FnaW5nXVxuICAgIGNvbnN0cnVjdG9yOiAob3B0aW9ucyA9IHt9KSAtPlxuICAgICAge0BoZWxwZXIsIHNlbmQsIHNlbmRJUX0gPSBfLmRlZmF1bHRzIG9wdGlvbnMsXG4gICAgICAgIGhlbHBlcjogc3Ryb3BoZU1lc3NhZ2luZ1xuXG4gICAgIyBTZW5kIGEgbWVzc2FnZSB0byBhIGNvbnZlcnNhdGlvbiBhdCBhIHNwZWNpZmllZCBqaWRcbiAgICAjXG4gICAgIyBAcGFyYW0gbWVzc2FnZSBbT2JqZWN0XVxuICAgICMgQG9wdGlvbiBtZXNzYWdlIGppZCBbU3RyaW5nXSBqaWQgb2YgdGhlIGNvbnZlcnNhdGlvblxuICAgICMgQG9wdGlvbiBtZXNzYWdlIHR5cGUgW1N0cmluZ10gdHlwZSBvZiB0aGUgbWVzc2FnZVxuICAgICMgQG9wdGlvbiBtZXNzYWdlIGJvZHkgW1N0cmluZ10gbWVzc2FnZSBib2R5IHRleHRcbiAgICAjXG4gICAgIyBAZXhhbXBsZVxuICAgICMgICB2YXIgY29ubmVjdGlvbiA9IE5pdHJvLmdldENvbm5lY3Rpb24oKTtcbiAgICAjICAgdmFyIG1lc3NhZ2luZyA9IGNvbm5lY3Rpb24uZ2V0Q29tcG9uZW50KE5pdHJvLk1FU1NBR0lORyk7XG4gICAgIyAgIHZhciBtZXNzYWdlID0ge1xuICAgICMgICAgIGppZDogJ3NvbWUubXVjLmkuYW0uaW5AY29uZmVyZW5jZS5yZXV0ZXJzLm5ldCcsXG4gICAgIyAgICAgdHlwZTogJ2dyb3VwY2hhdCcsXG4gICAgIyAgICAgYm9keTogJ0hlbGxvIEdyb3VwY2hhdC4nXG4gICAgIyAgIH1cbiAgICAjICAgLy8gU2VuZCB0aGUgbWVzc2FnZS5cbiAgICAjICAgbWVzc2FnaW5nLnNlbmQobWVzc2FnZSlcbiAgICBzZW5kOiAobWVzc2FnZSA9IHt9KSAtPlxuICAgICAge2ppZCwgYm9keSwgdHlwZSwgaWR9ID0gbWVzc2FnZVxuXG4gICAgICBOaXRyb1Byb21pc2UgKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgICAgcmV0dXJuIHJlamVjdCBcIkludmFsaWQgbWVzc2FnZVwiIHVubGVzcyBqaWQgYW5kIGJvZHlcblxuICAgICAgICBzZW5kXG4gICAgICAgICAgZWxlbWVudDogQGhlbHBlci5nZXRTZW5kU3RhbnphIGppZCwgYm9keSwgdHlwZSwgaWRcbiAgICAgICAgICByZXNvbHZlOiByZXNvbHZlXG5cbiAgICBzZW5kVHlwaW5nOiAoamlkKSAtPlxuICAgICAgTml0cm9Qcm9taXNlIChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgIHJldHVybiByZWplY3QgXCJJbnZhbGlkIG1lc3NhZ2VcIiB1bmxlc3MgamlkXG4gICAgICAgIHNlbmQgZWxlbWVudDogQGhlbHBlci5nZXRUeXBpbmdTdGFuemEgamlkXG4gICAgICAgIHJlc29sdmU6IHJlc29sdmVcblxuICAgICMgUmV0cmlldmUgYXJjaGl2ZWQgbWVzc2FnZXMgZm9yIHRoZSBwcm92aWRlZCBKSURcbiAgICAjXG4gICAgIyBAcGFyYW0gb3B0aW9ucyBbT2JqZWN0XVxuICAgICMgQG9wdGlvbiBvcHRpb25zIGppZCBbU3RyaW5nXSBqaWQgb2YgdGhlIGNvbnZlcnNhdGlvblxuICAgICMgQG9wdGlvbiBvcHRpb25zIGJlZm9yZSBbU3RyaW5nXSBtZXNzYWdlIGlkIGZvciB0aGUgbW9zdCByZWNlbnQgbWVzc2FnZVxuICAgICMgICBhbHJlYWR5IGtub3duIGluIHRoZSBjbGllbnQgbWVzc2FnZVxuICAgICMgQG9wdGlvbiBvcHRpb25zIG1heCBbSW50ZWdlcl0gbnVtYmVyIG9mIGhpc3RvcnkgbWVzc2FnZSBiZWluZyByZXF1ZXN0ZWRcbiAgICAjICAgZGVmYXVsdCBpcyA1MFxuICAgICNcbiAgICAjIEByZXR1cm4gW1EuUHJvbWlzZV0gZGlmZmVyZW50IGhpc3RvcnkgcmVxdWVzdCB3aWxsIHJldHVybiBkaWZmZXJlbnRcbiAgICAjICAgcmVzcG9uc2VzIHRvIHRoZSBwcm9taXNlJ3MgcmVzb2x2ZShkYXRhKTtcbiAgICAjXG4gICAgIyBAZXhhbXBsZSBIYW5kbGluZyBzdWNjZXNzZnVsIGFuZCBmYWlsZWQgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICAjICAgLy8gSW1wb3J0IG9wdGlvbmFsIGFkYXB0ZXJzIHRvIHByb2Nlc3MgaW5jb21pbmcgWE1MIGRhdGFcbiAgICAjICAgYWRhcHRlcnMgPSByZXF1aXJlICdhZGFwdGVycy9hZGFwdGVycydcbiAgICAjIEBleGFtcGxlXG4gICAgIyAgIHZhciBjb25uZWN0aW9uID0gTml0cm8uZ2V0Q29ubmVjdGlvbigpO1xuICAgICMgICB2YXIgbWVzc2FnaW5nID0gY29ubmVjdGlvbi5nZXRDb21wb25lbnQoTml0cm8uTUVTU0FHSU5HKTtcbiAgICAjXG4gICAgIyAgIC8vIEFyY2hpdmVkIG1lc3NhZ2VzIHdpbGwgYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHkgKG5vIG5lZWQgdG8gd2FpdCBmb3IgYSBwdXNoIGV2ZW50KVxuICAgICMgICBtZXNzYWdpbmcuZ2V0SGlzdG9yeSgpXG4gICAgIyAgICAgLy8gYWRhcHRlcnMgYXMgc3VjY2Vzc3MgaGFuZGxlcnMgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4gICAgIyAgICAgLnRoZW4oYWRhcHRlcnMuY29udmVydFRvSlNPTilcbiAgICAjICAgICAudGhlbihmdW5jdGlvbihkYXRhKXtcbiAgICAjICAgICAgIC8vIGFkZGl0aW9uYWwgc3VjY2VzcyBoYW5kbGVyIChvcHRpb25hbClcbiAgICAjICAgICAgIHJldHVybiBkYXRhO1xuICAgICMgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAjICAgICAgIC8vIGZhaWx1cmUgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiAgICAjICAgIH0pXG4gICAgZ2V0SGlzdG9yeTogKG9wdGlvbnMgPSB7fSkgLT5cbiAgICAgIHtqaWQsIGJlZm9yZSwgbWF4fSA9IG9wdGlvbnNcbiAgICAgIE5pdHJvUHJvbWlzZSAocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgICByZXR1cm4gcmVqZWN0IFwiSW52YWxpZCBjb252ZXJzYXRpb24gamlkIHBhc3NlZCB0byBoaXN0b3J5IHF1ZXJ5XCIgdW5sZXNzIGppZFxuICAgICAgICBnZXRIaXN0b3J5U3RhbnphID1cbiAgICAgICAgICAjIG1hbmFnZWQvbGVnYWN5IGdyb3VwY2hhdFxuICAgICAgICAgIGlmIE1hdGNoZXJzLmlzTWFuYWdlZEdyb3VwY2hhdCBqaWRcbiAgICAgICAgICAgIEBoZWxwZXIuZ2V0TWFuYWdlZEhpc3RvcnlTdGFuemFcbiAgICAgICAgICAjIGdyb3VwY2hhdFxuICAgICAgICAgIGVsc2UgaWYgTWF0Y2hlcnMuaXNHcm91cGNoYXQgamlkXG4gICAgICAgICAgICBAaGVscGVyLmdldEdyb3VwY2hhdEhpc3RvcnlTdGFuemFcbiAgICAgICAgICAjIGNoYXRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBAaGVscGVyLmdldENoYXRIaXN0b3J5U3RhbnphXG4gICAgICAgIHNlbmRJUVxuICAgICAgICAgIGVsZW1lbnQ6IGdldEhpc3RvcnlTdGFuemEgamlkLCBiZWZvcmUsIG1heFxuICAgICAgICAgIHJlc29sdmU6IHJlc29sdmVcbiAgICAgICAgICByZWplY3Q6IHJlamVjdFxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2luZ1xuIiwiUSA9IHJlcXVpcmUgJ1EnXG5OaXRyb1Byb21pc2UgPSByZXF1aXJlICd1dGlsL3Byb21pc2UnXG5fID0gcmVxdWlyZSAndW5kZXJzY29yZSdcblNpenpsZSA9IHJlcXVpcmUgJ3NpenpsZSdcbkNvbmZpZyA9IHJlcXVpcmUgJ2NvbmZpZydcbnN0cm9waGVNVUMgPSByZXF1aXJlICdzdHJvcGhlL3N0cm9waGVfbXVjJ1xuTVVDRmllbGQgPSByZXF1aXJlICdlbnVtL211Y19maWVsZCdcbk1VQ1JvbGUgPSByZXF1aXJlICdlbnVtL211Y19yb2xlJ1xuVXRpbHMgPSByZXF1aXJlICd1dGlsL3V0aWxzJ1xuTWF0Y2hlcnMgPSByZXF1aXJlICd1dGlsL21hdGNoZXJzJ1xuXG4jIFRoaXMgY2xhc3MgaGFzIHZpcnR1YWwgbWV0aG9kcywgdGhhdCBhcmUgYXZhaWxhYmxlIG9uIHRoZSBzaW5nbGV0b24gaW5zdGFuY2VcbiMgcmV0dXJuZWQgYnkgdGhlIHN0YXRpYyAjZ2V0KCkgbWV0aG9kLlxuI1xuIyBAbWV0aG9kICNzZWxmSklEQXNNVUNSZXNvdXJjZSgpXG4jICAgQ29udmVydHMgc2VsZidzIGppZCB0byB2YWxpZCAoaS5lLiwgTml0cm8gYWxsb3dlZCkgcmVzb3VyY2UgaWQsXG4jICAgd2hpY2ggaXMgdXNlZCBhcyB0aGUgJ25pY2snIGZvciBzZWxmIGluIHRoZSBncm91cGNoYXRcbiNcbiMgICBAcmV0dXJuIFtTdHJpbmddIHZhbGlkIHJlc291cmNlIGlkXG4jXG4jIEBtZXRob2QgI2dldEJhcmVTZWxmSklEKClcbiMgICBHZXQgc2VsZidzIGJhcmUgSklEXG4jXG4jICAgQHJldHVybiBbU3RyaW5nXSBCYXJlIEpJRCBvZiBzZWxmXG4jXG4jIEBtZXRob2QgI2NyZWF0ZShvcHRpb25zID0ge30pXG4jICAgQ3JlYXRlIGEgbmV3IE1VQyAoZ3JvdXBjaGF0KVxuI1xuIyAgIEBwYXJhbSBvcHRpb25zIFtPYmplY3RdIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBncm91cGNoYXRcbiMgICBAb3B0aW9uIG9wdGlvbnMgamlkIFtTdHJpbmddIGdyb3VwY2hhdCBqaWRcbiMgICBAb3B0aW9uIG9wdGlvbnMgbmFtZSBbU3RyaW5nXSBncm91cGNoYXQgbmFtZVxuI1xuIyAgIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2UgdG8gY29tcGxldGUgdGhlIHRhc2tcbiNcbiMgQG1ldGhvZCAjZGVzdHJveShqaWQpXG4jICAgRGVzdHJveSBhbiBleGlzdGluZyBNVUMgKGdyb3VwY2hhdCkuICBOT1RFOiBUaGlzIGNhbiBvbmx5IGJlIHBlcmZvcm1lZFxuIyAgIGlmIHNlbGYgaXMgdGhlICdvd25lcicgYW5kIHNlbGYgbXVzdCBiZSBpbiB0aGUgcm9vbS5cbiNcbiMgICBAcGFyYW0gamlkIFtTdHJpbmddIGppZCBvZiBncm91cGNoYXQgdG8gZGVzdHJveVxuI1xuIyAgIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2UgdG8gY29tcGxldGUgdGhlIHRhc2tcbiNcbiMgQG1ldGhvZCAjYWNjZXB0RGVmYXVsdENvbmZpZ3VyYXRpb24ob3B0aW9ucylcbiMgICBBY2NlcHQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBmb3IgYW4gZXhpc3RpbmcgTVVDIChncm91cGNoYXQpLmZcbiMgICBHZW5lcmFsbHkgdGhpcyB3aWxsIG5vdCBiZSBjYWxsZWQgYnkgdGhlIGFwcCwgYnV0IHJhdGhlciBieSB0aGUgTVVDXG4jICAgY29tcG9uZW50IGl0c2VsZi4gIFRoZSAjY3JlYXRlKCkgbWV0aG9kIHRha2VzIHRoZSBuYW1lIGFzIGFuIG9wdGlvblxuIyAgIGFuZCBjYWxscyBhY2NlcHREZWZhdWx0Q29uZmlndXJhdGlvbiguLikgb24gdGhlIHJlcXVlc3RlcidzIGJlaGFsZi5cbiNcbiMgICBAcGFyYW0gb3B0aW9ucyBbT2JqZWN0XSBvcHRpb25zIGZvciBhY2NlcHRpbmcgZ3JvdXBjaGF0IGRlZmF1bHQgY29uZmlnXG4jICAgQG9wdGlvbiBvcHRpb25zIGppZCBbU3RyaW5nXSBncm91cGNoYXQgamlkXG4jICAgQG9wdGlvbiBvcHRpb25zIG5hbWUgW1N0cmluZ10gZ3JvdXBjaGF0IG5hbWVcbiNcbiMgICBAcmV0dXJuIFtQcm9taXNlXSBwcm9taXNlIHRvIGNvbXBsZXRlIHRoZSB0YXNrXG4jXG4jIEBtZXRob2QgI2pvaW4oamlkKVxuIyAgIEpvaW4gYW4gZXhpc3RpbmcgTVVDIChncm91cGNoYXQpXG4jXG4jICAgQHBhcmFtIGppZCBbU3RyaW5nXSBqaWQgb2YgZ3JvdXBjaGF0IHRvIGpvaW5cbiNcbiMgICBAcmV0dXJuIFtQcm9taXNlXSBwcm9taXNlIHRvIGNvbXBsZXRlIHRoZSB0YXNrXG4jXG4jIEBtZXRob2QgI2xlYXZlKGppZClcbiMgICBMZWF2ZSBhbiBleGlzdGluZyBNVUMgKGdyb3VwY2hhdClcbiNcbiMgICBAcGFyYW0gamlkIFtTdHJpbmddIGppZCBvZiBncm91cGNoYXQgdG8gbGVhdmVcbiNcbiMgICBAcmV0dXJuIFtQcm9taXNlXSBwcm9taXNlIHRvIGNvbXBsZXRlIHRoZSB0YXNrXG4jXG4jIEBtZXRob2QgI3Jvb21EaXNjbyhqaWQpXG4jICAgU2VuZCBhIGRpc2NvIHJlcXVlc3QgdG8gc3BlY2lmaWVkIE1VQyAoZ3JvdXBjaGF0KVxuI1xuIyAgIEBwYXJhbSBqaWQgW1N0cmluZ10gamlkIG9mIGdyb3VwY2hhdCB0byBxdWVyeVxuI1xuIyAgIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2UgdG8gY29tcGxldGUgdGhlIHRhc2tcbiNcbiMgQG1ldGhvZCAjcmVxdWVzdE1lbWJlckxpc3Q6IChqaWQsIGFmZmlsaWF0aW9ucyA9IE1VQ1JvbGUuT1dORVIpIC0+XG4jICAgUmVxdWVzdCBhIE1VQyAoZ3JvdXBjaGF0KSBtZW1iZXIgbGlzdC4gIE5PVEU6IFNlbGYgbXVzdCBiZSBpblxuIyAgIHRoZSBncm91cGNoYXQgdG8gbWFrZSB0aGlzIHJlcXVlc3QuXG4jXG4jICAgQHBhcmFtIGppZCBbU3RyaW5nXSBqaWQgb2Ygcm9vbSB0byBxdWVyeVxuIyAgIEBwYXJhbSBhZmZpbGlhdGlvbnMgW1N0cmluZywgQXJyYXk8U3RyaW5nPl0gYWZmaWxpYXRpb24ocykgdG8gbGlzdFxuI1xuIyAgIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2UgdG8gY29tcGxldGUgdGhlIHRhc2tcbiNcbiMgQG1ldGhvZCAjc2VuZE1hbmFnZWRJbnZpdGUoamlkLCBpbnZpdGVlcyA9IFtdKVxuIyAgIFNlbmQgYSBtYW5hZ2VkIGludml0ZSB0byBhIHVzZXIgdmlhIHNwZWNpZmllZCBNVUMgKGdyb3VwY2hhdClcbiNcbiMgICBAcGFyYW0gamlkIFtTdHJpbmddIGppZCBvZiBncm91cGNoYXRcbiMgICBAcGFyYW0gaW52aXRlZXMgW0FycmF5PFN0cmluZz5dIGFycmF5IG9mIGppZHMgdG8gaW52aXRlIHRvIGdyb3VwY2hhdFxuI1xuIyAgIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2UgdG8gY29tcGxldGUgdGhlIHRhc2tcbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTVVDXG5cbiAgIyBAcHJvcGVydHkgW1N0cmluZ10gcHVibGljIG5hbWUgZm9yIHRoaXMgY29tcG9uZW50XG4gIEBOQU1FOiAnY29tcG9uZW50Lm11YydcblxuICAjIEBwcm9wZXJ0eSBbU3RyaW5nXSBlcnJvciBtZXNzYWdlIGZvciB3aGVuIGEgZ3JvdXBjaGF0IGppZCBpcyBpbnZhbGlkXG4gIEBJTlZBTElEX0dST1VQQ0hBVF9KSUQ6IFwiUmVqZWN0ZWQgZHVlIHRvIGFuIGludmFsaWQgZ3JvdXBjaGF0IGppZFwiXG5cbiAgIyBAcHJvcGVydHkgcHJpdmF0ZSBpbnN0YW5jZSBvZiBQcml2YXRlTVVDXG4gICMgQHByaXZhdGVcbiAgaW5zdGFuY2UgPSBudWxsXG4gICMgUmV0cmlldmUgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIFByaXZhdGVNVUMgY2xhc3NcbiAgI1xuICAjIEByZXR1cm4gW1ByaXZhdGVNVUNdIHNpbmdsZXRvbiBpbnN0YW5jZVxuICBAZ2V0OiAob3B0aW9ucykgLT5cbiAgICBjcmVhdGVJbnN0YW5jZSA9IC0+XG4gICAgICBuZXcgUHJpdmF0ZU1VQyBvcHRpb25zXG4gICAgaW5zdGFuY2UgPz0gY3JlYXRlSW5zdGFuY2UoKVxuXG4gICMgRGVzdHJveSB0aGUgc2luZ2xldG9uIGluc3RhbmNlLCBvbmx5IGZvciB1bml0IHRlc3RpbmdcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIHRydWUgaWYgdGhlIHNpbmdsZXRvbiB3YXMgZGVzdHJveWVkLCBvdGhlcndpc2UgZmFsc2VcbiAgIyBAbm9kb2NcbiAgQGRlc3Ryb3k6IFV0aWxzLnJldHVybkJvb2wgLT5cbiAgICBpbnN0YW5jZSA9IG51bGxcblxuICBjbGFzcyBQcml2YXRlTVVDXG5cbiAgICAjIEBwcm9wZXJ0eSBsb2NhbCByZWZlcmVuY2UgdG8gYW4gaW5qZWN0ZWQgJ3NlbmQnIGZ1bmN0aW9uXG4gICAgIyBAcHJpdmF0ZVxuICAgIHNlbmQgPSBudWxsXG5cbiAgICAjIEBwcm9wZXJ0eSBsb2NhbCByZWZlcmVuY2UgdG8gYW4gaW5qZWN0ZWQgJ3NlbmRJUScgZnVuY3Rpb25cbiAgICAjIEBwcml2YXRlXG4gICAgc2VuZElRID0gbnVsbFxuXG4gICAgIyBAcHJvcGVydHkgZ2V0cyB0aGUgY3VycmVudCB1c2VyJ3MgamlkIGZyb20gdGhlIGNvbm5lY3Rpb24gb2JqZWN0XG4gICAgIyBAcHJpdmF0ZVxuICAgIGdldEpJRCA9IG51bGxcblxuICAgICMgQHByb3BlcnR5IEV2ZW50TWFuYWdlciBpbnN0YW5jZSBhdHRhY2hlZCB0byBjb25uZWN0aW9uLCB1c2VkIHRvIGxpc3RlbiBmb3JcbiAgICAjICAgc2VydmVyIHB1c2ggZGF0YVxuICAgICMgQHByaXZhdGVcbiAgICBldmVudE1hbmFnZXIgPSBudWxsXG5cbiAgICAjIEBwcm9wZXJ0eSBbT2JqZWN0XSBoZWxwZXIgb2JqZWN0IHdpdGggbWV0aG9kcyBmb3IgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YXNcbiAgICBoZWxwZXI6IG51bGxcblxuICAgICMgQHByb3BlcnR5IHZhbGlkYXRvciBmb3IgTml0cm8gSklEICdsb2NhbCcgcGFydFxuICAgIHJlZ2V4VXNlckxvY2FsID0gL14oW1xcd1xcXFwnXCJdXFwuPykrL2lcblxuICAgICMgQHByb3BlcnR5IHZhbGlkYXRvciBmb3IgTml0cm8gSklEICdkb21haW4nIHBhcnRcbiAgICByZWdleFVzZXJEb21haW4gPSAvXihjb2xsYWJcXC4ocmV1dGVzdHx0aG9tc29ucmV1dGVyc3xpY3AyXFwubXBwXFwucmV1dGVzdClcXC5jb20pJC9pXG5cbiAgICAjIEBwcm9wZXJ0eSB2YWxpZGF0b3IgZm9yIE5pdHJvIEpJRCAnbG9jYWwnIHBhcnRcbiAgICByZWdleE1VQ0xvY2FsID0gL14oW1xcd1xcXFwnXCJ+XFwkYCFcXCstPXt9XFxbXFxdXVxcLj8pKy9pXG5cbiAgICAjIEBwcm9wZXJ0eSB2YWxpZGF0b3IgZm9yIE5pdHJvIEpJRCAnZG9tYWluJyBwYXJ0XG4gICAgcmVnZXhNVUNEb21haW4gPVxuICAgICAgL14oY29uZmVyZW5jZXxsZWdhY3ljaGF0KVxcLigocmV1YXNtYnxyZXV0ZXJzKVxcLm5ldHxhcnJheTEyXFwubXNndHN0XFwucmV1dGVyc1xcLmNvbSkkL2lcblxuICAgICMgVmFsaWRhdGUgYSBNVUMgKGdyb3VwY2hhdCkgSklEXG4gICAgIyBAcGFyYW0gW1N0cmluZ10gamlkIG9mIGdyb3VwY2hhdCB0byB0ZXN0XG4gICAgIyBAcmV0dXJuIFtCb29sZWFuXSB2YWxpZD9cbiAgICBpc1ZhbGlkTVVDSklEID0gKGppZCkgLT5cbiAgICAgICMgbXVzdCBwYXNzIGEgc3RyaW5nXG4gICAgICByZXR1cm4gZmFsc2UgdW5sZXNzIF8uaXNTdHJpbmcgamlkXG5cbiAgICAgICMgc3BsaXQgb24gQCwgZW5zdXJlIGV4YWN0bHkgdHdvIHNlY3Rpb25zXG4gICAgICByZXR1cm4gZmFsc2UgdW5sZXNzIChwYXJ0cyA9IGppZC5zcGxpdCAnQCcpLmxlbmd0aCBpcyAyXG5cbiAgICAgICMgdmFsaWQgbG9jYWwgcGFydCBhbmQgdmFsaWQgZG9tYWluIHBhcnQ/XG4gICAgICByZWdleE1VQ0xvY2FsLnRlc3QocGFydHNbMF0pIGFuZCByZWdleE1VQ0RvbWFpbi50ZXN0KHBhcnRzWzFdKVxuXG4gICAgY29uc3RydWN0b3I6IChvcHRpb25zKSAtPlxuICAgICAge0BoZWxwZXIsIHNlbmQsIHNlbmRJUSwgZ2V0SklELCBldmVudE1hbmFnZXJ9ID0gXy5kZWZhdWx0cyBvcHRpb25zLFxuICAgICAgICBoZWxwZXI6IHN0cm9waGVNVUNcblxuICAgICMgQ29udmVydHMgc2VsZidzIGppZCB0byB2YWxpZCAoaS5lLiwgTml0cm8gYWxsb3dlZCkgcmVzb3VyY2UgaWQsXG4gICAgIyB3aGljaCBpcyB1c2VkIGFzIHRoZSAnbmljaycgZm9yIHNlbGYgaW4gdGhlIGdyb3VwY2hhdFxuICAgICNcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdmFsaWQgcmVzb3VyY2UgaWRcbiAgICBzZWxmSklEQXNNVUNSZXNvdXJjZTogLT5cbiAgICAgIGlmIGppZCA9IFN0cm9waGUuZ2V0QmFyZUppZEZyb21KaWQgZ2V0SklEKClcbiAgICAgICAgamlkLnJlcGxhY2UgJ0AnLCAnX18nXG4gICAgICBlbHNlXG4gICAgICAgICcnXG5cbiAgICAjIEdldCBzZWxmJ3MgYmFyZSBKSURcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIEJhcmUgSklEIG9mIHNlbGZcbiAgICBnZXRCYXJlU2VsZkpJRDogLT5cbiAgICAgIFN0cm9waGUuZ2V0QmFyZUppZEZyb21KaWQgZ2V0SklEKClcblxuICAgICMgQ3JlYXRlIGEgbmV3IE1VQyAoZ3JvdXBjaGF0KVxuICAgICNcbiAgICAjIEBwYXJhbSBvcHRpb25zIFtPYmplY3RdIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBncm91cGNoYXRcbiAgICAjIEBvcHRpb24gb3B0aW9ucyBqaWQgW1N0cmluZ10gZ3JvdXBjaGF0IGppZFxuICAgICMgQG9wdGlvbiBvcHRpb25zIG5hbWUgW1N0cmluZ10gZ3JvdXBjaGF0IG5hbWVcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtQcm9taXNlXSBwcm9taXNlIHRvIGNvbXBsZXRlIHRoZSB0YXNrXG4gICAgY3JlYXRlOiAob3B0aW9ucyA9IHt9KSAtPlxuICAgICAge2ppZCwgbmFtZX0gPSBvcHRpb25zXG4gICAgICBhY2NlcHREZWZhdWx0Q29uZmlndXJhdGlvbiA9IF8uYmluZCBAYWNjZXB0RGVmYXVsdENvbmZpZ3VyYXRpb24sIHRoaXNcbiAgICAgIE5pdHJvUHJvbWlzZSAocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgICAjIG11c3QgcHJvdmlkZSB2YWxpZCBtdWMgamlkXG4gICAgICAgIHJldHVybiByZWplY3QgZ2V0SW52YWxpZEpJRFN0cmluZyBqaWQgdW5sZXNzIGlzVmFsaWRNVUNKSUQgamlkXG4gICAgICAgICMgY2FsbCBqb2luXG4gICAgICAgIEBqb2luIGppZFxuICAgICAgICAgIC50aGVuIChzdGFuemEpIC0+XG4gICAgICAgICAgICBhY2NlcHREZWZhdWx0Q29uZmlndXJhdGlvbiBqaWQ6IGppZCwgbmFtZTogbmFtZVxuICAgICAgICAgICAgICAudGhlbiByZXNvbHZlXG4gICAgICAgICAgLmZhaWwgcmVqZWN0XG5cbiAgICAjIERlc3Ryb3kgYW4gZXhpc3RpbmcgTVVDIChncm91cGNoYXQpLiAgTk9URTogVGhpcyBjYW4gb25seSBiZSBwZXJmb3JtZWRcbiAgICAjIGlmIHNlbGYgaXMgdGhlICdvd25lcicgYW5kIHNlbGYgbXVzdCBiZSBpbiB0aGUgcm9vbS5cbiAgICAjXG4gICAgIyBAcGFyYW0gamlkIFtTdHJpbmddIGppZCBvZiBncm91cGNoYXQgdG8gZGVzdHJveVxuICAgICNcbiAgICAjIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2UgdG8gY29tcGxldGUgdGhlIHRhc2tcbiAgICBkZXN0cm95OiAoamlkKSAtPlxuICAgICAgcmV0dXJuIGdldEpJRFJlamVjdGVkUHJvbWlzZSBqaWQgdW5sZXNzIGlzVmFsaWRNVUNKSUQgamlkXG4gICAgICBzZW5kTVVDUmVxdWVzdCBzZW5kSVEsIEBoZWxwZXIuZ2V0RGVzdHJveUdyb3VwY2hhdFN0YW56YSBqaWRcblxuICAgICMgQWNjZXB0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gZm9yIGFuIGV4aXN0aW5nIE1VQyAoZ3JvdXBjaGF0KS5cbiAgICAjIEdlbmVyYWxseSB0aGlzIHdpbGwgbm90IGJlIGNhbGxlZCBieSB0aGUgYXBwLCBidXQgcmF0aGVyIGJ5IHRoZSBNVUNcbiAgICAjIGNvbXBvbmVudCBpdHNlbGYuICBUaGUgI2NyZWF0ZSgpIG1ldGhvZCB0YWtlcyB0aGUgbmFtZSBhcyBhbiBvcHRpb25cbiAgICAjIGFuZCBjYWxscyBhY2NlcHREZWZhdWx0Q29uZmlndXJhdGlvbiguLikgb24gdGhlIHJlcXVlc3RlcidzIGJlaGFsZi5cbiAgICAjXG4gICAgIyBAcGFyYW0gb3B0aW9ucyBbT2JqZWN0XSBvcHRpb25zIGZvciBhY2NlcHRpbmcgZ3JvdXBjaGF0IGRlZmF1bHQgY29uZmlnXG4gICAgIyBAb3B0aW9uIG9wdGlvbnMgamlkIFtTdHJpbmddIGdyb3VwY2hhdCBqaWRcbiAgICAjIEBvcHRpb24gb3B0aW9ucyBuYW1lIFtTdHJpbmddIGdyb3VwY2hhdCBuYW1lXG4gICAgI1xuICAgICMgQHJldHVybiBbUHJvbWlzZV0gcHJvbWlzZSB0byBjb21wbGV0ZSB0aGUgdGFza1xuICAgIGFjY2VwdERlZmF1bHRDb25maWd1cmF0aW9uOiAob3B0aW9ucykgLT5cbiAgICAgIHtqaWQsIG5hbWV9ID0gb3B0aW9uc1xuICAgICAgcmV0dXJuIGdldEpJRFJlamVjdGVkUHJvbWlzZSBqaWQgdW5sZXNzIGlzVmFsaWRNVUNKSUQgamlkXG4gICAgICBzZW5kTVVDUmVxdWVzdCBzZW5kSVEsIEBoZWxwZXIuZ2V0R3JvdXBjaGF0Q29uZmlnRm9ybSBqaWQsIE1VQ0ZpZWxkLlJPT01fTkFNRSwgbmFtZVxuXG4gICAgIyBKb2luIGFuIGV4aXN0aW5nIE1VQyAoZ3JvdXBjaGF0KVxuICAgICNcbiAgICAjIEBwYXJhbSBqaWQgW1N0cmluZ10gamlkIG9mIGdyb3VwY2hhdCB0byBqb2luXG4gICAgI1xuICAgICMgQHJldHVybiBbUHJvbWlzZV0gcHJvbWlzZSB0byBjb21wbGV0ZSB0aGUgdGFza1xuICAgIGpvaW46IChqaWQpIC0+XG4gICAgICByZXR1cm4gZ2V0SklEUmVqZWN0ZWRQcm9taXNlIGppZCB1bmxlc3MgaXNWYWxpZE1VQ0pJRCBqaWRcbiAgICAgIHNlbmRNVUNSZXF1ZXN0IHNlbmQsIEBoZWxwZXIuZ2V0Sm9pblN0YW56YSBqaWQsIEBzZWxmSklEQXNNVUNSZXNvdXJjZSgpXG5cbiAgICAjIExlYXZlIGFuIGV4aXN0aW5nIE1VQyAoZ3JvdXBjaGF0KVxuICAgICNcbiAgICAjIEBwYXJhbSBqaWQgW1N0cmluZ10gamlkIG9mIGdyb3VwY2hhdCB0byBsZWF2ZVxuICAgICNcbiAgICAjIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2UgdG8gY29tcGxldGUgdGhlIHRhc2tcbiAgICBsZWF2ZTogKGppZCkgLT5cbiAgICAgIHJldHVybiBnZXRKSURSZWplY3RlZFByb21pc2UgamlkIHVubGVzcyBpc1ZhbGlkTVVDSklEIGppZFxuICAgICAgc2VuZE1VQ1JlcXVlc3Qgc2VuZCwgQGhlbHBlci5nZXRMZWF2ZVN0YW56YSBqaWRcblxuICAgICMgU2VuZCBhIGRpc2NvIHJlcXVlc3QgdG8gc3BlY2lmaWVkIE1VQyAoZ3JvdXBjaGF0KVxuICAgICNcbiAgICAjIEBwYXJhbSBqaWQgW1N0cmluZ10gamlkIG9mIGdyb3VwY2hhdCB0byBxdWVyeVxuICAgICNcbiAgICAjIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2UgdG8gY29tcGxldGUgdGhlIHRhc2tcbiAgICByb29tRGlzY286IChqaWQpIC0+XG4gICAgICByZXR1cm4gZ2V0SklEUmVqZWN0ZWRQcm9taXNlIGppZCB1bmxlc3MgaXNWYWxpZE1VQ0pJRCBqaWRcbiAgICAgIHN0YW56YUhlbHBlciA9IGlmIE1hdGNoZXJzLmlzTWFuYWdlZEdyb3VwY2hhdCBqaWRcbiAgICAgICAgQGhlbHBlci5nZXRNYW5hZ2VkUm9vbURpc2NvU3RhbnphXG4gICAgICBlbHNlXG4gICAgICAgIEBoZWxwZXIuZ2V0Um9vbURpc2NvU3RhbnphXG4gICAgICBzZW5kTVVDUmVxdWVzdCBzZW5kSVEsIHN0YW56YUhlbHBlciBqaWRcblxuICAgICMgUmVxdWVzdCBhIE1VQyAoZ3JvdXBjaGF0KSBtZW1iZXIgbGlzdC4gIE5PVEU6IFNlbGYgbXVzdCBiZSBpblxuICAgICMgdGhlIGdyb3VwY2hhdCB0byBtYWtlIHRoaXMgcmVxdWVzdC5cbiAgICAjXG4gICAgIyBAcGFyYW0gamlkIFtTdHJpbmddIGppZCBvZiByb29tIHRvIHF1ZXJ5XG4gICAgIyBAcGFyYW0gYWZmaWxpYXRpb25zIFtTdHJpbmcsIEFycmF5PFN0cmluZz5dIGFmZmlsaWF0aW9uKHMpIHRvIGxpc3RcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtQcm9taXNlXSBwcm9taXNlIHRvIGNvbXBsZXRlIHRoZSB0YXNrXG4gICAgcmVxdWVzdE1lbWJlckxpc3Q6IChqaWQsIGFmZmlsaWF0aW9ucyA9IE1VQ1JvbGUuT1dORVIpIC0+XG4gICAgICByZXR1cm4gZ2V0SklEUmVqZWN0ZWRQcm9taXNlIGppZCB1bmxlc3MgaXNWYWxpZE1VQ0pJRCBqaWRcbiAgICAgIGFmZmlsaWF0aW9ucyA9IFV0aWxzLmFycmF5IGFmZmlsaWF0aW9uc1xuICAgICAgc2VuZE1VQ1JlcXVlc3Qgc2VuZElRLCBAaGVscGVyLmdldE1lbWJlckxpc3RTdGFuemEgamlkLCBhZmZpbGlhdGlvbnNcblxuICAgICMgU2VuZCBhICdtZWRpYXRlZCcgaW52aXRlIHRvIGEgdXNlciB2aWEgc3BlY2lmaWVkIE1VQyAoZ3JvdXBjaGF0KVxuICAgICNcbiAgICAjIEBwYXJhbSBqaWQgW1N0cmluZ10gamlkIG9mIGdyb3VwY2hhdFxuICAgICMgQHBhcmFtIGludml0ZWVzIFtBcnJheTxTdHJpbmc+XSBhcnJheSBvZiBqaWRzIHRvIGludml0ZSB0byBncm91cGNoYXRcbiAgICAjIEBwYXJhbSB0eXBlIFtTdHJpbmddIGdyb3VwY2hhdCBwcm9kdWN0ICd0eXBlJyB0byBiZSBzZXJpYWx6ZWQgYXMganNvblxuICAgICMgICBhbmQgc2VudCBhcyBib2R5IG9mIDxyZWFzb24vPiBzdGFuemEuXG4gICAgI1xuICAgICMgQHJldHVybiBbUHJvbWlzZV0gcHJvbWlzZSB0byBjb21wbGV0ZSB0aGUgdGFza1xuICAgIHNlbmRNZWRpYXRlZEludml0ZTogKGppZCwgaW52aXRlZXMgPSBbXSwgdHlwZSA9ICcnKSAtPlxuICAgICAgcmV0dXJuIGdldEpJRFJlamVjdGVkUHJvbWlzZSBqaWQgdW5sZXNzIGlzVmFsaWRNVUNKSUQgamlkXG4gICAgICBzdGFuemEgPSAgQGhlbHBlci5nZXRNZWRpYXRlZEludml0ZVN0YW56YSBqaWQsIEBnZXRCYXJlU2VsZkpJRCgpLCBpbnZpdGVlcywgdHlwZVxuICAgICAgc2VuZE1VQ1JlcXVlc3Qgc2VuZCwgc3RhbnphXG5cbiAgICAjIERlY2xpbmUgYSAnbWVkaWF0ZWQnIGludml0ZSBmcm9tIGEgdXNlciB0byBhIGdyb3VwY2hhdFxuICAgICNcbiAgICAjIEBwYXJhbSBqaWQgW1N0cmluZ10gamlkIG9mIGdyb3VwY2hhdFxuICAgICMgQHBhcmFtIGludml0ZWVzIFtBcnJheTxTdHJpbmc+XSBhcnJheSBvZiBqaWRzIHRvIGludml0ZSB0byBncm91cGNoYXRcbiAgICAjIEBwYXJhbSB0eXBlIFtTdHJpbmddIGdyb3VwY2hhdCBwcm9kdWN0ICd0eXBlJyB0byBiZSBzZXJpYWx6ZWQgYXMganNvblxuICAgICMgICBhbmQgc2VudCBhcyBib2R5IG9mIDxyZWFzb24vPiBzdGFuemEuXG4gICAgI1xuICAgICMgQHJldHVybiBbUHJvbWlzZV0gcHJvbWlzZSB0byBjb21wbGV0ZSB0aGUgdGFza1xuICAgIGRlY2xpbmVNZWRpYXRlZEludml0ZTogKGppZCwgaW52aXRlciwgcmVhc29uID0gJycpIC0+XG4gICAgICByZXR1cm4gZ2V0SklEUmVqZWN0ZWRQcm9taXNlIGppZCB1bmxlc3MgaXNWYWxpZE1VQ0pJRCBqaWRcbiAgICAgIHN0YW56YSA9ICBAaGVscGVyLmdldERlY2xpbmVNZWRpYXRlZEludml0ZVN0YW56YSBqaWQsIGludml0ZXIsIHJlYXNvblxuICAgICAgc2VuZE1VQ1JlcXVlc3Qgc2VuZCwgc3RhbnphXG5cbiAgICAjIFNlbmQgYSBzZWFyY2ggcmVxdWVzdCB0byBtdWMgY29tcG9uZW50LlxuICAgICNcbiAgICAjIEBwYXJhbSBtYXRjaCBbU3RyaW5nXSBzdHJpbmcgdG8gbWF0Y2hcbiAgICAjIEBwYXJhbSBvcHRpb25zIFtPYmplY3RdIGFuIG9iamVjdCBvZiBvcHRpb25zXG4gICAgIyBAb3B0aW9uIG9wdGlvbnMgbWF4IFtJbnRlZ2VyXSB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVzdWx0cyByZXF1ZXN0ZWQsXG4gICAgIyAgIGxpbWl0ZWQgdG8gMSAtIDEwMCBvciBlbHNlIGEgZGVmYXVsdCB3aWxsIGJlIHVzZWRcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtQcm9taXNlXSByZXN1bHRzIG9mIHNlYXJjaCBzaG91bGQgYmUgZGVsaXZlcmVkIGluIHRoZW4oLi4pLlxuICAgIHNlYXJjaDogKG1hdGNoLCB7bWF4fSA9IHt9KSAtPlxuICAgICAgcmV0dXJuIFEucmVqZWN0IG5ldyBFcnJvcihcImludmFsaWQgc2VhcmNoIHRlcm1cIikgdW5sZXNzIF8uaXNTdHJpbmcgbWF0Y2hcbiAgICAgIGppZCA9IFwibGVnYWN5Y2hhdC4je0NvbmZpZy5nZXQgJ3htcHAuZG9tYWluJ31cIlxuICAgICAgIyBSZXN0cmljdCBtYXggdG8gYmUgZnJvbSAxIC0gMTAwIG9yIHNldCB0byBudWxsIGFuZCBhIGRlZmF1bHQgd2lsbCBiZSB1c2VkXG4gICAgICBtYXggPSBudWxsIHVubGVzcyAxIDwgcGFyc2VJbnQobWF4KSA8PSA1MFxuICAgICAgc2VuZE1VQ1JlcXVlc3Qgc2VuZElRLCBAaGVscGVyLmdldFNlYXJjaFN0YW56YSBqaWQsIG1hdGNoLCBtYXhcblxuICAgICMgS2ljayBhIHVzZXIgZnJvbSBhIGdyb3VwY2hhdFxuICAgICNcbiAgICAjIEBwYXJhbSBqaWQgW1N0cmluZ10gZ3JvdXBjaGF0IGlkXG4gICAgIyBAcGFyYW0gY29udGFjdHMgW0FycmF5XSBsaXN0IG9mIGNvbnRhY3RzIHRvIGtpY2tcbiAgICAjIEBwYXJhbSByZWFzb24gW1N0cmluZ10gbGV0IHRoZSBvdGhlciB1c2VycyBrbm93IHdoeS4gIE5PVEU6IFRoaXMgbWF5IGJlXG4gICAgIyAgIHNlcmlhbGl6ZWQgYW5kIHNlbnQgYXMganNvbiB3aXRoIG90aGVyIG1ldGEtZGF0YSBhYm91dCB0aGUgcmVxdWVzdC5cbiAgICAjXG4gICAgIyBAcHJpdmF0ZVxuICAgIGtpY2s6IChqaWQsIHVzZXJzID0gW10sIHJlYXNvbiA9ICcnKSAtPlxuICAgICAgcmV0dXJuIGdldEpJRFJlamVjdGVkUHJvbWlzZSBqaWQgdW5sZXNzIGlzVmFsaWRNVUNKSUQgamlkXG4gICAgICBzZW5kTVVDUmVxdWVzdCBzZW5kSVEsIEBoZWxwZXIuZ2V0S2lja1N0YW56YSBqaWQsIHVzZXJzLCByZWFzb25cblxuICAgICMgU2VuZCBNVUMgcmVxdWVzdCB2aWEgJ3NlbmQnIG9yICdzZW5kSVEnXG4gICAgI1xuICAgICMgQHBhcmFtIGZuIFtGdW5jdGlvbl0gZnVuY3Rpb24gdG8gY2FsbCwgZWl0aGVyICdzZW5kJyBvciAnc2VuZElRJ1xuICAgICMgQHBhcmFtIHN0YW56YSBbU3Ryb3BoZS5CdWlsZGVyXSBzdGFuemEgZm9yIE1VQ2RhdGEgb2JqZWN0IGZvciBNVUNcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdIGEgcHJvbWlzZSB0aGF0IHdpbGwgd3JhcCBhIGNhbGwgdG8gJ3NlbmQnIG9yICdzZW5kSVEnXG4gICAgc2VuZE1VQ1JlcXVlc3QgPSAoZm4sIHN0YW56YSA9IG51bGwpIC0+XG4gICAgICBOaXRyb1Byb21pc2UgKHJlc29sdmUsIHJlamVjdCkgLT5cbiAgICAgICAgcmV0dXJuIHJlamVjdCBcIkEgdmFsaWQgc3RhbnphIHdhcyBub3QgZm9ybWVkIGZvciB0aGlzIHJlcXVlc3RcIiB1bmxlc3Mgc3RhbnphXG4gICAgICAgIHJldHVybiByZWplY3QgXCJObyBmdW5jdGlvbiB3YXMgcHJvdmlkZWRcIiB1bmxlc3MgXy5pc0Z1bmN0aW9uIGZuXG5cbiAgICAgICAgZGF0YSA9IGVsZW1lbnQ6IHN0YW56YSwgcmVzb2x2ZTogcmVzb2x2ZSwgcmVqZWN0OiByZWplY3RcbiAgICAgICAgZm4gZGF0YVxuXG4gICAgIyBAcHJpdmF0ZVxuICAgICMgUmV0cmlldmUgYSByZWplY3RlZCBwcm9taXNlIGR1ZSB0byBhbiBpbnZhbGlkIGdyb3VwY2hhdCBKSURcbiAgICAjXG4gICAgIyBAcGFyYW0gamlkIFtTdHJpbmddIGEgZ3JvdXBjaGF0IGppZCB0aGF0IGlzIGludmFsaWRcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdIGFuIGltbWVkaWF0ZWx5IHJlamVjdGVkIHByb21pc2VcbiAgICBnZXRKSURSZWplY3RlZFByb21pc2UgPSAoamlkKSAtPlxuICAgICAgUS5yZWplY3QgbmV3IEVycm9yIGdldEludmFsaWRKSURTdHJpbmcgamlkXG5cbiAgICAjIEBwcml2YXRlXG4gICAgIyBSZXRyaWV2ZSBhIHN0cmluZyBmb3IgYW4gaW52YWxpZCBncm91cGNoYXQgamlkXG4gICAgI1xuICAgICMgQHBhcmFtIGppZCBbU3RyaW5nXSB0aGUgaW52YWxpZCBncm91cGNoYXQgamlkXG4gICAgI1xuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgcmVhc29uIGZvciByZWplY3Rpb24gaW5jbHVkaW5nIHRoZSBqaWQgYmVpbmcgcmVqZWN0ZWRcbiAgICBnZXRJbnZhbGlkSklEU3RyaW5nID0gKGppZCkgLT5cbiAgICAgIFwiI3tNVUMuSU5WQUxJRF9HUk9VUENIQVRfSklEfTogI3tqaWR9XCJcbiIsIlEgPSByZXF1aXJlICdxJ1xuTml0cm9Qcm9taXNlID0gcmVxdWlyZSAndXRpbC9wcm9taXNlJ1xuXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5VdGlscyA9IHJlcXVpcmUgJ3V0aWwvdXRpbHMnXG5QcmVzZW5jZVR5cGUgPSByZXF1aXJlICdlbnVtL3ByZXNlbmNlX3R5cGUnXG5zdHJvcGhlUm9zdGVyID0gcmVxdWlyZSAnc3Ryb3BoZS9zdHJvcGhlX3Jvc3RlcidcblByZXNlbmNlVHlwZSA9IHJlcXVpcmUgJ2VudW0vcHJlc2VuY2VfdHlwZSdcblxuIyBUaGlzIGNsYXNzIGhhcyB2aXJ0dWFsIG1ldGhvZHMsIHRoYXQgYXJlIGF2YWlsYWJsZSBvbiB0aGUgc2luZ2xldG9uIGluc3RhbmNlXG4jIHJldHVybmVkIGJ5IHRoZSBzdGF0aWMgI2dldCgpIG1ldGhvZC5cbiNcbiMgQG1ldGhvZCAjZ2V0Um9zdGVyKClcbiMgICBSZXRyaWV2ZSB0aGUgY29tcGxldGUgcm9zdGVyXG4jXG4jICAgQHJldHVybiBbUS5Qcm9taXNlXVxuI1xuIyAgIEBleGFtcGxlIEhhbmRsaW5nIHN1Y2Nlc3NmdWwgYW5kIGZhaWxlZCBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxuIyAgICAgLy8gSW1wb3J0IG9wdGlvbmFsIGFkYXB0ZXJzIHRvIHByb2Nlc3MgaW5jb21pbmcgWE1MIGRhdGFcbiMgICAgIGFkYXB0ZXJzID0gcmVxdWlyZSAnYWRhcHRlcnMvYWRhcHRlcnMnXG4jXG4jICAgICB2YXIgY29ubmVjdGlvbiA9IE5pdHJvLmdldENvbm5lY3Rpb24oKTtcbiMgICAgIHZhciByb3N0ZXIgPSBjb25uZWN0aW9uLmdldENvbXBvbmVudChOaXRyby5ST1NURVIpO1xuI1xuIyAgICAgLy8gUm9zdGVyIGRhdGEgd2lsbCBiZSByZXR1cm5lZCBpbW1lZGlhdGVseSAobm8gbmVlZCB0byB3YWl0IGZvciBhIHB1c2ggZXZlbnQpXG4jICAgICByb3N0ZXIuZ2V0Um9zdGVyKClcbiMgICAgICAgLy8gYWRhcHRlcnMgYXMgc3VjY2Vzc3MgaGFuZGxlcnMgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4jICAgICAgIC50aGVuKGFkYXB0ZXJzLmNvbnZlcnRUb0pTT04pXG4jICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpe1xuIyAgICAgICAgIC8vIGFkZGl0aW9uYWwgc3VjY2VzcyBoYW5kbGVyIChvcHRpb25hbClcbiMgICAgICAgICByZXR1cm4gZGF0YTtcbiMgICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuIyAgICAgICAgIC8vIGZhaWx1cmUgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiMgICAgICB9KTtcbiNcbiMgQG1ldGhvZCAjYWRkQ29udGFjdChjb250YWN0KVxuIyAgIEFkZCBhIHNpbmdsZSBjb250YWN0IHRvIHRoZSBSb3N0ZXJcbiNcbiMgICBAcGFyYW0gY29udGFjdCBbU3RyaW5nLCBPYmplY3RdIGNvbnRhY3Qgb2JqZWN0IG9yIGppZCBzdHJpbmcgZm9yIGEgY29udGFjdFxuI1xuIyAgIEByZXR1cm4gW1EuUHJvbWlzZV1cbiNcbiMgICBAZXhhbXBsZSBBZGQgYSBzaW5nbGUgY29udGFjdCBieSBqaWQgb25seVxuIyAgICAgcm9zdGVyLmFkZENvbnRhY3QoJ3NvbWVqaWQnKTtcbiNcbiMgICBAZXhhbXBsZSBBZGQgYSBzaW5nbGUgY29udGFjdCBieSBvYmplY3RcbiMgICAgIHJvc3Rlci5hZGRDb250YWN0KHtqaWQ6ICdzb21lamlkJywgbmFtZTogJ1NvbWUgQ29udGFjdCd9KTtcbiNcbiMgICBAZXhhbXBsZSBBZGQgY29udGFjdCBpbmNsdWRpbmcgZ3JvdXBzIGl0IGJlbG9uZ3MgdG9cbiMgICAgIGNvbnRhY3QgPSB7amlkOiAnamlkMScsIG5hbWU6ICdDb250YWN0IDEnLCBncm91cHM6IFsnR3JvdXBBJywgJ0dyb3VwQiddfTtcbiMgICAgIHJvc3Rlci5hZGRDb250YWN0KGNvbnRhY3QpO1xuI1xuIyAgIEBleGFtcGxlIEhhbmRsaW5nIHN1Y2Nlc3NmdWwgYW5kIGZhaWxlZCBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxuIyAgICAgdmFyIGNvbm5lY3Rpb24gPSBOaXRyby5nZXRDb25uZWN0aW9uKCk7XG4jICAgICB2YXIgcm9zdGVyID0gY29ubmVjdGlvbi5nZXRDb21wb25lbnQoTml0cm8uUk9TVEVSKTtcbiMgICAgIHJvc3Rlci5hZGRDb250YWN0KHtqaWQ6IFwidXNlcmppZFwiLCBuYW1lOiBcIkNvbnRhY3QgTmFtZVwifSlcbiMgICAgICAgLnRoZW4gZnVuY3Rpb24oZGF0YSl7XG4jICAgICAgICAgLy8gc3VjY2Vzc3MgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiMgICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuIyAgICAgICAgIC8vIGZhaWx1cmUgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiMgICAgICB9KTtcbiNcbiMgICBAZXhhbXBsZSBSZWdpc3RlcmluZyBmb3IgcHVzaCBub3RpZmljYXRpb25zIHRvIGNvbmZpcm0gcmVxdWVzdHNcbiMgICAgIGNvbm5lY3Rpb24uZXZlbnRNYW5hZ2VyLmxpc3RlbihFdmVudHMuUk9TVEVSX0FEREVELCBmdW5jdGlvbihkYXRhKSB7XG4jICAgICAgIC8vIFJlY2VpdmUgYWN0dWFsIHB1c2ggY29uZmlybWF0aW9uIChvciBhbnkgZnV0dXJlIHVwZGF0ZXMpXG4jICAgICAgIC8vIGZyb20gTml0cm8gd2hlbiBjb250YWN0cyBhcmUgYWRkZWQgdG8gdGhlIFJvc3Rlci5cbiMgICAgICB9KTtcbiNcbiMgICBAc2VlIEV2ZW50cy5ST1NURVJfQURERURcbiNcbiMgQG1ldGhvZCAjcmVtb3ZlKGNvbnRhY3QgPSB7fSlcbiMgICBSZW1vdmUgYSBjb250YWN0IGZyb20gdGhlIHJvc3RlclxuI1xuIyAgIEBwYXJhbSBjb250YWN0cyBbU3RyaW5nLCBPYmplY3QsIEFycmF5PFN0cmluZywgT2JqZWN0Pl0gYXJyYXkgb2YgY29udGFjdHMsXG4jICAgICBqaWRzIG9yIGEgY29tYmluYXRpb24gb2YgYm90aCBmb3IgY29udGFjdHMgYmVpbmcgcmVtb3ZlZFxuIyAgIEBvcHRpb24gamlkIGNvbnRhY3RzIFtTdHJpbmddIGppZCBvZiB0aGUgY29udGFjdCBiZWluZyByZW1vdmVkXG4jXG4jICAgQHJldHVybiBbUS5Qcm9taXNlXVxuI1xuIyAgIEBleGFtcGxlIFJlbW92ZSBhIHNpbmdsZSBjb250YWN0IGJ5IGppZCBvbmx5XG4jICAgICByb3N0ZXIucmVtb3ZlKCdzb21lamlkJyk7XG4jXG4jICAgQGV4YW1wbGUgUmVtb3ZlIGEgc2luZ2xlIGNvbnRhY3QgYnkgb2JqZWN0XG4jICAgICByb3N0ZXIucmVtb3ZlKHtqaWQ6ICdzb21lamlkJywgbmFtZTogJ1NvbWUgQ29udGFjdCd9KTtcbiNcbiMgICBAZXhhbXBsZSBSZW1vdmUgYW4gYXJyYXkgb2YgbXVsdGlwbGUgY29udGFjdHMgZnJvbSB0aGUgUm9zdGVyXG4jICAgICBjb250YWN0MSA9IHtqaWQ6ICdqaWQxJywgbmFtZTogJ0NvbnRhY3QgMSd9O1xuIyAgICAgY29udGFjdDIgPSB7amlkOiAnamlkMicsIG5hbWU6ICdDb250YWN0IDInfTtcbiMgICAgIHJvc3Rlci5yZW1vdmUoW2NvbnRhY3QxLCBjb250YWN0Ml0pO1xuI1xuIyAgIEBleGFtcGxlIFJlbW92ZSBhbiBhcnJheSBvZiBtaXhlZCBjb250YWN0cyBqaWRzIGFuZCBvYmplY3RzXG4jICAgICBjb250YWN0MSA9ICdqaWQxJztcbiMgICAgIGNvbnRhY3QyID0ge2ppZDogJ2ppZDInLCBuYW1lOiAnQ29udGFjdCAyJ307XG4jICAgICBjb250YWN0MiA9ICdqaWQzJztcbiMgICAgIHJvc3Rlci5yZW1vdmUoW2NvbnRhY3QxLCBjb250YWN0MiwgY29udGFjdDNdKTtcbiNcbiMgICBAZXhhbXBsZSBIYW5kbGluZyBzdWNjZXNzZnVsIGFuZCBmYWlsZWQgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3RcbiMgICAgIHZhciBjb25uZWN0aW9uID0gTml0cm8uZ2V0Q29ubmVjdGlvbigpO1xuIyAgICAgdmFyIHJvc3RlciA9IGNvbm5lY3Rpb24uZ2V0Q29tcG9uZW50KE5pdHJvLlJPU1RFUik7XG4jICAgICByb3N0ZXIucmVtb3ZlKHtqaWQ6IFwidXNlcmppZFwifSlcbiMgICAgICAgLnRoZW4gZnVuY3Rpb24oZGF0YSl7XG4jICAgICAgICAgLy8gc3VjY2Vzc3MgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiMgICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuIyAgICAgICAgIC8vIGZhaWx1cmUgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiMgICAgICB9KTtcbiNcbiMgICBAZXhhbXBsZSBSZWdpc3RlcmluZyBmb3IgcHVzaCBub3RpZmljYXRpb25zIHRvIGNvbmZpcm0gcmVxdWVzdHNcbiMgICAgIGNvbm5lY3Rpb24uZXZlbnRNYW5hZ2VyLmxpc3RlbihFdmVudHMuUk9TVEVSX1JFTU9WRUQsIGZ1bmN0aW9uKGRhdGEpIHtcbiMgICAgICAgLy8gUmVjZWl2ZSBhY3R1YWwgcHVzaCBjb25maXJtYXRpb24gKG9yIGFueSBmdXR1cmUgdXBkYXRlcylcbiMgICAgICAgLy8gZnJvbSBOaXRybyB3aGVuIGNvbnRhY3RzIGFyZSBhZGRlZCB0byB0aGUgUm9zdGVyLlxuIyAgICAgIH0pO1xuI1xuIyAgIEBzZWUgRXZlbnRzLlJPU1RFUl9SRU1PVkVEXG4jXG4jIEBtZXRob2QgI3VwZGF0ZShjb250YWN0ID0ge30pXG4jICAgQWxpYXMgZm9yIHRoZSAjYWRkKCkgbWV0aG9kIHVwZGF0ZXMgYSBjb250YWN0XG4jXG4jICAgQHBhcmFtIGNvbnRhY3RzIFtTdHJpbmcsIE9iamVjdCwgQXJyYXk8U3RyaW5nLCBPYmplY3Q+XSBhcnJheSBvZiBjb250YWN0cyxcbiMgICAgIGppZHMgb3IgYSBjb21iaW5hdGlvbiBvZiBib3RoIGZvciBjb250YWN0cyBiZWluZyB1cGRhdGVkXG4jICAgQG9wdGlvbiBqaWQgY29udGFjdHMgW1N0cmluZ10gamlkIG9mIHRoZSBjb250YWN0IGJlaW5nIHVwZGF0ZWRcbiNcbiMgICBAcmV0dXJuIFtRLlByb21pc2VdXG4jXG4jICAgQHNlZSBSb3N0ZXIjYWRkXG4jICAgQHNlZSBFdmVudHMuUk9TVEVSX1JFTU9WRURcbiNcbiMgQG1ldGhvZCAjaW52aXRlKGNvbnRhY3QgPSB7fSlcbiMgICBJbnZpdGUgYSB1c2VyIHRvIGJlIGEgcm9zdGVyIGNvbnRhY3RcbiNcbiMgICBAcGFyYW0gY29udGFjdCBbU3RyaW5nLCBPYmplY3RdIGNvbnRhY3QgamlkIG9yIGEgY29udGFjdCBvYmplY3QgdG9cbiMgICAgIGludml0ZSB0byB0aGUgcm9zdGVyXG4jICAgQG9wdGlvbiBqaWQgY29udGFjdCBbU3RyaW5nXSBqaWQgb2YgdGhlIGNvbnRhY3QgYmVpbmcgaW52aXRlZFxuI1xuIyAgIEByZXR1cm4gW1EuUHJvbWlzZV1cbiNcbiMgICBAZXhhbXBsZSBJbnZpdGluZyBhIGNvbnRhY3QgYnkgamlkIG9ubHlcbiMgICAgIHJvc3Rlci5pbnZpdGUoJ3NvbWVqaWQnKTtcbiNcbiMgICBAZXhhbXBsZSBJbnZpdGluZyBhIGNvbnRhY3QgYnkgb2JqZWN0XG4jICAgICByb3N0ZXIuaW52aXRlKHtqaWQ6ICdzb21lamlkJywgbmFtZTogJ1NvbWUgQ29udGFjdCd9KTtcbiNcbiMgICBAZXhhbXBsZSBIYW5kbGluZyBzdWNjZXNzZnVsIGFuZCBmYWlsZWQgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3RcbiMgICAgIHZhciBjb25uZWN0aW9uID0gTml0cm8uZ2V0Q29ubmVjdGlvbigpO1xuIyAgICAgdmFyIHJvc3RlciA9IGNvbm5lY3Rpb24uZ2V0Q29tcG9uZW50KE5pdHJvLlJPU1RFUik7XG4jICAgICByb3N0ZXIuaW52aXRlKHtqaWQ6IFwidXNlcmppZFwifSlcbiMgICAgICAgLnRoZW4gZnVuY3Rpb24oZGF0YSl7XG4jICAgICAgICAgLy8gc3VjY2Vzc3MgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiMgICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuIyAgICAgICAgIC8vIGZhaWx1cmUgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiMgICAgICB9KTtcbiNcbiMgICBAZXhhbXBsZSBSZWdpc3RlcmluZyBmb3IgcHVzaCBub3RpZmljYXRpb25zIHRvIGNvbmZpcm0gcmVxdWVzdHNcbiMgICAgIGNvbm5lY3Rpb24uZXZlbnRNYW5hZ2VyLmxpc3RlbihFdmVudHMuUk9TVEVSX0lOVklURSwgZnVuY3Rpb24oZGF0YSkge1xuIyAgICAgICAvLyBSZWNlaXZlIGFjdHVhbCBwdXNoIGNvbmZpcm1hdGlvbiAob3IgYW55IGZ1dHVyZSB1cGRhdGVzKVxuIyAgICAgICAvLyBmcm9tIE5pdHJvIHdoZW4gY29udGFjdHMgYXJlIGludml0ZWQgdG8gdGhlIFJvc3Rlci5cbiMgICAgICB9KTtcbiNcbiMgICBAc2VlIEV2ZW50cy5ST1NURVJfSU5WSVRFXG4jXG4jIEBtZXRob2QgI3N1YnNjcmliZShjb250YWN0KVxuIyAgIFNlbmQgYSBwcmVzZW5jZSBzdWJzY3JpcHRpb24gb2YgJ3N1YnNjcmliZScgdG8gTml0cm8gZm9yIGEgc3BlY2lmaWVkIGNvbnRhY3RcbiNcbiMgICBAcGFyYW0gY29udGFjdCBbU3RyaW5nLCBPYmplY3RdIGEgamlkIG9yIGFuIG9iamVjdCB3aXRoIGEgamlkIGZvciBhIGNvbnRhY3RcbiMgICBAb3B0aW9uIGppZCBjb250YWN0IFtTdHJpbmddIGNvbnRhY3QgamlkXG4jICAgICBwcmVzZW5jZSB0b1xuI1xuIyAgIEByZXR1cm4gW1EuUHJvbWlzZV1cbiNcbiMgICBAZXhhbXBsZSBTdWJzY3JpYmluZyB0byBhIGNvbnRhY3QncyBwcmVzZW5jZVxuIyAgICAgcm9zdGVyLnN1YnNjcmliZSgnYW5vdGhlcmNvbnRhY3RqaWQnKTtcbiNcbiMgQG1ldGhvZCAjc3Vic2NyaWJlZChjb250YWN0KVxuIyAgIFNlbmQgYSBwcmVzZW5jZSBzdWJzY3JpcHRpb24gb2YgJ3N1YnNjcmliZWQnIHRvIE5pdHJvIGZvciBhIHNwZWNpZmllZCBjb250YWN0XG4jXG4jICAgQHBhcmFtIGNvbnRhY3QgW1N0cmluZywgT2JqZWN0XSBhIGppZCBvciBhbiBvYmplY3Qgd2l0aCBhIGppZCBmb3IgYSBjb250YWN0XG4jICAgQG9wdGlvbiBqaWQgY29udGFjdCBbU3RyaW5nXSBjb250YWN0IGppZFxuI1xuIyAgIEByZXR1cm4gW1EuUHJvbWlzZV1cbiNcbiMgICBAZXhhbXBsZSBDb25maXJtaW5nIHN1YnNjcmlwdGlvbiBmb3IgYW5vdGhlciBjb250YWN0J3MgcHJlc2VuY2UgcmVxdWVzdCB0byB5b3VcbiMgICAgIHJvc3Rlci5zdWJzY3JpYmVkKCdhbm90aGVyY29udGFjdGppZCcpO1xuI1xuIyBAbWV0aG9kICN1bnN1YnNjcmliZShjb250YWN0ID0ge30pXG4jICAgVW5zdWJzY3JpYmUgZnJvbSBhIHNwZWNpZmllZCB1c2VyXG4jXG4jICAgQHBhcmFtIGNvbnRhY3QgW1N0cmluZywgT2JqZWN0XSBjb250YWN0IGppZCBvciBhIGNvbnRhY3Qgb2JqZWN0IHRvXG4jICAgICB1bnN1YnNjcmliZSBmcm9tXG4jICAgQG9wdGlvbiBqaWQgY29udGFjdCBbU3RyaW5nXSBqaWQgb2YgdGhlIGNvbnRhY3QgYmVpbmcgdW5zdWJzY3JpYmVkXG4jXG4jICAgQHJldHVybiBbUS5Qcm9taXNlXVxuI1xuIyAgIEBleGFtcGxlIFVuc3Vic2NyaWJpbmcgZnJvbSBhIGNvbnRhY3QgYnkgamlkIG9ubHlcbiMgICAgIHJvc3Rlci51bnN1YnNjcmliZSgnc29tZWppZCcpO1xuI1xuIyAgIEBleGFtcGxlIEluVW5zdWJzY3JpYmluZyBmcm9tIGEgY29udGFjdCBieSBvYmplY3RcbiMgICAgIHJvc3Rlci51bnN1YnNjcmliZSh7amlkOiAnc29tZWppZCcsIG5hbWU6ICdTb21lIENvbnRhY3QnfSk7XG4jXG4jICAgQGV4YW1wbGUgSGFuZGxpbmcgc3VjY2Vzc2Z1bCBhbmQgZmFpbGVkIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XG4jICAgICB2YXIgY29ubmVjdGlvbiA9IE5pdHJvLmdldENvbm5lY3Rpb24oKTtcbiMgICAgIHZhciByb3N0ZXIgPSBjb25uZWN0aW9uLmdldENvbXBvbmVudChOaXRyby5ST1NURVIpO1xuIyAgICAgcm9zdGVyLnVuc3Vic2NyaWJlKHtqaWQ6IFwidXNlcmppZFwifSlcbiMgICAgICAgLnRoZW4gZnVuY3Rpb24oZGF0YSl7XG4jICAgICAgICAgLy8gc3VjY2Vzc3MgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiMgICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuIyAgICAgICAgIC8vIGZhaWx1cmUgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiMgICAgICB9KTtcbiNcbiMgICBAZXhhbXBsZSBSZWdpc3RlcmluZyBmb3IgcHVzaCBub3RpZmljYXRpb25zIHRvIGNvbmZpcm0gcmVxdWVzdHNcbiMgICAgIGNvbm5lY3Rpb24uZXZlbnRNYW5hZ2VyLmxpc3RlbihFdmVudHMuUk9TVEVSX1VOU1VCU0NSSUJFLCBmdW5jdGlvbihkYXRhKSB7XG4jICAgICAgIC8vIFJlY2VpdmUgYWN0dWFsIHB1c2ggY29uZmlybWF0aW9uIChvciBhbnkgZnV0dXJlIHVwZGF0ZXMpXG4jICAgICAgIC8vIGZyb20gTml0cm8gd2hlbiBjb250YWN0cyBhcmUgdW5zdWJzY3JpYmVkLlxuIyAgICAgIH0pO1xuI1xuIyAgIEBzZWUgRXZlbnRzLlJPU1RFUl9VTlNVQlNDUklCRVxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSb3N0ZXJcblxuICAjIEBwcm9wZXJ0eSBbU3RyaW5nXSBwdWJsaWMgbmFtZSBmb3IgdGhpcyBjb21wb25lbnRcbiAgQE5BTUU6ICdjb21wb25lbnQucm9zdGVyJ1xuXG4gICMgQHByb3BlcnR5IHByaXZhdGUgaW5zdGFuY2Ugb2YgUHJpdmF0ZVJvc3RlclxuICAjIEBwcml2YXRlXG4gIGluc3RhbmNlID0gbnVsbFxuXG4gICMgUmV0cmlldmUgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIFByaXZhdGVSb3N0ZXIgY2xhc3NcbiAgI1xuICAjIEBwYXJhbSBvcHRpb25zIFtPYmplY3RdIGFuIG9iamVjdCBvZiBvcHRpb25zXG4gICMgQG9wdGlvbiBvcHRpb25zIHNlbmQgW0Z1bmN0aW9uXSBtZXRob2Qgd3JhcHBpbmcgU3Ryb3BoZSdzICdzZW5kJ1xuICAjIEBvcHRpb24gb3B0aW9ucyBzZW5kSVEgW0Z1bmN0aW9uXSBtZXRob2Qgd3JhcHBpbmcgU3Ryb3BoZSdzICdzZW5kSVEnXG4gICNcbiAgIyBAcmV0dXJuIFtQcml2YXRlUm9zdGVyXSBzaW5nbGV0b24gaW5zdGFuY2VcbiAgQGdldDogKG9wdGlvbnMgPSB7fSkgLT5cbiAgICBjcmVhdGVJbnN0YW5jZSA9IC0+XG4gICAgICBuZXcgUHJpdmF0ZVJvc3RlciBvcHRpb25zXG4gICAgaW5zdGFuY2UgPz0gY3JlYXRlSW5zdGFuY2UoKVxuXG4gICMgRGVzdHJveSB0aGUgc2luZ2xldG9uIGluc3RhbmNlLCBvbmx5IGZvciB1bml0IHRlc3RpbmdcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIHRydWUgaWYgdGhlIHNpbmdsZXRvbiB3YXMgZGVzdHJveWVkLCBvdGhlcndpc2UgZmFsc2VcbiAgIyBAbm9kb2NcbiAgQGRlc3Ryb3k6IFV0aWxzLnJldHVybkJvb2wgLT5cbiAgICBpbnN0YW5jZSA9IG51bGxcblxuICAjIENoZWNrIGlmIGEgdXNlciBqaWQgY29udGFpbnMgJ0BlbWFpbCcgYXMgcGFydCBvZiBpdHMgZG9tYWluXG4gICNcbiAgIyBAcGFyYW0gamlkIFtTdHJpbmddIHVzZXIgamlkXG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXVxuICBAaGFzRW1haWxEb21haW4gPSAoamlkKSAtPlxuICAgIC9AZW1haWxcXC4vaS50ZXN0IGppZFxuXG4gIGNsYXNzIFByaXZhdGVSb3N0ZXJcblxuICAgICMgQHByb3BlcnR5IFtPYmplY3RdIGhlbHBlciBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBTdHJvcGhlLkJ1aWxkZXIgc3Rhbnphc1xuICAgIGhlbHBlcjogbnVsbFxuXG4gICAgIyBAcHJvcGVydHkgbG9jYWwgcmVmZXJlbmNlIHRvIGFuIGluamVjdGVkICdzZW5kJyBmdW5jdGlvblxuICAgICMgQHByaXZhdGVcbiAgICBzZW5kID0gbnVsbFxuXG4gICAgIyBAcHJvcGVydHkgbG9jYWwgcmVmZXJlbmNlIHRvIGFuIGluamVjdGVkICdzZW5kSVEnIGZ1bmN0aW9uXG4gICAgIyBAcHJpdmF0ZVxuICAgIHNlbmRJUSA9IG51bGxcblxuICAgICMgQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIFByaXZhdGVSb3N0ZXJcbiAgICAjXG4gICAgIyBAcGFyYW0gb3B0aW9ucyBbT2JqZWN0XSBhbiBvYmplY3Qgb2Ygb3B0aW9uc1xuICAgICMgQG9wdGlvbiBvcHRpb25zIHNlbmQgW0Z1bmN0aW9uXSBtZXRob2Qgd3JhcHBpbmcgU3Ryb3BoZSdzICdzZW5kJ1xuICAgICMgQG9wdGlvbiBvcHRpb25zIHNlbmRJUSBbRnVuY3Rpb25dIG1ldGhvZCB3cmFwcGluZyBTdHJvcGhlJ3MgJ3NlbmRJUSdcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtQcml2YXRlUm9zdGVyXVxuICAgIGNvbnN0cnVjdG9yOiAob3B0aW9ucyA9IHt9KSAtPlxuICAgICAge0BoZWxwZXIsIHNlbmQsIHNlbmRJUX0gPSBfLmRlZmF1bHRzIG9wdGlvbnMsXG4gICAgICAgIGhlbHBlcjogc3Ryb3BoZVJvc3RlclxuXG4gICAgIyBSZXRyaWV2ZSB0aGUgY29tcGxldGUgcm9zdGVyXG4gICAgI1xuICAgICMgQHJldHVybiBbUS5Qcm9taXNlXVxuICAgICNcbiAgICAjIEBleGFtcGxlIEhhbmRsaW5nIHN1Y2Nlc3NmdWwgYW5kIGZhaWxlZCBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICMgICAvLyBJbXBvcnQgb3B0aW9uYWwgYWRhcHRlcnMgdG8gcHJvY2VzcyBpbmNvbWluZyBYTUwgZGF0YVxuICAgICMgICBhZGFwdGVycyA9IHJlcXVpcmUgJ2FkYXB0ZXJzL2FkYXB0ZXJzJ1xuICAgICNcbiAgICAjICAgdmFyIGNvbm5lY3Rpb24gPSBOaXRyby5nZXRDb25uZWN0aW9uKCk7XG4gICAgIyAgIHZhciByb3N0ZXIgPSBjb25uZWN0aW9uLmdldENvbXBvbmVudChOaXRyby5ST1NURVIpO1xuICAgICNcbiAgICAjICAgLy8gUm9zdGVyIGRhdGEgd2lsbCBiZSByZXR1cm5lZCBpbW1lZGlhdGVseSAobm8gbmVlZCB0byB3YWl0IGZvciBhIHB1c2ggZXZlbnQpXG4gICAgIyAgIHJvc3Rlci5nZXRSb3N0ZXIoKVxuICAgICMgICAgIC8vIGFkYXB0ZXJzIGFzIHN1Y2Nlc3NzIGhhbmRsZXJzIGZvciB0aGUgcmVxdWVzdCB0byBOaXRyb1xuICAgICMgICAgIC50aGVuKGFkYXB0ZXJzLmNvbnZlcnRUb0pTT04pXG4gICAgIyAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSl7XG4gICAgIyAgICAgICAvLyBhZGRpdGlvbmFsIHN1Y2Nlc3MgaGFuZGxlciAob3B0aW9uYWwpXG4gICAgIyAgICAgICByZXR1cm4gZGF0YTtcbiAgICAjICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgIyAgICAgICAvLyBmYWlsdXJlIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4gICAgIyAgICB9KVxuICAgIGdldFJvc3RlcjogLT5cbiAgICAgIE5pdHJvUHJvbWlzZSAocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgICBzZW5kSVFcbiAgICAgICAgICBlbGVtZW50OiBAaGVscGVyLmdldFJvc3RlclN0YW56YSgpXG4gICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZVxuICAgICAgICAgIHJlamVjdDogcmVqZWN0XG5cbiAgICAjIEFkZCBhIHNpbmdsZSBjb250YWN0IHRvIHRoZSBSb3N0ZXJcbiAgICAjXG4gICAgIyBAcGFyYW0gY29udGFjdCBbU3RyaW5nLCBPYmplY3RdIGNvbnRhY3Qgb2JqZWN0IG9yIGppZCBzdHJpbmcgZm9yIGEgY29udGFjdFxuICAgICNcbiAgICAjIEByZXR1cm4gW1EuUHJvbWlzZV1cbiAgICAjXG4gICAgIyBAZXhhbXBsZSBBZGQgYSBzaW5nbGUgY29udGFjdCBieSBqaWQgb25seVxuICAgICMgICByb3N0ZXIuYWRkQ29udGFjdCgnc29tZWppZCcpO1xuICAgICNcbiAgICAjIEBleGFtcGxlIEFkZCBhIHNpbmdsZSBjb250YWN0IGJ5IG9iamVjdFxuICAgICMgICByb3N0ZXIuYWRkQ29udGFjdCh7amlkOiAnc29tZWppZCcsIG5hbWU6ICdTb21lIENvbnRhY3QnfSk7XG4gICAgI1xuICAgICMgQGV4YW1wbGUgQWRkIGNvbnRhY3QgaW5jbHVkaW5nIGdyb3VwcyBpdCBiZWxvbmdzIHRvXG4gICAgIyAgIGNvbnRhY3QgPSB7amlkOiAnamlkMScsIG5hbWU6ICdDb250YWN0IDEnLCBncm91cHM6IFsnR3JvdXBBJywgJ0dyb3VwQiddfTtcbiAgICAjICAgcm9zdGVyLmFkZENvbnRhY3QoY29udGFjdCk7XG4gICAgI1xuICAgICMgQGV4YW1wbGUgSGFuZGxpbmcgc3VjY2Vzc2Z1bCBhbmQgZmFpbGVkIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgIyAgIHZhciBjb25uZWN0aW9uID0gTml0cm8uZ2V0Q29ubmVjdGlvbigpO1xuICAgICMgICB2YXIgcm9zdGVyID0gY29ubmVjdGlvbi5nZXRDb21wb25lbnQoTml0cm8uUk9TVEVSKTtcbiAgICAjICAgcm9zdGVyLmFkZENvbnRhY3Qoe2ppZDogXCJ1c2VyamlkXCIsIG5hbWU6IFwiQ29udGFjdCBOYW1lXCJ9KVxuICAgICMgICAgIC50aGVuIGZ1bmN0aW9uKGRhdGEpe1xuICAgICMgICAgICAgLy8gc3VjY2Vzc3MgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiAgICAjICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgIyAgICAgICAvLyBmYWlsdXJlIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4gICAgIyAgICB9KTtcbiAgICAjXG4gICAgIyBAZXhhbXBsZSBSZWdpc3RlcmluZyBmb3IgcHVzaCBub3RpZmljYXRpb25zIHRvIGNvbmZpcm0gcmVxdWVzdHNcbiAgICAjICAgY29ubmVjdGlvbi5ldmVudE1hbmFnZXIubGlzdGVuKEV2ZW50cy5ST1NURVJfQURERUQsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAjICAgICAvLyBSZWNlaXZlIGFjdHVhbCBwdXNoIGNvbmZpcm1hdGlvbiAob3IgYW55IGZ1dHVyZSB1cGRhdGVzKVxuICAgICMgICAgIC8vIGZyb20gTml0cm8gd2hlbiBjb250YWN0cyBhcmUgYWRkZWQgdG8gdGhlIFJvc3Rlci5cbiAgICAjICAgIH0pO1xuICAgICNcbiAgICAjIEBzZWUgRXZlbnRzLlJPU1RFUl9BRERFRFxuICAgIGFkZENvbnRhY3Q6IChjb250YWN0ID0ge30pIC0+XG4gICAgICBpZiB0eXBlb2YgY29udGFjdCBpcyAnc3RyaW5nJ1xuICAgICAgICBjb250YWN0ID0gamlkOiBjb250YWN0XG5cbiAgICAgIHtqaWQsIG5hbWUsIGdyb3Vwc30gPSBfLmRlZmF1bHRzIGNvbnRhY3QsXG4gICAgICAgIGppZDogJydcbiAgICAgICAgbmFtZTogXCJcIlxuICAgICAgICBncm91cHM6IFtdXG5cbiAgICAgIHByb21pc2UgPSBOaXRyb1Byb21pc2UgKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgICAgaWYgbm90IGppZFxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yIFwiQXR0ZW1wdGluZyB0byBhZGQgYW4gaW52YWxpZCBjb250YWN0IHRvIHRoZSBSb3N0ZXJcIlxuICAgICAgICAgIHJldHVybiByZWplY3QgZXJyb3JcblxuICAgICAgICBzZW5kSVFcbiAgICAgICAgICBlbGVtZW50OiBAaGVscGVyLmdldEFkZFN0YW56YSBqaWQsIG5hbWUsIGdyb3Vwc1xuICAgICAgICAgIHJlc29sdmU6IHJlc29sdmVcbiAgICAgICAgICByZWplY3Q6IHJlamVjdFxuXG4gICAgICAjIE5vdyB0aGF0IHdlJ3ZlIGFkZGVkIGEgY3VzdG9tIGVycm9yIGhhbmRsZXIgZm9yIGVycm9yIHBhcnNpbmdcbiAgICAgICMgd2UgY2FuIGluc3BlY3QgdGhlIGpzb24gYW5kIGV4dHJhY3QgYW4gZXJyb3IgbWVzc2FnZSBhbmQgY29kZVxuICAgICAgIyBiZWZvcmUgcmV0aHJvd2luZyB0aGUgZXJyb3IuXG4gICAgICBwcm9taXNlLmZhaWwgKGVycm9yKSAtPlxuICAgICAgICB7ZGF0YX0gPSBlcnJvclxuICAgICAgICBpZiBlcnJvckVsZW0gPSBkYXRhPy5qc29uPy5lcnJvclxuICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBlcnJvckVsZW0udGV4dC50ZXh0XG4gICAgICAgICAgZXJyb3IuY29kZSA9IHBhcnNlSW50IGVycm9yRWxlbS5hdHRyaWJ1dGVzLmNvZGUsIDEwXG4gICAgICAgIHRocm93IGVycm9yXG5cbiAgICAgIHByb21pc2VcblxuICAgICMgUmVtb3ZlIGEgY29udGFjdCBmcm9tIHRoZSByb3N0ZXJcbiAgICAjXG4gICAgIyBAcGFyYW0gY29udGFjdCBbU3RyaW5nLCBPYmplY3RdIGppZCBvciBvYmplY3QgYmVpbmcgcmVtb3ZlZFxuICAgICMgQG9wdGlvbiBqaWQgY29udGFjdHMgW1N0cmluZ10gamlkIG9mIHRoZSBjb250YWN0IGJlaW5nIHJlbW92ZWRcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdIHByb21pc2UgdG8gcmVtb3ZlXG4gICAgI1xuICAgICMgUmVtb3ZlIGEgY29udGFjdCBmcm9tIHRoZSBSb3N0ZXJcbiAgICAjXG4gICAgIyBAZXhhbXBsZSBSZW1vdmUgYSBjb250YWN0IGJ5IGppZCBvbmx5XG4gICAgIyAgIHJvc3Rlci5yZW1vdmVDb250YWN0KCdzb21lamlkJyk7XG4gICAgI1xuICAgICMgQGV4YW1wbGUgUmVtb3ZlIGEgY29udGFjdCBieSBvYmplY3RcbiAgICAjICAgcm9zdGVyLnJlbW92ZUNvbnRhY3Qoe2ppZDogJ3NvbWVqaWQnLCBuYW1lOiAnU29tZSBDb250YWN0J30pO1xuICAgICNcbiAgICAjIEBleGFtcGxlIEhhbmRsaW5nIHN1Y2Nlc3NmdWwgYW5kIGZhaWxlZCBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICMgICB2YXIgY29ubmVjdGlvbiA9IE5pdHJvLmdldENvbm5lY3Rpb24oKTtcbiAgICAjICAgdmFyIHJvc3RlciA9IGNvbm5lY3Rpb24uZ2V0Q29tcG9uZW50KE5pdHJvLlJPU1RFUik7XG4gICAgIyAgIHJvc3Rlci5yZW1vdmVDb250YWN0KHtqaWQ6IFwidXNlcmppZFwifSlcbiAgICAjICAgICAudGhlbiBmdW5jdGlvbihkYXRhKXtcbiAgICAjICAgICAgIC8vIHN1Y2Nlc3NzIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4gICAgIyAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICMgICAgICAgLy8gZmFpbHVyZSBoYW5kbGVyIGZvciB0aGUgcmVxdWVzdCB0byBOaXRyb1xuICAgICMgICAgfSk7XG4gICAgI1xuICAgICMgQGV4YW1wbGUgUmVnaXN0ZXJpbmcgZm9yIHB1c2ggbm90aWZpY2F0aW9ucyB0byBjb25maXJtIHJlcXVlc3RzXG4gICAgIyAgIGNvbm5lY3Rpb24uZXZlbnRNYW5hZ2VyLmxpc3RlbihFdmVudHMuUk9TVEVSX1JFTU9WRUQsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAjICAgICAvLyBSZWNlaXZlIGFjdHVhbCBwdXNoIGNvbmZpcm1hdGlvbiAob3IgYW55IGZ1dHVyZSB1cGRhdGVzKVxuICAgICMgICAgIC8vIGZyb20gTml0cm8gd2hlbiBjb250YWN0cyBhcmUgYWRkZWQgdG8gdGhlIFJvc3Rlci5cbiAgICAjICAgIH0pO1xuICAgICNcbiAgICAjIEBzZWUgRXZlbnRzLlJPU1RFUl9SRU1PVkVEXG5cbiAgICByZW1vdmVDb250YWN0OiAoY29udGFjdCA9IHt9KSAtPlxuICAgICAgaWYgdHlwZW9mIGNvbnRhY3QgaXMgJ3N0cmluZydcbiAgICAgICAgY29udGFjdCA9IGppZDogY29udGFjdFxuXG4gICAgICB7amlkfSA9IF8uZGVmYXVsdHMgY29udGFjdCwgamlkOiAnJ1xuXG4gICAgICBOaXRyb1Byb21pc2UgKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgICAgcmV0dXJuIHJlamVjdCBcIkF0dGVtcHRpbmcgdG8gcmVtb3ZlIGFuIGludmFsaWQgY29udGFjdCBmcm9tIHRoZSBSb3N0ZXJcIiB1bmxlc3MgamlkXG5cbiAgICAgICAgc2VuZElRXG4gICAgICAgICAgZWxlbWVudDogQGhlbHBlci5nZXRSZW1vdmVTdGFuemEgamlkXG4gICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZVxuICAgICAgICAgIHJlamVjdDogcmVqZWN0XG5cbiAgICAjIEFsaWFzIGZvciB0aGUgI2FkZENvbnRhY3QoKSBtZXRob2QgdXBkYXRlcyBhIGNvbnRhY3RcbiAgICAjXG4gICAgIyBAcGFyYW0gY29udGFjdCBbU3RyaW5nLCBPYmplY3RdIGNvbnRhY3Qgb2JqZWN0IG9yIGppZCBzdHJpbmcgZm9yIGEgY29udGFjdFxuICAgICNcbiAgICAjIEByZXR1cm4gW1EuUHJvbWlzZV1cbiAgICAjXG4gICAgIyBAc2VlIFJvc3RlciNhZGRDb250YWN0XG4gICAgdXBkYXRlQ29udGFjdDogKGNvbnRhY3QpIC0+XG4gICAgICBAYWRkQ29udGFjdCBjb250YWN0XG5cbiAgICAjIEludml0ZSBhIHVzZXIgdG8gYmUgYSByb3N0ZXIgY29udGFjdCBieSBzZW5kaW5nIGEgJ3N1YnNjcmliZSdcbiAgICAjXG4gICAgIyBAcGFyYW0gY29udGFjdCBbU3RyaW5nLCBPYmplY3RdIGNvbnRhY3QgamlkIG9yIGEgY29udGFjdCBvYmplY3QgdG9cbiAgICAjICAgaW52aXRlIHRvIHRoZSByb3N0ZXJcbiAgICAjIEBvcHRpb24gamlkIGNvbnRhY3QgW1N0cmluZ10gamlkIG9mIHRoZSBjb250YWN0IGJlaW5nIGludml0ZWRcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gICAgI1xuICAgICMgQGV4YW1wbGUgSW52aXRpbmcgYSBjb250YWN0IGJ5IGppZCBvbmx5XG4gICAgIyAgIHJvc3Rlci5pbnZpdGUoJ3NvbWVqaWQnKTtcbiAgICAjXG4gICAgIyBAZXhhbXBsZSBJbnZpdGluZyBhIGNvbnRhY3QgYnkgb2JqZWN0XG4gICAgIyAgIHJvc3Rlci5pbnZpdGUoe2ppZDogJ3NvbWVqaWQnLCBuYW1lOiAnU29tZSBDb250YWN0J30pO1xuICAgICNcbiAgICAjIEBleGFtcGxlIEhhbmRsaW5nIHN1Y2Nlc3NmdWwgYW5kIGZhaWxlZCBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICMgICB2YXIgY29ubmVjdGlvbiA9IE5pdHJvLmdldENvbm5lY3Rpb24oKTtcbiAgICAjICAgdmFyIHJvc3RlciA9IGNvbm5lY3Rpb24uZ2V0Q29tcG9uZW50KE5pdHJvLlJPU1RFUik7XG4gICAgIyAgIHJvc3Rlci5pbnZpdGUoe2ppZDogXCJ1c2VyamlkXCJ9KVxuICAgICMgICAgIC50aGVuIGZ1bmN0aW9uKGRhdGEpe1xuICAgICMgICAgICAgLy8gc3VjY2Vzc3MgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiAgICAjICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgIyAgICAgICAvLyBmYWlsdXJlIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4gICAgIyAgICB9KVxuICAgIGludml0ZTogKGNvbnRhY3QgPSB7fSkgLT5cbiAgICAgIEBzdWJzY3JpYmUgY29udGFjdFxuXG4gICAgIyBTZW5kIGEgcHJlc2VuY2Ugc3Vic2NyaXB0aW9uIG9mICdzdWJzY3JpYmUnIHRvIE5pdHJvIGZvciBhIHNwZWNpZmllZCBjb250YWN0XG4gICAgI1xuICAgICMgQHBhcmFtIGNvbnRhY3QgW1N0cmluZywgT2JqZWN0XSBhIGppZCBvciBhbiBvYmplY3Qgd2l0aCBhIGppZCBmb3IgYSBjb250YWN0XG4gICAgIyBAb3B0aW9uIGppZCBjb250YWN0IFtTdHJpbmddIGNvbnRhY3QgamlkXG4gICAgIyAgIHByZXNlbmNlIHRvXG4gICAgI1xuICAgICMgQHJldHVybiBbUS5Qcm9taXNlXVxuICAgICNcbiAgICAjIEBleGFtcGxlIFN1YnNjcmliaW5nIHRvIGEgY29udGFjdCdzIHByZXNlbmNlXG4gICAgIyAgIHJvc3Rlci5zdWJzY3JpYmUoJ2Fub3RoZXJjb250YWN0amlkJylcbiAgICBzdWJzY3JpYmU6IChjb250YWN0KSAtPlxuICAgICAgc2VuZFByZXNlbmNlVHlwZS5jYWxsIHRoaXMsIGNvbnRhY3QsIFByZXNlbmNlVHlwZS5TVUJTQ1JJQkVcblxuICAgICMgU2VuZCBhIHByZXNlbmNlIHN1YnNjcmlwdGlvbiBvZiAnc3Vic2NyaWJlZCcgdG8gTml0cm8gZm9yIGEgc3BlY2lmaWVkIGNvbnRhY3RcbiAgICAjXG4gICAgIyBAcGFyYW0gY29udGFjdCBbU3RyaW5nLCBPYmplY3RdIGEgamlkIG9yIGFuIG9iamVjdCB3aXRoIGEgamlkIGZvciBhIGNvbnRhY3RcbiAgICAjIEBvcHRpb24gamlkIGNvbnRhY3QgW1N0cmluZ10gY29udGFjdCBqaWRcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gICAgI1xuICAgICMgQGV4YW1wbGUgQ29uZmlybWluZyBzdWJzY3JpcHRpb24gZm9yIGFub3RoZXIgY29udGFjdCdzIHByZXNlbmNlIHJlcXVlc3QgdG8geW91XG4gICAgIyAgIHJvc3Rlci5zdWJzY3JpYmVkKCdhbm90aGVyY29udGFjdGppZCcpXG4gICAgc3Vic2NyaWJlZDogKGNvbnRhY3QpIC0+XG4gICAgICBzZW5kUHJlc2VuY2VUeXBlLmNhbGwgdGhpcywgY29udGFjdCwgUHJlc2VuY2VUeXBlLlNVQlNDUklCRURcblxuICAgICMgU2VuZCB1bnN1YnNjcmliZWQgcHJlc2VuY2UgdG8gYSBzcGVjaWZpZWQgdXNlclxuICAgICNcbiAgICAjIEBwYXJhbSBjb250YWN0IFtTdHJpbmcsIE9iamVjdF0gY29udGFjdCBqaWQgb3IgYSBjb250YWN0IG9iamVjdCB0b1xuICAgICMgICBzdG9wIHNlbmRpbmcgcHJlc2VuY2UgdG9cbiAgICAjIEBvcHRpb24gamlkIGNvbnRhY3QgW1N0cmluZ10gamlkIG9mIHRoZSBjb250YWN0IHlvdSBhcmUgbm8gbG9uZ2VyIHNlbmRpbmdcbiAgICAjICAgcHJlc2VuY2UgdG9cbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gICAgI1xuICAgICMgQGV4YW1wbGUgU3RvcCBzZW5kaW5nIHByZXNlbmNlIHRvIGEgY29udGFjdCBieSBqaWQgb25seVxuICAgICMgICByb3N0ZXIudW5zdWJzY3JpYmVkKCdzb21lamlkJyk7XG4gICAgI1xuICAgICMgQGV4YW1wbGUgU3RvcCBzZW5kaW5nIHByZXNlbmNlIHRvIGEgY29udGFjdCBieSBvYmplY3RcbiAgICAjICAgcm9zdGVyLnVuc3Vic2NyaWJlZCh7amlkOiAnc29tZWppZCcsIG5hbWU6ICdTb21lIENvbnRhY3QnfSk7XG4gICAgI1xuICAgICMgQGV4YW1wbGUgSGFuZGxpbmcgc3VjY2Vzc2Z1bCBhbmQgZmFpbGVkIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgIyAgIHZhciBjb25uZWN0aW9uID0gTml0cm8uZ2V0Q29ubmVjdGlvbigpO1xuICAgICMgICB2YXIgcm9zdGVyID0gY29ubmVjdGlvbi5nZXRDb21wb25lbnQoTml0cm8uUk9TVEVSKTtcbiAgICAjICAgcm9zdGVyLnVuc3Vic2NyaWJlZCh7amlkOiBcInVzZXJqaWRcIn0pXG4gICAgIyAgICAgLnRoZW4gZnVuY3Rpb24oZGF0YSl7XG4gICAgIyAgICAgICAvLyBzdWNjZXNzcyBoYW5kbGVyIGZvciB0aGUgcmVxdWVzdCB0byBOaXRyb1xuICAgICMgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAjICAgICAgIC8vIGZhaWx1cmUgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiAgICAjICAgIH0pO1xuICAgICNcbiAgICAjIEBzZWUgRXZlbnRzLlJPU1RFUl9VTlNVQlNDUklCRVxuICAgIHVuc3Vic2NyaWJlOiAoY29udGFjdCA9IHt9KSAtPlxuICAgICAgc2VuZFByZXNlbmNlVHlwZS5jYWxsIHRoaXMsIGNvbnRhY3QsIFByZXNlbmNlVHlwZS5VTlNVQlNDUklCRVxuXG4gICAgIyBAcHJpdmF0ZVxuICAgICMgU2VuZCBhIHByZXNlbmNlIHN1YnNjcmlwdGlvbiBieSB0eXBlIHRvIE5pdHJvXG4gICAgI1xuICAgICMgQHBhcmFtIGNvbnRhY3QgW1N0cmluZywgT2JqZWN0XSBhIGppZCBvciBhbiBvYmplY3Qgd2l0aCBhIGppZCBmb3IgYSBjb250YWN0XG4gICAgIyBAb3B0aW9uIGppZCBjb250YWN0IFtTdHJpbmddIGNvbnRhY3QgamlkXG4gICAgIyBAcGFyYW0gcHJlc2VuY2VUeXBlIFtTdHJpbmddIGEgUHJlc2VuY2VUeXBlIGVudW0sIGUuZy4gJ3N1YnNjcmliZScsICd1bnN1YnNjcmliZScsIGV0Yy5cbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gICAgI1xuICAgICMgQHNlZSBQcmVzZW5jZVR5cGVcbiAgICBzZW5kUHJlc2VuY2VUeXBlID0gKGNvbnRhY3QgPSAnJywgcHJlc2VuY2VUeXBlID0gJycpIC0+XG4gICAgICBpZiB0eXBlb2YgY29udGFjdCBpcyAnc3RyaW5nJ1xuICAgICAgICBjb250YWN0ID0gamlkOiBjb250YWN0XG5cbiAgICAgIHtqaWR9ID0gXy5kZWZhdWx0cyBjb250YWN0LCBqaWQ6ICcnXG5cbiAgICAgIE5pdHJvUHJvbWlzZSAocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgICBpZiBub3QgamlkIG9yIG5vdCBfLmlzU3RyaW5nIGppZFxuICAgICAgICAgIHJldHVybiByZWplY3QgXCJBdHRlbXB0aW5nIHRvIHNlbmQgI3twcmVzZW5jZVR5cGV9IHRvIGFuIGludmFsaWQgY29udGFjdFwiXG5cbiAgICAgICAgaWYgbm90IHByZXNlbmNlVHlwZSBvciBub3QgXy5pc1N0cmluZyBwcmVzZW5jZVR5cGVcbiAgICAgICAgICByZXR1cm4gcmVqZWN0IFwiUHJlc2VuY2UgdHlwZSBpcyBub3Qgc3BlY2lmaWVkXCJcblxuICAgICAgICBzdGFuemEgPSBAaGVscGVyLmdldFByZXNlbmNlU3Vic2NyaXB0aW9uU3RhbnphIGppZCwgcHJlc2VuY2VUeXBlXG4gICAgICAgIHNlbmQgcmVzb2x2ZTogcmVzb2x2ZSwgZWxlbWVudDogc3RhbnphXG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbl8ubWl4aW4gcmVxdWlyZSAndXRpbC9yZXRyeWVyJ1xuVXRpbHMgPSByZXF1aXJlICd1dGlsL3V0aWxzJ1xuUSA9IHJlcXVpcmUgJ3EnXG5OaXRyb1Byb21pc2UgPSByZXF1aXJlICd1dGlsL3Byb21pc2UnXG5zdHJvcGhlU3RvcmFnZSA9IHJlcXVpcmUgJ3N0cm9waGUvc3Ryb3BoZV9zdG9yYWdlJ1xuY29udmVydGVyID0gcmVxdWlyZSAnYWRhcHRlcnMvcHJlZmVyZW5jZXMnXG5cbiMgVGhpcyBjbGFzcyBoYXMgdmlydHVhbCBtZXRob2RzLCB0aGF0IGFyZSBhdmFpbGFibGUgb24gdGhlIHNpbmdsZXRvbiBpbnN0YW5jZVxuIyByZXR1cm5lZCBieSB0aGUgc3RhdGljICNnZXQoKSBtZXRob2QuXG4jXG4jIEBtZXRob2QgI2dldFByZWZlcmVuY2VzKClcbiMgICBJbml0aWFsaXplIHByZWZlcmVuY2VzIGJ5IHJldHJpZXZpbmcgdGhlbSBmcm9tIHRoZSBYTVBQIHNlcnZlclxuI1xuIyAgIEByZXR1cm4gW1EuUHJvbWlzZV1cbiNcbiMgICBAZXhhbXBsZSBIYW5kbGluZyBzdWNjZXNzZnVsIGFuZCBmYWlsZWQgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3RcbiMgICAgIC8vIEltcG9ydCBvcHRpb25hbCBhZGFwdGVycyB0byBwcm9jZXNzIGluY29taW5nIFhNTCBkYXRhXG4jICAgICBhZGFwdGVycyA9IHJlcXVpcmUgJ2FkYXB0ZXJzL2FkYXB0ZXJzJ1xuI1xuIyAgICAgdmFyIGNvbm5lY3Rpb24gPSBOaXRyby5nZXRDb25uZWN0aW9uKCk7XG4jICAgICB2YXIgc3RvcmFnZSA9IGNvbm5lY3Rpb24uZ2V0Q29tcG9uZW50KE5pdHJvLlNUT1JBR0UpO1xuI1xuIyAgICAgLy8gUm9zdGVyIGRhdGEgd2lsbCBiZSByZXR1cm5lZCBpbW1lZGlhdGVseSAobm8gbmVlZCB0byB3YWl0IGZvciBhIHB1c2ggZXZlbnQpXG4jICAgICBzdG9yYWdlLmdldFByZWZlcmVuY2VzKClcbiMgICAgICAgLy8gYWRhcHRlcnMgYXMgc3VjY2Vzc3MgaGFuZGxlcnMgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4jICAgICAgIC50aGVuKGFkYXB0ZXJzLmNvbnZlcnRUb0pTT04pXG4jICAgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpe1xuIyAgICAgICAgIC8vIGFkZGl0aW9uYWwgc3VjY2VzcyBoYW5kbGVyIChvcHRpb25hbClcbiMgICAgICAgICByZXR1cm4gZGF0YTtcbiMgICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuIyAgICAgICAgIC8vIGZhaWx1cmUgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiMgICAgICB9KTtcbiNcbiMgQG1ldGhvZCAjc2V0UHJlZmVyZW5jZXMocHJlZmVyZW5jZXMgPSB7fSlcbiMgICBMb29wIHRocm91Z2ggYWxsIHByZWZlcmVuY2VzIGFuZCBjcmVhdGUgeG1wcCBzdGFuemEgYW5kIHNlbmQgdG8gTml0cm9cbiNcbiMgICBAcmV0dXJuIFtRLlByb21pc2VdXG4jXG4jICAgQGV4YW1wbGUgSGFuZGxpbmcgc3VjY2Vzc2Z1bCBhbmQgZmFpbGVkIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XG4jICAgICB2YXIgY29ubmVjdGlvbiA9IE5pdHJvLmdldENvbm5lY3Rpb24oKTtcbiMgICAgIHZhciBzdG9yYWdlID0gY29ubmVjdGlvbi5nZXRDb21wb25lbnQoTml0cm8uU1RPUkFHRSk7XG4jICAgICBzdG9yYWdlLnNldFByZWZlcmVuY2VzKHtwcmVmMTogXCJ2YWx1ZTFcIiwgcHJlZjI6IFwidmFsdWUyXCJ9KVxuIyAgICAgICAudGhlbiBmdW5jdGlvbihkYXRhKXtcbiMgICAgICAgICAvLyBzdWNjZXNzcyBoYW5kbGVyIGZvciB0aGUgcmVxdWVzdCB0byBOaXRyb1xuIyAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4jICAgICAgICAgLy8gZmFpbHVyZSBoYW5kbGVyIGZvciB0aGUgcmVxdWVzdCB0byBOaXRyb1xuIyAgICAgIH0pO1xuI1xuIyAgIEBleGFtcGxlIFJlZ2lzdGVyaW5nIGZvciBwdXNoIG5vdGlmaWNhdGlvbnMgdG8gY29uZmlybSByZXF1ZXN0c1xuIyAgICAgY29ubmVjdGlvbi5ldmVudE1hbmFnZXIubGlzdGVuKEV2ZW50cy5QUkVGRVJFTkNFU19VUERBVEUsIGZ1bmN0aW9uKGRhdGEpIHtcbiMgICAgICAgLy8gUmVjZWl2ZSBhY3R1YWwgcHVzaCBjb25maXJtYXRpb24gKG9yIGFueSBmdXR1cmUgdXBkYXRlcylcbiMgICAgICAgLy8gZnJvbSBOaXRybyB3aGVuIHByZWZlcmVuY2VzIGFyZSBzZXQgb24gdGhlIHNlcnZlci5cbiMgICAgICB9KTtcbiNcbiMgICBAc2VlIEV2ZW50cy5QUkVGRVJFTkNFU19VUERBVEVcbiNcbiMgQG1ldGhvZCAjZ2V0Qm9va21hcmtzKClcbiMgICBJbml0aWFsaXplIGJvb2ttYXJrcyBieSByZXRyaWV2aW5nIHRoZW0gZnJvbSB0aGUgWE1QUCBzZXJ2ZXJcbiNcbiMgICBAcmV0dXJuIFtRLlByb21pc2VdXG4jXG4jICAgQGV4YW1wbGUgSGFuZGxpbmcgc3VjY2Vzc2Z1bCBhbmQgZmFpbGVkIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XG4jICAgICAvLyBJbXBvcnQgb3B0aW9uYWwgYWRhcHRlcnMgdG8gcHJvY2VzcyBpbmNvbWluZyBYTUwgZGF0YVxuIyAgICAgYWRhcHRlcnMgPSByZXF1aXJlICdhZGFwdGVycy9hZGFwdGVycydcbiNcbiMgICAgIHZhciBjb25uZWN0aW9uID0gTml0cm8uZ2V0Q29ubmVjdGlvbigpO1xuIyAgICAgdmFyIHN0b3JhZ2UgPSBjb25uZWN0aW9uLmdldENvbXBvbmVudChOaXRyby5TVE9SQUdFKTtcbiNcbiMgICAgIC8vIFJvc3RlciBkYXRhIHdpbGwgYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHkgKG5vIG5lZWQgdG8gd2FpdCBmb3IgYSBwdXNoIGV2ZW50KVxuIyAgICAgc3RvcmFnZS5nZXRCb29rbWFya3MoKVxuIyAgICAgICAvLyBhZGFwdGVycyBhcyBzdWNjZXNzcyBoYW5kbGVycyBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiMgICAgICAgLnRoZW4oYWRhcHRlcnMuY29udmVydFRvSlNPTilcbiMgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSl7XG4jICAgICAgICAgLy8gYWRkaXRpb25hbCBzdWNjZXNzIGhhbmRsZXIgKG9wdGlvbmFsKVxuIyAgICAgICAgIHJldHVybiBkYXRhO1xuIyAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4jICAgICAgICAgLy8gZmFpbHVyZSBoYW5kbGVyIGZvciB0aGUgcmVxdWVzdCB0byBOaXRyb1xuIyAgICAgIH0pO1xuI1xuIyBAbWV0aG9kICNzZXRCb29rbWFya3MoY2hhdHJvb21zKVxuIyAgIFNldCBib29rbWFya3MgZm9yIGxlZ2FjeSBhbmQgeG1wcCBjaGF0cm9vbXNcbiNcbiMgICBAcGFyYW0gd2NwQ2hhdHJvb21zIFtBcnJheTxPYmplY3Q+XSBsaXN0IG9mIFdDUCBjaGF0cm9vbSBkYXRhIG9iamVjdHNcbiMgICBAcGFyYW0geG1wcENoYXRyb29tcyBbQXJyYXk8T2JqZWN0Pl0gbGlzdCBvZiBYTVBQIGNoYXRyb29tIGRhdGEgb2JqZWN0c1xuI1xuIyAgIEByZXR1cm4gW1EuUHJvbWlzZV1cbiNcbiMgICBAZXhhbXBsZSBIYW5kbGluZyBzdWNjZXNzZnVsIGFuZCBmYWlsZWQgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3RcbiMgICAgIHZhciBjb25uZWN0aW9uID0gTml0cm8uZ2V0Q29ubmVjdGlvbigpO1xuIyAgICAgdmFyIHN0b3JhZ2UgPSBjb25uZWN0aW9uLmdldENvbXBvbmVudChOaXRyby5TVE9SQUdFKTtcbiMgICAgIHN0b3JhZ2Uuc2V0Qm9va21hcmtzKHtqaWQ6IFwicm9vbWppZFwiLCBuYW1lOiBcIlJvb20gTmFtZVwifSlcbiMgICAgICAgLnRoZW4gZnVuY3Rpb24oZGF0YSl7XG4jICAgICAgICAgLy8gc3VjY2Vzc3MgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiMgICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuIyAgICAgICAgIC8vIGZhaWx1cmUgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiMgICAgICB9KTtcbiNcbiMgICBAZXhhbXBsZSBSZWdpc3RlcmluZyBmb3IgcHVzaCBub3RpZmljYXRpb25zIHRvIGNvbmZpcm0gcmVxdWVzdHNcbiMgICAgIGNvbm5lY3Rpb24uZXZlbnRNYW5hZ2VyLmxpc3RlbihFdmVudHMuQk9PS01BUktTX1VQREFURSwgZnVuY3Rpb24oZGF0YSkge1xuIyAgICAgICAvLyBSZWNlaXZlIGFjdHVhbCBwdXNoIGNvbmZpcm1hdGlvbiAob3IgYW55IGZ1dHVyZSB1cGRhdGVzKVxuIyAgICAgICAvLyBmcm9tIE5pdHJvIHdoZW4gYm9va21hcmtzIGFyZSBzZXQgb24gdGhlIHNlcnZlci5cbiMgICAgICB9KTtcbiNcbiMgICBAc2VlIEV2ZW50cy5CT09LTUFSS1NfVVBEQVRFXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFN0b3JhZ2VcblxuICAjIEBwcm9wZXJ0eSBbU3RyaW5nXSBwdWJsaWMgbmFtZSBmb3IgdGhpcyBjb21wb25lbnRcbiAgQE5BTUU6ICdjb21wb25lbnQuc3RvcmFnZSdcblxuICAjIEBwcm9wZXJ0eSBwcml2YXRlIGluc3RhbmNlIG9mIFByaXZhdGVTdG9yYWdlXG4gICMgQHByaXZhdGVcbiAgaW5zdGFuY2UgPSBudWxsXG5cbiAgIyBSZXRyaWV2ZSBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgUHJpdmF0ZVN0b3JhZ2UgY2xhc3NcbiAgI1xuICAjIEByZXR1cm4gW1ByaXZhdGVTdG9yYWdlXSBzaW5nbGV0b24gaW5zdGFuY2VcbiAgQGdldDogKG9wdGlvbnMgPSB7fSkgLT5cbiAgICBjcmVhdGVJbnN0YW5jZSA9IC0+XG4gICAgICBuZXcgUHJpdmF0ZVN0b3JhZ2Ugb3B0aW9uc1xuICAgIGluc3RhbmNlID89IGNyZWF0ZUluc3RhbmNlKClcblxuICAjIERlc3Ryb3kgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSwgb25seSBmb3IgdW5pdCB0ZXN0aW5nXG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSB0cnVlIGlmIHRoZSBzaW5nbGV0b24gd2FzIGRlc3Ryb3llZCwgb3RoZXJ3aXNlIGZhbHNlXG4gIEBkZXN0cm95OiBVdGlscy5yZXR1cm5Cb29sIC0+XG4gICAgaW5zdGFuY2UgPSBudWxsXG4gICAgXG4gIGNsYXNzIFByaXZhdGVTdG9yYWdlXG5cbiAgICAjIEBwcm9wZXJ0eSBbSW50ZWdlcl0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGF0dGVtcHRzIHRvIGdldCBvciBzZXRcbiAgICAjICAgcHJlZmVyZW5jZXMgb24gdGhlIE5pdHJvIHNlcnZlclxuICAgIEBNQVhfQVRURU1QVFM6IDNcblxuICAgICMgQHByb3BlcnR5IFtPYmplY3RdIGhlbHBlciBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBTdHJvcGhlLkJ1aWxkZXIgc3Rhbnphc1xuICAgIGhlbHBlcjogbnVsbFxuXG4gICAgIyBAcHJvcGVydHkgW0Z1bmN0aW9uXSBsb2NhbCByZWZlcmVuY2UgdG8gYW4gaW5qZWN0ZWQgJ3NlbmRJUScgZnVuY3Rpb25cbiAgICAjIEBwcml2YXRlXG4gICAgc2VuZElRID0gbnVsbFxuXG4gICAgIyBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgUHJpdmF0ZVN0b3JhZ2VcbiAgICAjXG4gICAgIyBAcGFyYW0gb3B0aW9ucyBbT2JqZWN0XSBhbiBvYmplY3Qgb2Ygb3B0aW9uc1xuICAgICMgQG9wdGlvbiBvcHRpb25zIHNlbmRJUSBbRnVuY3Rpb25dIG1ldGhvZCB3cmFwcGluZyBTdHJvcGhlJ3MgJ3NlbmRJUSdcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtQcml2YXRlUm9zdGVyXVxuICAgIGNvbnN0cnVjdG9yOiAob3B0aW9ucyA9IHt9KSAtPlxuICAgICAge0BoZWxwZXIsIHNlbmRJUX0gPSBfLmRlZmF1bHRzIG9wdGlvbnMsXG4gICAgICAgIGhlbHBlcjogc3Ryb3BoZVN0b3JhZ2VcblxuICAgICMgSW5pdGlhbGl6ZSBwcmVmZXJlbmNlcyBieSByZXRyaWV2aW5nIHRoZW0gZnJvbSB0aGUgWE1QUCBzZXJ2ZXJcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gICAgI1xuICAgICMgQGV4YW1wbGUgSGFuZGxpbmcgc3VjY2Vzc2Z1bCBhbmQgZmFpbGVkIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgIyAgIC8vIEltcG9ydCBvcHRpb25hbCBhZGFwdGVycyB0byBwcm9jZXNzIGluY29taW5nIFhNTCBkYXRhXG4gICAgIyAgIGFkYXB0ZXJzID0gcmVxdWlyZSAnYWRhcHRlcnMvYWRhcHRlcnMnXG4gICAgI1xuICAgICMgICB2YXIgY29ubmVjdGlvbiA9IE5pdHJvLmdldENvbm5lY3Rpb24oKTtcbiAgICAjICAgdmFyIHN0b3JhZ2UgPSBjb25uZWN0aW9uLmdldENvbXBvbmVudChOaXRyby5TVE9SQUdFKTtcbiAgICAjXG4gICAgIyAgIC8vIFJvc3RlciBkYXRhIHdpbGwgYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHkgKG5vIG5lZWQgdG8gd2FpdCBmb3IgYSBwdXNoIGV2ZW50KVxuICAgICMgICBzdG9yYWdlLmdldFByZWZlcmVuY2VzKClcbiAgICAjICAgICAvLyBhZGFwdGVycyBhcyBzdWNjZXNzcyBoYW5kbGVycyBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiAgICAjICAgICAudGhlbihhZGFwdGVycy5jb252ZXJ0VG9KU09OKVxuICAgICMgICAgIC50aGVuKGZ1bmN0aW9uKGRhdGEpe1xuICAgICMgICAgICAgLy8gYWRkaXRpb25hbCBzdWNjZXNzIGhhbmRsZXIgKG9wdGlvbmFsKVxuICAgICMgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgIyAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICMgICAgICAgLy8gZmFpbHVyZSBoYW5kbGVyIGZvciB0aGUgcmVxdWVzdCB0byBOaXRyb1xuICAgICMgICAgfSlcbiAgICBnZXRQcmVmZXJlbmNlczogLT5cbiAgICAgIHNlbmRSZXF1ZXN0IEBoZWxwZXIuZ2V0UHJlZmVyZW5jZXNTdGFuemEoKVxuICAgICAgXG4gICAgIyBMb29wIHRocm91Z2ggYWxsIHByZWZlcmVuY2VzIGFuZCBjcmVhdGUgeG1wcCBzdGFuemEgYW5kIHNlbmQgdG8gTml0cm9cbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gICAgI1xuICAgICMgQGV4YW1wbGUgSGFuZGxpbmcgc3VjY2Vzc2Z1bCBhbmQgZmFpbGVkIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgIyAgIHZhciBjb25uZWN0aW9uID0gTml0cm8uZ2V0Q29ubmVjdGlvbigpO1xuICAgICMgICB2YXIgc3RvcmFnZSA9IGNvbm5lY3Rpb24uZ2V0Q29tcG9uZW50KE5pdHJvLlNUT1JBR0UpO1xuICAgICMgICBzdG9yYWdlLnNldFByZWZlcmVuY2VzKHtwcmVmMTogXCJ2YWx1ZTFcIiwgcHJlZjI6IFwidmFsdWUyXCJ9KVxuICAgICMgICAgIC50aGVuIGZ1bmN0aW9uKGRhdGEpe1xuICAgICMgICAgICAgLy8gc3VjY2Vzc3MgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiAgICAjICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgIyAgICAgICAvLyBmYWlsdXJlIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4gICAgIyAgICB9KTtcbiAgICAjXG4gICAgIyBAZXhhbXBsZSBSZWdpc3RlcmluZyBmb3IgcHVzaCBub3RpZmljYXRpb25zIHRvIGNvbmZpcm0gcmVxdWVzdHNcbiAgICAjICAgY29ubmVjdGlvbi5ldmVudE1hbmFnZXIubGlzdGVuKEV2ZW50cy5QUkVGRVJFTkNFU19VUERBVEUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAjICAgICAvLyBSZWNlaXZlIGFjdHVhbCBwdXNoIGNvbmZpcm1hdGlvbiAob3IgYW55IGZ1dHVyZSB1cGRhdGVzKVxuICAgICMgICAgIC8vIGZyb20gTml0cm8gd2hlbiBwcmVmZXJlbmNlcyBhcmUgc2V0IG9uIHRoZSBzZXJ2ZXIuXG4gICAgIyAgICB9KTtcbiAgICAjXG4gICAgIyBAc2VlIEV2ZW50cy5QUkVGRVJFTkNFU19VUERBVEVcblxuICAgIHNldFByZWZlcmVuY2VzOiAocHJlZmVyZW5jZXMgPSB7fSkgLT5cbiAgICAgIHNlbmRSZXF1ZXN0IEBoZWxwZXIuc2V0UHJlZmVyZW5jZXNTdGFuemEgcHJlZmVyZW5jZXNcblxuICAgICMgR2V0IGEgXCJzZXRcIiBwcmVmZXJlbmNlcyBzdGFuemEgZm9yIGVhY2ggYnVja2V0IGFuZCBzZW5kIHRvIE5pdHJvXG4gICAgI1xuICAgICMgQHJldHVybiBbQXJyYXk8US5Qcm9taXNlPl1cbiAgICBzZXRBbGxQcmVmZXJlbmNlczogKHByZWZlcmVuY2VzKSAtPlxuICAgICAgUS5hbGwgW1xuICAgICAgICBAc2V0R2xvYmFsUHJlZmVyZW5jZXMgcHJlZmVyZW5jZXM/Lmdsb2JhbD8uZmlyc3RDaGlsZCBvciAnJ1xuICAgICAgICBAc2V0RU1QcmVmZXJlbmNlcyBwcmVmZXJlbmNlcz8uZW0/LmZpcnN0Q2hpbGQgb3IgJydcbiAgICAgICAgQHNldEJsYXN0UHJlZmVyZW5jZXMgcHJlZmVyZW5jZXM/LmJsYXN0cz8uZmlyc3RDaGlsZCBvciAnJ1xuICAgICAgICBAc2V0Q29udmVyc2F0aW9uUHJlZmVyZW5jZXMgcHJlZmVyZW5jZXM/LmNvbnZlcnNhdGlvbnM/LmZpcnN0Q2hpbGQgb3IgJydcbiAgICAgICAgQHNldEFsZXJ0UHJlZmVyZW5jZXMgcHJlZmVyZW5jZXM/LmFsZXJ0cz8uZmlyc3RDaGlsZCBvciAnJ1xuICAgICAgXVxuXG4gICAgIyBHZXQgYSBcInNldFwiIGdsb2JhbCBwcmVmZXJlbmNlcyBzdGFuemEgYW5kIHNlbmQgdG8gTml0cm9cbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gICAgc2V0R2xvYmFsUHJlZmVyZW5jZXM6IChwcmVmZXJlbmNlcyA9IHt9KSAtPlxuICAgICAgcmV0dXJuIHVubGVzcyBwcmVmZXJlbmNlc1xuICAgICAgc3RhbnphID0gQGhlbHBlci5zZXRHbG9iYWxQcmVmZXJlbmNlc1N0YW56YSBwcmVmZXJlbmNlc1xuICAgICAgaWYgc3RhbnphIHRoZW4gc2VuZFJlcXVlc3Qgc3RhbnphXG5cbiAgICAjIEdldCBhIFwic2V0XCIgZW0gcHJlZmVyZW5jZXMgc3RhbnphIGFuZCBzZW5kIHRvIE5pdHJvXG4gICAgI1xuICAgICMgQHJldHVybiBbUS5Qcm9taXNlXVxuICAgIHNldEVNUHJlZmVyZW5jZXM6IChwcmVmZXJlbmNlcyA9IHt9KSAtPlxuICAgICAgcmV0dXJuIHVubGVzcyBwcmVmZXJlbmNlc1xuICAgICAgc3RhbnphID0gQGhlbHBlci5zZXRFTVByZWZlcmVuY2VzU3RhbnphIHByZWZlcmVuY2VzXG4gICAgICBpZiBzdGFuemEgdGhlbiBzZW5kUmVxdWVzdCBzdGFuemFcblxuICAgICMgR2V0IGEgXCJzZXRcIiBlbSBwcmVmZXJlbmNlcyBzdGFuemEgYW5kIHNlbmQgdG8gTml0cm9cbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gICAgc2V0Qmxhc3RQcmVmZXJlbmNlczogKHByZWZlcmVuY2VzID0ge30pIC0+XG4gICAgICByZXR1cm4gdW5sZXNzIHByZWZlcmVuY2VzXG4gICAgICBzdGFuemEgPSBAaGVscGVyLnNldEJsYXN0UHJlZmVyZW5jZXNTdGFuemEgcHJlZmVyZW5jZXNcbiAgICAgIGlmIHN0YW56YSB0aGVuIHNlbmRSZXF1ZXN0IHN0YW56YVxuXG4gICAgIyBHZXQgYSBcInNldFwiIGNvbnZlcnNhdGlvbnMgcHJlZmVyZW5jZXMgc3RhbnphIGFuZCBzZW5kIHRvIE5pdHJvXG4gICAgI1xuICAgICMgQHJldHVybiBbUS5Qcm9taXNlXVxuICAgIHNldENvbnZlcnNhdGlvblByZWZlcmVuY2VzOiAocHJlZmVyZW5jZXMgPSB7fSkgLT5cbiAgICAgIHJldHVybiB1bmxlc3MgcHJlZmVyZW5jZXNcbiAgICAgIHN0YW56YSA9IEBoZWxwZXIuc2V0Q29udmVyc2F0aW9uUHJlZmVyZW5jZXNTdGFuemEgcHJlZmVyZW5jZXNcbiAgICAgIGlmIHN0YW56YSB0aGVuIHNlbmRSZXF1ZXN0IHN0YW56YVxuXG4gICAgIyBHZXQgYSBcInNldFwiIGFsZXJ0cyBwcmVmZXJlbmNlcyBzdGFuemEgYW5kIHNlbmQgdG8gTml0cm9cbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gICAgc2V0QWxlcnRQcmVmZXJlbmNlczogKHByZWZlcmVuY2VzID0ge30pIC0+XG4gICAgICByZXR1cm4gdW5sZXNzIHByZWZlcmVuY2VzXG4gICAgICBzdGFuemEgPSBAaGVscGVyLnNldEFsZXJ0UHJlZmVyZW5jZXNTdGFuemEgcHJlZmVyZW5jZXNcbiAgICAgIGlmIHN0YW56YSB0aGVuIHNlbmRSZXF1ZXN0IHN0YW56YVxuXG4gICAgIyBHZXQgYSBcImdldFwiIHByZWZlcmVuY2VzIHN0YW56YSBmb3IgZWFjaCBidWNrZXQgYW5kIHNlbmQgdG8gTml0cm9cbiAgICAjXG4gICAgIyBAcmV0dXJuIFtBcnJheTxRLlByb21pc2U+XVxuICAgIGdldEFsbFByZWZlcmVuY2VzOiA9PlxuICAgICAgUS5hbGwgW1xuICAgICAgICBAZ2V0R2xvYmFsUHJlZmVyZW5jZXMoKSxcbiAgICAgICAgQGdldEVNUHJlZmVyZW5jZXMoKSxcbiAgICAgICAgQGdldEJsYXN0UHJlZmVyZW5jZXMoKSxcbiAgICAgICAgQGdldENvbnZlcnNhdGlvblByZWZlcmVuY2VzKCksXG4gICAgICAgIEBnZXRBbGVydFByZWZlcmVuY2VzKClcbiAgICAgIF1cblxuICAgICMgR2V0IGEgXCJnZXRcIiBnbG9iYWwgcHJlZmVyZW5jZXMgc3RhbnphIGFuZCBzZW5kIHRvIE5pdHJvXG4gICAgI1xuICAgICMgQHJldHVybiBbUS5Qcm9taXNlXVxuICAgIGdldEdsb2JhbFByZWZlcmVuY2VzOiAtPlxuICAgICAgc2VuZFJlcXVlc3QgQGhlbHBlci5nZXRHbG9iYWxQcmVmZXJlbmNlc1N0YW56YSgpXG5cbiAgICAjIEdldCBhIFwiZ2V0XCIgZ2xvYmFsIHByZWZlcmVuY2VzIHN0YW56YSBhbmQgc2VuZCB0byBOaXRyb1xuICAgICNcbiAgICAjIEByZXR1cm4gW1EuUHJvbWlzZV1cbiAgICBnZXRFTVByZWZlcmVuY2VzOiAtPlxuICAgICAgc2VuZFJlcXVlc3QgQGhlbHBlci5nZXRFTVByZWZlcmVuY2VzU3RhbnphKClcblxuICAgICMgR2V0IGEgXCJnZXRcIiBnbG9iYWwgcHJlZmVyZW5jZXMgc3RhbnphIGFuZCBzZW5kIHRvIE5pdHJvXG4gICAgI1xuICAgICMgQHJldHVybiBbUS5Qcm9taXNlXVxuICAgIGdldEJsYXN0UHJlZmVyZW5jZXM6IC0+XG4gICAgICBzZW5kUmVxdWVzdCBAaGVscGVyLmdldEJsYXN0c1ByZWZlcmVuY2VzU3RhbnphKClcblxuICAgICMgR2V0IGEgXCJnZXRcIiBnbG9iYWwgcHJlZmVyZW5jZXMgc3RhbnphIGFuZCBzZW5kIHRvIE5pdHJvXG4gICAgI1xuICAgICMgQHJldHVybiBbUS5Qcm9taXNlXVxuICAgIGdldENvbnZlcnNhdGlvblByZWZlcmVuY2VzOiAtPlxuICAgICAgc2VuZFJlcXVlc3QgQGhlbHBlci5nZXRDb252ZXJzYXRpb25QcmVmZXJlbmNlc1N0YW56YSgpXG5cbiAgICAjIEdldCBhIFwiZ2V0XCIgZ2xvYmFsIHByZWZlcmVuY2VzIHN0YW56YSBhbmQgc2VuZCB0byBOaXRyb1xuICAgICNcbiAgICAjIEByZXR1cm4gW1EuUHJvbWlzZV1cbiAgICBnZXRBbGVydFByZWZlcmVuY2VzOiAtPlxuICAgICAgc2VuZFJlcXVlc3QgQGhlbHBlci5nZXRBbGVydHNQcmVmZXJlbmNlc1N0YW56YSgpXG5cbiAgICAjIEdldCBhIFwic2V0XCIgcHJlZmVyZW5jZXMgc3RhbnphIHdpdGggYW4gZW1wdHkgc3RyaW5nIGFuZCBzZW5kIHRvIE5pdHJvXG4gICAgI1xuICAgICMgQHJldHVybiBbUS5Qcm9taXNlXVxuICAgIGNsZWFyUHJlZmVyZW5jZXM6IC0+XG4gICAgICBzZW5kUmVxdWVzdCBAaGVscGVyLmNsZWFyUHJlZmVyZW5jZXNTdGFuemEoKVxuXG4gICAgIyBGb3IgYWxsIGJ1Y2tldHMsIHNlbmQgYSBcInNldFwiIHByZWZlcmVuY2VzIHN0YW56YSB3aXRoIGFuIGVtcHR5IHN0cmluZyBhbmQgc2VuZCB0byBOaXRyb1xuICAgICNcbiAgICAjIEByZXR1cm4gW1EuUHJvbWlzZV1cbiAgICBjbGVhckFsbFByZWZlcmVuY2VzOiAtPlxuICAgICAgUS5hbGwgW1xuICAgICAgICBzZW5kUmVxdWVzdCBAaGVscGVyLmNsZWFyUHJlZmVyZW5jZXNTdGFuemEoKVxuICAgICAgICBzZW5kUmVxdWVzdCBAaGVscGVyLmNsZWFyR2xvYmFsUHJlZmVyZW5jZXNTdGFuemEoKVxuICAgICAgICBzZW5kUmVxdWVzdCBAaGVscGVyLmNsZWFyRU1QcmVmZXJlbmNlc1N0YW56YSgpXG4gICAgICAgIHNlbmRSZXF1ZXN0IEBoZWxwZXIuY2xlYXJCbGFzdHNQcmVmZXJlbmNlc1N0YW56YSgpXG4gICAgICAgIHNlbmRSZXF1ZXN0IEBoZWxwZXIuY2xlYXJDb252ZXJzYXRpb25zUHJlZmVyZW5jZXNTdGFuemEoKVxuICAgICAgICBzZW5kUmVxdWVzdCBAaGVscGVyLmNsZWFyQWxlcnRzUHJlZmVyZW5jZXNTdGFuemEoKVxuICAgICAgXVxuXG4gICAgdG9OaXRybzogY29udmVydGVyLnRvTml0cm9cbiAgICBmcm9tTml0cm86IGNvbnZlcnRlci5mcm9tTml0cm9cblxuICAgICMgSW5pdGlhbGl6ZSBib29rbWFya3MgYnkgcmV0cmlldmluZyB0aGVtIGZyb20gdGhlIFhNUFAgc2VydmVyXG4gICAgI1xuICAgICMgQHJldHVybiBbUS5Qcm9taXNlXVxuICAgICNcbiAgICAjIEBleGFtcGxlIEhhbmRsaW5nIHN1Y2Nlc3NmdWwgYW5kIGZhaWxlZCBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICMgICAvLyBJbXBvcnQgb3B0aW9uYWwgYWRhcHRlcnMgdG8gcHJvY2VzcyBpbmNvbWluZyBYTUwgZGF0YVxuICAgICMgICBhZGFwdGVycyA9IHJlcXVpcmUgJ2FkYXB0ZXJzL2FkYXB0ZXJzJ1xuICAgICNcbiAgICAjICAgdmFyIGNvbm5lY3Rpb24gPSBOaXRyby5nZXRDb25uZWN0aW9uKCk7XG4gICAgIyAgIHZhciBzdG9yYWdlID0gY29ubmVjdGlvbi5nZXRDb21wb25lbnQoTml0cm8uU1RPUkFHRSk7XG4gICAgI1xuICAgICMgICAvLyBSb3N0ZXIgZGF0YSB3aWxsIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5IChubyBuZWVkIHRvIHdhaXQgZm9yIGEgcHVzaCBldmVudClcbiAgICAjICAgc3RvcmFnZS5nZXRCb29rbWFya3MoKVxuICAgICMgICAgIC8vIGFkYXB0ZXJzIGFzIHN1Y2Nlc3NzIGhhbmRsZXJzIGZvciB0aGUgcmVxdWVzdCB0byBOaXRyb1xuICAgICMgICAgIC50aGVuKGFkYXB0ZXJzLmNvbnZlcnRUb0pTT04pXG4gICAgIyAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSl7XG4gICAgIyAgICAgICAvLyBhZGRpdGlvbmFsIHN1Y2Nlc3MgaGFuZGxlciAob3B0aW9uYWwpXG4gICAgIyAgICAgICByZXR1cm4gZGF0YTtcbiAgICAjICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgIyAgICAgICAvLyBmYWlsdXJlIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IHRvIE5pdHJvXG4gICAgIyAgICB9KVxuICAgIGdldEJvb2ttYXJrczogLT5cbiAgICAgIHNlbmRSZXF1ZXN0IEBoZWxwZXIuZ2V0Qm9va21hcmtzU3RhbnphKClcblxuICAgICMgU2V0IGJvb2ttYXJrcyBmb3IgbGVnYWN5IGFuZCB4bXBwIGNoYXRyb29tc1xuICAgICNcbiAgICAjIEBwYXJhbSB3Y3BDaGF0cm9vbXMgW0FycmF5PE9iamVjdD5dIGxpc3Qgb2YgV0NQIGNoYXRyb29tIGRhdGEgb2JqZWN0c1xuICAgICMgQHBhcmFtIHhtcHBDaGF0cm9vbXMgW0FycmF5PE9iamVjdD5dIGxpc3Qgb2YgWE1QUCBjaGF0cm9vbSBkYXRhIG9iamVjdHNcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtRLlByb21pc2VdXG4gICAgI1xuICAgICMgQGV4YW1wbGUgSGFuZGxpbmcgc3VjY2Vzc2Z1bCBhbmQgZmFpbGVkIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgIyAgIHZhciBjb25uZWN0aW9uID0gTml0cm8uZ2V0Q29ubmVjdGlvbigpO1xuICAgICMgICB2YXIgc3RvcmFnZSA9IGNvbm5lY3Rpb24uZ2V0Q29tcG9uZW50KE5pdHJvLlNUT1JBR0UpO1xuICAgICMgICBzdG9yYWdlLnNldEJvb2ttYXJrcyh7amlkOiBcInJvb21qaWRcIiwgbmFtZTogXCJSb29tIE5hbWVcIn0pXG4gICAgIyAgICAgLnRoZW4gZnVuY3Rpb24oZGF0YSl7XG4gICAgIyAgICAgICAvLyBzdWNjZXNzcyBoYW5kbGVyIGZvciB0aGUgcmVxdWVzdCB0byBOaXRyb1xuICAgICMgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAjICAgICAgIC8vIGZhaWx1cmUgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QgdG8gTml0cm9cbiAgICAjICAgIH0pO1xuICAgICNcbiAgICAjIEBleGFtcGxlIFJlZ2lzdGVyaW5nIGZvciBwdXNoIG5vdGlmaWNhdGlvbnMgdG8gY29uZmlybSByZXF1ZXN0c1xuICAgICMgICBjb25uZWN0aW9uLmV2ZW50TWFuYWdlci5saXN0ZW4oRXZlbnRzLkJPT0tNQVJLU19VUERBVEUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAjICAgICAvLyBSZWNlaXZlIGFjdHVhbCBwdXNoIGNvbmZpcm1hdGlvbiAob3IgYW55IGZ1dHVyZSB1cGRhdGVzKVxuICAgICMgICAgIC8vIGZyb20gTml0cm8gd2hlbiBib29rbWFya3MgYXJlIHNldCBvbiB0aGUgc2VydmVyLlxuICAgICMgICAgfSk7XG4gICAgI1xuICAgICMgQHNlZSBFdmVudHMuQk9PS01BUktTX1VQREFURVxuICAgIHNldEJvb2ttYXJrczogKGNoYXRyb29tcykgLT5cbiAgICAgIHN0YW56YSA9IEBoZWxwZXIuc2V0Qm9va21hcmtzU3RhbnphIGNoYXRyb29tc1xuICAgICAgc2VuZFJlcXVlc3Qgc3RhbnphXG4gICAgXG4gICAgIyBTZW5kIGEgcmVxdWVzdCB2aWEgc2VuZElRIHRvIE5pdHJvIHdpdGggcmV0cnkgYXR0ZW1wdHNcbiAgICAjIEBwcml2YXRlXG4gICAgc2VuZFJlcXVlc3QgPSAtPlxuICAgICAgcmV0cnlSZXF1ZXN0ID0gXy5yZXRyeSBzZW5kU3RvcmFnZUlRLFxuICAgICAgICBtYXg6IFByaXZhdGVTdG9yYWdlLk1BWF9BVFRFTVBUU1xuICAgICAgcmV0cnlSZXF1ZXN0LmFwcGx5IG51bGwsIGFyZ3VtZW50c1xuXG4gICAgc2VuZE1vY2tSZXF1ZXN0ID0gKHN0YW56YSkgLT5cbiAgICAgIGNvbnNvbGUubG9nIHN0YW56YS50b1N0cmluZygpXG5cbiAgICAjIFNlbmQgc3RvcmFnZSByZXF1ZXN0IHZpYSBzZW5kSVFcbiAgICAjIEBwcml2YXRlXG4gICAgI1xuICAgICMgQHBhcmFtIHN0YW56YSBbU3Ryb3BoZS5CdWlsZGVyXSBzdGFuemEgc2VuZCB0byBiZSBzZW50IHdpdGggdGhlIHJlcXVlc3RcbiAgICAjIEBvcHRpb25zIFtPYmplY3RdIG9iamVjdCBvZiBvcHRpb25zXG4gICAgIyBAb3B0aW9uIG9wdGlvbnMgYXR0ZW1wdCBbSW50ZWdlcl0gdGhlIGN1cnJlbnQgYXR0ZW1wdCBudW1iZXIgd2hlbiByZXRyeWluZ1xuICAgICNcbiAgICAjIEByZXR1cm4gW1Byb21pc2VdIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgYnkgc2VuZElRXG4gICAgc2VuZFN0b3JhZ2VJUSA9IChzdGFuemEsIG9wdGlvbnMgPSB7fSkgLT5cbiAgICAgIHttYXh9ID0gb3B0aW9uc1xuICAgICAgY29uc29sZS5sb2cgXCJbU3RvcmFnZV0gc2VuZFByZWZlcmVuY2VzSVEgdmlhIF8ucmV0cnksXG4gICAgICAgIGF0dGVtcHQgI3tvcHRpb25zLmF0dGVtcHR9IG9mICN7UHJpdmF0ZVN0b3JhZ2UuTUFYX0FUVEVNUFRTfVwiXG4gICAgICBOaXRyb1Byb21pc2UgKHJlc29sdmUsIHJlamVjdCkgLT5cbiAgICAgICAgc2VuZElRXG4gICAgICAgICAgZWxlbWVudDogc3RhbnphXG4gICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZVxuICAgICAgICAgIHJlamVjdDogcmVqZWN0XG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcblxuY2xhc3MgQ29uZmlnXG5cbiAgQEVOVl9QUk9EVUNUSU9OID0gJ3Byb2QnXG4gIEBFTlZfQkVUQSA9ICdiZXRhJ1xuICBARU5WX0FMUEhBID0gJ2FscGhhJ1xuICBARU5WX0RFViA9ICdkZXYnXG4gIEBFTlZfRklMRSA9ICdmaWxlJ1xuXG4gIF9wYXJhbXMgPSB7fVxuXG4gICgtPlxuICAgIGlmKCBwYXJhbXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoICkubGVuZ3RoXG4gICAgICBwYXJhbXMgPSBwYXJhbXMuc3Vic3RyKCAxICkgIyBkcm9wID9cbiAgICAgIF8uZWFjaCBwYXJhbXMuc3BsaXQoICcmJyApLCAoIHBhcmFtICkgLT5cbiAgICAgICAgcGFyYW0gPSBwYXJhbS5zcGxpdCAnPSdcbiAgICAgICAgX3BhcmFtc1twYXJhbVswXV0gPSBwYXJhbVsxXVxuICApKClcblxuICBfZGVmYXVsdHMgPVxuICAgICMgc3RyaW5nc1xuICAgIG5hbWU6ICdOaXRybyBYTVBQIENsaWVudCBDb25uZWN0aW9uJ1xuICAgIG5pdHJvUGF0aDogJ25odHRwLWJpbmQnXG5cbiAgX2N1c3RvbSAgID0ge31cbiAgX2NhY2hlZCAgID0ge31cblxuICBnZXQ6IChrZXkpIC0+XG4gICAgIyBmaXJzdCwgZ2V0IHRoZSB2YWx1ZSBmcm9tIHByZWNlZGVuY2UgY2hhaW5cbiAgICB2YWx1ZSA9IF9wYXJhbXNba2V5XSB8fCBfY2FjaGVkW2tleV0gfHwgX2N1c3RvbVtrZXldIHx8IF9kZWZhdWx0c1trZXldXG4gICAgIyBmdW5jdGlvblxuICAgIGlmICggdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlICkgaXMgJ2Z1bmN0aW9uJ1xuICAgICAgcmV0dXJuIF9jYWNoZWRba2V5XSA9IHZhbHVlKClcbiAgICAjIHN0cmluZywgbnVtYmVyLCBvYmplY3QsIGJvb2xlYW4sIGV0Yy5cbiAgICBlbHNlIGlmIHZhbHVlVHlwZSBpc250ICd1bmRlZmluZWQnXG4gICAgICByZXR1cm4gX2NhY2hlZFtrZXldID0gdmFsdWVcbiAgICAjIG51bGxcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbnVsbFxuXG4gIHNldDogKCBrZXksIHZhbHVlICkgLT5cbiAgICBfY3VzdG9tW2tleV0gPSB2YWx1ZVxuXG4gIHJlYWQ6IC0+XG4gICAgXy5lYWNoIF9kZWZhdWx0cywgKCB2YWx1ZSwga2V5ICkgPT4gQGdldCBrZXlcbiAgICBfLmVhY2ggX2N1c3RvbSwgICAoIHZhbHVlLCBrZXkgKSA9PiBAZ2V0IGtleVxuXG4gICAgcmV0dXJuIHRoaXNcblxuICByZXNldDogKGtleSkgLT5cbiAgICAjIHNwZWNpZmljIGtleSByZXNldFxuICAgIGlmIGtleVxuICAgICAgZGVsZXRlIF9jYWNoZWRba2V5XVxuICAgICMgYWxsIGtleXMgcmVzZXRcbiAgICBlbHNlXG4gICAgICBfY2FjaGVkID0ge31cblxuICBhbGw6IC0+XG4gICAgY29uc29sZS5sb2cgJ2N1c3RvbScsIF9jdXN0b21cbiAgICBjb25zb2xlLmxvZyAnY2FjaGVkJywgX2NhY2hlZFxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDb25maWcoKVxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5TaXp6bGUgPSByZXF1aXJlICdzaXp6bGUnXG5RID0gcmVxdWlyZSAncSdcbk5pdHJvUHJvbWlzZSA9IHJlcXVpcmUgJ3V0aWwvcHJvbWlzZSdcblN0cm9waGUgPSByZXF1aXJlICdzdHJvcGhlJ1xuU2hvcnRJRCA9IHJlcXVpcmUgJ3Nob3J0aWQnXG5SYXRlTGltaXRlciA9IHJlcXVpcmUgJ3V0aWwvcmF0ZV9saW1pdGVyJ1xuQ29uZmlnID0gcmVxdWlyZSAnY29uZmlnJ1xuXG4jIENvbXBvbmVudHNcblJvc3RlciA9IHJlcXVpcmUgJ2NvbXBvbmVudHMvcm9zdGVyJ1xuU3RvcmFnZSA9IHJlcXVpcmUgJ2NvbXBvbmVudHMvc3RvcmFnZSdcbkJsb2NrbGlzdCA9IHJlcXVpcmUgJ2NvbXBvbmVudHMvYmxvY2tsaXN0J1xuTVVDID0gcmVxdWlyZSAnY29tcG9uZW50cy9tdWMnXG5NZXNzYWdpbmcgPSByZXF1aXJlICdjb21wb25lbnRzL21lc3NhZ2luZydcbkdhdGV3YXkgPSByZXF1aXJlICdjb21wb25lbnRzL2dhdGV3YXknXG5HYXRld2F5TmFtZSA9IHJlcXVpcmUgJ2VudW0vZ2F0ZXdheXMnXG5cbiMgRXZlbnRzXG5FdmVudE1hbmFnZXIgPSByZXF1aXJlICdldmVudHMvZXZlbnRfbWFuYWdlcidcbkV2ZW50SGFuZGxlciA9IHJlcXVpcmUgJ2V2ZW50cy9ldmVudF9oYW5kbGVyJ1xuRXZlbnRzID0gcmVxdWlyZSAnZXZlbnRzL2V2ZW50cydcbklPRXZlbnQgPSByZXF1aXJlICdldmVudHMvaW9fZXZlbnQnXG5cbiMgQ29uc3RhbnRzXG5TdGF0dXMgPSByZXF1aXJlICdlbnVtL3N0YXR1cydcblhNUFBQcmVzZW5jZSA9IHJlcXVpcmUgJ2VudW0veG1wcF9wcmVzZW5jZSdcblN0YXR1c0xhYmVscyA9IHJlcXVpcmUgJ2VudW0vc3RhdHVzX2xhYmVscydcblxuIyBTdHJvcGhlIGhlbHBlcnNcbnN0cm9waGVQcmVzZW5jZSA9IHJlcXVpcmUgJ3N0cm9waGUvc3Ryb3BoZV9wcmVzZW5jZSdcbnN0cm9waGVZYWhvb0dhdGV3YXkgPSByZXF1aXJlICdzdHJvcGhlL3N0cm9waGVfeWFob29fZ2F0ZXdheSdcbnN0cm9waGVEaXNjbyA9IHJlcXVpcmUgJ3N0cm9waGUvc3Ryb3BoZV9kaXNjbydcblN0cm9waGVJTyA9IHJlcXVpcmUgJ3N0cm9waGUvc3Ryb3BoZV9pbydcblxuIyBVdGlsc1xuZGF0YVBheWxvYWQgPSByZXF1aXJlICdhZGFwdGVycy9kYXRhX3BheWxvYWQnXG5YTVBQVXRpbHMgPSByZXF1aXJlICd1dGlsL3htcHBfdXRpbHMnXG5cbiMgVGhpcyBjbGFzcyBoYXMgdmlydHVhbCBtZXRob2RzLCB0aGF0IGFyZSBhdmFpbGFibGUgb24gdGhlIHNpbmdsZXRvbiBpbnN0YW5jZVxuIyByZXR1cm5lZCBieSB0aGUgc3RhdGljICNnZXQoKSBtZXRob2QuXG4jXG4jIEBtZXRob2QgI2dldEFwcE5hbWUoKVxuIyAgIEdldHRlciBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgYXBwbGljYXRpb24gbmFtZVxuIyAgIEByZXR1cm4gW1N0cmluZ10gVGhlIG5hbWUgb2YgdGhlIGFwcGxpY2F0aW9uIHVzaW5nIHRoaXNcbiMgICAgIGNvbm5lY3Rpb24gb2JqZWN0XG4jXG4jIEBtZXRob2QgI2dldEFwcFZlcnNpb24oKVxuIyAgIEdldHRlciBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgYXBwbGljYXRpb24gdmVyc2lvbiNcbiMgICBAcmV0dXJuIFtTdHJpbmddIFRoZSB2ZXJzaW9uIG9mIHRoZSBhcHBsaWNhdGlvbiB1c2luZyB0aGlzXG4jICAgICBjb25uZWN0aW9uIG9iamVjdFxuI1xuIyBAbWV0aG9kICNnZXRTZXJ2aWNlKClcbiMgICBHZXR0ZXIgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHNlcnZpY2UgdG8gY29ubmVjdCB0byBvbiBOaXRyb1xuIyAgIEBleGFtcGxlXG4jICAgICAnbmh0dHAtYmluZCdcbiMgICBAcmV0dXJuIFtTdHJpbmddIFRoZSB2ZXJzaW9uIG9mIHRoZSBzZXJ2aWNlIHRvIGNvbm5lY3QgdG9cbiNcbiMgQG1ldGhvZCAjZ2V0Q29tcG9uZW50KG5hbWUgPSAnJylcbiMgICBHZXR0ZXIgZm9yIGNvbXBvbmVudHMgb3duZWQgYnkgdGhlIGNvbm5lY3Rpb24gaW5zdGFuY2UuXG4jICAgQGV4YW1wbGVcbiMgICAgIE5pdHJvLmdldENvbm5lY3Rpb24oKS5nZXRDb21wb25lbnQoTml0cm8uUk9TVEVSKTtcbiMgICBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgcmVxdWVzdGVkIGNvbXBvbmVudFxuIyAgIEBwYXJhbSBbU3RyaW5nXSBuYW1lIG9mIGNvbXBvbmVudCB0b1xuIyAgIEByZXR1cm4gW09iamVjdF0gQVBJIGNvbXBvbmVudCB0aHJvd3MgZXJyb3IgaWYgbm90IGZvdW5kXG4jXG4jIEBtZXRob2QgI2Nvbm5lY3Qob3B0aW9ucyA9IHt9KVxuIyAgIENvbm5lY3QgdG8gWE1QUCBieSBjYWxsaW5nIHRoZSBTdHJvcGhlIGNvbm5lY3QgbWV0aG9kLCBwYXNzaW5nIHVzZXJcbiMgICBjcmVkZW50aWFscyBhbmQgYSBjYWxsYmFjayBmb3Igc3RhdHVzIHVwZGF0ZXMuXG4jICAgQHBhcmFtIG9wdGlvbnMgW09iamVjdF0gYW4gb2JqZWN0IG9mIG9wdGlvbnNcbiMgICBAb3B0aW9uIG9wdGlvbnMgamlkIFtTdHJpbmddIGEgdW5pcXVlIGppZCBmb3IgdGhlIHVzZXJcbiMgICBAb3B0aW9uIG9wdGlvbnMgcGFzc3dvcmQgW1N0cmluZ10gdGhlIHVzZXIncyBwYXNzd29yZFxuIyAgIEBvcHRpb24gb3B0aW9ucyBjYWxsYmFjayBbRnVuY3Rpb25dIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgYW4gYXBwbGljYXRpb25cbiMgICAgIGNhbiBwYXNzIGluIHRvIGJlIG5vdGlmaWVkIG9mIGNvbm5lY3Rpb24gc3RhdHVzIGNoYW5nZXNcbiMgICBAcmV0dXJuIFtQcm9taXNlXSBwcm9taXNlIG9iamVjdCBvZiB0aGUgZGVmZXJyZWQgdXNlZCB0byBhdHRlbXB0IHRoZSBjb25uZWN0aW9uXG4jXG4jIEBtZXRob2QgI2Rpc2Nvbm5lY3QocmVhc29uKVxuIyAgIERpc2Nvbm5lY3QgZnJvbSBYTVBQIGJ5IGNhbGxpbmcgdGhlIFN0cm9waGUgZGlzY29ubmVjdCBtZXRob2RcbiMgICBAcGFyYW0gb3B0aW9ucyBbT2JqZWN0XSBhbiBvYmplY3Qgb2Ygb3B0aW9uc1xuIyAgIEBvcHRpb24gb3B0aW9ucyBub1JlY29ubmVjdCBbQm9vbGVhbl0gaW5kaWNhdGVzIHRoYXQgd2Ugc2hvdWxkIG5vdCBhdHRlbXB0XG4jICAgICB0byByZWNvbm5lY3QgYWZ0ZXIgZGlzY29ubmVjdGluZ1xuIyAgIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2Ugb2JqZWN0IG9mIHRoZSBkZWZlcnJlZCB1c2VkIHRvIGRpc2Nvbm5lY3RcbiNcbiMgQG1ldGhvZCAjZ2V0U2VydmljZSgpXG4jICAgR2V0dGVyIGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSBzZXJ2aWNlIHRvIGNvbm5lY3QgdG8gb24gTml0cm9cbiMgICBAZXhhbXBsZSAnbmh0dHAtYmluZCdcbiMgICBAcmV0dXJuIFtTdHJpbmddIFRoZSB2ZXJzaW9uIG9mIHRoZSBhcHBsaWNhdGlvbiB1c2luZyB0aGlzXG4jICAgICBjb25uZWN0aW9uIG9iamVjdFxuI1xuIyBAbWV0aG9kICNzdGF0dXMoKVxuIyAgIEdldHRlciBtZXRob2QgZm9yIHRoZSBTdHJvcGhlIGNvbm5lY3Rpb24gc3RhdHVzXG4jICAgQHJldHVybiBbU3RyaW5nXSBvbmUgb2YgU3Ryb3BoZSdzIHN0YXR1cyBzdHJpbmdzIGZvciAnY29ubmVjdGluZycsXG4jICAgICAnYXV0aGVudGljYXRpbmcnLCAnZGlzY29ubmVjdGVkJywgZXRjLlxuIyAgIEBzZWUgaHR0cDovL3N0cm9waGUuaW0vc3Ryb3BoZWpzL2RvYy8xLjAuMi9pbmRleC9Db25zdGFudHMuaHRtbFxuXG4jIEF0dGFjaCBDb25uZWN0aW9uIHRvIHRoZSB3aW5kb3cgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUgdG8gcHJlc2VydmUgQ09ETy5cbm1vZHVsZS5leHBvcnRzID0gd2luZG93LkNvbm5lY3Rpb24gPSBjbGFzcyBDb25uZWN0aW9uXG4jIG1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ29ubmVjdGlvblxuXG4gICMgQHByb3BlcnR5IFtTdHJpbmddIGxpYnJhcnkgdmVyc2lvblxuICBAdmVyc2lvbjogJzAuMC4xJ1xuXG4gICMgQHByb3BlcnR5IFtTdHJpbmddIHN0YXRpYyB0ZXN0IGtleSB1c2VkIGZvciB1bml0IHRlc3Rpbmcgb25seVxuICBAVEVTVF9LRVk6IFwiQ29ubmVjdGlvbi5URVNUX0tFWVwiXG5cbiAgIyBAcHJvcGVydHkgW051bWJlcl0gc3RhdGljIHN0YXR1cyBwcm9wZXJ0eSwgdmFsdWUgaXMgOFxuICBARkFUQUxfRkFJTFVSRTogU3RhdHVzLkZBVEFMX0ZBSUxVUkVcblxuICAjIEBwcm9wZXJ0eSBbT2JqZWN0XSBhbGlhcyB0byB0aGUgWE1QUFByZXNlbmNlIG9iamVjdCB3aXRoIGVudW1zXG4gIEBYTVBQUHJlc2VuY2U6IFhNUFBQcmVzZW5jZVxuXG4gICMgQHByb3BlcnR5IFtPYmplY3RdIGFsaWFzIHRvIHRoZSBFdmVudHMgY2xhc3NcbiAgQEV2ZW50czogRXZlbnRzXG5cbiAgIyBAcHJvcGVydHkgcHJpdmF0ZSBpbnN0YW5jZSBvZiBQcml2YXRlQ29ubmVjdGlvblxuICAjIEBwcml2YXRlXG4gIGluc3RhbmNlID0gbnVsbFxuXG4gICMgUmV0cmlldmUgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIFByaXZhdGVDb25uZWN0aW9uIGNsYXNzXG4gICNcbiAgIyBAcGFyYW0gb3B0aW9ucyBbT2JqZWN0XSBhbiBvYmplY3Qgb2YgbWFuZGF0b3J5IG9wdGlvbnNcbiAgIyBAb3B0aW9uIG9wdGlvbnMgYXBwTmFtZSBbU3RyaW5nXSBUaGUgbmFtZSBvZiB0aGUgYXBwbGljYXRpb24gdXNpbmcgdGhpc1xuICAjICAgY29ubmVjdGlvbiBvYmplY3QgLSByZXF1aXJlZFxuICAjIEBvcHRpb24gb3B0aW9ucyBhcHBWZXJzaW9uIFtTdHJpbmddIFRoZSB2ZXJzaW9uIG9mIHRoZSBhcHBsaWNhdGlvbiB1c2luZ1xuICAjICAgdGhpcyBjb25uZWN0aW9uIG9iamVjdCAtIHJlcXVpcmVkXG4gICNcbiAgIyBAcmV0dXJuIFtQcml2YXRlQ29ubmVjdGlvbl0gc2luZ2xldG9uIGluc3RhbmNlXG4gIEBnZXQ6IChvcHRpb25zID0ge30pIC0+XG4gICAge2FwcE5hbWUsIGFwcFZlcnNpb24sIHNlcnZpY2V9ID0gb3B0aW9uc1xuXG4gICAgY3JlYXRlSW5zdGFuY2UgPSAtPlxuICAgICAgIyBFbnN1cmUgdGhhdCBhbiBhcHBsaWNhdGlvbiBuYW1lIGFuZCBhcHBsaWNhdGlvbiB2ZXJzaW9uIGFyZSBwcm92aWRlZC5cbiAgICAgIGlmIG5vdCBhcHBOYW1lXG4gICAgICAgIHRocm93IG5ldyBFcnJvciBcIllvdSBtdXN0IHByb3ZpZGUgYW4gYXBwbGljYXRpb24gbmFtZS5cIlxuICAgICAgaWYgbm90IGFwcFZlcnNpb25cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yIFwiWW91IG11c3QgcHJvdmlkZSBhbiBhcHBsaWNhdGlvbiB2ZXJzaW9uIG5hbWUuXCJcblxuICAgICAgbmV3IFByaXZhdGVDb25uZWN0aW9uIG9wdGlvbnNcblxuICAgIGluc3RhbmNlID89IGNyZWF0ZUluc3RhbmNlKClcblxuICAjIERlc3Ryb3kgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSwgb25seSBmb3IgdW5pdCB0ZXN0aW5nXG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSB0cnVlIGlmIHRoZSBzaW5nbGV0b24gd2FzIGRlc3Ryb3llZCwgb3RoZXJ3aXNlIGZhbHNlXG4gIEBkZXN0cm95OiAtPlxuICAgIGlmIGluc3RhbmNlPy5nZXRBcHBOYW1lKCkgaXMgQFRFU1RfS0VZXG4gICAgICBpbnN0YW5jZSA9IG51bGxcbiAgICAgIHRydWVcbiAgICBlbHNlXG4gICAgICBmYWxzZVxuXG4gIGNsYXNzIFByaXZhdGVDb25uZWN0aW9uXG5cbiAgICAjIEBwcm9wZXJ0eSBbRXZlbnRNYW5hZ2VyXSBpbnN0YW5jZSBvZiB0aGUgRXZlbnRNYW5hZ2VyIGNsYXNzXG4gICAgZXZlbnRNYW5hZ2VyOiBudWxsXG5cbiAgICAjIEBwcm9wZXJ0eSBbU3Ryb3BoZS5Db25uZWN0aW9uXSBhIFN0cm9waGUgQ29ubmVjdGlvbiBpbnN0YW5jZVxuICAgICMgQHByaXZhdGVcbiAgICBfY29ubmVjdGlvbjogbnVsbFxuXG4gICAgIyBAcHJvcGVydHkgW1N0cmluZ10gVGhlIG5hbWUgb2YgdGhlIGFwcGxpY2F0aW9uIHVzaW5nIHRoaXNcbiAgICAjICAgY29ubmVjdGlvbiBvYmplY3RcbiAgICAjIEBwcml2YXRlXG4gICAgX2FwcE5hbWU6ICcnXG5cbiAgICAjIEBwcm9wZXJ0eSBbU3RyaW5nXSBUaGUgdmVyc2lvbiBvZiB0aGUgYXBwbGljYXRpb24gdXNpbmdcbiAgICAjICAgdGhpcyBjb25uZWN0aW9uIG9iamVjdFxuICAgICMgQHByaXZhdGVcbiAgICBfYXBwVmVyc2lvbjogJydcblxuICAgICMgQHByb3BlcnR5IFtTdHJpbmddIFRoZSBzZXJ2aWNlIHRvIGJlIGNhbGxlZCBvbiB0aGUgWE1QUCBzZXJ2ZXIsIHBhc3NlZFxuICAgICMgICB0byB0aGUgU3Ryb3BoZS5Db25uZWN0aW9uLlxuICAgICMgICBEZWZhdWx0cyB0byBDb25uZWN0aW9uLlNFUlZJQ0VfTkhUVFBfQklORCAoXCJuaHR0cC1iaW5kXCIpXG4gICAgIyBAcHJpdmF0ZVxuICAgIF9zZXJ2aWNlOiAnJ1xuXG4gICAgIyBAcHJvcGVydHkgW1N0cmluZ10gdXNlciBwYXNzd29yZCBmb3IgY29ubmVjdGluZyB0byB0aGUgWE1QUCBzZXJ2ZXJcbiAgICAjIEBwcml2YXRlXG4gICAgX3Bhc3N3b3JkOiBudWxsXG5cbiAgICAjIEBwcm9wZXJ0eSBbRGVmZXJyZWRdIGtlZXBzIHRyYWNrIG9mIGNvbm5lY3RpbmcgdG8gdGhlIHNlcnZlclxuICAgICMgQHByaXZhdGVcbiAgICBfY29ubmVjdGlvbkRmZDogbnVsbFxuXG4gICAgIyBAcHJvcGVydHkgW1N0cmluZ10gU3Ryb3BoZSBjb25uZWN0aW9uIHN0YXR1cywgZGVmYXVsdHMgdG9cbiAgICAjICAgU3Ryb3BoZS5TdGF0dXMuRElTQ09OTkVDVEVEXG4gICAgIyBAcHJpdmF0ZVxuICAgIF9jb25uZWN0aW9uU3RhdHVzOiBTdGF0dXMuRElTQ09OTkVDVEVEXG5cbiAgICAjIEBwcm9wZXJ0eSBbTWVzc2FnaW5nXSBJbnN0YW5jZSBvZiBNZXNzYWdpbmcgZm9yIHNlbmRpbmcgbWVzc2FnZXNcbiAgICAjIEBwcml2YXRlXG4gICAgX21lc3NhZ2luZzogbnVsbFxuXG4gICAgIyBAcHJvcGVydHkgW1Jvc3Rlcl0gSW5zdGFuY2Ugb2YgUm9zdGVyIGZvciBtYW5hZ2luZyB0aGUgdXNlcidzIHJvc3RlclxuICAgICMgQHByaXZhdGVcbiAgICBfcm9zdGVyOiBudWxsXG5cbiAgICAjIEBwcm9wZXJ0eSBbU3RvcmFnZV0gSW5zdGFuY2Ugb2YgU3RvcmFnZSBmb3IgbWFuYWdpbmcgdGhlIGJvb2ttYXJzXG4gICAgIyAgIGFuZCB1c2VyIHByZWZlcmVuY2VzXG4gICAgIyBAcHJpdmF0ZVxuICAgIF9zdG9yYWdlOiBudWxsXG5cbiAgICAjIEBwcm9wZXJ0eSBbQmxvY2tsaXN0XSBJbnN0YW5jZSBvZiBCbG9ja2xpc3QgZm9yIG1hbmFnaW5nIHVzZXIncyBibG9ja2xpc3RcbiAgICAjIEBwcml2YXRlXG4gICAgX2Jsb2NrbGlzdDogbnVsbFxuXG4gICAgIyBAcHJvcGVydHkgW01VQ10gSW5zdGFuY2Ugb2YgTVVDIGZvciBtYW5hZ2luZyBNVUNzIChncm91cGNoYXRzKVxuICAgICMgQHByaXZhdGVcbiAgICBfbXVjOiBudWxsXG5cbiAgICAjIEBwcm9wZXJ0eSBbR2F0ZXdheV0gSW5zdGFuY2Ugb2YgWWFob28gR2F0ZXdheVxuICAgICMgQHByaXZhdGVcbiAgICBfeWFob286IG51bGxcblxuICAgICMgQHByb3BlcnR5IFtSYXRlTGltaXRlcl0gcmF0ZSBsaW1pdGVkIGNvbm5lY3Rpb24gbWFuYWdlciBmb3IgY29ubmVjdGluZyB0byBOaXRyb1xuICAgIF9jb25uZWN0VG9TZXJ2ZXI6IG51bGxcblxuICAgICMgQHByb3BlcnR5IFtTdHJpbmddIHRlbXBvcmFyeSB1c2VyLXN1Ym1pdHRlZCBqaWQgZm9yIGNvbm5lY3RpbmcgdG9cbiAgICAjICAgdGhlIFhNUFAgc2VydmVyXG4gICAgIyBAcHJpdmF0ZVxuICAgIF90ZW1wSklEOiBudWxsXG5cbiAgICAjIEBwcm9wZXJ0eSBbQXJyYXk8U3RyaW5nPl0gYXJyYXkgb2YgdmFsaWQgc3RhdHVzIGNvZGVzXG4gICAgX3N0YXR1c2VzOiBbXG4gICAgICBTdGF0dXMuQ09OTkVDVElOR1xuICAgICAgU3RhdHVzLkNPTk5GQUlMXG4gICAgICBTdGF0dXMuQ09OTlRJTUVPVVRcbiAgICAgIFN0YXR1cy5BVVRIRU5USUNBVElOR1xuICAgICAgU3RhdHVzLkFVVEhGQUlMXG4gICAgICBTdGF0dXMuQ09OTkVDVEVEXG4gICAgICBTdGF0dXMuRElTQ09OTkVDVEVEXG4gICAgICBTdGF0dXMuRElTQ09OTkVDVElOR1xuICAgICAgU3RhdHVzLkZBVEFMX0ZBSUxVUkVcbiAgICBdXG5cbiAgICAjIEBwcm9wZXJ0eSBbT2JqZWN0XSBoYXNoIG9mIGNvbXBvbmVudCBuYW1lcy9pbnN0YW5jZXNcbiAgICBfY29tcG9uZW50czoge31cbiAgICAjIEBwYXJhbSBbQXJyYXldIHN1Yi1jb21wb25lbnRzIHdobyBpbXBsbWVudCBhICd0b2dnbGVDb25uZWN0aW9uJyBtZXRob2RcbiAgICAjICAgYW5kIG5lZWQgdG8gYmUgbm90aWZpZWQgb2YgYSBib29sZWFuIGNvbm5lY3RlZCBzdGF0dXMgY2hhbmdlXG4gICAgX2Nvbm5lY3Rpb25Ub2dnbGVTdWJzOiBudWxsXG5cbiAgICAjIENvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBQcml2YXRlQ29ubmVjdGlvblxuICAgICNcbiAgICAjIEBwYXJhbSBvcHRpb25zIFtPYmplY3RdIGFuIG9iamVjdCBvZiBvcHRpb25zXG4gICAgIyBAb3B0aW9uIG9wdGlvbnMgYXBwTmFtZSBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgYXBwbGljYXRpb24gdXNpbmcgdGhpc1xuICAgICMgICBjb25uZWN0aW9uIG9iamVjdFxuICAgICMgQG9wdGlvbiBvcHRpb25zIGFwcFZlcnNpb24gW1N0cmluZ10gdGhlIHZlcnNpb24gb2YgdGhlIGFwcGxpY2F0aW9uIHVzaW5nXG4gICAgIyAgIHRoaXMgY29ubmVjdGlvbiBvYmplY3RcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtQcml2YXRlQ29ubmVjdGlvbl1cbiAgICBjb25zdHJ1Y3RvcjogKG9wdGlvbnMgPSB7fSkgLT5cbiAgICAgIHthcHBOYW1lLCBhcHBWZXJzaW9uLCBzZXJ2aWNlfSA9IF8uZGVmYXVsdHMgb3B0aW9ucyxcbiAgICAgICAgc2VydmljZTogQ29uZmlnLmdldCAnbml0cm9QYXRoJ1xuXG4gICAgICBAX2FwcE5hbWUgPSBhcHBOYW1lXG4gICAgICBAX2FwcFZlcnNpb24gPSBhcHBWZXJzaW9uXG4gICAgICBAX3NlcnZpY2UgPSBub3JtYWxpemVTZXJ2aWNlIHNlcnZpY2VcblxuICAgICAgIyBJbnN0YW50aWF0ZSBhIG5ldyBTdHJvcGhlIENvbm5lY3Rpb24uXG4gICAgICBAX2Nvbm5lY3Rpb24gPSBuZXcgU3Ryb3BoZS5Db25uZWN0aW9uIEBfc2VydmljZSxcbiAgICAgICAgY3VzdG9tSGVhZGVyczpcbiAgICAgICAgICAnQ2xpZW50LVJldmlzaW9uJzogb3B0aW9ucy5jbGllbnRSZXZpc2lvblxuXG4gICAgICAjIFNldHVwIGluamVjdGlvbiBvZiBtdWx0aXBsZSBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHJhdyBhbmQgWE1MIElPIGV2ZW50cy5cbiAgICAgIFN0cm9waGVJTy5jb25uZWN0SU9MaXN0ZW5lcnNcbiAgICAgICAgY29ubmVjdGlvbjogQF9jb25uZWN0aW9uXG4gICAgICAgIGdldFJhd0lucHV0TGlzdGVuZXJzOiAtPiBTdHJvcGhlSU8ucmF3SW5wdXRMaXN0ZW5lcnNcbiAgICAgICAgZ2V0UmF3T3V0cHV0TGlzdGVuZXJzOiAtPiBTdHJvcGhlSU8ucmF3T3V0cHV0TGlzdGVuZXJzXG4gICAgICAgIGdldFhNTElucHV0TGlzdGVuZXJzOiAtPiBTdHJvcGhlSU8ueG1sSW5wdXRMaXN0ZW5lcnNcbiAgICAgICAgZ2V0WE1MT3V0cHV0TGlzdGVuZXJzOiAtPiBTdHJvcGhlSU8ueG1sT3V0cHV0TGlzdGVuZXJzXG5cbiAgICAgICMgQmluZCB0aGVzZSBtZXRob2RzIHRvIGJlZm9yZSBpbmplY3RpbmcgdGhlbSBpbnRvIGRlcGVuZGVuY2llc1xuICAgICAgYm91bmRTZW5kID0gXy5iaW5kIHNlbmQsIHRoaXNcbiAgICAgIGJvdW5kU2VuZElRID0gXy5iaW5kIHNlbmRJUSwgdGhpc1xuICAgICAgYm91bmRBZGRIYW5kbGVyID0gXy5iaW5kIEBfY29ubmVjdGlvbi5hZGRIYW5kbGVyLCBAX2Nvbm5lY3Rpb25cbiAgICAgIGJvdW5kRGVsZXRlSGFuZGxlciA9IF8uYmluZCBAX2Nvbm5lY3Rpb24uZGVsZXRlSGFuZGxlciwgQF9jb25uZWN0aW9uXG5cbiAgICAgICMgRXZlbnRzTWFuYWdlclxuICAgICAgQGV2ZW50TWFuYWdlciA9IEV2ZW50TWFuYWdlci5nZXRcbiAgICAgICAgYWRkSGFuZGxlcjogYm91bmRBZGRIYW5kbGVyXG4gICAgICAgIGRlbGV0ZUhhbmRsZXI6IGJvdW5kRGVsZXRlSGFuZGxlclxuICAgICAgICBjb25maWc6IEV2ZW50cy5nZXRDb25maWcoKVxuICAgICAgICBoYW5kbGVyQ2xhc3M6IEV2ZW50SGFuZGxlclxuXG4gICAgICAjIENyZWF0ZSBhIHJhdGUgbGltaXRlZCBjb25uZWN0b3Igb2JqZWN0IHRvIG1hbmFnZSBhbGwgY29ubmVjdGluZ1xuICAgICAgIyBhbmQgcmVjb25uZWN0aW5nLlxuICAgICAgQF9jb25uZWN0VG9TZXJ2ZXIgPSBjcmVhdGVDb25uZWN0b3JcbiAgICAgICAgZnVuYzogQF9jb25uZWN0aW9uLmNvbm5lY3RcbiAgICAgICAgY29udGV4dDogQF9jb25uZWN0aW9uXG5cbiAgICAgIGNyZWF0ZUNvbXBvbmVudHMuY2FsbCB0aGlzLFxuICAgICAgICBjb21wb25lbnRzOiBAX2NvbXBvbmVudHNcbiAgICAgICAgc2VuZDogYm91bmRTZW5kXG4gICAgICAgIHNlbmRJUTogYm91bmRTZW5kSVFcblxuICAgICAgIyBBZGQgc3ViLWNvbXBvbmVudHMgdG8gYmUgbm90aWZpZWQgb2YgQ09OTkVDVEVEIG9yIERJU0NPTk5FQ1RFRCBzdGF0dXNcbiAgICAgIEBfY29ubmVjdGlvblRvZ2dsZVN1YnMgPSBbQGV2ZW50TWFuYWdlciwgQF95YWhvb11cblxuICAgIG5vcm1hbGl6ZVNlcnZpY2UgPSAoc2VydmljZSkgLT5cbiAgICAgIGlmIF8uaXNTdHJpbmcgc2VydmljZVxuICAgICAgICAjIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gICAgICAgIHVubGVzcyAvXlxcLy8udGVzdCBzZXJ2aWNlXG4gICAgICAgICAgc2VydmljZSA9IFwiLyN7c2VydmljZX1cIlxuICAgICAgICAjIGVuc3VyZSB0cmFpbGluZyBzbGFzaFxuICAgICAgICB1bmxlc3MgL1xcLyQvLnRlc3Qgc2VydmljZVxuICAgICAgICAgIHNlcnZpY2UgPSBcIiN7c2VydmljZX0vXCJcbiAgICAgICAgIyBkb25lXG4gICAgICAgIHNlcnZpY2VcbiAgICAgIGVsc2VcbiAgICAgICAgQ29uZmlnLmdldCgnbml0cm9QYXRoJylcblxuICAgIGNyZWF0ZUNvbXBvbmVudHMgPSAoe2NvbXBvbmVudHMsIHNlbmQsIHNlbmRJUX0pIC0+XG4gICAgICBAX3Jvc3RlciA9IHJlZ2lzdGVyQ29tcG9uZW50IGNvbXBvbmVudHMsIFJvc3Rlci5OQU1FLFxuICAgICAgICBSb3N0ZXIuZ2V0IHNlbmQ6IHNlbmQsIHNlbmRJUTogc2VuZElRXG5cbiAgICAgIEBfbXVjID0gcmVnaXN0ZXJDb21wb25lbnQgY29tcG9uZW50cywgTVVDLk5BTUUsIE1VQy5nZXRcbiAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICBzZW5kSVE6IHNlbmRJUVxuICAgICAgICBzdGF0dXM6IEBzdGF0dXMuYmluZCB0aGlzXG4gICAgICAgIGdldEpJRDogQGdldEpJRC5iaW5kIHRoaXNcbiAgICAgICAgZXZlbnRNYW5hZ2VyOiBAZXZlbnRNYW5hZ2VyXG5cbiAgICAgIEBfc3RvcmFnZSA9IHJlZ2lzdGVyQ29tcG9uZW50IEBfY29tcG9uZW50cywgU3RvcmFnZS5OQU1FLFxuICAgICAgICBTdG9yYWdlLmdldCBzZW5kSVE6IHNlbmRJUVxuXG4gICAgICBAX2Jsb2NrbGlzdCA9IHJlZ2lzdGVyQ29tcG9uZW50IGNvbXBvbmVudHMsIEJsb2NrbGlzdC5OQU1FLFxuICAgICAgICBCbG9ja2xpc3QuZ2V0IHNlbmRJUTogc2VuZElRXG5cbiAgICAgIEBfbWVzc2FnaW5nID0gcmVnaXN0ZXJDb21wb25lbnQgY29tcG9uZW50cywgTWVzc2FnaW5nLk5BTUUsXG4gICAgICAgIE1lc3NhZ2luZy5nZXQgc2VuZDogc2VuZCwgc2VuZElROiBzZW5kSVFcblxuICAgICAgeWFob29PcHRzID1cbiAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICBzZW5kSVE6IHNlbmRJUVxuICAgICAgICBoZWxwZXI6IHN0cm9waGVZYWhvb0dhdGV3YXlcblxuICAgICAgQF95YWhvbyA9IHJlZ2lzdGVyQ29tcG9uZW50IGNvbXBvbmVudHMsIEdhdGV3YXlOYW1lLllBSE9PLFxuICAgICAgICBuZXcgR2F0ZXdheSB5YWhvb09wdHNcblxuICAgIGdldENvbXBvbmVudHM6IC0+XG4gICAgICBAX2NvbXBvbmVudHNcblxuICAgICMgR2V0IGNvbmZpZyB2YWx1ZSBmb3Iga2V5XG4gICAgIyBAcGFyYW0ga2V5IFtTdHJpbmddIEtleSB0byBmaW5kXG4gICAgIyBAcmV0dXJuIFtTdHJpbmcsT2JqZWN0XSBWYWx1ZSBmb3Iga2V5IChvciBudWxsKVxuICAgIGdldENvbmZpZ1ZhbHVlOiAoa2V5KSAtPlxuICAgICAgQ29uZmlnLmdldCBrZXlcblxuICAgICMgR2V0dGVyIG1ldGhvZCBmb3IgcmV0cmlldmluZyB0aGUgYXBwbGljYXRpb24gbmFtZVxuICAgICNcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gVGhlIG5hbWUgb2YgdGhlIGFwcGxpY2F0aW9uIHVzaW5nIHRoaXNcbiAgICAjICAgY29ubmVjdGlvbiBvYmplY3RcbiAgICBnZXRBcHBOYW1lOiAtPlxuICAgICAgQF9hcHBOYW1lXG5cbiAgICAjIEdldHRlciBtZXRob2QgZm9yIHJldHJpZXZpbmcgdGhlIGFwcGxpY2F0aW9uIHZlcnNpb25cbiAgICAjXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIFRoZSB2ZXJzaW9uIG9mIHRoZSBhcHBsaWNhdGlvbiB1c2luZyB0aGlzXG4gICAgIyAgIGNvbm5lY3Rpb24gb2JqZWN0XG4gICAgZ2V0QXBwVmVyc2lvbjogLT5cbiAgICAgIEBfYXBwVmVyc2lvblxuXG4gICAgIyBHZXR0ZXIgbWV0aG9kIGZvciByZXRyaWV2aW5nIHRoZSBzZXJ2aWNlIHRvIGNvbm5lY3QgdG8gb24gTml0cm9cbiAgICAjXG4gICAgIyBAZXhhbXBsZVxuICAgICMgICAnbmh0dHAtYmluZCdcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIFRoZSB2ZXJzaW9uIG9mIHRoZSBzZXJ2aWNlIHRvIGNvbm5lY3QgdG9cbiAgICBnZXRTZXJ2aWNlOiAtPlxuICAgICAgQF9zZXJ2aWNlXG5cbiAgICAjIEdldHRlciBtZXRob2QgZm9yIHJldHJpZXZpbmcgdGhlIHNlcnZlci1kZWZpbmVkIGppZFxuICAgICNcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gamlkIGZyb20gdGhlIHNlcnZlciB2aWEgdGhlIFN0cm9waGUuQ29ubmVjdGlvbiBvYmplY3QuXG4gICAgZ2V0SklEOiAtPlxuICAgICAgQF9jb25uZWN0aW9uLmppZFxuXG4gICAgIyBHZXR0ZXIgZm9yIGEgc3BlY2lmaWMgY29tcG9uZW50IGluc3RhbmNlIG93bmVkIGJ5IHRoaXMgY29ubmVjdGlvbiBpbnN0YW5jZVxuICAgICNcbiAgICAjIEBleGFtcGxlXG4gICAgIyAgIC8vIHJldHVybnMgUHJpdmF0ZVJvc3RlciBpbnN0YW5jZVxuICAgICMgICBOaXRyby5nZXRDb25uZWN0aW9uKCkuZ2V0Q29tcG9uZW50KE5pdHJvLlJPU1RFUik7XG4gICAgI1xuICAgICMgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIHJlcXVlc3RlZCBjb21wb25lbnRcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtPYmplY3RdIEFQSSBjb21wb25lbnQgaW5zdGFuY2Ugb3IgdGhyb3dzIGVycm9yIGlmIG5vdCBmb3VuZFxuICAgIGdldENvbXBvbmVudDogKG5hbWUgPSAnJykgLT5cbiAgICAgIGNvbXBvbmVudHMgPSBAZ2V0Q29tcG9uZW50cygpXG4gICAgICBjb21wb25lbnRzP1tuYW1lXSBvciB0aHJvdyBuZXcgRXJyb3IgXCJDb21wb25lbnQgJyN7bmFtZX0nIGRvZXMgbm90IGV4aXN0LlwiXG5cbiAgICAjIFJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgU3Ryb3BoZSBjb25uZWN0aW9uLlxuICAgICNcbiAgICAjIEBwYXJhbSBvcHRpb25zIFtPYmplY3RdIEFuIG9iamVjdCBvZiBvcHRpb25zLlxuICAgICMgI29wdGlvbiBvcHRpb25zIGxpc3RlbmVyIFtGdW5jdGlvbiwgQXJyYXk8RnVuY3Rpb24+XSBUaGUgY2FsbGJhY2socykgdG8gYWRkLlxuICAgICMgI29wdGlvbiBvcHRpb25zIHR5cGUgW1N0cmluZ10gVGhlIGVudW0gdHlwZSwgZS5nLiBYTUwsIFJBVyAoZGVmYXVsdCkuXG4gICAgIyAjb3B0aW9uIG9wdGlvbnMgaW9UeXBlIFtTdHJpbmddIFRoZSBlbnVtIGV2ZW50IHR5cGUsIGUuZy4gSU5QVVQsIE9VVFBVVCxcbiAgICAjICAgYm90aCAoZGVmYXVsdCkuXG4gICAgI1xuICAgICMgQHJldHVybiBbRnVuY3Rpb25dIEEgcmVtb3ZlIGZ1bmN0aW9uIGZvciB0aGUgY2FsbGJhY2socykganVzdCBhZGRlZC5cbiAgICBhZGRTdHJvcGhlTGlzdGVuZXI6IChvcHRpb25zID0ge30pIC0+XG4gICAgICB7bGlzdGVuZXIsIHR5cGUsIGlvVHlwZX0gPSBfLmRlZmF1bHRzIG9wdGlvbnMsXG4gICAgICAgIGxpc3RlbmVyOiBbXVxuICAgICAgICB0eXBlOiBJT0V2ZW50LlJBV1xuICAgICAgICBpb1R5cGU6ICcnXG5cbiAgICAgICMgQ2hvb3NlIHRoZSBjb3JyZWN0IGFycmF5IG9mIGxpc3RlbmVycyBiYXNlZCBvbiB0eXBlLCBlLmcuIFhNTCwgUkFXIChkZWZhdWx0KS5cbiAgICAgIGlmIHR5cGUgaXMgSU9FdmVudC5YTUxcbiAgICAgICAgaW5wdXRMaXN0ZW5lcnMgPSBTdHJvcGhlSU8ueG1sSW5wdXRMaXN0ZW5lcnNcbiAgICAgICAgb3V0cHV0TGlzdGVuZXJzID0gU3Ryb3BoZUlPLnhtbE91dHB1dExpc3RlbmVyc1xuICAgICAgZWxzZVxuICAgICAgICBpbnB1dExpc3RlbmVycyA9IFN0cm9waGVJTy5yYXdJbnB1dExpc3RlbmVyc1xuICAgICAgICBvdXRwdXRMaXN0ZW5lcnMgPSBTdHJvcGhlSU8ucmF3T3V0cHV0TGlzdGVuZXJzXG5cbiAgICAgICMgUmVnaXN0ZXIgbGlzdGVuZXJzIGJhc2VkIG9uIGlvVHlwZSwgZS5nLiBJTlBVVCwgT1VUUFVULCBvciBib3RoIChkZWZhdWx0KS5cbiAgICAgIHN3aXRjaCBpb1R5cGVcbiAgICAgICAgd2hlbiBJT0V2ZW50LklOUFVUXG4gICAgICAgICAgU3Ryb3BoZUlPLmFkZElPTGlzdGVuZXIgbGlzdGVuZXIsIGlucHV0TGlzdGVuZXJzXG4gICAgICAgIHdoZW4gSU9FdmVudC5PVVRQVVRcbiAgICAgICAgICBTdHJvcGhlSU8uYWRkSU9MaXN0ZW5lciBsaXN0ZW5lciwgb3V0cHV0TGlzdGVuZXJzXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBTdHJvcGhlSU8uYWRkSU9MaXN0ZW5lciBsaXN0ZW5lciwgaW5wdXRMaXN0ZW5lcnNcbiAgICAgICAgICBTdHJvcGhlSU8uYWRkSU9MaXN0ZW5lciBsaXN0ZW5lciwgb3V0cHV0TGlzdGVuZXJzXG5cbiAgICAjIENvbm5lY3QgdG8gWE1QUCBieSBjYWxsaW5nIHRoZSBTdHJvcGhlIGNvbm5lY3QgbWV0aG9kLCBwYXNzaW5nIHVzZXJcbiAgICAjICAgY3JlZGVudGlhbHMgYW5kIGEgY2FsbGJhY2sgZm9yIHN0YXR1cyB1cGRhdGVzLlxuICAgICNcbiAgICAjIEBwYXJhbSBvcHRpb25zIFtPYmplY3RdIGFuIG9iamVjdCBvZiBvcHRpb25zXG4gICAgIyBAb3B0aW9uIG9wdGlvbnMgamlkIFtTdHJpbmddIGEgdW5pcXVlIGppZCBmb3IgdGhlIHVzZXJcbiAgICAjIEBvcHRpb24gb3B0aW9ucyBwYXNzd29yZCBbU3RyaW5nXSB0aGUgdXNlcidzIHBhc3N3b3JkXG4gICAgIyBAb3B0aW9uIG9wdGlvbnMgY2FsbGJhY2sgW0Z1bmN0aW9uXSBvcHRpb25hbCBjYWxsYmFjayB0aGF0IGFuIGFwcGxpY2F0aW9uXG4gICAgIyAgIGNhbiBwYXNzIGluIHRvIGJlIG5vdGlmaWVkIG9mIGNvbm5lY3Rpb24gc3RhdHVzIGNoYW5nZXNcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtQcm9taXNlXSBwcm9taXNlIG9iamVjdCBvZiB0aGUgZGVmZXJyZWQgdXNlZCB0byBhdHRlbXB0IHRoZSBjb25uZWN0aW9uXG4gICAgY29ubmVjdDogKG9wdGlvbnMgPSB7fSkgLT5cbiAgICAgIHN0YXR1cyA9IEBzdGF0dXMoKVxuXG4gICAgICAjIFRoZXJlIGlzIGFscmVhZHkgYSBwcmV2aW91cyBjb25uZWN0aW9uIGRlZmVycmVkXG4gICAgICBpZiBAX2Nvbm5lY3Rpb25EZmRcbiAgICAgICAgcHJvbWlzZSA9IEBfY29ubmVjdGlvbkRmZC5wcm9taXNlXG5cbiAgICAgICAgIyBQcm9taXNlIGlzUGVuZGluZygpIHNob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIGZvciAnaW4tcHJvZ3Jlc3MnIHN0YXR1c2VzXG4gICAgICAgIGlmIHByb21pc2UuaXNQZW5kaW5nKClcbiAgICAgICAgICBwZW5kaW5nTXNnID0gZ2V0UGVuZGluZ01lc3NhZ2Ugc3RhdHVzXG4gICAgICAgICAgQF9jb25uZWN0aW9uRGZkLm5vdGlmeSBzdGF0dXMsIHBlbmRpbmdNc2dcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZVxuXG4gICAgICBpZiBzdGF0dXMgaXMgU3RhdHVzLkNPTk5FQ1RFRFxuICAgICAgICByZXR1cm4gUSBzdGF0dXNcblxuICAgICAgYXR0ZW1wdENvbm5lY3Rpb24uY2FsbCB0aGlzLCBvcHRpb25zXG5cbiAgICAjIERpc2Nvbm5lY3QgZnJvbSBYTVBQIGJ5IGNhbGxpbmcgdGhlIFN0cm9waGUgZGlzY29ubmVjdCBtZXRob2RcbiAgICAjXG4gICAgIyBAcGFyYW0gb3B0aW9ucyBbT2JqZWN0XSBhbiBvYmplY3Qgb2Ygb3B0aW9uc1xuICAgICMgQG9wdGlvbiBvcHRpb25zIG5vUmVjb25uZWN0IFtCb29sZWFuXSBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGQgbm90IGF0dGVtcHRcbiAgICAjICAgdG8gcmVjb25uZWN0IGFmdGVyIGRpc2Nvbm5lY3RpbmdcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtQcm9taXNlXSBwcm9taXNlIG9iamVjdCBvZiB0aGUgZGVmZXJyZWQgdXNlZCB0byBkaXNjb25uZWN0XG4gICAgZGlzY29ubmVjdDogKG9wdGlvbnMgPSB7fSkgLT5cbiAgICAgIHN0YXR1cyA9IEBzdGF0dXMoKVxuXG4gICAgICBpZiBzdGF0dXMgaXMgU3RhdHVzLkRJU0NPTk5FQ1RFRFxuICAgICAgICByZXR1cm4gUSBzdGF0dXNcblxuICAgICAgIyBUaGVyZSBpcyBhbHJlYWR5IGEgcHJldmlvdXMgZGlzY29ubmVjdGlvbiBkZWZlcnJlZFxuICAgICAgaWYgQF9kaXNjb25uZWN0aW9uRGZkXG4gICAgICAgIHByb21pc2UgPSBAX2Rpc2Nvbm5lY3Rpb25EZmQucHJvbWlzZVxuXG4gICAgICAgICMgUHJvbWlzZSBpc1BlbmRpbmcoKSBzaG91bGQgcmV0dXJuIHRydWUgd2hlbiBmb3IgJ2luLXByb2dyZXNzJyBzdGF0dXNlc1xuICAgICAgICBpZiBwcm9taXNlLmlzUGVuZGluZygpXG4gICAgICAgICAgcGVuZGluZ01zZyA9IGdldFBlbmRpbmdNZXNzYWdlIHN0YXR1c1xuICAgICAgICAgIEBfZGlzY29ubmVjdGlvbkRmZC5ub3RpZnkgc3RhdHVzLCBwZW5kaW5nTXNnXG4gICAgICAgICAgcmV0dXJuIHByb21pc2VcblxuICAgICAgYXR0ZW1wdERpc2Nvbm5lY3Rpb24uY2FsbCB0aGlzLCBvcHRpb25zXG5cbiAgICAjIEdldHRlciBtZXRob2QgZm9yIHRoZSBTdHJvcGhlIGNvbm5lY3Rpb24gc3RhdHVzXG4gICAgI1xuICAgICMgQHJldHVybiBbU3RyaW5nXSBvbmUgb2YgU3Ryb3BoZSdzIHN0YXR1cyBzdHJpbmdzIGZvciAnY29ubmVjdGluZycsXG4gICAgIyAgICdhdXRoZW50aWNhdGluZycsICdkaXNjb25uZWN0ZWQnLCBldGMuXG4gICAgIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4wLjIvaW5kZXgvQ29uc3RhbnRzLmh0bWxcbiAgICBzdGF0dXM6IC0+XG4gICAgICBAX2Nvbm5lY3Rpb25TdGF0dXNcblxuICAgICMgRGV0ZXJtaW5lIGlmIHRoZSBjb25uZWN0aW9uIHN0YXR1cyBpcyBjdXJyZW50bHkgQ09OTkVDVEVEXG4gICAgI1xuICAgICMgQHJldHVybiBbQm9vbGVhbl1cbiAgICBpc0Nvbm5lY3RlZDogLT5cbiAgICAgIEBzdGF0dXMoKSBpcyBTdGF0dXMuQ09OTkVDVEVEXG5cbiAgICAjIFByZXBhcmUgdG8gc2VuZCBhIHByZXNlbmNlIHVwZGF0ZSB0byBOaXRybyBieSBkZWxlZ2F0aW5nIHRvIHRoZVxuICAgICMgICBQcmVzZW5jZSBzaW5nbGV0b25cbiAgICAjXG4gICAgIyBAcGFyYW0gc3RhdHVzIFtTdHJpbmddIGEgcHJlc2VuY2Ugc3RhdHVzIGZyb20gWE1QUFByZXNlbmNlXG4gICAgIyBAcGFyYW0gb3B0aW9ucyBbT2JqZWN0XSBvYmplY3Qgb2Ygb3B0aW9uc1xuICAgICMgQG9wdGlvbiBvcHRpb25zIGluaXRpYWwgW0Jvb2xlYW5dIHdoZXRoZXIgdGhpcyBpcyBpbml0aWFsIHByZXNlbmNlIGJlaW5nIHNldCBvciBub3RcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtQcm9taXNlXSBhIHByb21pc2UgZm9yIHdoZW4gdGhlIHByZXNlbmNlIGlzIHNldCBvbiBOaXRyb1xuICAgICMgQHNlZSBYTVBQUHJlc2VuY2VcbiAgICBzZXRQcmVzZW5jZTogKHN0YXR1cyA9ICcnLCBvcHRpb25zID0ge30pIC0+XG4gICAgICB7aW5pdGlhbH0gPSBfLmRlZmF1bHRzIG9wdGlvbnMsXG4gICAgICAgIGluaXRpYWw6IGZhbHNlXG5cbiAgICAgIE5pdHJvUHJvbWlzZSAocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgICAjIFJlamVjdCBpZiB3ZSByZWNlaXZlIGFuIGludmFsaWQgcHJlc2VuY2UuXG4gICAgICAgIGlmIG5vdCBfLmNvbnRhaW5zIFhNUFBQcmVzZW5jZSwgc3RhdHVzXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IgXCJBdHRlbXB0ZWQgdG8gc2V0IGFuIGludmFsaWQgcHJlc2VuY2VcIlxuICAgICAgICAgIHJldHVybiByZWplY3QgZXJyb3JcblxuICAgICAgICBzZW5kT3B0cyA9IHJlc29sdmU6IHJlc29sdmUsIHJlamVjdDogcmVqZWN0XG5cbiAgICAgICAgIyBJZiB0aGUgaW50ZW50aW9uIGlzIHRvIGdvIGludmlzaWJsZSAodW5hdmFpbGFibGUpIHRoZW5cbiAgICAgICAgIyBzZW5kIElRIHN0YW56YVxuICAgICAgICBpZiBzdGF0dXMgaXMgWE1QUFByZXNlbmNlLklOVklTSUJMRVxuICAgICAgICAgIGludmlzaWJsZVN0YW56YSA9IHN0cm9waGVQcmVzZW5jZS5nZXRWaXNpYmxlU3RhbnphIGZhbHNlXG4gICAgICAgICAgc2VuZElRLmNhbGwgdGhpcywgXy5leHRlbmQge30sIHNlbmRPcHRzLCBlbGVtZW50OiBpbnZpc2libGVTdGFuemFcblxuICAgICAgICAgIGlmIGluaXRpYWxcbiAgICAgICAgICAgICMgSW5pdGlhbCBwcmVzZW5jZSByZXF1aXJlcyB1cyB0byBzZW5kIEFWQUlMQUJMRSB0byBnZXQgcHJlc2VuY2Ugb2YgUm9zdGVyIGNvbnRhY3RzLFxuICAgICAgICAgICAgIyBldmVuIGFmdGVyIHNldHRpbmcgaW52aXNpYmxlIGZsYWcgdG8gdHJ1ZSBvbiBzZXJ2ZXJcbiAgICAgICAgICAgIHN0YXR1cyA9IFhNUFBQcmVzZW5jZS5BVkFJTEFCTEVcbiAgICAgICAgICAgIHNob3cgPSBYTVBQVXRpbHMueG1wcFByZXNlbmNlVG9TaG93IHN0YXR1c1xuICAgICAgICAgICAgc3RhbnphID0gc3Ryb3BoZVByZXNlbmNlLmdldFByZXNlbmNlU3RhbnphICcnLCAnJywgc2hvd1xuICAgICAgICAgICAgc2VuZC5jYWxsIHRoaXMsIF8uZXh0ZW5kIHt9LFxuICAgICAgICAgICAgICBlbGVtZW50OiBzdGFuemFcbiAgICAgICAgICByZXR1cm5cblxuXG4gICAgICAgICMgTm9uLWluaXRpYWwgcHJlc2VuY2UgcmVxdWlyZXMgdGhhdCB3ZSBzZW5kIGEgdmlzaWJsZSBzdGFuemEgYWxvbmcgd2l0aFxuICAgICAgICAjIG91ciBwcmVzZW5jZS5cbiAgICAgICAgaWYgbm90IGluaXRpYWxcbiAgICAgICAgICAjIFNlbmQgSVEgZm9yIFwidmlzaWJsZVwiIGZvciBhbGwgc3RhdHVzZXMgb3RoZXIgdGhhbiBJTlZJU0lCTEVcbiAgICAgICAgICB2aXNpYmxlU3RhbnphID0gc3Ryb3BoZVByZXNlbmNlLmdldFZpc2libGVTdGFuemEoKVxuICAgICAgICAgIHNlbmRJUS5jYWxsIHRoaXMsIF8uZXh0ZW5kIHt9LCBzZW5kT3B0cywgZWxlbWVudDogdmlzaWJsZVN0YW56YVxuXG4gICAgICAgICMgU2VuZCBhY3R1YWwgcHJlc2VuY2UuXG4gICAgICAgIHNob3cgPSBYTVBQVXRpbHMueG1wcFByZXNlbmNlVG9TaG93IHN0YXR1c1xuICAgICAgICBzdGFuemEgPSBzdHJvcGhlUHJlc2VuY2UuZ2V0UHJlc2VuY2VTdGFuemEgJycsICcnLCBzaG93XG4gICAgICAgIHNlbmQuY2FsbCB0aGlzLCBfLmV4dGVuZCB7fSxcbiAgICAgICAgICBlbGVtZW50OiBzdGFuemFcbiAgICAgICAgICByZXNvbHZlOiByZXNvbHZlXG4gICAgICAgICAgcmVqZWN0OiByZWplY3RcblxuICAgICMgU2V0cyBpbml0aWFsIHByZXNlbmNlXG4gICAgI1xuICAgICMgQHBhcmFtIHN0YXR1cyBbU3RyaW5nXSBhIHByZXNlbmNlIHN0YXR1cyBmcm9tIFhNUFBQcmVzZW5jZVxuICAgICNcbiAgICAjIEByZXR1cm4gW1Byb21pc2VdIGEgcHJvbWlzZSBmb3Igd2hlbiB0aGUgcHJlc2VuY2UgaXMgc2V0IG9uIE5pdHJvXG4gICAgIyBAc2VlIFhNUFBQcmVzZW5jZVxuICAgIHNldEluaXRpYWxQcmVzZW5jZTogKHN0YXR1cyA9ICcnKSAtPlxuICAgICAgQHNldFByZXNlbmNlIHN0YXR1cywgaW5pdGlhbDogdHJ1ZVxuXG4gICAgcmVnaXN0ZXJDb21wb25lbnQgPSAoY29tcG9uZW50cywgbmFtZSwgaW5zdGFuY2UpIC0+XG4gICAgICBjb21wb25lbnRzW25hbWVdID0gaW5zdGFuY2VcblxuICAgICMgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIFJhdGVMaW1pdGVyIHJlcHJlc2VudGluZyB0aGUgI2Nvbm5lY3QoKSBtZXRob2Qgb25cbiAgICAjICAgdGhlIFN0cm9waGUuQ29ubmVjdGlvbiBvYmplY3RcbiAgICAjIEBwcml2YXRlXG4gICAgI1xuICAgICMgQHBhcmFtIG9wdGlvbnMgW09iamVjdF0gYW4gb2JqZWN0IG9mIG9wdGlvbnNcbiAgICAjIEBvcHRpb24gb3B0aW9ucyBmdW5jIFtGdW5jdGlvbl0gYSBmdW5jdGlvbiB0byByYXRlIGxpbWl0XG4gICAgIyBAb3B0aW9uIG9wdGlvbnMgY29udGV4dCBbRnVuY3Rpb25dIHRoZSBjb250ZXh0IG9mIHRoZSByYXRlIGxpbWl0ZWQgY2FsbHNcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtSYXRlTGltaXRlcl0gdGhlIGNvbm5lY3RvciBpbnN0YW5jZVxuICAgICMgQHNlZSBSYXRlTGltaXRlclxuICAgIGNyZWF0ZUNvbm5lY3RvciA9IChvcHRpb25zID0ge30pIC0+XG4gICAgICB7ZnVuYywgY29udGV4dH0gPSBvcHRpb25zXG4gICAgICBsaW1pdE9wdGlvbnMgPVxuICAgICAgICBtYXg6IDVcbiAgICAgICAgdGltZTogNjAgKiAxMDAwXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBcIlRvbyBtYW55IGNvbm5lY3Rpb24gYXR0ZW1wdHMgaGF2ZSBiZWVuIG1hZGUuXCJcbiAgICAgIGNvbm5lY3RvciA9IG5ldyBSYXRlTGltaXRlciBmdW5jLCBsaW1pdE9wdGlvbnNcbiAgICAgIGNvbm5lY3Rvci5hZGRBbGlhcyAnYWZ0ZXJTZXJ2ZXJGYWlsdXJlJ1xuICAgICAgY29ubmVjdG9yLmFkZEFsaWFzICdhZnRlckxvbmdQb2xsRmFpbHVyZScsIG1heDogMywgdGltZTogNiAqIDYwICogMTAwMFxuICAgICAgY29ubmVjdG9yXG5cbiAgICAjIEF0dGVtcHQgdG8gY29ubmVjdCB0byBYTVBQIHVzaW5nIHRoZSBTdHJvcGhlIGNvbm5lY3Rpb24ncyAnY29ubmVjdCgpJ1xuICAgICMgICBWYWxpZGF0ZXMgYW5kIHNhdmVzIHRoZSBpbmNvbWluZyB1c2VyIGNyZWRlbnRpYWxzIGFuZCB0aGUgY29ubmVjdGlvbidzXG4gICAgIyAgIGRlZmVycmVkIHdpbGwgYXV0b21hdGljYWxseSBjbGVhbiBpdHNlbGYgdXAgKHNldHMgdmFsdWUgdG8gbnVsbCkgb25jZVxuICAgICMgICB0aGUgZGVmZXJyZWQgaXMgZWl0aGVyIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cbiAgICAjIEBwcml2YXRlXG4gICAgI1xuICAgICMgQHBhcmFtIG9wdGlvbnMgW09iamVjdF0gYW4gb2JqZWN0IG9mIG9wdGlvbnNcbiAgICAjIEBvcHRpb24gb3B0aW9ucyBqaWQgW1N0cmluZ10gYSB1bmlxdWUgamlkIGZvciB0aGUgdXNlclxuICAgICMgQG9wdGlvbiBvcHRpb25zIHBhc3N3b3JkIFtTdHJpbmddIHRoZSB1c2VyJ3MgcGFzc3dvcmRcbiAgICAjIEBvcHRpb24gb3B0aW9ucyBjYWxsYmFjayBbRnVuY3Rpb25dIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgYW4gYXBwbGljYXRpb25cbiAgICAjICAgY2FuIHBhc3MgaW4gdG8gYmUgbm90aWZpZWQgb2YgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlc1xuICAgICNcbiAgICAjIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2Ugb2JqZWN0IG9mIHRoZSBkZWZlcnJlZCB1c2VkIHRvIGF0dGVtcHQgdGhlIGNvbm5lY3Rpb25cbiAgICBhdHRlbXB0Q29ubmVjdGlvbiA9IChvcHRpb25zID0ge30pIC0+XG4gICAgICB7amlkLCBwYXNzd29yZCwgY2FsbGJhY2t9ID0gXy5kZWZhdWx0cyBvcHRpb25zLFxuICAgICAgICBjYWxsYmFjazogLT5cblxuICAgICAgQF9jb25uZWN0aW9uRGZkID0gUS5kZWZlcigpXG4gICAgICBwcm9taXNlID0gQF9jb25uZWN0aW9uRGZkLnByb21pc2VcbiAgICAgICMgQWx3YXlzIGRlc3Ryb3kgdGhlIGRlZmVycmVkIHdoZW4gZWl0aGVyIGRvbmUgb3IgZmFpbGVkLlxuICAgICAgcHJvbWlzZS5maW5hbGx5ID0+XG4gICAgICAgIEBfY29ubmVjdGlvbkRmZCA9IG51bGxcblxuICAgICAgaWYgbm90IGNyZWRlbnRpYWxzID0gc2V0Q3JlZGVudGlhbHMuY2FsbCB0aGlzLCBqaWQsIHBhc3N3b3JkXG4gICAgICAgIEBfY29ubmVjdGlvbkRmZC5yZWplY3QgXCJDYW4gbm90IGNvbm5lY3QgZHVlIHRvIG1pc3NpbmcgY3JlZGVudGlhbHNcIlxuICAgICAgICByZXR1cm4gcHJvbWlzZVxuXG4gICAgICBjb25uZWN0aW9uSGFuZGxlciA9IF8uYmluZCBvbkNvbm5lY3Rpb25TdGF0dXMsIHRoaXMsIEBfY29ubmVjdGlvbkRmZCxcbiAgICAgICAgY2FsbGJhY2tcblxuICAgICAgIyBAX2Nvbm5lY3Rpb24ucmVzZXQoKVxuXG4gICAgICBbamlkLCBwYXNzd29yZF0gPSBjcmVkZW50aWFsc1xuICAgICAgbGltaXRFcnJvciA9IEBfY29ubmVjdFRvU2VydmVyLmludm9rZSBqaWQsIHBhc3N3b3JkLCBjb25uZWN0aW9uSGFuZGxlclxuICAgICAgaWYgbGltaXRFcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgIGNvbnNvbGUuZXJyb3IgXCJbQ29ubmVjdGlvbl1cIiwgbGltaXRFcnJvci5tZXNzYWdlXG4gICAgICAgIGNvbm5lY3Rpb25IYW5kbGVyIFN0YXR1cy5GQVRBTF9GQUlMVVJFLCBlcnJvcjogbGltaXRFcnJvclxuXG4gICAgICAjIHNldCB0aGUgeG1wcCBkb21haW4gZm9yIGZ1dHVyZSB1c2UgKGUuZy4sIGNvbmZlcmVuY2UgamlkcylcbiAgICAgIENvbmZpZy5zZXQgJ3htcHAuZG9tYWluJywgWE1QUFV0aWxzLmdldFhNUFBEb21haW4gamlkXG4gICAgICBwcm9taXNlXG5cbiAgICAjIEF0dGVtcHQgdG8gZGlzY29ubmVjdCBmcm9tIFhNUFAgdXNpbmcgdGhlIFN0cm9waGUgY29ubmVjdGlvbidzICdkaXNjb25uZWN0KCknXG4gICAgIyBAcHJpdmF0ZVxuICAgICNcbiAgICAjIEBwYXJhbSBvcHRpb25zIFtPYmplY3RdIGFuIG9iamVjdCBvZiBvcHRpb25zXG4gICAgIyBAb3B0aW9uIG9wdGlvbnMgbm9SZWNvbm5lY3QgW0Jvb2xlYW5dIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZCBub3QgYXR0ZW1wdFxuICAgICMgICB0byByZWNvbm5lY3QgYWZ0ZXIgZGlzY29ubmVjdGluZ1xuICAgICNcbiAgICAjIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2Ugb2JqZWN0IG9mIHRoZSBkZWZlcnJlZCB1c2VkIHRvIGF0dGVtcHQgdGhlIGRpc2Nvbm5lY3Rpb25cbiAgICBhdHRlbXB0RGlzY29ubmVjdGlvbiA9IChvcHRpb25zID0ge30pIC0+XG4gICAgICBAX2Rpc2Nvbm5lY3Rpb25EZmQgPSBRLmRlZmVyKClcbiAgICAgIHByb21pc2UgPSBAX2Rpc2Nvbm5lY3Rpb25EZmQucHJvbWlzZVxuICAgICAgIyBBbHdheXMgZGVzdHJveSB0aGUgZGVmZXJyZWQgd2hlbiBlaXRoZXIgZG9uZSBvciBmYWlsZWQuXG4gICAgICBwcm9taXNlLmZpbmFsbHkgPT5cbiAgICAgICAgQF9kaXNjb25uZWN0aW9uRGZkID0gbnVsbFxuXG4gICAgICAjIFBhc3MgdGhlIG9wdGlvbnMgdGhyb3VnaCB0byBTdHJvcGhlJ3MgI2Rpc2Nvbm5lY3QoKVxuICAgICAgIyBhbmQgdGhleSB3aWxsIGJlIHBhc3NlZCB0byBvdXIgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgIEBfY29ubmVjdGlvbi5kaXNjb25uZWN0IG9wdGlvbnNcblxuICAgICAgcHJvbWlzZVxuXG4gICAgZG9EaXNjbyA9IC0+XG4gICAgICBRLnByb21pc2UgKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgICAgc2VuZC5jYWxsIHRoaXMsIF8uZXh0ZW5kIHt9LFxuICAgICAgICAgIGVsZW1lbnQ6IHN0cm9waGVEaXNjby5nZXREaXNjb1N0YW56YSBDb25maWcuZ2V0ICd4bXBwLmRvbWFpbidcbiAgICAgICAgICByZXNvbHZlOiByZXNvbHZlXG4gICAgICAgICAgcmVqZWN0OiByZWplY3RcblxuICAgICMgVmFsaWRhdGUgYW5kIHN0b3JlIGNyZWRlbnRpYWxzIGZvciBmdXR1cmUgdXNlXG4gICAgIyBAcHJpdmF0ZVxuICAgICNcbiAgICAjIEBwYXJhbSBjcmVkZW50aWFscyBqaWQgW1N0cmluZ10gYSB1bmlxdWUgamlkIGZvciB0aGUgdXNlclxuICAgICMgQHBhcmFtIGNyZWRlbnRpYWxzIHBhc3N3b3JkIFtTdHJpbmddIHRoZSB1c2VyJ3MgcGFzc3dvcmRcbiAgICBzZXRDcmVkZW50aWFscyA9IChuZXdKSUQsIG5ld1Bhc3N3b3JkKSAtPlxuICAgICAgQF90ZW1wSklEID0gbmV3SklEIGlmIG5ld0pJRFxuICAgICAgQF9wYXNzd29yZCA9IG5ld1Bhc3N3b3JkIGlmIG5ld1Bhc3N3b3JkXG5cbiAgICAgIGlmIEBfdGVtcEpJRCBhbmQgQF9wYXNzd29yZFxuICAgICAgICBbQF90ZW1wSklELCBAX3Bhc3N3b3JkXVxuICAgICAgZWxzZVxuICAgICAgICBmYWxzZVxuXG4gICAgIyBIYW5kbGUgY29ubmVjdGlvbiBzdGF0dXMgdXBkYXRlcyBmcm9tIGEgY2FsbCB0byBTdHJvcGhlJ3NcbiAgICAjICAgY29ubmVjdCBtZXRob2RcbiAgICAjIEBwcml2YXRlXG4gICAgI1xuICAgICMgQHBhcmFtIGNvbm5lY3Rpb25EZWZlcnJlZCBbRGVmZXJyZWRdIGEgRGVmZXJyZWQgZm9yIGNvbm5lY3RpbmcgdG8gdGhlXG4gICAgIyAgIFhNUFAgc2VydmVyXG4gICAgIyBAcGFyYW0gc3RhdHVzIFtTdHJpbmddIG9uZSBvZiBTdHJvcGhlJ3Mgc3RhdHVzIHN0cmluZ3MgZm9yICdjb25uZWN0aW5nJyxcbiAgICAjICAgJ2F1dGhlbnRpY2F0aW5nJywgJ2Rpc2Nvbm5lY3RlZCcsIGV0Yy5cbiAgICAjIEBwYXJhbSBvcHRpb25zIFtPYmplY3RdIGVpdGhlciBhIGN1c3RvbSBvYmplY3Qgb2Ygb3B0aW9ucyBvciBhbiBlcnJvclxuICAgICMgY29uZGl0aW9uIGZyb20gU3Ryb3BoZSBhcyB0byB3aHkgd2Ugd2VyZSBkaXNjb25uZWN0ZWRcbiAgICAjIEBzZWUgaHR0cDovL3N0cm9waGUuaW0vc3Ryb3BoZWpzL2RvYy8xLjAuMi9pbmRleC9Db25zdGFudHMuaHRtbFxuICAgICNcbiAgICAjIEByZXR1cm4gW1ByaXZhdGVDb25uZWN0aW9uXSB0aGlzXG4gICAgb25Db25uZWN0aW9uU3RhdHVzID0gKGNvbm5lY3Rpb25EZWZlcnJlZCwgY2FsbGJhY2ssIHN0YXR1cywgb3B0aW9ucyA9IHt9KSAtPlxuICAgICAgY29uc29sZVxuICAgICAgICAubG9nIFwiW0Nvbm5lY3Rpb25dWyN7bmV3IERhdGUoKS50b1RpbWVTdHJpbmcoKX1dIFN0YXR1czpcIiwgU3RhdHVzTGFiZWxzW3N0YXR1c11cbiAgICAgIGlmIF8uY29udGFpbnMgQF9zdGF0dXNlcywgc3RhdHVzXG4gICAgICAgIEBfY29ubmVjdGlvblN0YXR1cyA9IHN0YXR1c1xuXG4gICAgICAjIFBlcmZvcm0gc3RhdHVzLXNwZWNpZmljIGFjdGlvbnNcbiAgICAgIHN3aXRjaCBAX2Nvbm5lY3Rpb25TdGF0dXNcbiAgICAgICAgd2hlbiBTdGF0dXMuQ09OTkVDVEVEXG4gICAgICAgICAgdG9nZ2xlQ29ubmVjdGlvbi5jYWxsIHRoaXMsIHRydWVcbiAgICAgICAgICBkb0Rpc2NvLmNhbGwgdGhpc1xuICAgICAgICB3aGVuIFN0YXR1cy5ESVNDT05ORUNURUQsIFN0YXR1cy5DT05OVElNRU9VVCwgU3RhdHVzLkNPTk5GQUlMXG4gICAgICAgICAgIyBJbW1lZGlhdGVseSByZXNldCB0aGUgY29ubmVjdGlvbiBwZXIgU3Ryb3BoZSBkb2N1bWVudGF0aW9uIGZvclxuICAgICAgICAgICMgaGFuZGxpbmcgRElTQ09OTkVDVCBzdGF0ZS5cbiAgICAgICAgICBAX2Nvbm5lY3Rpb24ucmVzZXQoKVxuICAgICAgICAgICMgSWYgdGhlcmUgaXMgYSBwcm9taXNlIGZvciBkaXNjb25uZWN0aW5nLCByZXNvbHZlIGl0XG4gICAgICAgICAgQF9kaXNjb25uZWN0aW9uRGZkPy5yZXNvbHZlKClcbiAgICAgICAgICB0b2dnbGVDb25uZWN0aW9uLmNhbGwgdGhpcywgZmFsc2VcblxuICAgICAgIyBTZWxlY3QgdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCB0byBjYWxsIG9uIHRoZSBfY29ubmVjdGlvbkRlZmVycmVkXG4gICAgICBkZmRNZXRob2QgPSBnZXRDb25uZWN0RGZkTWV0aG9kIEBfY29ubmVjdGlvblN0YXR1c1xuXG4gICAgICAjIEFkZCB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgICBvcHRpb25zID0gXy5leHRlbmQge30sIG9wdGlvbnMsIHN0YXR1czogQF9jb25uZWN0aW9uU3RhdHVzXG5cbiAgICAgICMgSW52b2tlIHRoZSBtZXRob2Qgb24gdGhlIF9jb25uZWN0aW9uRGVmZXJyZWQsIHBhc3NpbmcgaXQgdGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAgaWYgY29ubmVjdGlvbkRlZmVycmVkIGFuZCBkZmRNZXRob2RcbiAgICAgICAgY29ubmVjdGlvbkRlZmVycmVkW2RmZE1ldGhvZF0gb3B0aW9uc1xuXG4gICAgICAjIEludm9rZSB0aGUgY3VzdG9tIGNhbGxiYWNrIHdpdGggdGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAgaWYgXy5pc0Z1bmN0aW9uIGNhbGxiYWNrXG4gICAgICAgIGNhbGxiYWNrIG9wdGlvbnNcblxuICAgICAgcmV0dXJuIHRoaXNcblxuICAgICMgQHByaXZhdGVcbiAgICAjIFNlbGVjdCB0aGUgYXBwcm9wcmlhdGUgcHJvbWlzZSBtZXRob2QgdG8gY2FsbCBvbiB0aGUgX2Nvbm5lY3Rpb25EZWZlcnJlZCBvYmplY3RcbiAgICAjXG4gICAgIyBAcGFyYW0gc3RhdHVzIFtTdHJpbmddIGEgY29ubmVjdGlvbiBzdGF0dXMgY29uc3RhbnRcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBkZWZlcnJlZCBtZXRob2QsIGUuZy4gJ3Jlc29sdmUnLCAncmVqZWN0JywgJ25vdGlmeSdcbiAgICAjXG4gICAgIyBAc2VlIFN0YXR1c1xuICAgIGdldENvbm5lY3REZmRNZXRob2QgPSAoc3RhdHVzKSAtPlxuICAgICAgc3dpdGNoIHN0YXR1c1xuICAgICAgICB3aGVuIFN0YXR1cy5DT05ORUNUSU5HLCBTdGF0dXMuQVVUSEVOVElDQVRJTkdcbiAgICAgICAgICAnbm90aWZ5J1xuICAgICAgICB3aGVuIFN0YXR1cy5DT05ORUNURURcbiAgICAgICAgICAncmVzb2x2ZSdcbiAgICAgICAgd2hlbiBTdGF0dXMuQ09OTkZBSUwsIFN0YXR1cy5BVVRIRkFJTCwgU3RhdHVzLkRJU0NPTk5FQ1RFRCwgU3RhdHVzLkZBVEFMX0ZBSUxVUkVcbiAgICAgICAgICAncmVqZWN0J1xuICAgICAgICB3aGVuIFN0YXR1cy5DT05OVElNRU9VVCwgU3RhdHVzLkFVVEhGQUlMLCBTdGF0dXMuRElTQ09OTkVDVEVELCBTdGF0dXMuRkFUQUxfRkFJTFVSRVxuICAgICAgICAgICdyZWplY3QnXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAnJ1xuXG4gICAgIyBOb3RpZnkgc3ViLWNvbXBvbmVudHMgb2YgYSB0b2dnbGVkIGNoYW5nZSBpbiBjb25uZWN0aW9uIHN0YXR1c1xuICAgICMgQHByaXZhdGVcbiAgICAjXG4gICAgIyBAcGFyYW0gY29ubmVjdGVkIFtCb29sZWFuXSB0cnVlIGlmIGNvbm5lY3RlZCwgZmFsc2UgaWYgZGlzY29ubmVjdGVkXG4gICAgI1xuICAgICMgQHJldHVybiBbQ29ubmVjdGlvbl0gdGhpc1xuICAgIHRvZ2dsZUNvbm5lY3Rpb24gPSAoY29ubmVjdGVkID0gdHJ1ZSkgLT5cbiAgICAgIGZvciBzdWJzY3JpYmVyIGluIEBfY29ubmVjdGlvblRvZ2dsZVN1YnMgb3IgW11cbiAgICAgICAgc3Vic2NyaWJlci50b2dnbGVDb25uZWN0aW9uIGNvbm5lY3RlZCwgQGdldEpJRCgpXG4gICAgICByZXR1cm4gdGhpc1xuXG4gICAgIyBSZXRyaWV2ZSBhIG1lc3NhZ2UgaW5kaWNhdGluZyB0byB0aGUgdXNlciB0aGF0IGEgY29ubmVjdGlvbiBhdHRlbXB0IGlzXG4gICAgIyAgICdwZW5kaW5nJywgZS5nLiBDT05ORUNUSU5HLCBBVVRIRU5USUNBVElORywgb3IgRElTQ09OTkVDVElOR1xuICAgICMgQHByaXZhdGVcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIFVJIG1lc3NhZ2UgaW5mb3JtaW5nIHRoZSB1c2VyIG9mIHRoZSB0eXBlIG9mIHBlbmRpbmdcbiAgICAjICAgY29ubmVjdGlvbiBzdGF0dXNcbiAgICBnZXRQZW5kaW5nTWVzc2FnZSA9IChzdGF0dXMpIC0+XG4gICAgICBzd2l0Y2ggc3RhdHVzXG4gICAgICAgIHdoZW4gU3RhdHVzLkNPTk5FQ1RJTkdcbiAgICAgICAgICBcIkFsZWFkeSBjb25uZWN0aW5nIHRvIHRoZSBOaXRybyBzZXJ2ZXJcIlxuICAgICAgICB3aGVuIFN0YXR1cy5BVVRIRU5USUNBVElOR1xuICAgICAgICAgIFwiQWxyZWFkeSBhdXRoZW50aWNhdGluZyB3aXRoIHRoZSBOaXRybyBzZXJ2ZXJcIlxuICAgICAgICB3aGVuIFN0YXR1cy5ESVNDT05ORUNURURcbiAgICAgICAgICBcIkFscmVhZHkgZGlzY29ubmVjdGluZyBmcm9tIHRoZSBOaXRybyBzZXJ2ZXJcIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgXCJcIlxuXG4gICAgIyBTZW5kIGEgcmVxdWVzdCB1c2luZyBTdHJvcGhlXG4gICAgI1xuICAgICMgQHBhcmFtIG9wdGlvbnMgW09iamVjdF0gYW4gb2JqZWN0IG9mIG9wdGlvbnNcbiAgICAjIEBvcHRpb24gb3B0aW9ucyBlbGVtZW50IFtTdHJvcGhlLkJ1aWxkZXJdIGEgcmVxdWVzdCBzdGFuemFcbiAgICAjIEBvcHRpb24gb3B0aW9ucyByZXNvbHZlIFtGdW5jdGlvbl0gYWxsb3dzIHVzIHRvIHJlc29sdmUgdGhlIGNhbGxlcidzXG4gICAgIyAgIGRlZmVycmVkIG9iamVjdCBvciBhcyBhIGdlbmVyaWMgY2FsbGJhY2tcbiAgICAjIEBvcHRpb24gb3B0aW9ucyByZWplY3QgW0Z1bmN0aW9uXSBhbGxvd3MgdXMgdG8gcmVqZWN0IHRoZSBjYWxsZXInc1xuICAgICMgICBkZWZlcnJlZCBvYmplY3Qgb3IgYXMgYSBnZW5lcmljIGVycmJhY2tcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtdXG4gICAgc2VuZCA9IChvcHRpb25zID0ge30pIC0+XG4gICAgICB7ZWxlbWVudCwgcmVzb2x2ZSwgcmVqZWN0fSA9IG9wdGlvbnNcblxuICAgICAgIyBUT0RPOiBhZGQgbG9nZ2luZyBhbmQgcHJpbnQgU3Ryb3BoZS5zZXJpYWxpemUgc3RhbnphXG4gICAgICBpZiBlcnJvck1zZyA9IGNoZWNrRm9yRXJyb3IgZWxlbWVudCwgQGlzQ29ubmVjdGVkKClcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IgZXJyb3JNc2dcbiAgICAgICAgcmV0dXJuIHJlamVjdD8gZXJyb3JcblxuICAgICAgQF9jb25uZWN0aW9uLnNlbmQgZWxlbWVudFxuXG5cbiAgICAgICMgRGVjb3JhdGUgdGhlIHJlc29sdmUgZnVuY3Rpb24gdG8gYXNzZW1ibGUgYSBkYXRhIHBheWxvYWQgd2hlbiBpbnZva2VkLlxuICAgICAgcmVzb2x2ZSA9IHJlc29sdmVXaXRoRGF0YSByZXNvbHZlXG5cbiAgICAgICMgQXV0by1yZXNvbHZlICdzZW5kJyByZXF1ZXN0cyBzaW5jZSB0aGV5IGFyZSBmaXJlIGFuZCBmb3JnZXQuXG4gICAgICByZXNvbHZlIGVsZW1lbnQudHJlZSgpXG5cbiAgICAjIFNlbmQgYSByZXF1ZXN0IHVzaW5nIFN0cm9waGVcbiAgICAjXG4gICAgIyBAcGFyYW0gb3B0aW9ucyBbT2JqZWN0XSBhbiBvYmplY3Qgb2Ygb3B0aW9uc1xuICAgICMgQG9wdGlvbiBvcHRpb25zIGVsZW1lbnQgW1N0cm9waGUuQnVpbGRlcl0gYSByZXF1ZXN0IHN0YW56YVxuICAgICMgQG9wdGlvbiBvcHRpb25zIHJlc29sdmUgW0Z1bmN0aW9uXSBhbGxvd3MgdXMgdG8gcmVzb2x2ZSB0aGUgY2FsbGVyJ3NcbiAgICAjICAgZGVmZXJyZWQgb2JqZWN0IG9yIGFzIGEgZ2VuZXJpYyBjYWxsYmFja1xuICAgICMgQG9wdGlvbiBvcHRpb25zIHJlamVjdCBbRnVuY3Rpb25dIGFsbG93cyB1cyB0byByZWplY3QgdGhlIGNhbGxlcidzXG4gICAgIyAgIGRlZmVycmVkIG9iamVjdCBvciBhcyBhIGdlbmVyaWMgZXJyYmFja1xuICAgICNcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gaWQgb2YgdGhlIHJlcXVlc3QsIHVzZWQgdG8gbWF0Y2ggdXAgd2l0aCBmdXR1cmUgcHVzaFxuICAgIHNlbmRJUSA9IChvcHRpb25zID0ge30pIC0+XG4gICAgICB7ZWxlbWVudCwgcmVzb2x2ZSwgcmVqZWN0fSA9IG9wdGlvbnNcblxuICAgICAgIyBUT0RPOiBhZGQgbG9nZ2luZyBhbmQgcHJpbnQgU3Ryb3BoZS5zZXJpYWxpemUgZWxlbVxuICAgICAgaWYgZXJyb3JNc2cgPSBjaGVja0ZvckVycm9yIGVsZW1lbnQsIEBpc0Nvbm5lY3RlZCgpXG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yIGVycm9yTXNnXG4gICAgICAgIHJldHVybiByZWplY3Q/IGVycm9yXG5cbiAgICAgICMgRGVjb3JhdGUgdGhlIHJlc29sdmUgZnVuY3Rpb24gdG8gYXNzZW1ibGUgYSBkYXRhIHBheWxvYWQgd2hlbiBpbnZva2VkLlxuICAgICAgcmVzb2x2ZSA9IHJlc29sdmVXaXRoRGF0YSByZXNvbHZlXG4gICAgICByZWplY3QgPSByZWplY3RXaXRoRGF0YSByZWplY3RcblxuICAgICAgQF9jb25uZWN0aW9uLnNlbmRJUSBlbGVtZW50LCByZXNvbHZlLCByZWplY3RcblxuXG4gICAgIyBAcHJpdmF0ZVxuICAgICMgRGVjb3JhdGUgYSBwcm9taXNlJ3MgcmVzb2x2ZSBmdW5jdGlvbiBieSByZXR1cm5pbmcgb25lIHRoYXQgcGFzc2VzIGluXG4gICAgIyBhIGRhdGEgcGFja2FnZSB3aGljaCBpcyBhbiBvYmplY3Qgd2l0aCBYTUwsIEpTT04sIGFuZCBmdW5jdGlvbnNcbiAgICAjXG4gICAgIyBAcGFyYW0gcmVzb2x2ZSBbRnVuY3Rpb25dIGEgcmVzb2x2ZSBtZXRob2Qgb2YgYSBwcm9taXNlXG4gICAgI1xuICAgICMgQHJldHVybiBbRnVuY3Rpb25dIGEgZGVjb3JhdGVkIHJlc29sdmUgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBvcmlnaW5hbFxuICAgICMgICByZXNvbHZlIG1ldGhvZCB3aXRoIGEgZGF0YSBwYWNrYWdlIG9iamVjdFxuICAgIHJlc29sdmVXaXRoRGF0YSA9IChyZXNvbHZlKSAtPlxuICAgICAgKHN0YW56YSkgLT5cbiAgICAgICAgZGF0YSA9IGRhdGFQYXlsb2FkLmdldERhdGEgc3RhbnphXG4gICAgICAgIGlmIF8uaXNGdW5jdGlvbiByZXNvbHZlXG4gICAgICAgICAgcmVzb2x2ZS5jYWxsIG51bGwsIGRhdGFcblxuICAgICMgQHByaXZhdGVcbiAgICAjIEFsaWFzIHRvIHJlc29sdmVXaXRoRGF0YSgpLCB0aGlzIGRlY29yYXRlcyBhIHByb21pc2UncyByZXNvbHZlIGZ1bmN0aW9uIGJ5XG4gICAgIyByZXR1cm5pbmcgb25lIHRoYXQgcGFzc2VzIGluIGEgZGF0YSBwYWNrYWdlIHdoaWNoIGlzIGFuIG9iamVjdCB3aXRoIFhNTCxcbiAgICAjIEpTT04sIGFuZCBmdW5jdGlvbnNcbiAgICAjXG4gICAgIyBAcGFyYW0gcmVqZWN0IFtGdW5jdGlvbl0gYSByZWplY3QgbWV0aG9kIG9mIGEgcHJvbWlzZVxuICAgICNcbiAgICAjIEByZXR1cm4gW0Z1bmN0aW9uXSBhIGRlY29yYXRlZCByZWplY3QgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBvcmlnaW5hbFxuICAgICMgICByZWplY3QgbWV0aG9kIHdpdGggYSBkYXRhIHBhY2thZ2Ugb2JqZWN0XG4gICAgcmVqZWN0V2l0aERhdGEgPSAocmVqZWN0KSAtPlxuICAgICAgcmVzb2x2ZVdpdGhEYXRhIHJlamVjdFxuXG4gICAgIyBAcHJpdmF0ZVxuICAgICMgQ2hlY2tzIGZvciBlcnJvciBjb25kaXRpb25zIGZvciBjYWxscyB0byAjc2VuZCgpIGFuZCAjc2VuZElRKClcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIGFuIGVycm9yIHN0cmluZyBvciBhbiBlbXB0eSBzdHJpbmdcbiAgICBjaGVja0ZvckVycm9yID0gKGVsZW1lbnQsIGlzQ29ubmVjdGVkKSAtPlxuICAgICAgc3dpdGNoIGZhbHNlXG4gICAgICAgIHdoZW4gZWxlbWVudCBpbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgICAgIFwiRGF0YSBpcyBub3QgYSBTdHJvcGhlLkJ1aWxkZXIgaW5zdGFuY2VcIlxuICAgICAgICB3aGVuIGlzQ29ubmVjdGVkXG4gICAgICAgICAgXCJDYW4gbm90IGNhbGwgc2VuZElRIHVubGVzcyB1c2VyIGlzIENPTk5FQ1RFRFwiXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBcIlwiXG4iLCIjIE5hbWVzcGFjZXMgdXNlZCB0byBzcGVjaWZ5IHJlcXVlc3RzIGZvciByZXF1ZXN0aW5nIGFuZCByZWNlaXZpbmcgbWVzc2FnZSBhY2tzXG5tb2R1bGUuZXhwb3J0cyA9XG4gICMgTmFtZXNwYWNlcyBmb3IgcmVjZWlwdHNcbiAgTklUUk9fUkVDRUlQVFM6ICduaXRybzp4bXBwOnJlY2VpcHRzJ1xuICBTVEFOREFSRF9SRUNFSVBUUzogJ3Vybjp4bXBwOnJlY2VpcHRzJ1xuIiwibW9kdWxlLmV4cG9ydHMgPVxuICBDSEFUX1NUQVRFUzogJ2h0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL2NoYXRzdGF0ZXMnXG4iLCIjIENvbnRhbnRzIGZvciB2YXJpb3VzIHJvbGVzIGZvciBwZW9wbGUgY3JlYXRpbmcsIG1hbmFnaW5nIG9yIHBhcnRpY2lwYXRpbmcgaW4gTVVDc1xubW9kdWxlLmV4cG9ydHMgPVxuICBNRVNTQUdFX0JMT0NLOiAnbWVzc2FnZS5ibG9jaydcbiAgTUVTU0FHRV9TT0ZUX0JMT0NLOiAnbWVzc2FnZS5zb2Z0LmJsb2NrJ1xuICBNRVNTQUdFX1NPRlRfQkxPQ0tfRkxBRzogODIzOVxuICBNRVNTQUdFX0JMT0NLX0NPREU6ICc0MDUnXG4gIE1FU1NBR0VfSEFSRF9CTE9DS19DT0RFOiAnNDA2J1xuIiwibW9kdWxlLmV4cG9ydHMgPVxuICBJTlZBTElEX0NSRURFTlRJQUxTOiAnaW52YWxpZF9jcmVkZW50aWFscydcbiAgXG4gIE5PX05JVFJPX0NPTk5FQ1RJT046ICdub19uaXRyb19jb25uZWN0aW9uJ1xuXG4gIEFMUkVBRFlfUkVHSVNURVJJTkc6ICdhbHJlYWR5X3JlZ2lzdGVyaW5nJ1xuICBBTFJFQURZX1VOUkVHSVNURVJJTkc6ICdhbHJlYWR5X3VucmVnaXN0ZXJlZCdcbiAgQUxSRUFEWV9TVUJTQ1JJQklORzogJ2FscmVhZHlfc3Vic2NyaWJpbmcnXG4gIEFMUkVBRFlfVU5TVUJTQ1JJQklORzogJ2FscmVhZHlfdW5zdWJzY3JpYmluZydcbiIsIm1vZHVsZS5leHBvcnRzID1cbiAgUkVHSVNURVJJTkc6ICdyZWdpc3RlcmluZydcbiAgUkVHSVNURVJFRDogJ3JlZ2lzdGVyZWQnXG4gIFNVQlNDUklCSU5HOiAnc3Vic2NyaWJpbmcnXG4gIFNVQlNDUklCRUQ6ICdzdWJzY3JpYmVkJ1xuICBVTlJFR0lTVEVSSU5HOiAndW5yZWdpc3RlcmluZydcbiAgVU5SRUdJU1RFUkVEOiAndW5yZWdpc3RlcmVkJ1xuIiwibW9kdWxlLmV4cG9ydHMgPVxuICBZQUhPTzogJ3lhaG9vJ1xuIiwiIyBOYW1lc3BhY2VzIHVzZWQgdG8gc3BlY2lmeSByZXF1ZXN0cyBmb3IgZ2V0dGluZyBoaXN0b3J5IG1lc3NhZ2VzXG5tb2R1bGUuZXhwb3J0cyA9XG4gICMgTmFtZXNwYWNlIGZvciBjaGF0IGhpc3RvcnlcbiAgQ0hBVF9ISVNUT1JZOiAndXJuOnhtcHA6bWFtOnRtcCdcblxuICAjIE5hbWVzcGFjZSBmb3IgJ3Jlc3VsdCBzZXAgbWFuYWdlbWVudCdcbiAgUlNNOiAnaHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvcnNtJ1xuXG4gICMgTmFtZXNwYWNlIG9mIDxkZWxheS8+IHN0YW56YSBpbiBncm91cGNoYXQgaGlzdG9yeSBtZXNzYWdlc1xuICBERUxBWTogJ3Vybjp4bXBwOmRlbGF5J1xuXG4gIFNFQVJDSDogJ2phYmJlcjppcTpzZWFyY2gnXG4iLCIjIENvbnN0YW50cyBmb3IgbWVzc2FnZSB0eXBlc1xubW9kdWxlLmV4cG9ydHMgPVxuICAjIFRoZSBjaGF0IGluY2x1ZGVzIDEtMVxuICBDSEFUOiAnY2hhdCdcblxuICAjIFRoZSBncm91cGNoYXQgaXMgZm9yIGFueSBncm91cCBjaGF0XG4gIEdST1VQQ0hBVDogJ2dyb3VwY2hhdCdcbiIsIiMgQ29uc3RhbnRzIGZvciB0aGUgdmFsdWUgb2YgYSBNVUMgZXJyb3IncyB0eXBlIGF0dHJpYnV0ZVxubW9kdWxlLmV4cG9ydHMgPVxuICBBVVRIOiAnYXV0aCdcbiAgQ0FOQ0VMOiAnY2FuY2VsJ1xuICBNT0RJRlk6ICdtb2RpZnknXG4gIFdBSVQ6ICd3YWl0J1xuIiwiIyBDb25zdGFudHMgZm9yIEdyb3VwY2hhdCBFcnJvciBUeXBlc1xubW9kdWxlLmV4cG9ydHMgPVxuICAjIFRoZSBncm91cGNoYXQgaXMgZm9yIGFueSBncm91cCBjaGF0XG4gIElURU1fTk9UX0ZPVU5EOiAnaXRlbS1ub3QtZm91bmQnXG4iLCIjIENvbnN0YW50cyBmb3IgTVVDIFN0cm9waGUgc3RhbnphIGZpZWxkIG5hbWVzXG4jXG4jIEBzZWUgc3Ryb3BoZS9zdHJvcGhlX211Yy5jb2ZmZWUuaHRtbFxubW9kdWxlLmV4cG9ydHMgPVxuICBST09NX05BTUU6ICdtdWMjcm9vbWNvbmZpZ19yb29tbmFtZSdcbiAgRk9STV9UWVBFOiAnRk9STV9UWVBFJ1xuIiwiIyBDb25zdGFudHMgZm9yIE1VQyByZWxhdGVkIHN0YW56YSBub2RlcyByZWNlaXZlZCBmcm9tIE5pdHJvXG5tb2R1bGUuZXhwb3J0cyA9XG5cbiAgIyBYTUwgbm9kZSBuYW1lIGZvciBXQ1AgY2hhdHJvb21cbiAgV0NQOiAnd2NwY2hhdHJvb20nXG5cbiAgIyBYTUwgbm9kZSBuYW1lIGZvciBXQ1AgYmlsYXRlcmFsIGNoYXRcbiAgQ09ORkVSRU5DRTogJ2NvbmZlcmVuY2UnXG5cbiAgIyBYTUwgbm9kZSBuYW1lIGZvciBkZXNrXG4gIERFU0s6ICdkZXNrJ1xuIiwibW9kdWxlLmV4cG9ydHMgPVxuICBST09UOiAnaHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvbXVjJ1xuICBPV05FUjogJ2h0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL211YyNvd25lcidcbiAgQURNSU46ICdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWMjYWRtaW4nXG4gIFVTRVI6ICdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWMjdXNlcidcbiAgRElTQ09fSU5GTzogJ2h0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL2Rpc2NvI2luZm8nXG4iLCIjIENvbnRhbnRzIGZvciB2YXJpb3VzIHJvbGVzIGZvciBwZW9wbGUgY3JlYXRpbmcsIG1hbmFnaW5nIG9yIHBhcnRpY2lwYXRpbmcgaW4gTVVDc1xubW9kdWxlLmV4cG9ydHMgPVxuICBPV05FUjogJ293bmVyJ1xuICBBRE1JTjogJ2FkbWluJ1xuICBQQVJUSUNJUEFOVDogJ3BhcnRpY2lwYW50J1xuICBNT0RFUkFUT1I6ICdtb2RlcmF0b3InXG4gIE5PTkU6ICdub25lJ1xuICBNRU1CRVI6ICdtZW1iZXInXG4iLCJtb2R1bGUuZXhwb3J0cyA9XG4gIE1BTkFHRUQ6IFwibWFuYWdlZFwiXG4gIEJJTEFURVJBTDogXCJiaWxhdGVyYWxcIlxuICBERVNLOiBcImRlc2tcIlxuIiwibW9kdWxlLmV4cG9ydHMgPVxuICAjIEBwcm9wZXJ0eSBUZXh0IHZhbHVlIGZvciA8c2hvdz4gc3RhbnphIHdpdGhpbiB0aGUgPHByZXNlbmNlPiBzdGFuemFcbiAgIyAgIFRoZSBlbnRpdHkgb3IgcmVzb3VyY2UgaXMgdGVtcG9yYXJpbHkgYXdheS5cbiAgQVdBWTogJ2F3YXknXG5cbiAgIyBAcHJvcGVydHkgVGV4dCB2YWx1ZSBmb3IgPHNob3c+IHN0YW56YSB3aXRoaW4gdGhlIDxwcmVzZW5jZT4gc3RhbnphXG4gICMgICBUaGUgZW50aXR5IG9yIHJlc291cmNlIGlzIGFjdGl2ZWx5IGludGVyZXN0ZWQgaW4gY2hhdHRpbmcuXG4gIENIQVQ6ICdpbnZpc2libGUnXG4gIFxuICAjIEBwcm9wZXJ0eSBUZXh0IHZhbHVlIGZvciA8c2hvdz4gc3RhbnphIHdpdGhpbiB0aGUgPHByZXNlbmNlPiBzdGFuemFcbiAgIyAgIFRoZSBlbnRpdHkgb3IgcmVzb3VyY2UgaXMgYnVzeSAoZG5kID0gXCJEbyBOb3QgRGlzdHVyYlwiKS5cbiAgRE5EOiAnZG5kJ1xuXG4gICMgQHByb3BlcnR5IFRleHQgdmFsdWUgZm9yIDxzaG93PiBzdGFuemEgd2l0aGluIHRoZSA8cHJlc2VuY2U+IHN0YW56YVxuICAjICAgVGhlIGVudGl0eSBvciByZXNvdXJjZSBpcyBhd2F5IGZvciBhbiBleHRlbmRlZCBwZXJpb2QgKHhhID0gXCJlWHRlbmRlZCBBd2F5XCIpLlxuICBFWFRFTkRFRF9BV0FZOiAneGEnXG4iLCJtb2R1bGUuZXhwb3J0cyA9XG4gICMgQHByb3BlcnR5IHR5cGUgYXR0cmlidXRlIGZvciA8cHJlc2VuY2U+IHN0YW56YS5cbiAgIyAgIFNpZ25hbHMgdGhhdCB0aGUgZW50aXR5IGlzIG5vIGxvbmdlciBhdmFpbGFibGUgZm9yIGNvbW11bmljYXRpb24uXG4gIFVOQVZBSUxBQkxFOiAndW5hdmFpbGFibGUnXG5cbiAgIyBAcHJvcGVydHkgdHlwZSBhdHRyaWJ1dGUgZm9yIDxwcmVzZW5jZT4gc3RhbnphLlxuICAjICAgVGhlIHNlbmRlciB3aXNoZXMgdG8gc3Vic2NyaWJlIHRvIHRoZSByZWNpcGllbnQncyBwcmVzZW5jZS5cbiAgU1VCU0NSSUJFOiAnc3Vic2NyaWJlJ1xuXG4gICMgQHByb3BlcnR5IHR5cGUgYXR0cmlidXRlIGZvciA8cHJlc2VuY2U+IHN0YW56YS5cbiAgIyAgIFRoZSBzZW5kZXIgaGFzIGFsbG93ZWQgdGhlIHJlY2lwaWVudCB0byByZWNlaXZlIHRoZWlyIHByZXNlbmNlLlxuICBTVUJTQ1JJQkVEOiAnc3Vic2NyaWJlZCdcblxuICAjIEBwcm9wZXJ0eSB0eXBlIGF0dHJpYnV0ZSBmb3IgPHByZXNlbmNlPiBzdGFuemEuXG4gICMgICBUaGUgc2VuZGVyIGlzIHVuc3Vic2NyaWJpbmcgZnJvbSBhbm90aGVyIGVudGl0eSdzIHByZXNlbmNlLlxuICBVTlNVQlNDUklCRTogJ3Vuc3Vic2NyaWJlJ1xuXG4gICMgQHByb3BlcnR5IHR5cGUgYXR0cmlidXRlIGZvciA8cHJlc2VuY2U+IHN0YW56YS5cbiAgIyAgIFRoZSBzdWJzY3JpcHRpb24gcmVxdWVzdCBoYXMgYmVlbiBkZW5pZWQgb3IgYSBwcmV2aW91c2x5LWdyYW50ZWRcbiAgIyAgIHN1YnNjcmlwdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQuXG4gIFVOU1VCU0NSSUJFRDogJ3Vuc3Vic2NyaWJlZCdcblxuICAjIEBwcm9wZXJ0eSB0eXBlIGF0dHJpYnV0ZSBmb3IgPHByZXNlbmNlPiBzdGFuemEuXG4gICMgICBBIHJlcXVlc3QgZm9yIGFuIGVudGl0eSdzIGN1cnJlbnQgcHJlc2VuY2U7IFNIT1VMRCBiZSBnZW5lcmF0ZWQgb25seSBieVxuICAjICAgYSBzZXJ2ZXIgb24gYmVoYWxmIG9mIGEgdXNlci5cbiAgUFJPQkU6ICdwcm9iZSdcblxuICAjIEBwcm9wZXJ0eSB0eXBlIGF0dHJpYnV0ZSBmb3IgPHByZXNlbmNlPiBzdGFuemEuXG4gICMgICBBbiBlcnJvciBoYXMgb2NjdXJyZWQgcmVnYXJkaW5nIHByb2Nlc3Npbmcgb3IgZGVsaXZlcnkgb2YgYVxuICAjICAgcHJldmlvdXNseS1zZW50IHByZXNlbmNlIHN0YW56YS5cbiAgRVJST1I6ICdlcnJvcidcbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICAnRXJyb3InXG4gICdDb25uZWN0aW5nJ1xuICAnQ29ubkZhaWwnXG4gICdBdXRoZW50aWNhdGluZydcbiAgJ0F1dGhGYWlsJ1xuICAnQ29ubmVjdGVkJ1xuICAnRGlzY29ubmVjdGVkJ1xuICAnRGlzY29ubmVjdGluZydcbiAgJ0F0dGFjaGVkJ1xuICAnUmVkaXJlY3QnXG4gICdDb25uVGltZW91dCdcbl1cbiIsIlN0cm9waGUgPSByZXF1aXJlICdzdHJvcGhlJ1xuXG5tb2R1bGUuZXhwb3J0cyA9XG4gICMgQHByb3BlcnR5IFtOdW1iZXJdIHN0YXRpYyBzdGF0dXMgcHJvcGVydHksIHZhbHVlIGlzIDFcbiAgQ09OTkVDVElORzogU3Ryb3BoZS5TdGF0dXMuQ09OTkVDVElOR1xuXG4gICMgQHByb3BlcnR5IFtOdW1iZXJdIHN0YXRpYyBzdGF0dXMgcHJvcGVydHksIHZhbHVlIGlzIDJcbiAgQ09OTkZBSUw6IFN0cm9waGUuU3RhdHVzLkNPTk5GQUlMXG5cbiAgIyBAcHJvcGVydHkgW051bWJlcl0gc3RhdGljIHN0YXR1cyBwcm9wZXJ0eSwgdmFsdWUgaXMgM1xuICBBVVRIRU5USUNBVElORzogU3Ryb3BoZS5TdGF0dXMuQVVUSEVOVElDQVRJTkdcblxuICAjIEBwcm9wZXJ0eSBbTnVtYmVyXSBzdGF0aWMgc3RhdHVzIHByb3BlcnR5LCB2YWx1ZSBpcyA0XG4gIEFVVEhGQUlMOiBTdHJvcGhlLlN0YXR1cy5BVVRIRkFJTFxuXG4gICMgQHByb3BlcnR5IFtOdW1iZXJdIHN0YXRpYyBzdGF0dXMgcHJvcGVydHksIHZhbHVlIGlzIDVcbiAgQ09OTkVDVEVEOiBTdHJvcGhlLlN0YXR1cy5DT05ORUNURURcblxuICAjIEBwcm9wZXJ0eSBbTnVtYmVyXSBzdGF0aWMgc3RhdHVzIHByb3BlcnR5LCB2YWx1ZSBpcyA2XG4gIERJU0NPTk5FQ1RFRDogU3Ryb3BoZS5TdGF0dXMuRElTQ09OTkVDVEVEXG5cbiAgIyBAcHJvcGVydHkgW051bWJlcl0gc3RhdGljIHN0YXR1cyBwcm9wZXJ0eSwgdmFsdWUgaXMgN1xuICBESVNDT05ORUNUSU5HOiBTdHJvcGhlLlN0YXR1cy5ESVNDT05ORUNUSU5HXG5cbiAgIyBAcHJvcGVydHkgW051bWJlcl0gc3RhdGljIHN0YXR1cyBwcm9wZXJ0eSwgdmFsdWUgaXMgOFxuICBGQVRBTF9GQUlMVVJFOiA4XG5cbiAgIyBAcHJvcGVydHkgW051bWJlcl0gc3RhdGljIHN0YXR1cyBwcm9wZXJ0eSwgdmFsdWUgaXMgOVxuICBSRURJUkVDVDogOVxuXG4gICMgQHByb3BlcnR5IFtOdW1iZXJdIHN0YXRpYyBzdGF0dXMgcHJvcGVydHksIHZhbHVlIGlzIDEwXG4gIENPTk5USU1FT1VUOiAxMFxuIiwiIyBDb25zdGFudHMgZm9yIGNoYXQgb3IgZ3JvdXBjaGF0IHN1YnNjcmlwdGlvbiBzdGF0dXNcbiNcbiMgQHNlZSBzdHJvcGhlL3N0cm9waGVfbXVjLmNvZmZlZS5odG1sXG5tb2R1bGUuZXhwb3J0cyA9XG4gIFNVQlNDUklCSU5HOiAnc3Vic2NyaWJpbmcnXG4gIFNVQlNDUklCRUQ6ICdzdWJzY3JpYmVkJ1xuICBVTlNVQlNDUklCSU5HOiAndW5zdWJzY3JpYmluZydcbiAgVU5TVUJTQ1JJQkVEOiAndW5zdWJzY3JpYmVkJ1xuIiwiUHJlc2VuY2VUeXBlID0gcmVxdWlyZSAnZW51bS9wcmVzZW5jZV90eXBlJ1xuUHJlc2VuY2VTaG93ID0gcmVxdWlyZSAnZW51bS9wcmVzZW5jZV9zaG93J1xuXG4jIFRoZXNlIHByZXNlbmNlIHN0YXR1ZXMgYXJlIHRoZSBjYW5ub25pY2FsIFhNUFAgc3RhdHVzZXMuXG5tb2R1bGUuZXhwb3J0cyA9XG4gICMgQHByb3BlcnR5IFtTdHJpbmddICdhdmFpbGFibGUnXG4gIEFWQUlMQUJMRTogJ2F2YWlsYWJsZSdcblxuICAjIEBwcm9wZXJ0eSBbU3RyaW5nXSAnYXdheSdcbiAgQVdBWTogUHJlc2VuY2VTaG93LkFXQVlcbiAgXG4gICMgQHByb3BlcnR5IFtTdHJpbmddICd4YSdcbiAgRVhURU5ERURfQVdBWTogUHJlc2VuY2VTaG93LkVYVEVOREVEX0FXQVlcbiAgXG4gICMgQHByb3BlcnR5IFtTdHJpbmddICdkbmQnXG4gIERORDogUHJlc2VuY2VTaG93LkRORFxuICBcbiAgIyBAcHJvcGVydHkgW1N0cmluZ10gJ3VuYXZhaWxhYmxlJ1xuICBVTkFWQUlMQUJMRTogUHJlc2VuY2VUeXBlLlVOQVZBSUxBQkxFXG5cbiAgIyBAcHJvcGVydHkgW1N0cmluZ10gJ2ludmlzaWJsZSdcbiAgIyBvdXRnb2luZyB0byBOaXRybyBvbmx5XG4gIElOVklTSUJMRTogJ2ludmlzaWJsZSdcbiIsIiMgQ29uc3RhbnRzIGZvciBZYWhvbyBFcnJvciBUeXBlc1xubW9kdWxlLmV4cG9ydHMgPVxuICAjIE5vdCBhY3R1YWxseSBsb2dnZWQgaW50byB5YWhvb1xuICBOT1RfUkVHSVNURVJFRDogJ25vdC1yZWdpc3RlcmVkJ1xuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5fLm1peGluIHJlcXVpcmUgJ3V0aWwvbm90J1xuU2l6emxlID0gcmVxdWlyZSAnc2l6emxlJ1xuQ29uZmlnID0gcmVxdWlyZSAnY29uZmlnJ1xuU3Ryb3BoZSA9IHJlcXVpcmUgJ3N0cm9waGUnXG5YTVBQVXRpbHMgPSByZXF1aXJlICd1dGlsL3htcHBfdXRpbHMnXG5NYXRjaGVycyA9IHJlcXVpcmUgJ3V0aWwvbWF0Y2hlcnMnXG5NVUNFcnJvclR5cGUgPSByZXF1aXJlICdlbnVtL211Y19lcnJvcl90eXBlJ1xuQ2hhdFN0YXRlc05TID0gcmVxdWlyZSAnZW51bS9jaGF0X3N0YXRlc19ucydcblxuIyBUaGlzIGNsYXNzIGNvbnRhaW5zIHN0YXRpYyBtZXRob2RzIG9mIGZpbHRlcnMgdG8gcmVqZWN0IGluY29taW5nIFN0cm9waGUgZXZlbnRzXG4jIGFzIG5lZWRlZCBhcyB3ZWxsIGFzIGEgZnVuY3Rpb24gdG8gcnVuIGEgc2VyaWVzIG9mIGZpbHRlcnMgYmFzZWQgb24gYSBsaXN0XG4jIG9mIGZpbHRlciBmdW5jdGlvbiBuYW1lcy5cblxuIyBAbWV0aG9kIC5pc250TVVDKHN0YW56YSlcbiMgICBEZXRlcm1pbmUgaWYgdGhlIHN0YW56YSBkb2VzIG5vdCByZXByZXNlbnQgYSBNVUMgLSB0aGUgb3Bwb3NpdGUgb2YgaXNNdWMoKVxuI1xuIyAgIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4jXG4jICAgQHJldHVybiBbQm9vbGVhbl0gdHJ1ZSBpZiBpdCBpcyBub3QgYSBNVUNcbiNcbiMgICBAc2VlIEV2ZW50RmlsdGVycy5pc01VQ1xuI1xuIyBAbWV0aG9kIC5pc250TVVDSW52aXRlKHN0YW56YSlcbiMgICBEZXRlcm1pbmUgaWYgdGhlIHN0YW56YSBkb2VzIG5vdCByZXByZXNlbnQgYSBNVUMgaW52aXRlIChncm91cGNoYXQgaW52aXRlKVxuI1xuIyAgIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4jXG4jICAgQHJldHVybiBbQm9vbGVhbl0gdHJ1ZSB1bmxlc3MgaXQgaXMgYSBNVUMgYW5kIGNvbnRhaW5zIGFuIGludml0ZSBlbGVtZW50XG4jXG4jICAgQHNlZSBFdmVudEZpbHRlcnMuaXNNVUNJbnZpdGVcbiNcbiMgQG1ldGhvZCAuaXNudE1VQ1N1YmplY3Qoc3RhbnphKVxuIyAgIERldGVybWluZSBpZiB0aGUgc3RhbnphIGRvZXMgbm90IHJlcHJlc2VudCBhIE1VQyBpbnZpdGUgKGdyb3VwY2hhdCBpbnZpdGUpXG4jXG4jICAgQHBhcmFtIHN0YW56YSBbWE1MXSB4bWwgc3RhbnphIHJlY2VpdmVkIGZyb20gU3Ryb3BoZSBmb3IgYW4gZXZlbnRcbiNcbiMgICBAcmV0dXJuIFtCb29sZWFuXSB0cnVlIHVubGVzcyBpdCBpcyBhIE1VQyBhbmQgY29udGFpbnMgYW4gaW52aXRlIGVsZW1lbnRcbiNcbiMgICBAc2VlIEV2ZW50RmlsdGVycy5pc01VQ1N1YmplY3RcbiNcbiMgQG1ldGhvZCAuaGFzbnRUeXBlKHN0YW56YSlcbiMgICBEZXRlcm1pbmUgaWYgdGhlIHN0YW56YSBjb250YWlucyBhICd0eXBlJyBhdHRyaWJ1dGVcbiNcbiMgICBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBldmVudFxuI1xuIyAgIEByZXR1cm4gW0Jvb2xlYW5dIHRydWUgaWYgaGFzIHRoZSAndHlwZScgYXR0cmlidXRlXG4jXG4jICAgQHNlZSBFdmVudEZpbHRlcnMuaGFzVHlwZVxuI1xuIyBAbWV0aG9kIC5pc250U2VsZihzdGFuemEsIHNlbGZKSUQpXG4jICAgRGV0ZXJtaW5lIGlmIHRoZSBzdGFuemEgd2FzIG5vdCBzZW50IGZyb20gc2VsZiAtIHRoZSBvcHBvc2l0ZSBvZiBpc1NlbGYoKVxuI1xuIyAgIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4jICAgQHBhcmFtIHNlbGZKSUQgW1N0cmluZ10gdXNlciBKSURcbiNcbiMgICBAcmV0dXJuIFtCb29sZWFuXSB0cnVlIGlmIHN0YW56YSBpcyBub3QgZnJvbSBzZWxmXG4jXG4jICAgQHNlZSBFdmVudEZpbHRlcnMuaXNTZWxmXG4jXG4jIEBtZXRob2QgLmlzbnRNVUNTZWxmKHN0YW56YSwgc2VsZkpJRClcbiMgICBEZXRlcm1pbmUgaWYgdGhlIHN0YW56YSB3YXMgbm90IHNlbnQgZnJvbSBzZWxmIGluIGEgTVVDIChncm91cGNoYXQpIC1cbiMgICB0aGUgb3Bwb3NpdGUgb2YgaXNTZWxmKClcbiNcbiMgICBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBldmVudFxuIyAgIEBwYXJhbSBzZWxmSklEIFtTdHJpbmddIHVzZXIgSklEXG4jXG4jICAgQHJldHVybiBbQm9vbGVhbl0gdHJ1ZSBpZiBzdGFuemEgaXMgbm90IGZyb20gc2VsZiBpbiBhIE1VQyAoZ3JvdXBjaGF0KVxuI1xuIyAgIEBzZWUgRXZlbnRGaWx0ZXJzLmlzTVVDU2VsZlxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFdmVudEZpbHRlcnNcblxuICAjIGtldmluLm1hZXMudGhvbXNvbnJldXRlcnMuY29tQHJldXRlcnMubmV0XG4gICMgcmVuYW1lIG11Y19yZXNvdXJjZVxuICAjIGtldmluLm1hZXMudGhvbXNvbnJldXRlcnMuY29tX19yZXV0ZXJzLm5ldFxuICAjIGZ1bGwgbXVjIGppZDogeHl6QGNvbmZlcmVuY2UucmV1dGVycy5uZXQva2V2aW4ubWFlcy50aG9tc29ucmV1dGVycy5jb21fX3JldXRlcnMubmV0XG4gIEBTRUxGX0pJRDogJ3NlbGZKSUQnXG5cbiAgIyBEZXRlcm1pbmUgaWYgdGhlIHN0YW56YSByZXByZXNlbnRzIGEgTVVDXG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBldmVudFxuICAjXG4gICMgQHJldHVybiBbQm9vbGVhbl0gdHJ1ZSBpZiBpdCBpcyBhIE1VQ1xuICBAaXNNVUM6IChzdGFuemEpIC0+XG4gICAgISFTaXp6bGUoJ3hbeG1sbnM9XCJodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWMjdXNlclwiXScsIHN0YW56YSkubGVuZ3RoIG9yXG4gICAgICBNYXRjaGVycy5pc0dyb3VwY2hhdCBzdGFuemEuZ2V0QXR0cmlidXRlICdmcm9tJ1xuXG4gIEBpc250TVVDOiBfLm5vdCBAaXNNVUNcblxuICAjIERldGVybWluZSBpZiB0aGUgc3RhbnphIHJlcHJlc2VudHMgYSBNVUMgaW52aXRlIChncm91cGNoYXQgaW52aXRlKVxuICAjXG4gICMgQHBhcmFtIHN0YW56YSBbWE1MXSB4bWwgc3RhbnphIHJlY2VpdmVkIGZyb20gU3Ryb3BoZSBmb3IgYW4gZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIHRydWUgaWYgaXQgaXMgYSBNVUMgYW5kIGNvbnRhaW5zIGFuIGludml0ZSBlbGVtZW50XG4gIEBpc01VQ0ludml0ZTogKHN0YW56YSkgLT5cbiAgICBFdmVudEZpbHRlcnMuaXNNVUMoc3RhbnphKSBhbmQgISFTaXp6bGUoJ2ludml0ZScsIHN0YW56YSkubGVuZ3RoXG5cbiAgQGlzbnRNVUNJbnZpdGU6IF8ubm90IEBpc01VQ0ludml0ZVxuXG4gICMgRGV0ZXJtaW5lIGlmIHRoZSBzdGFuemEgcmVwcmVzZW50cyBhIE1VQyBpbnZpdGUgKGdyb3VwY2hhdCBpbnZpdGUpXG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBldmVudFxuICAjXG4gICMgQHJldHVybiBbQm9vbGVhbl0gdHJ1ZSBpZiBpdCBpcyBhIE1VQyBhbmQgY29udGFpbnMgYW4gaW52aXRlIGVsZW1lbnRcbiAgQGlzTVVDU3ViamVjdDogKHN0YW56YSkgLT5cbiAgICBzdGFuemEuZ2V0QXR0cmlidXRlKCd0eXBlJykgaXMgJ2dyb3VwY2hhdCcgYW5kICEhU2l6emxlKCdzdWJqZWN0Jywgc3RhbnphKS5sZW5ndGhcblxuICBAaXNudE1VQ1N1YmplY3Q6IF8ubm90IEBpc01VQ1N1YmplY3RcblxuICAjIERldGVybWluZSBpZiB0aGUgc3RhbnphIHJlcHJlc2VudHMgYSBNVUMgaW52aXRlIChncm91cGNoYXQgaW52aXRlKVxuICAjXG4gICMgQHBhcmFtIHN0YW56YSBbWE1MXSB4bWwgc3RhbnphIHJlY2VpdmVkIGZyb20gU3Ryb3BoZSBmb3IgYW4gZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIHRydWUgaWYgaXQgaXMgYSBNVUMgYW5kIGNvbnRhaW5zIGFuIGludml0ZSBlbGVtZW50XG4gIEBpc0hpc3RvcnlGaW46IChzdGFuemEpIC0+XG4gICAgISFTaXp6bGUoJ2ZpbicsIHN0YW56YSkubGVuZ3RoXG5cbiAgQGlzbnRIaXN0b3J5RmluOiBfLm5vdCBAaXNIaXN0b3J5RmluXG5cblxuICAjIERldGVybWluZSBpZiB0aGUgc3RhbnphIGNvbnRhaW5zIGEgJ3R5cGUnIGF0dHJpYnV0ZVxuICAjXG4gICMgQHBhcmFtIHN0YW56YSBbWE1MXSB4bWwgc3RhbnphIHJlY2VpdmVkIGZyb20gU3Ryb3BoZSBmb3IgYW4gZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIHRydWUgaWYgaGFzIHRoZSAndHlwZScgYXR0cmlidXRlXG4gIEBoYXNUeXBlOiAoc3RhbnphKSAtPlxuICAgIG5vdCBfLmlzRW1wdHkgc3RhbnphLmdldEF0dHJpYnV0ZSAndHlwZSdcblxuICBAaGFzbnRUeXBlOiBfLm5vdCBAaGFzVHlwZVxuXG4gICMgRGV0ZXJtaW5lIGlmIHRoZSBzdGFuemEgd2FzIHNlbnQgZnJvbSBzZWxmXG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBldmVudFxuICAjIEBwYXJhbSBzZWxmSklEIFtTdHJpbmddIHVzZXIgSklEXG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSB0cnVlIGlmIHN0YW56YSBpcyBmcm9tIHNlbGZcbiAgQGlzU2VsZjogKHN0YW56YSwgc2VsZkpJRCkgLT5cbiAgICBzdGFuemEuZ2V0QXR0cmlidXRlKCdmcm9tJykgaXMgc2VsZkpJRC5yZXBsYWNlKFwiJ1wiLCBcIlxcXFwyN1wiKSBvclxuICAgIHN0YW56YS5nZXRBdHRyaWJ1dGUoJ2Zyb20nKSBpcyBzZWxmSklEXG5cbiAgQGlzbnRTZWxmOiBfLm5vdCBAaXNTZWxmXG5cbiAgIyBEZXRlcm1pbmUgaWYgdGhlIHN0YW56YSB3YXMgYSAnc3Vic2NyaWJlZCcgdXBkYXRlXG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBldmVudFxuICAjXG4gICMgQHJldHVybiBbQm9vbGVhbl0gdHJ1ZSBpZiBzdGFuemEgaGFzIHR5cGU9J3N1YnNjcmliZWQnXG4gIEBpc1N1YnNjcmliZWQ6IChzdGFuemEpIC0+XG4gICAgc3RhbnphLmdldEF0dHJpYnV0ZSgndHlwZScpIGlzICdzdWJzY3JpYmVkJ1xuXG4gIEBpc250U3Vic2NyaWJlZDogXy5ub3QgQGlzU3Vic2NyaWJlZFxuXG4gICMgRGV0ZXJtaW5lIGlmIHRoZSBzdGFuemEgd2FzIGEgJ3N1YnNjcmliZScgdXBkYXRlXG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBldmVudFxuICAjXG4gICMgQHJldHVybiBbQm9vbGVhbl0gdHJ1ZSBpZiBzdGFuemEgaGFzIHR5cGU9J3N1YnNjcmliZSdcbiAgQGlzU3Vic2NyaWJlOiAoc3RhbnphKSAtPlxuICAgIHN0YW56YS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSBpcyAnc3Vic2NyaWJlJ1xuXG4gIEBpc250U3Vic2NyaWJlOiBfLm5vdCBAaXNTdWJzY3JpYmVcblxuICAjIERldGVybWluZSBpZiB0aGUgc3RhbnphIHdhcyBhbiAndW5zdWJzY3JpYmUnIHVwZGF0ZVxuICAjXG4gICMgQHBhcmFtIHN0YW56YSBbWE1MXSB4bWwgc3RhbnphIHJlY2VpdmVkIGZyb20gU3Ryb3BoZSBmb3IgYW4gZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIHRydWUgaWYgc3RhbnphIGhhcyB0eXBlPSd1bnN1YnNjcmliZSdcbiAgQGlzVW5zdWJzY3JpYmU6IChzdGFuemEpIC0+XG4gICAgc3RhbnphLmdldEF0dHJpYnV0ZSgndHlwZScpIGlzICd1bnN1YnNjcmliZSdcblxuICBAaXNudFVuc3Vic2NyaWJlOiBfLm5vdCBAaXNVbnN1YnNjcmliZVxuXG4gICMgRGV0ZXJtaW5lIGlmIHRoZSBzdGFuemEgd2FzIHNlbnQgZnJvbSBiYXJlIGppZCBzZWxmXG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBldmVudFxuICAjIEBwYXJhbSBzZWxmSklEIFtTdHJpbmddIHVzZXIgSklEXG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSB0cnVlIGlmIHN0YW56YSBpcyBmcm9tIHNlbGZcbiAgQGlzUmVjaXBpZW50VW5hdmFpbGFibGU6IChzdGFuemEsIHNlbGZKSUQpIC0+XG4gICAgISFTaXp6bGUoJ3JlY2lwaWVudC11bmF2YWlsYWJsZScsIHN0YW56YSkubGVuZ3RoXG5cbiAgIyBEZXRlcm1pbmUgaWYgdGhlIHN0YW56YSB3YXMgc2VudCBmcm9tIHNlbGYgaW4gYSBNVUMgKGdyb3VwY2hhdClcbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4gICMgQHBhcmFtIHNlbGZKSUQgW1N0cmluZ10gdXNlciBKSURcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIHRydWUgaWYgc3RhbnphIGlzIGZyb20gc2VsZiBpbiBhIE1VQyAoZ3JvdXBjaGF0KVxuICBAaXNNVUNTZWxmOiAoc3RhbnphLCBzZWxmSklEKSAtPlxuICAgIHJlc291cmNlID0gU3Ryb3BoZS5nZXRSZXNvdXJjZUZyb21KaWQoIHN0YW56YS5nZXRBdHRyaWJ1dGUoJ2Zyb20nKSApXG4gICAgIyBhIG11YyBqaWQgYWx3YXlzIGhhcyBhIHJlc291cmNlIHZhbHVlXG4gICAgdW5sZXNzIHJlc291cmNlXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICBiYXJlU2VsZkpJRCA9IFN0cm9waGUuZ2V0QmFyZUppZEZyb21KaWQgc2VsZkpJRFxuICAgIGppZCA9IHJlc291cmNlLnJlcGxhY2UgJ19fJywgJ0AnXG4gICAgamlkID0gU3Ryb3BoZS51bmVzY2FwZU5vZGUgamlkXG4gICAgYmFyZVNlbGZKSUQgaXMgWE1QUFV0aWxzLmVtYWlsVG9KSUQoamlkLCBDb25maWcuZ2V0ICd4bXBwLmRvbWFpbicpIG9yXG4gICAgYmFyZVNlbGZKSUQgaXMgamlkXG5cbiAgICMgQHJldHVybiBbQm9vbGVhbl0gdHJ1ZSBpZiBzdGFuemEgaXMgbm90IGZyb20gc2VsZiBpbiBhIE1VQyAoZ3JvdXBjaGF0KVxuICBAaXNudE1VQ1NlbGY6IF8ubm90IEBpc01VQ1NlbGZcblxuICAjIERldGVybWluZSBpZiB0aGUgc3RhbnphIHJlcHJlc2VudHMgYW4gQWNrIGZyb20gdGhlIHNlcnZlciB3aGVuIGl0IHJlY2VpdmVzXG4gICMgYSBjaGF0IG1lc3NhZ2VcbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXVxuICBAaXNDaGF0QWNrOiAoc3RhbnphKSAtPlxuICAgICMgY2hlY2sgZm9yIDxhbXA+PHJ1bGUvPjxhbXA+XG4gICAgaWYgYW1wID0gU2l6emxlKCdhbXAnLCBzdGFuemEpWzBdXG4gICAgICAhIVNpenpsZSgncnVsZScsIHN0YW56YSkubGVuZ3RoXG4gICAgZWxzZVxuICAgICAgZmFsc2VcblxuICAjIERldGVybWluZSBpZiB0aGUgc3RhbnphIGNvbnRhaW5zIGEgPGRlbGF5Lz4gc3RhbnphLCB3aGljaCBpbmRpY2F0ZXNcbiAgIyBkZWxheWVkIGRlbGl2ZXJ5XG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBldmVudFxuICAjXG4gICMgQHJldHVybiBbQm9vbGVhbl1cbiAgQGlzRGVsYXllZDogKHN0YW56YSkgLT5cbiAgICAhIVNpenpsZSgnZGVsYXknLCBzdGFuemEpLmxlbmd0aFxuXG4gIEBpc250RGVsYXllZDogXy5ub3QgQGlzRGVsYXllZFxuXG4gICMgRGV0ZXJtaW5lIGlmIHRoZSBzdGFuemEgcmVwcmVzZW50cyBhbiBBY2sgZnJvbSB0aGUgc2VydmVyIHdoZW4gaXQgcmVjZWl2ZXNcbiAgIyBhIGdyb3VwY2hhdCBtZXNzYWdlXG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBldmVudFxuICAjIEBwYXJhbSBzZWxmSklEIFtTdHJpbmddIHVzZXIgSklEXG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXVxuICBAaXNHcm91cGNoYXRBY2s6IChzdGFuemEsIHNlbGZKSUQpIC0+XG4gICAgQGlzTVVDU2VsZiBzdGFuemEsIHNlbGZKSURcblxuICAjIERldGVybWluZSBpZiB0aGUgc3RhbnphIHJlcHJlc2VudHMgYW4gQWNrIGZyb20gdGhlIHJlY2lwaWVudCBjbGllbnRcbiAgIyB3aGVuIGl0IHJlY2VpdmVzIGEgY2hhdCBvciBncm91cGNoYXQgbWVzc2FnZVxuICAjXG4gICMgQHBhcmFtIHN0YW56YSBbWE1MXSB4bWwgc3RhbnphIHJlY2VpdmVkIGZyb20gU3Ryb3BoZSBmb3IgYW4gZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dXG4gIEBpc0NsaWVudEFjazogKHN0YW56YSkgLT5cbiAgICAjIGNoZWNrIGZvciA8cmVzcG9uc2UvPiBlbGVtZW50XG4gICAgISFTaXp6bGUoJ3Jlc3BvbnNlJywgc3RhbnphKS5sZW5ndGhcblxuICAjIERldGVybWluZSBpZiBhIHN0YW56YSByZXByZXNlbnRzIHByZWZlcmVuY2VzIGluIHN0b3JhZ2VcbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXVxuICBAaXNQcmVmZXJlbmNlczogKHN0YW56YSkgLT5cbiAgICAhIVNpenpsZSgnW3htbG5zPVwic3RvcmFnZTpwcmVmZXJlbmNlc1wiXScsIHN0YW56YSkubGVuZ3RoXG5cbiAgIyBEZXRlcm1pbmUgaWYgYSBzdGFuemEgcmVwcmVzZW50cyBib29rbWFya3MgaW4gc3RvcmFnZVxuICAjXG4gICMgQHBhcmFtIHN0YW56YSBbWE1MXSB4bWwgc3RhbnphIHJlY2VpdmVkIGZyb20gU3Ryb3BoZSBmb3IgYW4gZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dXG4gIEBpc0Jvb2ttYXJrczogKHN0YW56YSkgLT5cbiAgICAhIVNpenpsZSgnW3htbG5zPVwic3RvcmFnZTpib29rbWFya3NcIl0nLCBzdGFuemEpLmxlbmd0aFxuXG5cbiAgIyBEZXRlcm1pbmUgaWYgYSBzdGFuemEgcmVwcmVzZW50cyBjb250YWN0cyB0aGF0IHdlcmUgcmVtb3ZlZCB0byB0aGUgUm9zdGVyXG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBldmVudFxuICAjXG4gICMgQHJldHVybiBbQm9vbGVhbl0gaWYgdGhlIGlxIGhhcyBhIHN1YnNjcmlwdGlvbiBhdHRyaWJ1dGUgb2YgXCJyZW1vdmVcIlxuICBAaXNSb3N0ZXJSZW1vdmVkOiAoc3RhbnphKSAtPlxuICAgIFNpenpsZSgnaXRlbScsIHN0YW56YSlbMF0/LmdldEF0dHJpYnV0ZSgnc3Vic2NyaXB0aW9uJykgaXMgXCJyZW1vdmVcIlxuXG4gICMgRGV0ZXJtaW5lIGlmIGEgc3RhbnphIHJlcHJlc2VudHMgY29udGFjdHMgdGhhdCB3ZXJlIGFkZGVkIHRvIHRoZSBSb3N0ZXJcbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSBpZiB0aGUgaXEgaGFzIGEgc3Vic2NyaXB0aW9uIGF0dHJpYnV0ZSBvZiBcIm5vbmVcIlxuICBAaXNSb3N0ZXJBZGRlZDogXy5ub3QgQGlzUm9zdGVyUmVtb3ZlZFxuXG4gICMgRGV0ZXJtaW5lIGlmIGEgc3RhbnphIHJlcHJlc2VudHMgYSBsaXN0IG9mIGNvbnRhY3RzIGFkZGVkIHRvIHRoZSBCbG9ja2xpc3RcbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSBpZiB0aGUgaXEgaGFzIGEgPGJsb2NrPiBlbGVtZW50XG4gIEBpc0Jsb2NrbGlzdEJsb2NrZWQ6IChzdGFuemEpIC0+XG4gICAgISFTaXp6bGUoJ2Jsb2NrJywgc3RhbnphKS5sZW5ndGhcblxuICAjIERldGVybWluZSBpZiBhIHN0YW56YSByZXByZXNlbnRzIGEgbGlzdCBvZiBjb250YWN0cyByZW1vdmVkIGZyb20gdGhlIEJsb2NrbGlzdFxuICAjXG4gICMgQHBhcmFtIHN0YW56YSBbWE1MXSB4bWwgc3RhbnphIHJlY2VpdmVkIGZyb20gU3Ryb3BoZSBmb3IgYW4gZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIGlmIHRoZSBpcSBoYXMgYSA8dW5ibG9jaz4gZWxlbWVudFxuICBAaXNCbG9ja2xpc3RVbmJsb2NrZWQ6IChzdGFuemEpIC0+XG4gICAgISFTaXp6bGUoJ3VuYmxvY2snLCBzdGFuemEpLmxlbmd0aFxuXG4gICMgRGV0ZXJtaW5lIGlmIGEgc3RhbnphIHJlcHJlc2VudHMgYW55dGhpbmcgZnJvbSB0aGUgWWFob28hIGdhdGV3YXksXG4gICMgYnkgdGVzdGluZyB0byBzZWUgaWYgdGhlIGRvbWFpbiBzdGFydHMgd2l0aCB5YWhvby54eHgueHh4XG4gICMgKGUuZy4sIHlhaG9vLnJldXRlcnMubmV0KS5cbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSB0cnVlIGlmIHRoZSBzdGFuemEgaXMgJ2Zyb20nIHRoZSBZYWhvbyEgZ2F0ZXdheSBkb21haW4uXG4gIEBpc1lhaG9vR2F0ZXdheTogKHN0YW56YSkgLT5cbiAgICAvXnlhaG9vXFwuL2kudGVzdCBzdGFuemEuZ2V0QXR0cmlidXRlKCdmcm9tJylcblxuICAjIEZpbHRlciBldmVudHMgZnJvbSB0aGUgWWFob28hIGdhdGV3YXkgYnkgdGVzdGluZyB0byBzZWUgaWYgdGhlIGRvbWFpbiBzdGFydHNcbiAgIyB3aXRoIHlhaG9vLnh4eC54eHggKGUuZy4sIHlhaG9vLnJldXRlcnMubmV0KS5cbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSB0cnVlIGlmIHRoZSBzdGFuemEgaXNudCAnZnJvbScgdGhlIFlhaG9vISBnYXRld2F5IGRvbWFpbi5cbiAgQGlzbnRZYWhvb0dhdGV3YXk6IF8ubm90IEBpc1lhaG9vR2F0ZXdheVxuXG4gIEBpc0Vycm9yOiAoc3RhbnphKSAtPlxuICAgIHN0YW56YS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSBpcyAnZXJyb3InXG5cbiAgQGlzbnRFcnJvcjogXy5ub3QgQGlzRXJyb3JcblxuICAjIERldGVybWluZSBpZiBhIHN0YW56YSBoYXMgYSA8ZGVjbGluZS8+IGNoaWxkLlxuICAjXG4gICMgQHBhcmFtIHN0YW56YSBbWE1MXSB4bWwgc3RhbnphIHJlY2VpdmVkIGZyb20gU3Ryb3BoZSBmb3IgYW4gZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIGlmIHRoZSBzdGFuemEgaGFzIGEgPGRlY2xpbmUvPiBjaGlsZFxuICBAaGFzRGVjbGluZTogKHN0YW56YSkgLT5cbiAgICAhIVNpenpsZSgnZGVjbGluZScsIHN0YW56YSkubGVuZ3RoXG5cbiAgQGhhc250RGVjbGluZTogXy5ub3QgQGhhc0RlY2xpbmVcblxuICAjIERldGVybWluZSBpZiBhIHN0YW56YSBoYXMgYSA8cG9saWN5LXZpb2xhdGlvbi8+IGNoaWxkLlxuICAjXG4gICMgQHBhcmFtIHN0YW56YSBbWE1MXSB4bWwgc3RhbnphIHJlY2VpdmVkIGZyb20gU3Ryb3BoZSBmb3IgYW4gZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIGlmIHRoZSBzdGFuemEgaGFzIGEgPHBvbGljeS12aW9sYXRpb24vPiBjaGlsZFxuICBAaGFzUG9saWN5VmlvbGF0aW9uOiAoc3RhbnphKSAtPlxuICAgICEhU2l6emxlKCdwb2xpY3ktdmlvbGF0aW9uJywgc3RhbnphKS5sZW5ndGhcblxuICBAaGFzbnRQb2xpY3lWaW9sYXRpb246IF8ubm90IEBoYXNQb2xpY3lWaW9sYXRpb25cblxuICAjIERldGVybWluZSBpZiBhIHN0YW56YSBoYXMgYSA8aW52aXRlZS8+IGNoaWxkLlxuICAjXG4gICMgQHBhcmFtIHN0YW56YSBbWE1MXSB4bWwgc3RhbnphIHJlY2VpdmVkIGZyb20gU3Ryb3BoZSBmb3IgYW4gZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIGlmIHRoZSBzdGFuemEgaGFzIGEgPGludml0ZWUvPiBjaGlsZFxuICBAaGFzSW52aXRlZTogKHN0YW56YSkgLT5cbiAgICAhIVNpenpsZSgnaW52aXRlZScsIHN0YW56YSkubGVuZ3RoXG5cbiAgQGhhc250SW52aXRlZTogXy5ub3QgQGhhc0ludml0ZWVcblxuICAjIERldGVybWluZSBpZiBhIHN0YW56YSBoYXMgYSA8Y29uZmxpY3QvPiBjaGlsZC5cbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSBpZiB0aGUgc3RhbnphIGhhcyBhIDxjb25mbGljdC8+IGNoaWxkXG4gIEBpc0NvbmZsaWN0OiAoc3RhbnphKSAtPlxuICAgICEhU2l6emxlKCdjb25mbGljdCcsIHN0YW56YSkubGVuZ3RoXG5cbiAgIyBEZXRlcm1pbmUgaWYgc3RhbnphIGhhcyBhbiA8ZXJyb3IgdHlwZT0nY2FuY2VsJy8+IHN0YW56YVxuICAjXG4gICMgQHBhcmFtIHN0YW56YSBbWE1MXSB4bWwgc3RhbnphIHJlY2VpdmVkIGZyb20gU3Ryb3BoZSBmb3IgYW4gZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIGlmIHN0YW56YSBoYXMgYW4gPGVycm9yIHR5cGU9J2NhbmNlbCcvPiBzdGFuemFcbiAgQGhhc0Vycm9yVHlwZUNhbmNlbDogKHN0YW56YSkgLT5cbiAgICBTaXp6bGUoJ2Vycm9yJywgc3RhbnphKVswXT8uZ2V0QXR0cmlidXRlKCd0eXBlJykgaXMgTVVDRXJyb3JUeXBlLkNBTkNFTFxuXG4gICMgRGV0ZXJtaW5lIGlmIHN0YW56YSBkb2Vzbid0IGhhdmUgYW4gPGVycm9yIHR5cGU9J2NhbmNlbCcvPiBzdGFuemFcbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSBpZiBzdGFuemEgZG9lc24ndCBoYXZlIGFuIDxlcnJvciB0eXBlPSdjYW5jZWwnLz4gc3RhbnphXG4gIEBoYXNudEVycm9yVHlwZUNhbmNlbDogXy5ub3QgQGhhc0Vycm9yVHlwZUNhbmNlbFxuXG4gICMgRGV0ZXJtaW5lIGlmIHN0YW56YSBoYXMgYW4gPGVycm9yIHR5cGU9J2NhbmNlbCcvPiBzdGFuemFcbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSBpZiBzdGFuemEgaGFzIGFuIDxlcnJvciB0eXBlPSdjYW5jZWwnLz4gc3RhbnphXG4gIEBoYXNFcnJvclR5cGVBdXRoOiAoc3RhbnphKSAtPlxuICAgIFNpenpsZSgnZXJyb3InLCBzdGFuemEpWzBdPy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSBpcyBNVUNFcnJvclR5cGUuQVVUSFxuXG4gICMgRGV0ZXJtaW5lIGlmIHN0YW56YSBkb2Vzbid0IGhhdmUgYW4gPGVycm9yIHR5cGU9J2F1dGgnLz4gc3RhbnphXG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBldmVudFxuICAjXG4gICMgQHJldHVybiBbQm9vbGVhbl0gaWYgc3RhbnphIGRvZXNuJ3QgaGF2ZSBhbiA8ZXJyb3IgdHlwZT0nY2FuY2VsJy8+IHN0YW56YVxuICBAaGFzbnRFcnJvclR5cGVBdXRoOiBfLm5vdCBAaGFzRXJyb3JUeXBlQXV0aFxuXG4gICMgRGV0ZXJtaW5lIGlmIHN0YW56YSBoYXMgYW4gPGVycm9yIHR5cGU9J21vZGlmeScvPiBzdGFuemFcbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZm9yIGFuIGV2ZW50XG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSBpZiBzdGFuemEgaGFzIGFuIDxlcnJvciB0eXBlPSdjYW5jZWwnLz4gc3RhbnphXG4gIEBoYXNFcnJvclR5cGVNb2RpZnk6IChzdGFuemEpIC0+XG4gICAgU2l6emxlKCdlcnJvcicsIHN0YW56YSlbMF0/LmdldEF0dHJpYnV0ZSgndHlwZScpIGlzIE1VQ0Vycm9yVHlwZS5NT0RJRllcblxuICAjIERldGVybWluZSBpZiBzdGFuemEgZG9lc24ndCBoYXZlIGFuIDxlcnJvciB0eXBlPSdtb2RpZnknLz4gc3RhbnphXG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBldmVudFxuICAjXG4gICMgQHJldHVybiBbQm9vbGVhbl0gaWYgc3RhbnphIGRvZXNuJ3QgaGF2ZSBhbiA8ZXJyb3IgdHlwZT0nbW9kaWZ5Jy8+IHN0YW56YVxuICBAaGFzbnRFcnJvclR5cGVNb2RpZnk6IF8ubm90IEBoYXNFcnJvclR5cGVNb2RpZnlcblxuICAjIFRlc3QgdG8gc2VlIGlmIHRoaXMgaXMgYSB0eXBpbmcgbm90aWZpY2F0aW9uXG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGV2ZW50XG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSBpZiBzdGFuemEgaGFzIDxjb21wb3NpbmcgLz4gY2hpbGRcbiAgQGlzVHlwaW5nTm90aWNlOiAoc3RhbnphKSAtPlxuICAgICEhU2l6emxlKCdjb21wb3NpbmdbeG1sbnM9XCInICsgQ2hhdFN0YXRlc05TLkNIQVRfU1RBVEVTICsgJ1wiXScsIHN0YW56YSkubGVuZ3RoXG5cbiAgIyBUZXN0IHRvIHNlZSBpZiB0aGlzIGlzIE5PVCBhIHR5cGluZyBub3RpZmljYXRpb25cbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIGlmIHN0YW56YSBkb2VzIG5vdCBoYXZlIDxjb21wb3NpbmcgLz4gY2hpbGRcbiAgQGlzbnRUeXBpbmdOb3RpY2U6IF8ubm90IEBpc1R5cGluZ05vdGljZVxuXG4gICMgVGVzdCB0byBzZWUgaWYgdGhpcyBpcyBhIHR5cGluZyBub3RpZmljYXRpb25cbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIGlmIHN0YW56YSBoYXMgPGNvbXBvc2luZyAvPiBjaGlsZFxuICBAaXNIaXN0b3J5QmxvY2tlZDogKHN0YW56YSkgLT5cbiAgICAhIVNpenpsZSgnZXJyb3JbdHlwZT1cIm1vZGlmeVwiXSBwb2xpY3ktdmlvbGF0aW9uJywgc3RhbnphKS5sZW5ndGggYW5kXG4gICAgISFTaXp6bGUoJ2NvbXBsaWFuY2VbY29kZT1cIjYwNlwiXScsIHN0YW56YSkubGVuZ3RoXG5cbiAgIyBUZXN0IHRvIHNlZSBpZiB0aGlzIGlzIE5PVCBhIHR5cGluZyBub3RpZmljYXRpb25cbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIGlmIHN0YW56YSBkb2VzIG5vdCBoYXZlIDxjb21wb3NpbmcgLz4gY2hpbGRcbiAgQGlzbnRIaXN0b3J5QmxvY2tlZDogXy5ub3QgQGlzSGlzdG9yeUJsb2NrZWRcblxuXG4gICMgUnVuIGFsbCBmaWx0ZXJzIGZyb20gYSBsaXN0XG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciBhbiBFdmVudEZpbHRlcnNcbiAgIyBAcGFyYW0gZmlsdGVycyBbQXJyYXk8U3RyaW5nPl0gYXJyYXkgb2YgZmlsdGVyIGZ1bmN0aW9uIG5hbWVzXG4gICMgQHBhcmFtIHNlbGZKSUQgW1N0cmluZ10gdXNlciBKSURcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIHRydWUgaWYgcGFzc2VkIGFsbCBmaWx0ZXJzIHN1Y2Nlc3NmdWxseVxuICBAcnVuOiAoc3RhbnphLCBmaWx0ZXJzLCBzZWxmSklEKSAtPlxuICAgIHBhc3MgPSB0cnVlXG4gICAgZm9yIGZpbHRlciBpbiBmaWx0ZXJzXG4gICAgICBpZiBfLmlzRnVuY3Rpb24gZmlsdGVyXG4gICAgICAgIGlmIG5vdCBmaWx0ZXIuY2FsbCB0aGlzLCBzdGFuemEsIHNlbGZKSURcbiAgICAgICAgICBwYXNzID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IgXCJBdHRlbXB0ZWQgdG8gaW52b2tlIGFuIGludmFsaWQgZmlsdGVyIGZ1bmN0aW9uICN7ZmlsdGVyfVwiXG4gICAgcGFzc1xuXG4gICMgRGVjb3JhdGUgYSBjYWxsYmFjayBmdW5jdGlvbiBieSBvbmx5IGludm9raW5nIGl0IGlmIGEgc3RhbnphIGluY2x1ZGVzXG4gICMgICB0aGUgcmVjaXBpZW50IEpJRCB3ZSBhcmUgbG9va2luZyBmb3JcbiAgI1xuICAjIEBwYXJhbSBmdW5jIFtGdW5jdGlvbl0gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZVxuICAjIEBwYXJhbSBleHBlY3RlZEpJRCBbU3RyaW5nXSB0aGUgSklEIHdlIGV4cGVjdCB0byBmaW5kXG4gICMgQHBhcmFtIGJhcmUgW0Jvb2xlYW5dIHdoZXRoZXIgd2UgY2FuIG1hdGNoIGp1c3QgdGhlIGJhcmUgamlkIHdpdGhvdXQgdGhlIHJlc291cmNlXG4gICNcbiAgIyBAcmV0dXJuIFtGdW5jdGlvbl0gYSBuZXcgY2FsbGJhY2sgZnVuY3Rpb25cbiAgQGZpbHRlckJ5UmVjaXBpZW50OiAoZnVuYywgZXhwZWN0ZWRKSUQsIGJhcmUpIC0+XG4gICAgZmlsdGVyQnlKSUQgJ3RvJywgZnVuYywgZXhwZWN0ZWRKSUQsIGdldE1hdGNoZXIgYmFyZVxuXG4gICMgRGVjb3JhdGUgYSBjYWxsYmFjayBmdW5jdGlvbiBieSBvbmx5IGludm9raW5nIGl0IGlmIGEgc3RhbnphIGluY2x1ZGVzXG4gICMgICB0aGUgc2VuZGVyIHdlIGFyZSBsb29raW5nIGZvclxuICAjXG4gICMgQHBhcmFtIGZ1bmMgW0Z1bmN0aW9uXSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gICMgQHBhcmFtIGV4cGVjdGVkSklEIFtTdHJpbmddIHRoZSBKSUQgd2UgZXhwZWN0IHRvIGZpbmRcbiAgIyBAcGFyYW0gYmFyZSBbQm9vbGVhbl0gd2hldGhlciB3ZSBjYW4gbWF0Y2gganVzdCB0aGUgYmFyZSBqaWQgd2l0aG91dCB0aGUgcmVzb3VyY2VcbiAgI1xuICAjIEByZXR1cm4gW0Z1bmN0aW9uXSBhIG5ldyBjYWxsYmFjayBmdW5jdGlvblxuICBAZmlsdGVyQnlTZW5kZXI6IChmdW5jLCBleHBlY3RlZEpJRCwgYmFyZSkgLT5cbiAgICBmaWx0ZXJCeUpJRCAnZnJvbScsIGZ1bmMsIGV4cGVjdGVkSklELCBnZXRNYXRjaGVyIGJhcmVcblxuICAjIFRlc3QgdG8gc2VlIGlmIHRoZSBiYXJlIHBhcnQgb2YgYSBKSUQgbWF0Y2hlcyBhbm90aGVyIEpJRFxuICAjXG4gICMgQHBhcmFtIGV4cGVjdGVkSklEIFtTdHJpbmddIHRoZSBKSUQgd2UgZXhwZWN0IHRvIGZpbmRcbiAgIyBAcGFyYW0gdGVzdEpJRCBbU3RyaW5nXSB0aGUgSklEIHdlIGFyZSB0ZXN0aW5nIGZvciBhIG1hdGNoXG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSB0cnVlIGlmIHRoZXJlIGlzIGEgbWF0Y2hcbiAgQG1hdGNoQmFyZUpJRDogKGV4cGVjdGVkSklELCB0ZXN0SklEKSAtPlxuICAgIGV4cGVjdGVkSklEIGlzIFN0cm9waGUuZ2V0QmFyZUppZEZyb21KaWQgdGVzdEpJRFxuXG4gICMgVGVzdCB0byBzZWUgaWYgdGhlIEpJRCBtYXRjaGVzIGFub3RoZXIgSklELCBiYXJlIG9yIG90aGVyd2lzZVxuICAjXG4gICMgQHBhcmFtIGV4cGVjdGVkSklEIFtTdHJpbmddIHRoZSBKSUQgd2UgZXhwZWN0IHRvIGZpbmRcbiAgIyBAcGFyYW0gdGVzdEpJRCBbU3RyaW5nXSB0aGUgSklEIHdlIGFyZSB0ZXN0aW5nIGZvciBhIG1hdGNoXG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXSB0cnVlIGlmIHRoZXJlIGlzIGEgbWF0Y2hcbiAgQG1hdGNoSklEOiAoZXhwZWN0ZWRKSUQsIHRlc3RKSUQpIC0+XG4gICAgXy5pc0VxdWFsKGV4cGVjdGVkSklELCB0ZXN0SklEKSBvciBAbWF0Y2hCYXJlSklEIHRlc3RKSURcblxuXG4gICMgVGVzdCB0byBzZWUgaWYgdGhlIE1lc3NhZ2UgaGFzIGEgYm9keSB0YWdcbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIGlmIHN0YW56YSBoYXMgPGJvZHk+IGNoaWxkXG4gIEBoYXNCb2R5VGFnOiAoc3RhbnphKSAtPlxuICAgICEhU2l6emxlKCdib2R5Jywgc3RhbnphKS5sZW5ndGhcblxuICBAaGFzbnRCb2R5VGFnOiBfLm5vdCBAaGFzQm9keVRhZ1xuXG4gICMgVGVzdCB0byBzZWUgaWYgdGhlIE1lc3NhZ2UgaGFzIGEgYm9keSB0YWdcbiAgI1xuICAjIEBwYXJhbSBzdGFuemEgW1hNTF0geG1sIHN0YW56YSByZWNlaXZlZCBmcm9tIFN0cm9waGUgZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIGlmIHN0YW56YSBoYXMgPHN0YXR1cyAvPiBjaGlsZFxuICBAaGFzU3RhdHVzVGFnOiAoc3RhbnphKSAtPlxuICAgICEhU2l6emxlKCdzdGF0dXMnLCBzdGFuemEpLmxlbmd0aFxuXG4gIEBoYXNudFN0YXR1c1RhZzogXy5ub3QgQGhhc1N0YXR1c1RhZ1xuXG4gICMgQHByaXZhdGVcbiAgIyBBIEZpbHRlciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBvbmx5IGlmIGEgSklEIG1hdGNoZXIgZnVuY3Rpb24gcmV0dXJucyB0cnVlXG4gICNcbiAgIyBAcGFyYW0gYXR0ck5hbWUgW1N0cmluZ10gYSBzdGFuemEgYXR0cmlidXRlIG5hbWUsIGUuZy4gJ3RvJyBvciAnZnJvbSdcbiAgIyBAcGFyYW0gZnVuYyBbRnVuY3Rpb25dIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gICMgQHBhcmFtIGV4cGVjdGVkSklEIFtTdHJpbmddIHRoZSBKSUQgd2UgZXhwZWN0IHRvIGZpbmRcbiAgIyBAcGFyYW0gbWF0Y2hlckZuIFtGdW5jdGlvbl0gYSBtYXRjaGVyIGZ1bmN0aW9uIHRvIHRlc3QgYSBKSURcbiAgI1xuICAjIEByZXR1cm4gW2Z1bmN0aW9uXSBhIHdyYXBwZWQgY2FsbGJhY2sgZnVuY3Rpb24gdGFraW5nIGEgc3RhbnphIHBhcmFtXG4gIGZpbHRlckJ5SklEID0gKGF0dHJOYW1lLCBmdW5jLCBleHBlY3RlZEpJRCwgbWF0Y2hlckZuKSAtPlxuICAgIChzdGFuemEpIC0+XG4gICAgICBzdGFuemFKSUQgPSBzdGFuemEuZ2V0QXR0cmlidXRlIGF0dHJOYW1lXG4gICAgICBpZiBtYXRjaGVyRm4gZXhwZWN0ZWRKSUQsIHN0YW56YUpJRFxuICAgICAgICBmdW5jIHN0YW56YVxuXG4gICMgQHByaXZhdGVcbiAgIyBSZXRyaWV2ZSBhIG1hdGNoZXIgZnVuY3Rpb24gZm9yIEpJRHNcbiAgI1xuICAjIEBwYXJhbSBiYXJlIFtCb29sZWFuXSB3aGV0aGVyIG1hdGNoaW5nIHRoZSBiYXJlIEpJRCAod2l0aG91dCB0aGUgcmVzb3VyY2UpXG4gICMgICBpcyBnb29kIGVub3VnaCB0byByZXR1cm4gYSBwb3NpdGl2ZSBtYXRjaFxuICAjXG4gICMgQHJldHVybiBbRnVuY3Rpb25dIGEgbWF0Y2hlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBCb29sZWFuIHZhbHVlXG4gIGdldE1hdGNoZXIgPSAoYmFyZSA9IGZhbHNlKSAtPiBkbyAoYmFyZSkgLT4gKGV4cGVjdGVkLCB0ZXN0KSAtPlxuICAgIGlmIGJhcmVcbiAgICAgIEV2ZW50RmlsdGVycy5tYXRjaEJhcmVKSUQgZXhwZWN0ZWQsIHRlc3RcbiAgICBlbHNlXG4gICAgICBfLmlzRXF1YWwgZXhwZWN0ZWQsIHRlc3RcbiIsIl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xuU2hvcnRJRCA9IHJlcXVpcmUgJ3Nob3J0aWQnXG5TdHJvcGhlID0gcmVxdWlyZSAnc3Ryb3BoZSdcbkV2ZW50RmlsdGVycyA9IHJlcXVpcmUgJ2V2ZW50cy9ldmVudF9maWx0ZXJzJ1xuZGF0YVBheWxvYWQgPSByZXF1aXJlICdhZGFwdGVycy9kYXRhX3BheWxvYWQnXG5cbiMgVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgc2luZ2xlIGV2ZW50IGZyb20gU3Ryb3BoZSBhbmQgbWFuYWdlcyBpdHMgbGlzdCBvZlxuIyBjYWxsYmFjayBmdW5jdGlvbnMgYXMgd2VsbCBhcyBpdHMgXCJzaWduYXR1cmVcIiBjb25maWd1cmF0aW9uLlxuIyBJdCB1c2VzIEV2ZW50RmlsdGVycyB0byByZWplY3QgaW5jb21pbmcgU3Ryb3BoZSBldmVudHMgYmFzZWQgb24gYSBsaXN0XG4jIG9mIGZpbHRlcnNcbiNcbiMgQHNlZSBFdmVudEZpbHRlcnNcbiMgQHNlZSBldmVudHMvZXZlbnRfY29uZmlnLmNvZmZlZVxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFdmVudEhhbmRsZXJcblxuICAjIEBwcm9wZXJ0eSBbU3RyaW5nXSB0aGUgZnVsbCBwYXRoIGZvciB0aGUgZXZlbnQgdGhpcyBoYW5kbGVyIHJlcHJlc2VudHNcbiAgcGF0aDogbnVsbFxuXG4gICMgQHByb3BlcnR5IFtTdHJpbmddIHVzZXIgSklEXG4gIHNlbGZKSUQ6IG51bGxcblxuICAjIEBwcm9wZXJ0eSBbT2JqZWN0XSBjb25maWcgb2JqZWN0IGZvciBhIHNwZWNpZmljIGV2ZW50IHNpZ25hdHVyZVxuICBjb25maWc6IG51bGxcblxuICAjIEBwcm9wZXJ0eSBbT2JqZWN0XSBvYmplY3QgY29udGFpbmluZyBhIGxpc3Qgb2YgY2FsbGJhY2tzXG4gICMgQGV4YW1wbGVcbiAgIyAgIF9jYWxsYmFja3MgPSB7XG4gICMgICAgIE5KelBXZVRJbjogZnVuY3Rpb24oKVxuICAjICAgICBFa2F3YmdwVTM6IGZ1bmN0aW9uKClcbiAgIyAgIH1cbiAgX2NhbGxiYWNrczogbnVsbFxuXG4gICMgQHByb3BlcnR5IFtTdHJvcGhlLkhhbmRsZXJdIFN0cm9waGUgaGFuZGxlciByZXR1cm5lZCBmcm9tIHRoZSBhZGRIYW5kbGVyXG4gICMgICBtZXRob2Qgb24gU3Ryb3BoZS5Db25uZWN0aW9uXG4gIF9zdHJvcGhlSGFuZGxlcjogbnVsbFxuXG4gICMgQ29uc3RydWN0b3IgZnVuY3Rpb25cbiAgI1xuICAjIEBwYXJhbSBbT2JqZWN0XSBjb25maWcgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZXZlbnQncyBcInNpZ25hdHVyZVwiXG4gICNcbiAgIyBAcmV0dXJuIFtFdmVudEhhbmRsZXJdIHRoaXNcbiAgY29uc3RydWN0b3I6IChAY29uZmlnID0ge30pIC0+XG4gICAgIyBlbnN1cmUgYXQgbGVhc3QgbnVsbHNcbiAgICBAY29uZmlnLm5zID89IG51bGxcbiAgICBAY29uZmlnLm5hbWUgPz0gbnVsbFxuICAgIEBjb25maWcudHlwZSA/PSBudWxsXG4gICAgQGNvbmZpZy5pZCA/PSBudWxsXG4gICAgQGNvbmZpZy5mcm9tID89IG51bGxcbiAgICBAY29uZmlnLmZpbHRlcnMgPz0gW11cblxuICAgIGlmIG1hdGNoQmFyZSA9IEBjb25maWcubWF0Y2hCYXJlXG4gICAgICBAY29uZmlnLm9wdGlvbnMgPSBtYXRjaEJhcmU6IG1hdGNoQmFyZVxuICAgIGVsc2VcbiAgICAgIEBjb25maWcub3B0aW9ucyA/PSBtYXRjaEJhcmU6IGZhbHNlXG5cbiAgICBAX2NhbGxiYWNrcyA9IHt9XG5cbiAgIyBBZGQgYSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhpcyBldmVudFxuICAjXG4gICMgQHBhcmFtIGNhbGxiYWNrIFtGdW5jdGlvbl0gd2lsbCBiZSBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gU3Ryb3BoZSBldmVudCBoYW5kbGVyXG4gICNcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHVuaXF1ZSBpZCBmb3IgdGhlIGNhbGxiYWNrIGJlaW5nIGFkZGVkXG4gIGFkZENhbGxiYWNrOiAoY2FsbGJhY2ssIG9uY2UgPSBmYWxzZSkgLT5cbiAgICByZXR1cm4gbnVsbCB1bmxlc3MgXy5pc0Z1bmN0aW9uIGNhbGxiYWNrXG4gICAgaWQgPSBTaG9ydElELmdlbmVyYXRlKClcblxuICAgIGlmIG9uY2VcbiAgICAgIGNhbGxiYWNrID0gb25jZUFuZFJlbW92ZSBjYWxsYmFjaywgXy5iaW5kIEByZW1vdmVDYWxsYmFjaywgdGhpcywgaWRcblxuICAgIEBfY2FsbGJhY2tzW2lkXSA9IGNhbGxiYWNrXG4gICAgaWRcblxuICAjIFJlbW92ZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIGJ5IGl0cyBpZFxuICAjXG4gICMgQHBhcmFtIGlkIFtTdHJpbmddIGEgdW5pcXVlIGlkIGZvciB0aGUgY2FsbGJhY2sgYmVpbmcgcmVtb3ZlZFxuICAjXG4gICMgQHJldHVybiBbU3RyaW5nLCBudWxsXSB0aGUgaWQgaWYgZm91bmQgYW5kIHJlbW92ZWQsIG90aGVyd2lzZSwgbnVsbFxuICByZW1vdmVDYWxsYmFjazogKGlkKSAtPlxuICAgIGlmIF8uaGFzIEBfY2FsbGJhY2tzLCBpZFxuICAgICAgZGVsZXRlIEBfY2FsbGJhY2tzW2lkXVxuICAgICAgaWRcbiAgICBlbHNlXG4gICAgICBudWxsXG5cbiAgIyBEZXRlcm1pbmUgaWYgYW55IGNhbGxiYWNrcyBhcmUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIHRydWUgaWYgdGhlcmUgYXJlIGNhbGxiYWNrc1xuICBoYXNDYWxsYmFja3M6IC0+XG4gICAgbm90IF8uaXNFbXB0eSBAX2NhbGxiYWNrc1xuXG4gICMgUmV0cmlldmUgdGhlIFN0cm9waGUuSGFuZGxlciBpbnN0YW5jZVxuICAjXG4gICMgQHJldHVybiBbU3Ryb3BoZS5IYW5kbGVyXVxuICBnZXRTdHJvcGhlSGFuZGxlcjogLT5cbiAgICBAX3N0cm9waGVIYW5kbGVyXG5cbiAgIyBTZXQgdGhlIFN0cm9waGUuSGFuZGxlciBpbnN0YW5jZSBmb3IgdGhpcyBldmVudFxuICAjXG4gICMgQHBhcmFtIGhhbmRsZXIgW1N0cm9waGUuSGFuZGxlcl0gaGFuZGxlciBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggb3VyIGV2ZW50XG4gICMgQHBhcmFtIHJlc2V0IFtCb29sZWFuXSBpbmRpY2F0ZXMgdGhhdCB3ZSBhcmUgaW50ZW50aW9uYWxseSByZXNldHRpbmdcbiAgI1xuICAjIEByZXR1cm4gW0V2ZW50SGFuZGxlcl0gdGhpc1xuICBzZXRTdHJvcGhlSGFuZGxlcjogKGhhbmRsZXIgPSBudWxsLCByZXNldCA9IGZhbHNlKSAtPlxuICAgIGlmIG5vdCByZXNldFxuICAgICAgcmV0dXJuIHRoaXMgdW5sZXNzIGhhbmRsZXIgaW5zdGFuY2VvZiBTdHJvcGhlLkhhbmRsZXJcbiAgICBAX3N0cm9waGVIYW5kbGVyID0gaGFuZGxlclxuICAgIHJldHVybiB0aGlzXG5cbiAgIyBSZXNldCB0aGUgU3Ryb3BoZSBoYW5kbGVyIGFuZCBhbGwgY2FsbGJhY2tzIGZvciB0aGlzIGV2ZW50XG4gICNcbiAgIyBAcmV0dXJuIFtBcnJheTxTdHJpbmc+XSBhbiBhcnJheSBvZiBpZHMgZm9yIGNhbGxiYWNrcyB0aGF0IHdlcmUgZGVsZXRlZFxuICByZXNldDogLT5cbiAgICAjIFJlc2V0IHRoZSBTdHJvcGhlIGhhbmRsZXIgcGFzc2luZyBudWxsIGFuZCBpbmRpY2F0aW5nIHJlc2V0PXRydWVcbiAgICBAcmVzZXRTdHJvcGhlSGFuZGxlcigpXG5cbiAgICAjIFJldHVybnMgYW4gYXJyYXkgb2YgaWRzIGZvciBjYWxsYmFja3MgdGhhdCB3ZXJlIGRlbGV0ZWRcbiAgICBAcmVzZXRDYWxsYmFja3MoKVxuXG4gICMgUmVzZXQgdGhlIHN0cm9waGUgaGFuZGxlciBvbmx5LiBUaGlzIGlzIHVzZWZ1bCBmb3Igd2hlbiAjcmVzZXQoKSBpcyBjYWxsZWRcbiAgIyBvbiBTdHJvcGhlIHNpbmNlIHdlIG5lZWQgdG8gc3luYyBTdHJvcGhlIGhhbmRsZXJzIHdpdGggdGhlIHJlZmVyZW5jZXMgc3RvcmVkXG4gICMgaGVyZS5cbiAgI1xuICAjIEByZXR1cm4gW0V2ZW50SGFuZGxlcl0gdGhpc1xuICByZXNldFN0cm9waGVIYW5kbGVyOiAtPlxuICAgIEBzZXRTdHJvcGhlSGFuZGxlciBudWxsLCB0cnVlXG4gICAgcmV0dXJuIHRoaXNcblxuICAjIFJlc2V0IGFsbCBjYWxsYmFja3MgZm9yIHRoaXMgZXZlbnRcbiAgI1xuICAjIEBwYXJhbSBkZWxldGVJZHMgW0FycmF5PFN0cmluZz5dIG9wdGlvbmFsIGFycmF5IG9mIHNwZWNpZmljIGNhbGxiYWNrIGlkcyB0byBkZWxldGVcbiAgI1xuICAjIEByZXR1cm4gW0FycmF5PFN0cmluZz5dIGFycmF5IG9mIGlkcyBmb3IgY2FsbGJhY2sgdGhhdCB3ZXJlIGRlbGV0ZWRcbiAgcmVzZXRDYWxsYmFja3M6IC0+XG4gICAgaWRzID0gXy5rZXlzIEBfY2FsbGJhY2tzXG4gICAgQF9jYWxsYmFja3MgPSB7fVxuICAgIGlkc1xuXG4gICMgQ29udmVydCBjb25maWcgb2JqZWN0IHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXNcbiAgI1xuICAjIEBwYXJhbSBzZWxmSklEIFtTdHJpbmddIHRoZSB1c2VyIEpJRFxuICAjXG4gICMgQHJldHVybiBbQXJyYXk8U3RyaW5nPl0gbGlzdCBvZiBhcmdzIGZvciBTdHJvcGhlLkNvbm5lY3Rpb24uYWRkSGFuZGxlciguLilcbiAgZ2V0U2lnbmF0dXJlQXJnczogKEBzZWxmSklEKSAtPlxuICAgIHNlbGVjdGVkID0gXy5waWNrIEBjb25maWcsICducycsICduYW1lJywgJ3R5cGUnLCAnaWQnLCAnZnJvbScsICdvcHRpb25zJ1xuICAgIGlmIHNlbGVjdGVkLmZyb20gaXMgRXZlbnRGaWx0ZXJzLlNFTEZfSklEXG4gICAgICBzZWxlY3RlZC5mcm9tID0gQHNlbGZKSURcbiAgICBfLnZhbHVlcyBzZWxlY3RlZFxuXG4gICMgSW52b2tlIGFsbCBjYWxsYmFja3MgdXBvbiByZWNlaXB0IG9mIGFuIGV2ZW50IGFmdGVyIHJ1bm5pbmcgcG9zdCBmaWx0ZXJzXG4gICNcbiAgIyBAcGFyYW0gc3RhbnphIFtYTUxdIHhtbCBzdGFuemEgcmVjZWl2ZWQgZnJvbSBTdHJvcGhlIGZvciB0aGlzIGV2ZW50XG4gICNcbiAgIyBAcmV0dXJuIFtFdmVudEhhbmRsZXJdIHRoaXNcbiAgaW52b2tlQ2FsbGJhY2tzOiAoc3RhbnphKSAtPlxuICAgIHJldHVybiB0aGlzIHVubGVzcyBwYXNzID0gRXZlbnRGaWx0ZXJzLnJ1biBzdGFuemEsIEBjb25maWcuZmlsdGVycywgQHNlbGZKSURcbiAgICBmb3Igb3duIGlkLCBjYWxsYmFjayBvZiBAX2NhbGxiYWNrc1xuICAgICAgdHJ5XG4gICAgICAgIGRhdGEgPSBkYXRhUGF5bG9hZC5nZXREYXRhIHN0YW56YVxuICAgICAgICBjYWxsYmFjayBkYXRhXG4gICAgICAgICMgZGVsZXRlSWZPbmNlLmNhbGwgdGhpcywgY2FsbGJhY2tcblxuICAgICAgY2F0Y2ggZVxuICAgIHJldHVybiB0aGlzXG5cbiAgIyBAcHJpdmF0ZVxuICAjIERlY29yYXRlIGEgZnVuY3Rpb24gc28gdGhhdCBvbmNlIGludm9rZWQsIGEgcmVtb3ZlIGZ1bmN0aW9uIGlzIGltbWVkaWF0ZWx5IGludm9rZWRcbiAgI1xuICAjIGZ1bmMgW0Z1bmN0aW9uXSBhIGZ1bmN0aW9uIHRvIGludm9rZVxuICAjIHJlbW92ZSBbRnVuY3Rpb25dIGEgcmVtb3ZlIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgaW52b2tpbmcgZnVuY1xuICAjXG4gICMgQHJldHVybiBbRnVuY3Rpb25dIHRoYXQgd2lsbCBpbnZva2UgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGFuZCBjYWxsIGEgcmVtb3ZlIGZ1bmN0aW9uXG4gIG9uY2VBbmRSZW1vdmUgPSAoZnVuYywgcmVtb3ZlKSAtPlxuICAgIC0+XG4gICAgICBmdW5jLmFwcGx5IG51bGwsIGFyZ3VtZW50c1xuICAgICAgcmVtb3ZlKClcbiIsIiMgc3RkIGhlbHBlciBsaWJzXG5fID0gcmVxdWlyZSAndW5kZXJzY29yZSdcblV0aWxzID0gcmVxdWlyZSAndXRpbC91dGlscydcblxuIyBNYW5hZ2VyIGNsYXNzIGZvciBpbnRlcmZhY2luZyB3aXRoIFN0cm9waGUgZXZlbnRzLlxuI1xuIyBUaGlzIGNsYXNzIGhhcyB2aXJ0dWFsIG1ldGhvZHMsIHRoYXQgYXJlIGF2YWlsYWJsZSBvbiB0aGUgc2luZ2xldG9uIGluc3RhbmNlXG4jIHJldHVybmVkIGJ5IHRoZSBzdGF0aWMgI2dldCgpIG1ldGhvZC5cbiNcbiMgQG1ldGhvZCAjdG9nZ2xlQ29ubmVjdGlvbihjb25uZWN0ZWQsIHNlbGZKSUQgPSAnJylcbiMgICBSZWNlaXZlIG5vdGlmaWNhdGlvbiBvZiBhIGNoYW5nZSBpbiB0aGUgY29ubmVjdGlvbidzIHN0YXR1cyBiZXR3ZWVuXG4jICAgICBDT05ORUNURUQgYW5kIERJU0NPTk5FQ1RFRCNcbiMgICBAcGFyYW0gY29ubmVjdGVkIFtCb29sZWFuXSBpbmRpY2F0ZXMgd2hldGhlciB3ZSBhcmUgY29ubmVjdGVkIG9yIGRpc2Nvbm5lY3RlZFxuIyAgIEBwYXJhbSBzZWxmSklEIFtTdHJpbmddIHRoZSB1c2VyJ3MgSklEI1xuIyAgIEByZXR1cm4gW0V2ZW50TWFuYWdlcl0gdGhpc1xuI1xuIyBAbWV0aG9kICNsaXN0ZW5UbyhwYXRoLCBjYWxsYmFjaywgb25jZSlcbiMgICBSZWdpc3RlciBhIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBhIHBhcnRpY3VsYXIgZXZlbnQuXG4jXG4jICAgQHBhcmFtIHBhdGggW1N0cmluZ10gcGF0aCBuYW1lIGZvciB0aGUgZXZlbnQgYmVpbmcgbGlzdGVuZWQgZm9yXG4jICAgQHBhcmFtIGNhbGxiYWNrIFtGdW5jdGlvbl0gY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBldmVudCBpcyByZWNlaXZlZFxuIyAgIEBwYXJhbSBvbmNlIFtCb29sZWFuXSB3aGV0aGVyIG9yIG5vdCB0aGUgY2FsbGJhY2sgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCBvbmNlXG4jICAgICBiZWZvcmUgYmVpbmcgaW1tZWRpYXRlbHkgcmVtb3ZlZCBmcm9tIGl0cyBFdmVudEhhbmRsZXIgaW5zdGFuY2VcbiNcbiMgICBAcmV0dXJuIFtTdHJpbmddIGEgdW5pcXVlIGlkIGZvciB0aGUgY2FsbGJhY2sgdGhhdCB3YXMgYWRkZWRcbiNcbiMgICBAZXhhbXBsZVxuIyAgICAgLy8gQWRkIGEgY2FsbGJhY2sgdG8gYW4gZXZlbnQgcGF0aC5cbiMgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKCl7fTtcbiMgICAgIGV2ZW50TWFuYWdlci5saXN0ZW5UbygncGF0aC50by5teS5ldmVudCcsIGNhbGxiYWNrKTtcbiMgICAgIC8vPT4gcmV0dXJucyAnekIzcFcnXG4jXG4jICAgQGV4YW1wbGVcbiMgICAgIC8vIEFkZCBhIGNhbGxiYWNrIHRvIGFuIGV2ZW50IHBhdGggdGhhdCB3aWxsIG9ubHkgYmUgaW52b2tlZCBvbmNlLlxuIyAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oKXt9O1xuIyAgICAgZXZlbnRNYW5hZ2VyLmxpc3RlblRvKCdwYXRoLnRvLm15LmV2ZW50JywgY2FsbGJhY2ssIHRydWUpO1xuIyAgICAgLy89PiByZXR1cm5zICd6QjNwVydcbiNcbiMgICBAc2VlIEV2ZW50SGFuZGxlclxuI1xuIyBAbWV0aG9kICNsaXN0ZW5Ub09uY2UocGF0aCwgY2FsbGJhY2spXG4jICAgUmVnaXN0ZXIgYSBvbmUtdGltZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgYSBwYXJ0aWN1bGFyIGV2ZW50LiBDYWxsYmFjayB3aWxsXG4jICAgYmUgcmVtb3ZlZCBpbW1lZGlhdGVseSBmb2xsb3dpbmcgaXRzIGZpcnN0IGFuZCBvbmx5IGludm9jYXRpb24uXG4jXG4jICAgQHBhcmFtIFtTdHJpbmddIHBhdGggbmFtZSBmb3IgdGhlIGV2ZW50IGJlaW5nIGxpc3RlbmVkIGZvclxuIyAgIEBwYXJhbSBbRnVuY3Rpb25dIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkXG4jXG4jICAgQHJldHVybiBbU3RyaW5nXSBhIHVuaXF1ZSBpZCBmb3IgdGhlIGNhbGxiYWNrIHRoYXQgd2FzIGFkZGVkXG4jXG4jICAgQGV4YW1wbGVcbiMgICAgIC8vIEFkZCBhIGNhbGxiYWNrIHRvIGFuIGV2ZW50IHBhdGggdGhhdCB3aWxsIG9ubHkgYmUgaW52b2tlZCBvbmNlLlxuIyAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oKXt9O1xuIyAgICAgZXZlbnRNYW5hZ2VyLmxpc3RlblRvT25jZSgncGF0aC50by5teS5ldmVudCcsIGNhbGxiYWNrKTtcbiMgICAgIC8vPT4gcmV0dXJucyAnekIzcFcnXG4jXG4jICAgQHNlZSBFdmVudEhhbmRsZXJcbiNcbiMgQG1ldGhvZCAjc3RvcExpc3RlbmluZyhpZClcbiMgICBTdG9wIGxpc3RlbmluZyB0byBldmVudHMgYnkgcmVtb3ZpbmcgYSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgY2FsbGJhY2tcbiMgICBieSBzcGVjaWZ5aW5nIGEgdW5pcXVlIGlkXG4jXG4jICAgQHBhcmFtIGlkIFtTdHJpbmddIHRoZSB1bmlxdWUgaWQgZm9yIHRoZSByZWdpc3RlcmVkIGNhbGxiYWNrXG4jXG4jICAgQHJldHVybiBbU3RyaW5nXSB0aGUgaWQgaWYgdGhlIGNhbGxiYWNrIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZCxcbiMgICAgIG90aGVyd2lzZSwgdW5kZWZpbmVkXG4jXG4jICAgQGV4YW1wbGVcbiMgICAgIC8vIFN0b3AgbGlzdGVuaW5nIGJ5IHJlbW92aW5nIGEgcHJldmlvdXNseSByZWdpc3RlcmVkIGNhbGxiYWNrXG4jICAgICBldmVudE1hbmFnZXIuc3RvcExpc3RlbmluZygnekIzcFcnKTtcbiMgICAgIC8vPT4gcmV0dXJucyAnekIzcFcnIGlmIGEgY2FsbGJhY2sgd2l0aCB0aGF0IGlkIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZFxuI1xuIyAgIEBzZWUgRXZlbnRIYW5kbGVyXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEV2ZW50TWFuYWdlclxuXG4gICMgQHByb3BlcnR5IHByaXZhdGUgaW5zdGFuY2Ugb2YgUHJpdmF0ZUV2ZW50TWFuYWdlclxuICAjIEBwcml2YXRlXG4gIGluc3RhbmNlID0gbnVsbFxuXG4gICMgUmV0cmlldmUgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIFByaXZhdGVFdmVudE1hbmFnZXIgY2xhc3NcbiAgI1xuICAjIEByZXR1cm4gW1ByaXZhdGVFdmVudE1hbmFnZXJdIHNpbmdsZXRvbiBpbnN0YW5jZVxuICBAZ2V0OiAob3B0aW9ucyA9IHt9KSAtPlxuICAgIGNyZWF0ZUluc3RhbmNlID0gLT5cbiAgICAgIG5ldyBQcml2YXRlRXZlbnRNYW5hZ2VyIG9wdGlvbnNcbiAgICBpbnN0YW5jZSA/PSBjcmVhdGVJbnN0YW5jZSgpXG5cbiAgIyBEZXN0cm95IHRoZSBzaW5nbGV0b24gaW5zdGFuY2UsIG9ubHkgZm9yIHVuaXQgdGVzdGluZ1xuICAjXG4gICMgQHJldHVybiBbQm9vbGVhbl0gdHJ1ZSBpZiB0aGUgc2luZ2xldG9uIHdhcyBkZXN0cm95ZWQsIG90aGVyd2lzZSBmYWxzZVxuICBAZGVzdHJveTogVXRpbHMucmV0dXJuQm9vbCAtPlxuICAgIGluc3RhbmNlID0gbnVsbFxuICAgIFxuICBjbGFzcyBQcml2YXRlRXZlbnRNYW5hZ2VyXG5cbiAgICAjIEBtZXRob2QgI2FkZEhhbmRsZXIoKVxuICAgICMgICBpbml0aWFsbHkgbnVsbCwgdGhpcyBtZXRob2QgZGVmaW5pdGlvbiB3aWxsIGJlIHBhc3NlZFxuICAgICMgICBieSByZWZlcmVuY2UgZnJvbSB0aGUgQ29ubmVjdGlvblxuICAgICMgICBAcHJpdmF0ZVxuICAgIGFkZEhhbmRsZXIgPSBudWxsXG5cbiAgICAjIEBtZXRob2QgI2RlbGV0ZUhhbmRsZXIoaGFuZGxlKVxuICAgICMgICBpbml0aWFsbHkgbnVsbCwgdGhlIG1ldGhvZCBkZWZpbml0aW9uIHdpbGwgYmVcbiAgICAjICAgcGFzc2VkIGJ5IHJlZmVyZW5jZSBmcm9tIHRoZSBDb25uZWN0aW9uXG4gICAgIyAgIEBwcml2YXRlXG4gICAgZGVsZXRlSGFuZGxlciA9IG51bGxcblxuICAgICMgQHBhcmFtIFtGdW5jdGlvbl0gaG9sZHMgYSBsYXp5IHZlcnNpb24gb2YgYSBmdW5jdGlvbiB0byBhZGQgU3Ryb3BoZSBoYW5kbGVyc1xuICAgICMgQHByaXZhdGVcbiAgICBhZGRTdHJvcGhlSGFuZGxlckxhemlseSA9IG51bGxcblxuICAgICMgQHByb3BlcnR5IFtPYmplY3RdIGRpY3Rpb25hcnkgZm9yIGV2ZW50IGNvbmZpZyBkYXRhIGFuZFxuICAgICMgICBFdmVudEhhbmRsZXIgaW5zdGFuY2VzXG4gICAgIyBAcHJpdmF0ZVxuICAgIF9ldmVudHNEaWN0aW9uYXJ5OiB7fVxuXG4gICAgIyBAcHJvcGVydHkgW1N0cmluZ10gdXNlciBKSURcbiAgICAjIEBwcml2YXRlXG4gICAgX3NlbGZKSUQ6IG51bGxcbiAgICBcbiAgICAjIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gICAgI1xuICAgICMgQHBhcmFtIG9wdGlvbnMgW09iamVjdF0gb3B0aW9ucyBvYmplY3RcbiAgICAjIEBvcHRpb24gb3B0aW9ucyBhZGRIYW5kbGVyIFtGdW5jdGlvbl0gZnVuY3Rpb24gZm9yIGFkZGluZyBoYW5kbGVycyB0byBTdHJvcGhlXG4gICAgIyBAb3B0aW9uIG9wdGlvbnMgZGVsZXRlSGFuZGxlciBbRnVuY3Rpb25dIGZ1bmN0aW9uIGZvciBkZWxldGluZyBoYW5kbGVycyBmcm9tIFN0cm9waGVcbiAgICAjIEBvcHRpb24gb3B0aW9ucyBjb25maWcgW09iamVjdF0gY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGFsbCBldmVudHNcbiAgICAjIEBvcHRpb24gb3B0aW9ucyBoYW5kbGVyQ2xhc3MgW0Z1bmN0aW9uXSBhIGNsYXNzIHRvIGluc3RhbnRpYXRlIHRvIGhhbmRsZVxuICAgICMgICBlYWNoIGV2ZW50XG4gICAgI1xuICAgICMgQHJldHVybiBbUHJpdmF0ZUV2ZW50TWFuYWdlcl0gc2luZ2xldG9uIGluc3RhbmNlIG9mIEV2ZW50TWFuYWdlclxuICAgIGNvbnN0cnVjdG9yOiAob3B0aW9ucyA9IHt9KSAtPlxuICAgICAgIyB0aGVzZSBhcmUgcGFzc2VkIHRvIHVzIGluIHRoZSBwcmluY2lwbGUgb2YgbGVhc3QgcHJpdmlsZWRnZVxuICAgICAge2FkZEhhbmRsZXIsIGRlbGV0ZUhhbmRsZXIsIGNvbmZpZywgaGFuZGxlckNsYXNzfSA9IG9wdGlvbnNcblxuICAgICAgQF9ldmVudHNEaWN0aW9uYXJ5ID0gY3JlYXRlRXZlbnRzRGljdGlvbmFyeSBjb25maWcsIGhhbmRsZXJDbGFzc1xuXG4gICAgICAjIENyZWF0ZSBhIGZ1bmN0aW9uIGZvciBsYXp5IGFkZGluZyBvZiBTdHJvcGhlIGhhbmRsZXJzXG4gICAgICBhZGRTdHJvcGhlSGFuZGxlckxhemlseSA9IFV0aWxzLmNvbmRpdGlvbmFsIGFkZFN0cm9waGVIYW5kbGVyLCBsYXp5U3Ryb3BoZVBvbGljeVxuICAgIFxuICAgICAgcmV0dXJuIHRoaXNcblxuICAgICMgUmVjZWl2ZSBub3RpZmljYXRpb24gb2YgYSBjaGFuZ2UgaW4gdGhlIGNvbm5lY3Rpb24ncyBzdGF0dXMgYmV0d2VlblxuICAgICMgICBDT05ORUNURUQgYW5kIERJU0NPTk5FQ1RFRFxuICAgICNcbiAgICAjIEBwYXJhbSBjb25uZWN0ZWQgW0Jvb2xlYW5dIGluZGljYXRlcyB3aGV0aGVyIHdlIGFyZSBjb25uZWN0ZWQgb3IgZGlzY29ubmVjdGVkXG4gICAgIyBAcGFyYW0gc2VsZkpJRCBbU3RyaW5nXSB0aGUgdXNlcidzIEpJRFxuICAgICNcbiAgICAjIEByZXR1cm4gW0V2ZW50TWFuYWdlcl0gdGhpc1xuICAgIHRvZ2dsZUNvbm5lY3Rpb246IChjb25uZWN0ZWQsIHNlbGZKSUQgPSAnJykgLT5cbiAgICAgICMgcmVtb3ZlIGFueSB1bmljb2RlIHN0dWZmIGZyb20gamlkXG4gICAgICBAX3NlbGZKSUQgPSBTdHJvcGhlLnVuZXNjYXBlTm9kZSBzZWxmSklEXG4gICAgICBpZiBjb25uZWN0ZWRcbiAgICAgICAgYWRkU3Ryb3BoZUhhbmRsZXJzIEBfc2VsZkpJRCwgQF9ldmVudHNEaWN0aW9uYXJ5XG4gICAgICBlbHNlXG4gICAgICAgIHJlbW92ZVN0cm9waGVIYW5kbGVycyBAX2V2ZW50c0RpY3Rpb25hcnlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgXG4gICAgIyBSZWdpc3RlciBhIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBhIHBhcnRpY3VsYXIgZXZlbnQuXG4gICAgI1xuICAgICMgQHBhcmFtIHBhdGggW1N0cmluZ10gcGF0aCBuYW1lIGZvciB0aGUgZXZlbnQgYmVpbmcgbGlzdGVuZWQgZm9yXG4gICAgIyBAcGFyYW0gY2FsbGJhY2sgW0Z1bmN0aW9uXSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIGV2ZW50IGlzIHJlY2VpdmVkXG4gICAgIyBAcGFyYW0gb25jZSBbQm9vbGVhbl0gd2hldGhlciBvciBub3QgdGhlIGNhbGxiYWNrIHNob3VsZCBvbmx5IGJlIGludm9rZWQgb25jZVxuICAgICMgICBiZWZvcmUgYmVpbmcgaW1tZWRpYXRlbHkgcmVtb3ZlZCBmcm9tIGl0cyBFdmVudEhhbmRsZXIgaW5zdGFuY2VcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIGEgdW5pcXVlIGlkIGZvciB0aGUgY2FsbGJhY2sgdGhhdCB3YXMgYWRkZWRcbiAgICAjXG4gICAgIyBAZXhhbXBsZVxuICAgICMgICAvLyBBZGQgYSBjYWxsYmFjayB0byBhbiBldmVudCBwYXRoLlxuICAgICMgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpe307XG4gICAgIyAgIGV2ZW50TWFuYWdlci5saXN0ZW5UbygncGF0aC50by5teS5ldmVudCcsIGNhbGxiYWNrKTtcbiAgICAjICAgLy89PiByZXR1cm5zICd6QjNwVydcbiAgICAjXG4gICAgIyBAZXhhbXBsZVxuICAgICMgICAvLyBBZGQgYSBjYWxsYmFjayB0byBhbiBldmVudCBwYXRoIHRoYXQgd2lsbCBvbmx5IGJlIGludm9rZWQgb25jZS5cbiAgICAjICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oKXt9O1xuICAgICMgICBldmVudE1hbmFnZXIubGlzdGVuVG8oJ3BhdGgudG8ubXkuZXZlbnQnLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgIyAgIC8vPT4gcmV0dXJucyAnekIzcFcnXG4gICAgI1xuICAgICMgQHNlZSBFdmVudEhhbmRsZXJcbiAgICBsaXN0ZW5UbzogKHBhdGgsIGNhbGxiYWNrLCBvbmNlID0gZmFsc2UpIC0+XG4gICAgICAjIElmIHRoZSBwYXRoIGlzIGxlZ2l0aW1hdGUgYW5kIGlzIGEga2V5IHRvIGFuIEV2ZW50SGFuZGxlclxuICAgICAgIyBhZGQgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGl0cyBsaXN0LlxuICAgICAgaWYgZXZlbnRIYW5kbGVyID0gQF9ldmVudHNEaWN0aW9uYXJ5W3BhdGhdXG4gICAgICAgICMgRmlyc3QsIGFkZCB0aGUgY2FsbGJhY2sgc28gdGhhdCBhIFN0cm9waGUuSGFuZGxlciB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgICAgIyBzaW5jZSBpdCdzIGxhenkgcG9saWN5IHJlcXVpcmVzIHRoYXQgdGhlcmUgYmUgYXQgbGVhc3Qgb25lIGNhbGxiYWNrLlxuICAgICAgICBjYWxsYmFja0lkID0gZXZlbnRIYW5kbGVyLmFkZENhbGxiYWNrIGNhbGxiYWNrLCBvbmNlXG5cbiAgICAgICAgIyBTZWUgaWYgd2UgbmVlZCB0byBhbHNvIGNyZWF0ZSBhIFN0cm9waGUgaGFuZGxlci5cbiAgICAgICAgYWRkSGFuZGxlckZvckNhbGxiYWNrIGV2ZW50SGFuZGxlciwgQF9zZWxmSklEXG4gICAgICAgIFxuICAgICAgICAjIFJldHVybiB2YWx1ZSBjb21lcyBmcm9tIGV2ZW50SGFuZGxlci5hZGRDYWxsYmFjaygpIGFuZCBzaG91bGQgYmVcbiAgICAgICAgIyBhIHVuaXF1ZSBTdHJpbmcgaWQgYXNzb2NpYXRlZCB3aXRoIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICAjIGV4YW1wbGU6ICd6QjNBdydcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrSWRcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yIFwiVW5zdXBwb3J0ZWQgZXZlbnQ6ICN7cGF0aH1cIlxuXG4gICAgIyBSZWdpc3RlciBhIG9uZS10aW1lIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBhIHBhcnRpY3VsYXIgZXZlbnQuIENhbGxiYWNrIHdpbGxcbiAgICAjIGJlIHJlbW92ZWQgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGl0cyBmaXJzdCBhbmQgb25seSBpbnZvY2F0aW9uLlxuICAgICNcbiAgICAjIEBwYXJhbSBbU3RyaW5nXSBwYXRoIG5hbWUgZm9yIHRoZSBldmVudCBiZWluZyBsaXN0ZW5lZCBmb3JcbiAgICAjIEBwYXJhbSBbRnVuY3Rpb25dIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAgI1xuICAgICMgQHJldHVybiBbU3RyaW5nXSBhIHVuaXF1ZSBpZCBmb3IgdGhlIGNhbGxiYWNrIHRoYXQgd2FzIGFkZGVkXG4gICAgI1xuICAgICMgQGV4YW1wbGVcbiAgICAjICAgLy8gQWRkIGEgY2FsbGJhY2sgdG8gYW4gZXZlbnQgcGF0aCB0aGF0IHdpbGwgb25seSBiZSBpbnZva2VkIG9uY2UuXG4gICAgIyAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKCl7fTtcbiAgICAjICAgZXZlbnRNYW5hZ2VyLmxpc3RlblRvT25jZSgncGF0aC50by5teS5ldmVudCcsIGNhbGxiYWNrKTtcbiAgICAjICAgLy89PiByZXR1cm5zICd6QjNwVydcbiAgICAjXG4gICAgIyBAc2VlIEV2ZW50SGFuZGxlclxuICAgIGxpc3RlblRvT25jZTogKHBhdGgsIGNhbGxiYWNrKSAtPlxuICAgICAgQGxpc3RlblRvIHBhdGgsIGNhbGxiYWNrLCB0cnVlXG5cbiAgICAjIFN0b3AgbGlzdGVuaW5nIHRvIGV2ZW50cyBieSByZW1vdmluZyBhIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBjYWxsYmFja1xuICAgICMgYnkgc3BlY2lmeWluZyBhIHVuaXF1ZSBpZFxuICAgICNcbiAgICAjIEBwYXJhbSBpZCBbU3RyaW5nXSB0aGUgdW5pcXVlIGlkIGZvciB0aGUgcmVnaXN0ZXJlZCBjYWxsYmFja1xuICAgICNcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGlkIGlmIHRoZSBjYWxsYmFjayB3YXMgZm91bmQgYW5kIHJlbW92ZWQsXG4gICAgIyAgIG90aGVyd2lzZSwgdW5kZWZpbmVkXG4gICAgI1xuICAgICMgQGV4YW1wbGVcbiAgICAjICAgLy8gU3RvcCBsaXN0ZW5pbmcgYnkgcmVtb3ZpbmcgYSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgY2FsbGJhY2tcbiAgICAjICAgZXZlbnRNYW5hZ2VyLnN0b3BMaXN0ZW5pbmcoJ3pCM3BXJyk7XG4gICAgIyAgIC8vPT4gcmV0dXJucyAnekIzcFcnIGlmIGEgY2FsbGJhY2sgd2l0aCB0aGF0IGlkIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZFxuICAgICNcbiAgICAjIEBzZWUgRXZlbnRIYW5kbGVyXG4gICAgc3RvcExpc3RlbmluZzogKGlkKSAtPlxuICAgICAgcmVtb3ZlZElkcyA9IF8uaW52b2tlIEBfZXZlbnRzRGljdGlvbmFyeSwgJ3JlbW92ZUNhbGxiYWNrJywgaWRcbiAgICAgIHJlbW92ZWRJZHMgPSBfLmNvbXBhY3QgcmVtb3ZlZElkc1xuICAgICAgcmVtb3ZlZElkc1swXVxuXG4gICAgIyBCdWlsZCBhIGRpY3Rpb25hcnkgb2YgZXZlbnRzIHdpdGggZWFjaCBrZXkgYmVpbmcgdGhlIHVuaXF1ZSBldmVudCBwYXRoXG4gICAgIyBhbmQgaXRzIHZhbHVlIGJlaW5nIGFuIGluc3RhbmNlIG9mIEV2ZW50SGFuZGxlclxuICAgICMgQHByaXZhdGVcbiAgICAjXG4gICAgIyBAcGFyYW0gY29uZmlnT2JqIFtPYmplY3RdIGFuIG9iamVjdCB3aXRoIHRoZSBldmVudCBrZXlzLCBlYWNoIG9uZVxuICAgICMgICBjb250YWluaW5nIGl0cyBvd24gY29uZmlnIG9iamVjdCByZXByZXNlbnRpbmcgaXRzICdzaWduYXR1cmUnXG4gICAgIyBAcGFyYW0gaGFuZGxlckNsYXNzIFtGdW5jdGlvbl0gYSBjbGFzcyB0byBpbnN0YW50aWF0ZSBmb3IgZWFjaCBldmVudCBoYW5kbGVyXG4gICAgI1xuICAgICMgQHJldHVybiBbT2JqZWN0XSB0aGUgZXZlbnQgZGljdGlvbmFyeVxuICAgICNcbiAgICAjIEBleGFtcGxlXG4gICAgIyAgIF9ldmVudHNEaWN0aW9uYXJ5ID0ge1xuICAgICMgICAgICdwcmVzZW5jZS51c2VyLnVwZGF0ZSc6IC8vIGluc3RhbmNlb2YgRXZlbnRIYW5kbGVyXG4gICAgIyAgICAgJ21lc3NhZ2UuY2hhdC5yZWNlaXZlZCc6ICAvLyBpbnN0YW5jZW9mIEV2ZW50SGFuZGxlclxuICAgICMgICAgICdtZXNzYWdlLmdyb3VwY2hhdC5kZWxpdmVyZWQnOiAgLy8gaW5zdGFuY2VvZiBFdmVudEhhbmRsZXJcbiAgICAjICAgfVxuICAgICNcbiAgICAjIEBzZWUgRXZlbnRIYW5kbGVyXG4gICAgY3JlYXRlRXZlbnRzRGljdGlvbmFyeSA9IChjb25maWdPYmosIGhhbmRsZXJDbGFzcykgLT5cbiAgICAgIHJldHVybiBudWxsIGlmIF8uaXNFbXB0eSBjb25maWdPYmpcbiAgICAgIHJldHVybiBudWxsIHVubGVzcyBfLmlzRnVuY3Rpb24gaGFuZGxlckNsYXNzXG4gICAgICBkaWN0aW9uYXJ5ID0gXy5jbG9uZSBjb25maWdPYmpcbiAgICAgIGZvciBvd24gcGF0aCwgc2lnbmF0dXJlIG9mIGRpY3Rpb25hcnlcbiAgICAgICAgIyBSZXBsYWNlIHRoZSBzaWduYXR1cmUgY29uZmlnIG9iamVjdCB3aXRoIGFuIEV2ZW50SGFuZGxlciBpbnN0YW5jZVxuICAgICAgICBldmVudEhhbmRsZXIgPSBuZXcgaGFuZGxlckNsYXNzIHNpZ25hdHVyZVxuICAgICAgICBldmVudEhhbmRsZXIucGF0aCA9IHBhdGhcbiAgICAgICAgZGljdGlvbmFyeVtwYXRoXSA9IGV2ZW50SGFuZGxlclxuICAgICAgZGljdGlvbmFyeVxuXG4gICAgIyBBIHBvbGljeSBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB3ZSBzaG91bGQgYWRkIGEgc3Ryb3BoZSBoYW5kbGVyIGluIGFcbiAgICAjIGxhenkgZmFzaGlvbiwgb25seSB3aGVuIG5lY2Vzc2FyeVxuICAgICMgQHByaXZhdGVcbiAgICAjXG4gICAgIyBAcGFyYW0gZXZlbnRIYW5kbGVyIFtFdmVudEhhbmRsZXJdIGluc3RhbmNlIHVzZWQgaW4gdGhlIHBvbGljeSBjaGVja1xuICAgICNcbiAgICAjIEByZXR1cm4gW0Jvb2xlYW5dIHRydWUgaWYgYWxsb3dlZCB0byBwcm9jZWVkXG4gICAgbGF6eVN0cm9waGVQb2xpY3kgPSAoZXZlbnRIYW5kbGVyKSAtPlxuICAgICAgZXZlbnRIYW5kbGVyLmhhc0NhbGxiYWNrcygpXG5cbiAgICAjIEFkZCBTdHJvcGhlIGhhbmRsZXJzXG4gICAgI1xuICAgICMgQHBhcmFtIHNlbGZKSUQgW1N0cmluZ10gdXNlciBKSURcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtBcnJheV1cbiAgICBhZGRTdHJvcGhlSGFuZGxlcnMgPSAoc2VsZkpJRCwgZXZlbnRzRGljdGlvbmFyeSkgLT5cbiAgICAgIGZvciBvd24gcGF0aCwgZXZlbnRIYW5kbGVyIG9mIGV2ZW50c0RpY3Rpb25hcnlcbiAgICAgICAgYWRkU3Ryb3BoZUhhbmRsZXJMYXppbHkgZXZlbnRIYW5kbGVyLCBzZWxmSklEXG4gICAgXG4gICAgIyBSZW1vdmUgYWxsIFN0cm9waGUgaGFuZGxlcnNcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtBcnJheV1cbiAgICByZW1vdmVTdHJvcGhlSGFuZGxlcnMgPSAoZXZlbnRzRGljdGlvbmFyeSkgLT5cbiAgICAgIGZvciBvd24gcGF0aCwgZXZlbnRIYW5kbGVyIG9mIGV2ZW50c0RpY3Rpb25hcnlcbiAgICAgICAgZGVsZXRlU3Ryb3BoZUhhbmRsZXIgZXZlbnRIYW5kbGVyLmdldFN0cm9waGVIYW5kbGVyKClcbiAgICAgICAgZXZlbnRIYW5kbGVyLnJlc2V0U3Ryb3BoZUhhbmRsZXIoKVxuXG4gICAgIyBTZWUgaWYgd2UgbmVlZCB0byBjcmVhdGUgYSBTdHJvcGhlIGhhbmRsZXIgZm9yIGFuIGV2ZW50IGhhbmRsZXIgcGFzc2VkXG4gICAgIyBpbnRvIHRoaXMgZnVuY3Rpb25cbiAgICAjXG4gICAgIyBAcGFyYW0gZXZlbnRIYW5kbGVyIFtFdmVudEhhbmRsZXJdIGFuIGV2ZW50IGhhbmRsZXIgaW5zdGFuY2UgZm9yIGFcbiAgICAjICAgcGFydGljdWxhciBldmVudFxuICAgICMgQHBhcmFtIGppZCBbU3RyaW5nXSB0aGUgdXNlciBqaWRcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtTdHJvcGhlLkhhbmRsZXIsIG51bGxdIGFuIGluc3RhbmNlIG9mIGEgU3Ryb3BoZS5IYW5kbGVyIHRoYXQgaXMgY3JlYXRlZFxuICAgICMgICB1bmxlc3Mgb25lIGFscmVhZHkgZXhpc3RlZFxuICAgIGFkZEhhbmRsZXJGb3JDYWxsYmFjayA9IChldmVudEhhbmRsZXIsIGppZCkgLT5cbiAgICAgIGFkZFN0cm9waGVIYW5kbGVyTGF6aWx5IGV2ZW50SGFuZGxlciwgamlkIHVubGVzcyBldmVudEhhbmRsZXIuZ2V0U3Ryb3BoZUhhbmRsZXIoKVxuICAgICAgICAgICBcbiAgICAjIEFkZCBhIG5ldyBTdHJvcGhlIGhhbmRsZXIgdXNpbmcgdGhlIGFkZEhhbmRsZXIgbWV0aG9kIG9uXG4gICAgIyBTdHJvcGhlLkNvbm5lY3Rpb24uIFRoaXMgd2lsbCBvbmx5IGJlIGRvbmUgaWYgd2UgYWxyZWFkeSBoYXZlIGNhbGxiYWNrc1xuICAgICMgcmVnaXN0ZXJlZCBmb3IgYSBwYXJ0aWNsYXIgZXZlbnQgcGF0aC5cbiAgICAjIEBwcml2YXRlXG4gICAgI1xuICAgICMgQHBhcmFtIGV2ZW50SGFuZGxlciBbRXZlbnRIYW5kbGVyXSBpbnN0YW5jZSB0aGF0IHdpbGwgb3duIHRoZSBuZXdcbiAgICAjICAgU3Ryb3BoZSBoYW5kbGVyXG4gICAgIyBAcGFyYW0gc2VsZkpJRCBbU3RyaW5nXSB0aGUgdXNlciBqaWRcbiAgICAjIEBwYXJhbSBmaWx0ZXJKSUQgW1N0cmluZ10gZHJvcCBhbnkgc3RhbnphIG5vdCAndG8nIGppZFxuICAgICNcbiAgICAjIEByZXR1cm4gW1N0cm9waGUuSGFuZGxlcl0gaGFuZGxlIHJldHVybmVkIGJ5IFN0cm9waGUuQ29ubmVjdGlvbi5hZGRIYW5kbGVyXG4gICAgIyAgIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHN0b3AgbGlzdGVuaW5nIGxhdGVyXG4gICAgYWRkU3Ryb3BoZUhhbmRsZXIgPSAoZXZlbnRIYW5kbGVyLCBzZWxmSklELCBmaWx0ZXJKSUQpIC0+XG5cbiAgICAgIHJldHVybiBudWxsIHVubGVzcyBzZWxmSklEXG4gICAgICByZXR1cm4gbnVsbCBpZiBldmVudEhhbmRsZXIuZ2V0U3Ryb3BoZUhhbmRsZXIoKVxuICAgICAgaW52b2tlQ2FsbGJhY2tzID0gXy5iaW5kIGV2ZW50SGFuZGxlci5pbnZva2VDYWxsYmFja3MsIGV2ZW50SGFuZGxlclxuICAgICAgIyBhbHdheXMgcmV0dXJuIHRydWUgc28gU3Ryb3BoZSBkb2VzIG5vdCBkcm9wIHRoZSBoYW5kbGVyXG4gICAgICBoYW5kbGVyID0gVXRpbHMucmV0dXJuQm9vbCBpbnZva2VDYWxsYmFja3MsIHRydWVcbiAgICAgIHNpZ25hdHVyZUFyZ3MgPSBldmVudEhhbmRsZXIuZ2V0U2lnbmF0dXJlQXJncyBzZWxmSklELCBmaWx0ZXJKSURcbiAgICAgIGFyZ3MgPSBbaGFuZGxlcl0uY29uY2F0IHNpZ25hdHVyZUFyZ3NcbiAgICAgICMgSW52b2tpbmcgU3Ryb3BoZS5Db25uZWN0aW9uLmFkZEhhbmRsZXIgd2l0aDpcbiAgICAgICMgaGFuZGxlciwgbnMsIG5hbWUsIHR5cGUsIGlkLCBmcm9tLCB7bWF0Y2hCYXJlOiBib29sZWFufVxuICAgICAgc3Ryb3BoZUhhbmRsZXIgPSBhZGRIYW5kbGVyLmFwcGx5IG51bGwsIGFyZ3NcbiAgICAgIGV2ZW50SGFuZGxlci5zZXRTdHJvcGhlSGFuZGxlciBzdHJvcGhlSGFuZGxlclxuICAgICAgc3Ryb3BoZUhhbmRsZXJcbiAgIFxuICAgICMgRGVsZXRlIGEgU3Ryb3BoZSBoYW5kbGVyIHVzaW5nIGRlbGV0ZUhhbmRsZXIoKSBvbiBTdHJvcGhlLkNvbm5lY3Rpb25cbiAgICAjIEBwcml2YXRlXG4gICAgI1xuICAgICMgQHBhcmFtIFtTdHJvcGhlLkhhbmRsZXJdIFN0cm9waGUgaGFuZGxlciBpbnN0YW5jZSB0byBiZSBkZWxldGVkXG4gICAgI1xuICAgICMgQHJldHVybiBbdW5kZWZpbmVkXSByZXR1cm4gdmFsdWUgb2YgU3Ryb3BoZSdzIGRlbGV0ZUhhbmRsZXIgbWV0aG9kXG4gICAgZGVsZXRlU3Ryb3BoZUhhbmRsZXIgPSAoc3Ryb3BoZUhhbmRsZXIpIC0+XG4gICAgICByZXR1cm4gbnVsbCB1bmxlc3Mgc3Ryb3BoZUhhbmRsZXIgaW5zdGFuY2VvZiBTdHJvcGhlLkhhbmRsZXJcbiAgICAgIGRlbGV0ZUhhbmRsZXIgc3Ryb3BoZUhhbmRsZXJcbiIsIl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xuc3Ryb3BoZVByZXNlbmNlID0gcmVxdWlyZSAnc3Ryb3BoZS9zdHJvcGhlX3ByZXNlbmNlJ1xuUHJlc2VuY2VUeXBlID0gcmVxdWlyZSAnZW51bS9wcmVzZW5jZV90eXBlJ1xuTWVzc2FnZVR5cGUgPSByZXF1aXJlICdlbnVtL21lc3NhZ2VfdHlwZSdcbkV2ZW50RmlsdGVycyA9IHJlcXVpcmUgJ2V2ZW50cy9ldmVudF9maWx0ZXJzJ1xuSGlzdG9yeU5TID0gcmVxdWlyZSAnZW51bS9oaXN0b3J5X25zJ1xuQUNLTlMgPSByZXF1aXJlICdlbnVtL2Fja19ucydcbkdhdGV3YXlOYW1lID0gcmVxdWlyZSAnZW51bS9nYXRld2F5cydcblxuIyBBcHBsaWNhdGlvbnMgdXNpbmcgdGhlIE5pdHJvIFhNUFAgTGlicmFyeSBjYW4gc3Vic2NyaWJlIHRvIGV2ZW50cyBmcm9tIE5pdHJvXG4jIGJ5IHJlZ2lzdGVyaW5nIGNhbGxiYWNrcyBmb3Igc3BlY2lmaWMgZXZlbnQgdHlwZXMsIGFsbCBvZiB3aGljaCBhcmUgZGVmaW5lZFxuIyBpbiBjbGFzcyBjb25zdGFudHMgYW5kIGRlc2NyaWJlZCBoZXJlLlxuI1xuIyBAZXhhbXBsZSBTdWJzY3JpYmluZyB0byBhIHB1c2ggZXZlbnQgZm9yIGFuIHVwZGF0ZSB0byBhIHVzZXIncyBwcmVzZW5jZVxuIyAgIHZhciBjb25uZWN0aW9uID0gTml0cm8uZ2V0Q29ubmVjdGlvbigpO1xuIyAgIGNvbm5lY3Rpb24uZXZlbnRNYW5hZ2VyLmxpc3RlbihFdmVudHMuUFJFU0VOQ0VfVVNFUl9VUERBVEUsIGZ1bmN0aW9uKGRhdGEpIHtcbiMgICAgIC8vIFJlY2VpdmUgYWN0dWFsIHB1c2ggY29uZmlybWF0aW9uIChvciBhbnkgZnV0dXJlIHVwZGF0ZXMpIGZyb20gTml0cm9cbiMgICB9KTtcbiNcbiMgQGV4YW1wbGUgU3Vic2NyaWJpbmcgdG8gYSBwdXNoIGV2ZW50IGZvciByZWNlaXB0IG9mIGEgY2hhdCBtZXNzYWdlXG4jICAgdmFyIGNvbm5lY3Rpb24gPSBOaXRyby5nZXRDb25uZWN0aW9uKCk7XG4jICAgY29ubmVjdGlvbi5ldmVudE1hbmFnZXIubGlzdGVuKEV2ZW50cy5NRVNTQUdFX0NIQVRfUkVDRUlWRUQsIGZ1bmN0aW9uKGRhdGEpIHtcbiMgICAgIC8vIFJlY2VpdmUgYWN0dWFsIHB1c2ggY29uZmlybWF0aW9uIChvciBhbnkgZnV0dXJlIHVwZGF0ZXMpIGZyb20gTml0cm9cbiMgICB9KTtcbiNcbiMgQGV4YW1wbGUgU3Vic2NyaWJpbmcgdG8gYSBwdXNoIGV2ZW50IGNvbmZpcm1pbmcgYSBjb250YWN0IGFkZGVkIHRvIHRoZSBSb3N0ZXJcbiMgICB2YXIgY29ubmVjdGlvbiA9IE5pdHJvLmdldENvbm5lY3Rpb24oKTtcbiMgICBjb25uZWN0aW9uLmV2ZW50TWFuYWdlci5saXN0ZW4oRXZlbnRzLlJPU1RFUl9BRERFRCwgZnVuY3Rpb24oZGF0YSkge1xuIyAgICAgLy8gUmVjZWl2ZSBhY3R1YWwgcHVzaCBjb25maXJtYXRpb24gKG9yIGFueSBmdXR1cmUgdXBkYXRlcykgZnJvbSBOaXRyb1xuIyAgIH0pO1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFdmVudHNcblxuICAjIERlY29yYXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gYnkgb25seSBpbnZva2luZyBpdCBpZiBhIHN0YW56YSBpbmNsdWRlc1xuICAjIHRoZSByZWNpcGllbnQgSklEIHdlIGFyZSBsb29raW5nIGZvclxuICAjXG4gICMgQHBhcmFtIGZ1bmMgW0Z1bmN0aW9uXSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gICMgQHBhcmFtIGV4cGVjdGVkSklEIFtTdHJpbmddIHRoZSBKSUQgd2UgZXhwZWN0IHRvIGZpbmRcbiAgIyBAcGFyYW0gYmFyZSBbQm9vbGVhbl0gd2hldGhlciB3ZSBjYW4gbWF0Y2gganVzdCB0aGUgYmFyZSBqaWQgd2l0aG91dCB0aGUgcmVzb3VyY2VcbiAgI1xuICAjIEByZXR1cm4gW0Z1bmN0aW9uXSBhIG5ldyBjYWxsYmFjayBmdW5jdGlvblxuICAjXG4gICMgQHNlZSBFdmVudEZpbHRlcnMuZmlsdGVyQnlSZWNpcGllbnRcbiAgQGZpbHRlckJ5UmVjaXBpZW50OiAtPlxuICAgIEV2ZW50RmlsdGVycy5maWx0ZXJCeVJlY2lwaWVudC5hcHBseSBFdmVudEZpbHRlcnMsIGFyZ3VtZW50c1xuXG4gICMgRGVjb3JhdGUgYSBjYWxsYmFjayBmdW5jdGlvbiBieSBvbmx5IGludm9raW5nIGl0IGlmIGEgc3RhbnphIGluY2x1ZGVzXG4gICMgdGhlIHNlbmRlciB3ZSBhcmUgbG9va2luZyBmb3JcbiAgI1xuICAjIEBwYXJhbSBmdW5jIFtGdW5jdGlvbl0gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZVxuICAjIEBwYXJhbSBleHBlY3RlZEpJRCBbU3RyaW5nXSB0aGUgSklEIHdlIGV4cGVjdCB0byBmaW5kXG4gICMgQHBhcmFtIGJhcmUgW0Jvb2xlYW5dIHdoZXRoZXIgd2UgY2FuIG1hdGNoIGp1c3QgdGhlIGJhcmUgamlkIHdpdGhvdXQgdGhlIHJlc291cmNlXG4gICNcbiAgIyBAcmV0dXJuIFtGdW5jdGlvbl0gYSBuZXcgY2FsbGJhY2sgZnVuY3Rpb25cbiAgI1xuICAjIEBzZWUgRXZlbnRGaWx0ZXJzLmZpbHRlckJ5U2VuZGVyXG4gIEBmaWx0ZXJCeVNlbmRlcjogLT5cbiAgICBFdmVudEZpbHRlcnMuZmlsdGVyQnlTZW5kZXIuYXBwbHkgRXZlbnRGaWx0ZXJzLCBhcmd1bWVudHNcblxuICAjIFN1YnNjcmliZSB0byBwcmVzZW5jZSB1cGRhdGVzIGZvciBvdGhlciB1c2Vyc1xuICBAUFJFU0VOQ0VfVVNFUl9VUERBVEU6ICdwcmVzZW5jZS51c2VyLnVwZGF0ZSdcblxuICAjIFJlY2VpdmUgY29uZmlybWF0aW9uIG9mIHNldHRpbmcgc2VsZiBwcmVzZW5jZVxuICBAUFJFU0VOQ0VfU0VMRl9VUERBVEU6ICdwcmVzZW5jZS5zZWxmLnVwZGF0ZSdcblxuICAjIFJlY2VpdmUgdXBkYXRlZCBwcmVmZXJlbmNlcyBmcm9tIE5pdHJvXG4gIEBQUkVGRVJFTkNFU19VUERBVEU6ICdwcmVmZXJlbmNlcy51cGRhdGUnXG5cbiAgIyBSZWNlaXZlIHVwZGF0ZWQgYm9va21hcmtzIGZyb20gTml0cm9cbiAgQEJPT0tNQVJLU19VUERBVEU6ICdib29rbWFya3MudXBkYXRlJ1xuXG4gICMgUmVjZWl2ZSBub3RpY2Ugb2YgcmVjZWlwdCBvZiBhbiBpbmNvbWluZyBjaGF0IG1lc3NhZ2VcbiAgQE1FU1NBR0VfQ0hBVF9SRUNFSVZFRDogJ21lc3NhZ2UuY2hhdC5yZWNlaXZlZCdcblxuICAjIFJlY2VpdmUgbm90aWNlIG9mIHJlY2VpcHQgb2YgYW4gaW5jb21pbmcgY2hhdCBoaXN0b3J5IG1lc3NhZ2VcbiAgQE1FU1NBR0VfQ0hBVF9ISVNUT1JZX1JFQ0VJVkVEOiAnbWVzc2FnZS5jaGF0Lmhpc3RvcnkucmVjZWl2ZWQnXG5cbiAgIyBSZWNlaXZlIG5vdGljZSBvZiB3aGVuIGEgY2hhdCBtZXNzYWdlIGhhcyBiZWVuIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXJcbiAgIyBzdWNjZXNzZnVsIGRlbGl2ZXJ5IG9mIGFuIG91dGdvaW5nIGNoYXQgbWVzc2FnZVxuICBATUVTU0FHRV9DSEFUX1JFR0lTVEVSRUQ6ICdtZXNzYWdlLmNoYXQucmVnaXN0ZXJlZCdcblxuICAjIFJlY2VpdmUgbm90aWNlIG9mIHN1Y2Nlc3NmdWwgY2xpZW50IGRlbGl2ZXJ5IG9mIGFuIG91dGdvaW5nIGNoYXQgbWVzc2FnZVxuICBATUVTU0FHRV9DSEFUX0RFTElWRVJFRDogJ21lc3NhZ2UuY2hhdC5kZWxpdmVyZWQnXG5cbiAgIyBSZWNlaXZlIG5vdGljZSBvZiBhIGZhaWxlZCBvdXRnb2luZyBjaGF0IG1lc3NhZ2UgZHVlIHRvIGEgY29tcGxpYW5jZSBlcnJvclxuICAjIG9yIHRoZSByZWNpcGllbnQgaXMgb2ZmbGluZVxuICBATUVTU0FHRV9DSEFUX0ZBSUxFRDogJ21lc3NhZ2UuY2hhdC5mYWlsZWQnXG5cbiAgIyBSZWNlaXZlIG5vdGljZSB3aGVuIGNoYXQgKDEtMSkgaGlzdG9yeSBtZXNzYWdlIGZsdXNoIGlzIGNvbSBoYXZlIGJlZW4gY29tcGxldGVseSBmbHVzaGVkXG4gIEBNRVNTQUdFX0NIQVRfRklOOiAnbWVzc2FnZS5jaGF0LmZpbidcblxuICAjIFJlY2VpdmUgbm90aWNlIG9mIGFuIGluY29taW5nIGdyb3VwY2hhdCBpbnZpdGF0aW9uXG4gIEBNRVNTQUdFX0dST1VQQ0hBVF9JTlZJVEU6ICdtZXNzYWdlLmdyb3VwY2hhdC5pbnZpdGUnXG5cbiAgIyBSZWNlaXZlIG5vdGljZSBvZiBhIHJlamVjdGVkIGdyb3VwY2hhdCBpbnZpdGF0aW9uXG4gIEBNRVNTQUdFX0dST1VQQ0hBVF9JTlZJVEVfUkVKRUNURUQ6ICdtZXNzYWdlLmdyb3VwY2hhdC5pbnZpdGUucmVqZWN0ZWQnXG5cbiAgIyBSZWNlaXZlIGEgbm90aWNlIHRoYXQgYW4gb3V0Z29pbmcgZ3JvdXBjaGF0IGludml0ZSB3YXMgYmxvY2tlZCBieSBjb21wbGlhbmNlXG4gIEBNRVNTQUdFX0dST1VQQ0hBVF9JTlZJVEVfQkxPQ0tFRDogJ21lc3NhZ2UuZ3JvdXBjaGF0Lmludml0ZS5ibG9ja2VkJ1xuXG4gICMgUmVjZWl2ZSBhIG5vdGljZSB0aGF0IGFuIG91dGdvaW5nIGdyb3VwY2hhdCBpbnZpdGUgaGFzIGZhaWxlZCB3aXRoIGFuIGVycm9yXG4gIEBNRVNTQUdFX0dST1VQQ0hBVF9JTlZJVEVfRVJST1I6ICdtZXNzYWdlLmdyb3VwY2hhdC5pbnZpdGUuZXJyb3InXG5cbiAgIyBSZWNlaXZlIG5vdGljZSBvZiBhIHN1Y2Nlc3NmdWxseSByZWNlaXZlZCBpbmNvbWluZyBncm91cGNoYXQgbWVzc2FnZVxuICBATUVTU0FHRV9HUk9VUENIQVRfUkVDRUlWRUQ6ICdtZXNzYWdlLmdyb3VwY2hhdC5yZWNlaXZlZCdcblxuICAjIFJlY2VpdmUgbm90aWNlIG9mIHJlY2VpcHQgb2YgYW4gaW5jb21pbmcgY2hhdCBoaXN0b3J5IG1lc3NhZ2VcbiAgQE1FU1NBR0VfR1JPVVBDSEFUX0hJU1RPUllfUkVDRUlWRUQ6ICdtZXNzYWdlLmdyb3VwY2hhdC5oaXN0b3J5LnJlY2VpdmVkJ1xuXG4gICMgUmVjZWl2ZSBub3RpY2Ugb2YgaGlzdG9yeSBibG9ja2VkIGR1ZSB0byBjb21wYW55IHBvbGljeVxuICBAUFJFU0VOQ0VfR1JPVVBDSEFUX0hJU1RPUllfQkxPQ0tFRDogJ21lc3NhZ2UuZ3JvdXBjaGF0Lmhpc3RvcnkuYmxvY2tlZCdcblxuICAjIFJlY2VpdmUgbm90aWNlIG9mIHdoZW4gYSBncm91cGNoYXQgbWVzc2FnZSBoYXMgYmVlbiByZWNlaXZlZCBieSB0aGUgc2VydmVyXG4gICMgc3VjY2Vzc2Z1bCBkZWxpdmVyeSBvZiBhbiBvdXRnb2luZyBjaGF0IG1lc3NhZ2VcbiAgQE1FU1NBR0VfR1JPVVBDSEFUX1JFR0lTVEVSRUQ6ICdtZXNzYWdlLmdyb3VwY2hhdC5yZWdpc3RlcmVkJ1xuXG4gICMgUmVjZWl2ZSBhIG5vdGljZSB3aGVuIGEgZ3JvdXBjaGF0IG1lc3NhZ2UgaGFzIGJlZW4gcmVjZWl2ZWQgYnkgdGhlIGxlZ2FjeVxuICAjIGdyb3VwY2hhdCBzZXJ2ZXIgKHZpYSBNVUMgQWRhcHRlcilcbiAgQE1FU1NBR0VfTUFOQUdFRF9HUk9VUENIQVRfUkVHSVNURVJFRDogJ21lc3NhZ2UubWFuYWdlZC5ncm91cGNoYXQucmVnaXN0ZXJlZCdcblxuICAjIFJlY2VpdmUgbm90aWNlIG9mIHN1Y2Nlc3NmdWwgY2xpZW50IGRlbGl2ZXJ5IG9mIGFuIG91dGdvaW5nIGdyb3VwY2hhdCBtZXNzYWdlXG4gIEBNRVNTQUdFX0dST1VQQ0hBVF9ERUxJVkVSRUQ6ICdtZXNzYWdlLmdyb3VwY2hhdC5kZWxpdmVyZWQnXG5cbiAgIyBSZWNlaXZlIG5vdGljZSBvZiBhIGZhaWxlZCBvdXRnb2luZyBncm91cGNoYXQgbWVzc2FnZSBiZWNhdXNlIG9mIGEgY29tcGxpYW5jZSBlcnJvclxuICBATUVTU0FHRV9HUk9VUENIQVRfRkFJTEVEOiAnbWVzc2FnZS5ncm91cGNoYXQuZmFpbGVkJ1xuXG4gICMgUmVjZWl2ZSBzdWJqZWN0IGxpbmUgZm9yIGdyb3VwY2hhdC5cbiAgQE1FU1NBR0VfR1JPVVBDSEFUX1NVQkpFQ1QgPSAnbWVzc2FnZS5ncm91cGNoYXQuc3ViamVjdCdcblxuICAjIFJlY2VpdmUgY29uZmlybWF0aW9uIG9mIGEgcmVxdWVzdCB0byBhZGQgdXNlcihzKSB0byB0aGUgUm9zdGVyXG4gIEBST1NURVJfQURERUQ6ICdyb3N0ZXIuYWRkZWQnXG5cbiAgIyBSZWNlaXZlIGNvbmZpcm1hdGlvbiBvZiBhIHJlcXVlc3QgdG8gcmVtb3ZlIHVzZXIocykgZnJvbSB0aGUgUm9zdGVyXG4gIEBST1NURVJfUkVNT1ZFRDogJ3Jvc3Rlci5yZW1vdmVkJ1xuXG4gICMgUmVjZWl2ZSBhbiBpbmNvbWluZyByZXF1ZXN0IGZyb20gYW5vdGhlciB1c2VyIHdobyB3YW50cyB0byBzZWUgeW91ciBwcmVzZW5jZVxuICAjXG4gICMgQGV4YW1wbGVcbiAgIyAgIFhNTCByZWNlaXZlZCBieSBRQTkgd2hlbiBoZSBpcyBiZWluZyBpbnZpdGVkIGJ5IFFBOFxuICAjICAgPHByZXNlbmNlXG4gICMgICAgIHRvPVwicm0tcWFfOS50aG9tc29ucmV1dGVycy5jb21AcmV1YXNtYi5uZXRcIlxuICAjICAgICBmcm9tPVwicm0tcWFfOC50aG9tc29ucmV1dGVycy5jb21AcmV1YXNtYi5uZXRcIlxuICAjICAgICB0eXBlPVwic3Vic2NyaWJlXCJcbiAgIyAgICAgbmFtZT1cIlJNIFFBOCAtIFBpb25lZXIgSW52ZXN0bWVudCBNYW5hZ2VtZW50IFNHUnBBXCJcbiAgIyAgICAgZW1haWw9XCJybS1xYV84QHRob21zb25yZXV0ZXJzLmNvbVwiIGNvbXBhbnk9XCJQaW9uZWVyIEludmVzdG1lbnQgTWFuYWdlbWVudCBTR1JwQVwiXG4gICMgICAvPlxuICBAUk9TVEVSX0lOVklURV9SRUNFSVZFRDogJ3Jvc3Rlci5pbnZpdGUucmVjZWl2ZWQnXG5cbiAgIyBSZWNlaXZlIGNvbmZpcm1hdGlvbiBmb3IgeW91ciBvdXRnb2luZyBpbnZpdGUgdG8gc2VlIGEgdXNlcidzIHByZXNlbmNlXG4gICNcbiAgIyBAZXhhbXBsZVxuICAjICAgWE1MIGNvbmZpcm1hdGlvbiByZWNlaXZlZCBieSBRQTggYWZ0ZXIgaGUgaW52aXRlZCBRQTkgKGFuZCB3YXMgYWNjZXB0ZWQpXG4gICMgICA8cHJlc2VuY2VcbiAgIyAgICAgdG89XCJybS1xYV84LnRob21zb25yZXV0ZXJzLmNvbUByZXVhc21iLm5ldFwiXG4gICMgICAgIGZyb209XCJybS1xYV85LnRob21zb25yZXV0ZXJzLmNvbUByZXVhc21iLm5ldFwiXG4gICMgICAgIHR5cGU9XCJzdWJzY3JpYmVkXCJcbiAgIyAgICAgbmFtZT1cIlJNIFFBOSAtIFBpb25lZXIgSW52ZXN0bWVudCBNYW5hZ2VtZW50IFNHUnBBXCJcbiAgIyAgICAgZW1haWw9XCJybS1xYV85QHRob21zb25yZXV0ZXJzLmNvbVwiIC8+XG4gICMgICAvPlxuICBAUk9TVEVSX0lOVklURV9DT05GSVJNRUQ6ICdyb3N0ZXIuaW52aXRlLmNvbmZpcm1lZCdcblxuICAjIFJlY2VpdmUgY29uZmlybWF0aW9uIG9mIGEgcmVxdWVzdCB0byBibG9jayB1c2VyKHMpXG4gIEBCTE9DS0xJU1RfQkxPQ0s6ICdibG9ja2xpc3QuYmxvY2tlZCdcblxuICAjIFJlY2VpdmUgY29uZmlybWF0aW9uIG9mIGEgcmVxdWVzdCB0byB1bmJsb2NrIHVzZXIocylcbiAgQEJMT0NLTElTVF9VTkJMT0NLOiAnYmxvY2tsaXN0LnVuYmxvY2tlZCdcblxuICAjIFJlY2VpdmUgY29uZmlybWF0aW9uIG9mIHdoZW4gc2VsZiBqb2luZWQgYSBncm91cGNoYXRcbiAgQEdST1VQQ0hBVF9TRUxGX0pPSU5FRDogJ2dyb3VwY2hhdC5zZWxmLmpvaW5lZCdcblxuICAjIFJlY2VpdmUgY29uZmlybWF0aW9uIG9mIHdoZW4gc2VsZiBsZWZ0IGEgZ3JvdXBjaGF0XG4gIEBHUk9VUENIQVRfU0VMRl9MRUZUOiAnZ3JvdXBjaGF0LnNlbGYubGVmdCdcblxuICAjIFJlY2VpdmUgY29uZmlybWF0aW9uIG9mIHdoZW4gYSB1c2VyIGpvaW5lZCBhIGdyb3VwY2hhdFxuICBAR1JPVVBDSEFUX1VTRVJfSk9JTkVEOiAnZ3JvdXBjaGF0LnVzZXIuam9pbmVkJ1xuXG4gICMgUmVjZWl2ZSBjb25maXJtYXRpb24gb2Ygd2hlbiBhIHVzZXIgbGVmdCBhIGdyb3VwY2hhdFxuICBAR1JPVVBDSEFUX1VTRVJfTEVGVDogJ2dyb3VwY2hhdC51c2VyLmxlZnQnXG5cbiAgIyBSZWNlaXZlIGVycm9yIGNyZWF0aW5nIGdyb3VwY2hhdFxuICBAR1JPVVBDSEFUX0NSRUFURV9FUlJPUjogJ2dyb3VwY2hhdC5jcmVhdGUuZXJyb3InXG5cbiAgIyBSZWNlaXZlIGVycm9yIGpvaW5pbmcgZ3JvdXBjaGF0XG4gIEBHUk9VUENIQVRfSk9JTl9FUlJPUjogJ2dyb3VwY2hhdC5qb2luLmVycm9yJ1xuXG4gICMgUmVjZWl2ZSBzdGF0dXMgY29kZSB0aGF0IGEgZ3JvdXBjaGF0cyBjb25maWd1cmF0aW9uIGhhcyBjaGFuZ2VkXG4gIEBHUk9VUENIQVRfQ09ORklHVVJBVElPTl9DSEFOR0U6ICdncm91cGNoYXQuY29uZmlnLmNoYW5nZWQnXG5cbiAgIyBSZWNlaXZlIGEgcmVxdWVzdCBmcm9tIHJlbW90ZSBnYXRld2F5IHRvICdzdWJzY3JpYmUnIChpLmUuLCBnbyBvbmxpbmUpXG4gIEBHQVRFV0FZX1lBSE9PX1NVQlNDUklCRTogJ2dhdGV3YXkueWFob28uc3Vic2NyaWJlJ1xuXG4gICMgUmVjZWl2ZSBhIHJlcXVlc3QgZnJvbSByZW1vdGUgZ2F0ZXdheSB0byAnc3Vic2NyaWJlJyAoaS5lLiwgZ28gb25saW5lKVxuICBAR0FURVdBWV9ZQUhPT19TRUxGX1BSRVNFTkNFOiAnZ2F0ZXdheS55YWhvby5zZWxmLnByZXNlbmNlJ1xuXG4gICMgUmVjZWl2ZSBhIG5vdGljZSB0aGF0IHNlbGYgaXMgbm8gbG9uZ2VyIHN1YnNjcmliZWQgdG8gdGhlIGdhdGV3YXkgKG5vdyBvZmZsaW5lKVxuICBAR0FURVdBWV9ZQUhPT19VTlNVQlNDUklCRUQ6ICdnYXRld2F5LnlhaG9vLnVuc3Vic2NyaWJlZCdcblxuICAjIFJlY2VpdmUgYSBzdHJlYW0gZXJyb3Igc3RhbnphIGZyb20gTml0cm8gaW5kaWNhdGluZyB0aGF0IHdlIGhhdmUgYmVlblxuICAjIGxvZ2dlZCBpbiBlbHNld2hlcmVcbiAgQFNUUkVBTV9FUlJPUjogJ3N0cmVhbS5lcnJvcidcblxuICAjIFJlY2VpdmUgYSBub3RpY2UgdGhhdCBhIHBhcnRuZXIgaXMgXCJjb21wb3NpbmdcIiBhIG1lc3NhZ2UuXG4gIEBUWVBJTkdfTk9USUNFOiAndHlwaW5nLm5vdGljZSdcblxuICBATkFNRV9NRVNTQUdFID0gJ21lc3NhZ2UnXG4gIEBOQU1FX1BSRVNFTkNFID0gc3Ryb3BoZVByZXNlbmNlLlBSRVNFTkNFXG4gIEBOQU1FX0lRID0gJ2lxJ1xuXG4gIEBUWVBFX0hFQURMSU5FID0gJ2hlYWRsaW5lJ1xuICBAVFlQRV9TRVQgPSAnc2V0J1xuICBAVFlQRV9DSEFUID0gTWVzc2FnZVR5cGUuQ0hBVFxuICBAVFlQRV9HUk9VUENIQVQgPSBNZXNzYWdlVHlwZS5HUk9VUENIQVRcblxuICAjIGFkZCB0eXBlIG5vcm1hbFxuICBAVFlQRV9FUlJPUiA9ICdlcnJvcidcblxuICAjIFN0YXRpYyBtZXRob2QgdG8gcmV0cmlldmUgYSBjb25maWcgb2JqZWN0LCBpbmNsdWRpbmcgYWxsIE5pdHJvIGV2ZW50c1xuICAjIHRoYXQgYXBwbGljYXRpb25zIGNhbiBzdWJzY3JpYmUgdG9cbiAgI1xuICAjIEByZXR1cm4gW09iamVjdF0gaGFzaCB3aG9zZSBrZXlzIGFyZSBhbGwgY29uc3RhbnRzIG9uIHRoaXMgY2xhc3NcbiAgQGdldENvbmZpZzogLT5cbiAgICBjb25maWcgPSB7fVxuXG4gICAgY29uZmlnW0BQUkVTRU5DRV9VU0VSX1VQREFURV0gPVxuICAgICAgbmFtZTogQE5BTUVfUFJFU0VOQ0VcbiAgICAgIGZpbHRlcnM6IFtcbiAgICAgICAgRXZlbnRGaWx0ZXJzLmlzbnRNVUNcbiAgICAgICAgRXZlbnRGaWx0ZXJzLmlzbnRTZWxmXG4gICAgICAgIEV2ZW50RmlsdGVycy5pc250U3Vic2NyaWJlZFxuICAgICAgICBFdmVudEZpbHRlcnMuaXNudFVuc3Vic2NyaWJlXG4gICAgICBdXG5cbiAgICBjb25maWdbQFBSRVNFTkNFX1NFTEZfVVBEQVRFXSA9XG4gICAgICBuYW1lOiBATkFNRV9QUkVTRU5DRVxuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5pc1NlbGZdXG5cbiAgICBjb25maWdbQFBSRUZFUkVOQ0VTX1VQREFURV0gPVxuICAgICAgbmFtZTogQE5BTUVfTUVTU0FHRVxuICAgICAgdHlwZTogQFRZUEVfSEVBRExJTkVcbiAgICAgIG5zOiAnaHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvcHVic3ViI2V2ZW50J1xuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5pc1ByZWZlcmVuY2VzXVxuXG4gICAgY29uZmlnW0BCT09LTUFSS1NfVVBEQVRFXSA9XG4gICAgICBuYW1lOiBATkFNRV9NRVNTQUdFXG4gICAgICB0eXBlOiBAVFlQRV9IRUFETElORVxuICAgICAgbnM6ICdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9wdWJzdWIjZXZlbnQnXG4gICAgICBmaWx0ZXJzOiBbRXZlbnRGaWx0ZXJzLmlzQm9va21hcmtzXVxuXG4gICAgY29uZmlnW0BNRVNTQUdFX0NIQVRfSElTVE9SWV9SRUNFSVZFRF0gPVxuICAgICAgbmFtZTogQE5BTUVfTUVTU0FHRVxuICAgICAgbnM6IEhpc3RvcnlOUy5DSEFUX0hJU1RPUllcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaXNudE1VQ11cblxuICAgIGNvbmZpZ1tATUVTU0FHRV9DSEFUX1JFQ0VJVkVEXSA9XG4gICAgICBuYW1lOiBATkFNRV9NRVNTQUdFXG4gICAgICB0eXBlOiBAVFlQRV9DSEFUXG4gICAgICBmaWx0ZXJzOiBbRXZlbnRGaWx0ZXJzLmlzbnRNVUNdXG5cbiAgICBjb25maWdbQE1FU1NBR0VfQ0hBVF9SRUdJU1RFUkVEXSA9XG4gICAgICBuYW1lOiBATkFNRV9NRVNTQUdFXG4gICAgICBuczogQUNLTlMuTklUUk9fUkVDRUlQVFNcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaXNudE1VQ11cblxuICAgIGNvbmZpZ1tATUVTU0FHRV9DSEFUX0RFTElWRVJFRF0gPVxuICAgICAgbmFtZTogQE5BTUVfTUVTU0FHRVxuICAgICAgdHlwZTogQFRZUEVfQ0hBVFxuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5pc0NsaWVudEFjaywgRXZlbnRGaWx0ZXJzLmlzbnRNVUNdXG5cbiAgICBjb25maWdbQE1FU1NBR0VfQ0hBVF9GQUlMRURdID1cbiAgICAgIG5hbWU6IEBOQU1FX01FU1NBR0VcbiAgICAgIHR5cGU6IEBUWVBFX0VSUk9SXG4gICAgICBmaWx0ZXJzOiBbRXZlbnRGaWx0ZXJzLmlzbnRNVUNdXG5cbiAgICBjb25maWdbQE1FU1NBR0VfR1JPVVBDSEFUX0lOVklURV0gPVxuICAgICAgbmFtZTogQE5BTUVfTUVTU0FHRVxuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5pc01VQ0ludml0ZSwgRXZlbnRGaWx0ZXJzLmlzbnRFcnJvcl1cblxuICAgIGNvbmZpZ1tATUVTU0FHRV9HUk9VUENIQVRfSU5WSVRFX1JFSkVDVEVEXSA9XG4gICAgICBuYW1lOiBATkFNRV9NRVNTQUdFXG4gICAgICBmaWx0ZXJzOiBbRXZlbnRGaWx0ZXJzLmlzTVVDLCBFdmVudEZpbHRlcnMuaGFzRGVjbGluZV1cblxuICAgIGNvbmZpZ1tATUVTU0FHRV9HUk9VUENIQVRfSU5WSVRFX0JMT0NLRURdID1cbiAgICAgIG5hbWU6IEBOQU1FX01FU1NBR0VcbiAgICAgIHR5cGU6IEBUWVBFX0VSUk9SXG4gICAgICBmaWx0ZXJzOiBbXG4gICAgICAgIEV2ZW50RmlsdGVycy5oYXNQb2xpY3lWaW9sYXRpb25cbiAgICAgICAgRXZlbnRGaWx0ZXJzLmhhc0ludml0ZWVcbiAgICAgICAgRXZlbnRGaWx0ZXJzLmhhc250RXJyb3JUeXBlQ2FuY2VsXG4gICAgICBdXG5cbiAgICBjb25maWdbQE1FU1NBR0VfR1JPVVBDSEFUX0lOVklURV9FUlJPUl0gPVxuICAgICAgbmFtZTogQE5BTUVfTUVTU0FHRVxuICAgICAgdHlwZTogQFRZUEVfRVJST1JcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaGFzRXJyb3JUeXBlQ2FuY2VsLCBFdmVudEZpbHRlcnMuaGFzSW52aXRlZV1cblxuICAgIGNvbmZpZ1tATUVTU0FHRV9HUk9VUENIQVRfU1VCSkVDVF0gPVxuICAgICAgbmFtZTogQE5BTUVfTUVTU0FHRVxuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5pc01VQ1N1YmplY3RdXG5cbiAgICBjb25maWdbQE1FU1NBR0VfR1JPVVBDSEFUX1JFQ0VJVkVEXSA9XG4gICAgICBuYW1lOiBATkFNRV9NRVNTQUdFXG4gICAgICB0eXBlOiBAVFlQRV9HUk9VUENIQVRcbiAgICAgIGZpbHRlcnM6IFtcbiAgICAgICAgRXZlbnRGaWx0ZXJzLmlzbnRNVUNTZWxmXG4gICAgICAgIEV2ZW50RmlsdGVycy5pc250TVVDSW52aXRlXG4gICAgICAgIEV2ZW50RmlsdGVycy5pc250TVVDU3ViamVjdFxuICAgICAgICBFdmVudEZpbHRlcnMuaXNudERlbGF5ZWRcbiAgICAgICAgRXZlbnRGaWx0ZXJzLmhhc0JvZHlUYWdcbiAgICAgIF1cblxuICAgIGNvbmZpZ1tATUVTU0FHRV9NQU5BR0VEX0dST1VQQ0hBVF9SRUdJU1RFUkVEXSA9XG4gICAgICBuYW1lOiBATkFNRV9NRVNTQUdFXG4gICAgICBuczogQUNLTlMuU1RBTkRBUkRfUkVDRUlQVFNcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaXNNVUMsIEV2ZW50RmlsdGVycy5oYXNudEVycm9yVHlwZU1vZGlmeV1cblxuICAgIGNvbmZpZ1tATUVTU0FHRV9HUk9VUENIQVRfSElTVE9SWV9SRUNFSVZFRF0gPVxuICAgICAgbmFtZTogQE5BTUVfTUVTU0FHRVxuICAgICAgdHlwZTogQFRZUEVfR1JPVVBDSEFUXG4gICAgICBuczogSGlzdG9yeU5TLkRFTEFZXG4gICAgICBmaWx0ZXJzOiBbRXZlbnRGaWx0ZXJzLmlzRGVsYXllZF1cblxuICAgIGNvbmZpZ1tATUVTU0FHRV9HUk9VUENIQVRfUkVHSVNURVJFRF0gPVxuICAgICAgbmFtZTogQE5BTUVfTUVTU0FHRVxuICAgICAgdHlwZTogQFRZUEVfR1JPVVBDSEFUXG4gICAgICBmaWx0ZXJzOiBbRXZlbnRGaWx0ZXJzLmlzR3JvdXBjaGF0QWNrXVxuXG4gICAgY29uZmlnW0BNRVNTQUdFX0dST1VQQ0hBVF9ERUxJVkVSRURdID1cbiAgICAgIG5hbWU6IEBOQU1FX01FU1NBR0VcbiAgICAgIHR5cGU6IEBUWVBFX0dST1VQQ0hBVFxuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5pc0NsaWVudEFja11cblxuICAgIGNvbmZpZ1tATUVTU0FHRV9HUk9VUENIQVRfRkFJTEVEXSA9XG4gICAgICBuYW1lOiBATkFNRV9NRVNTQUdFXG4gICAgICB0eXBlOiBAVFlQRV9FUlJPUlxuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5pc01VQ11cblxuICAgIGNvbmZpZ1tATUVTU0FHRV9DSEFUX0ZJTl0gPVxuICAgICAgbmFtZTogQE5BTUVfTUVTU0FHRVxuICAgICAgbnM6IEhpc3RvcnlOUy5DSEFUX0hJU1RPUllcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaXNIaXN0b3J5RmluXVxuXG4gICAgY29uZmlnW0BST1NURVJfQURERURdID1cbiAgICAgIG5hbWU6IEBOQU1FX0lRXG4gICAgICB0eXBlOiBAVFlQRV9TRVRcbiAgICAgIG5zOiAnamFiYmVyOmlxOnJvc3RlcidcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaXNSb3N0ZXJBZGRlZF1cblxuICAgIGNvbmZpZ1tAUk9TVEVSX1JFTU9WRURdID1cbiAgICAgIG5hbWU6IEBOQU1FX0lRXG4gICAgICB0eXBlOiBAVFlQRV9TRVRcbiAgICAgIG5zOiAnamFiYmVyOmlxOnJvc3RlcidcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaXNSb3N0ZXJSZW1vdmVkXVxuXG4gICAgY29uZmlnW0BST1NURVJfSU5WSVRFX1JFQ0VJVkVEXSA9XG4gICAgICBuYW1lOiBATkFNRV9QUkVTRU5DRVxuICAgICAgdHlwZTogUHJlc2VuY2VUeXBlLlNVQlNDUklCRVxuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5pc250U2VsZiwgRXZlbnRGaWx0ZXJzLmlzbnRZYWhvb0dhdGV3YXldXG5cbiAgICBjb25maWdbQFJPU1RFUl9JTlZJVEVfQ09ORklSTUVEXSA9XG4gICAgICBuYW1lOiBATkFNRV9QUkVTRU5DRVxuICAgICAgdHlwZTogUHJlc2VuY2VUeXBlLlNVQlNDUklCRVxuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5pc250U2VsZl1cblxuICAgIGNvbmZpZ1tAQkxPQ0tMSVNUX0JMT0NLXSA9XG4gICAgICBuYW1lOiBATkFNRV9JUVxuICAgICAgdHlwZTogQFRZUEVfU0VUXG4gICAgICBuczogJ3Vybjp4bXBwOmJsb2NraW5nJ1xuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5pc0Jsb2NrbGlzdEJsb2NrZWRdXG5cbiAgICBjb25maWdbQEJMT0NLTElTVF9VTkJMT0NLXSA9XG4gICAgICBuYW1lOiBATkFNRV9JUVxuICAgICAgdHlwZTogQFRZUEVfU0VUXG4gICAgICBuczogJ3Vybjp4bXBwOmJsb2NraW5nJ1xuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5pc0Jsb2NrbGlzdFVuYmxvY2tlZF1cblxuICAgIGNvbmZpZ1tAR1JPVVBDSEFUX1NFTEZfSk9JTkVEXSA9XG4gICAgICBuYW1lOiBATkFNRV9QUkVTRU5DRVxuICAgICAgbnM6ICdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWMjdXNlcidcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaXNNVUNTZWxmLCBFdmVudEZpbHRlcnMuaGFzbnRUeXBlXVxuXG4gICAgY29uZmlnW0BHUk9VUENIQVRfU0VMRl9MRUZUXSA9XG4gICAgICBuYW1lOiBATkFNRV9QUkVTRU5DRVxuICAgICAgbnM6ICdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWMjdXNlcidcbiAgICAgIHR5cGU6IFByZXNlbmNlVHlwZS5VTkFWQUlMQUJMRVxuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5pc01VQ1NlbGZdXG5cbiAgICBjb25maWdbQEdST1VQQ0hBVF9VU0VSX0pPSU5FRF0gPVxuICAgICAgbmFtZTogQE5BTUVfUFJFU0VOQ0VcbiAgICAgIG5zOiAnaHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvbXVjI3VzZXInXG4gICAgICBmaWx0ZXJzOiBbRXZlbnRGaWx0ZXJzLmlzbnRNVUNTZWxmLCBFdmVudEZpbHRlcnMuaGFzbnRUeXBlXVxuXG4gICAgY29uZmlnW0BHUk9VUENIQVRfVVNFUl9MRUZUXSA9XG4gICAgICBuYW1lOiBATkFNRV9QUkVTRU5DRVxuICAgICAgbnM6ICdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWMjdXNlcidcbiAgICAgIHR5cGU6IFByZXNlbmNlVHlwZS5VTkFWQUlMQUJMRVxuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5pc250TVVDU2VsZl1cblxuICAgIGNvbmZpZ1tAR1JPVVBDSEFUX0pPSU5fRVJST1JdID1cbiAgICAgIG5hbWU6IEBOQU1FX1BSRVNFTkNFXG4gICAgICB0eXBlOiBQcmVzZW5jZVR5cGUuRVJST1JcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaXNNVUNTZWxmXVxuXG4gICAgY29uZmlnW0BHUk9VUENIQVRfQ09ORklHVVJBVElPTl9DSEFOR0VdID1cbiAgICAgIG5hbWU6IEBOQU1FX01FU1NBR0VcbiAgICAgIHR5cGU6IEBUWVBFX0dST1VQQ0hBVFxuICAgICAgZmlsdGVyczogW0V2ZW50RmlsdGVycy5oYXNTdGF0dXNDb2RlXVxuXG4gICAgY29uZmlnW0BHQVRFV0FZX1lBSE9PX1NVQlNDUklCRV0gPVxuICAgICAgbmFtZTogQE5BTUVfUFJFU0VOQ0VcbiAgICAgIHR5cGU6IFByZXNlbmNlVHlwZS5TVUJTQ1JJQkVcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaXNZYWhvb0dhdGV3YXldXG5cbiAgICBjb25maWdbQEdBVEVXQVlfWUFIT09fU0VMRl9QUkVTRU5DRV0gPVxuICAgICAgbmFtZTogQE5BTUVfUFJFU0VOQ0VcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaXNZYWhvb0dhdGV3YXksIEV2ZW50RmlsdGVycy5pc250U3Vic2NyaWJlXVxuXG4gICAgY29uZmlnW0BHQVRFV0FZX1lBSE9PX1VOU1VCU0NSSUJFRF0gPVxuICAgICAgbmFtZTogQE5BTUVfUFJFU0VOQ0VcbiAgICAgIHR5cGU6IFByZXNlbmNlVHlwZS5VTlNVQlNDUklCRURcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaXNZYWhvb0dhdGV3YXldXG5cbiAgICBjb25maWdbQFNUUkVBTV9FUlJPUl0gPVxuICAgICAgbmFtZTogJ3N0cmVhbTplcnJvcidcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaXNDb25mbGljdF1cblxuICAgIGNvbmZpZ1tAVFlQSU5HX05PVElDRV0gPVxuICAgICAgbmFtZTogJ21lc3NhZ2UnXG4gICAgICBmaWx0ZXJzOiBbRXZlbnRGaWx0ZXJzLmlzVHlwaW5nTm90aWNlXVxuXG4gICAgY29uZmlnW0BQUkVTRU5DRV9HUk9VUENIQVRfSElTVE9SWV9CTE9DS0VEXSA9XG4gICAgICBuYW1lOiBATkFNRV9QUkVTRU5DRVxuICAgICAgdHlwZTogQFRZUEVfRVJST1JcbiAgICAgIGZpbHRlcnM6IFtFdmVudEZpbHRlcnMuaXNIaXN0b3J5QmxvY2tlZF1cbiAgICByZXR1cm4gY29uZmlnXG4iLCIjIElPRXZlbnQgY29udGFpbnMgZW51bXMgZm9yIHR5cGVzIG9mIFN0cm9waGUgSU8gZXZlbnRzIHdlIGNhbiBsaXN0ZW4gdG8uXG4jXG4jIEBleGFtcGxlXG4jICAgTGlzdGVuIHRvIFJBVywgSU5QVVQgZXZlbnRzLlxuIyAgIExpc3RlbiB0byBSQVcsIE9VVFBVVCBldmVudHMuXG4jICAgTGlzdGVuIHRvIFhNTCwgSU5QVVQgZXZlbnRzLlxuIyAgIExpc3RlbiB0byBYTUwsIElOUFVUIGV2ZW50cy5cbiMgICBMaXN0ZW4gdG8gUkFXLCBJTlBVVCBhbmQgT1VUUFVUIGV2ZW50cy5cbiMgICBMaXN0ZW4gdG8gWE1MLCBJTlBVVCBhbmQgT1VUUFVUIGV2ZW50cy5cbm1vZHVsZS5leHBvcnRzID1cbiAgIyBAcHJvcGVydHkgW1N0cmluZ10gUmF3IGV2ZW50cy5cbiAgUkFXOiAnSU9FdmVudC5SQVcnXG4gICMgQHByb3BlcnR5IFtTdHJpbmddIFhNTCBldmVudHMuXG4gIFhNTDogJ0lPRXZlbnQuWE1MJ1xuXG4gICMgQHByb3BlcnR5IFtTdHJpbmddIElucHV0IGV2ZW50cy5cbiAgSU5QVVQ6ICdJT0V2ZW50LklOUFVUJ1xuICAjIEBwcm9wZXJ0eSBbU3RyaW5nXSBPdXRwdXQgZXZlbnRzLlxuICBPVVRQVVQ6ICdJT0V2ZW50Lk9VVFBVVCdcbiIsIjsgdmFyIF9fYnJvd3NlcmlmeV9zaGltX3JlcXVpcmVfXz1yZXF1aXJlOyhmdW5jdGlvbiBicm93c2VyaWZ5U2hpbShtb2R1bGUsIGV4cG9ydHMsIHJlcXVpcmUsIGRlZmluZSwgYnJvd3NlcmlmeV9zaGltX19kZWZpbmVfX21vZHVsZV9fZXhwb3J0X18pIHtcbi8qKiBGaWxlOiBzdHJvcGhlLmpzXG4gKiAgQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIHdyaXRpbmcgWE1QUCBjbGllbnRzLlxuICpcbiAqICBUaGlzIGxpYnJhcnkgdXNlcyBlaXRoZXIgQmlkaXJlY3Rpb25hbC1zdHJlYW1zIE92ZXIgU3luY2hyb25vdXMgSFRUUCAoQk9TSClcbiAqICB0byBlbXVsYXRlIGEgcGVyc2lzdGVudCwgc3RhdGVmdWwsIHR3by13YXkgY29ubmVjdGlvbiB0byBhbiBYTVBQIHNlcnZlciBvclxuICogIGFsdGVybmF0aXZlbHkgV2ViU29ja2V0cy5cbiAqXG4gKiAgTW9yZSBpbmZvcm1hdGlvbiBvbiBCT1NIIGNhbiBiZSBmb3VuZCBpbiBYRVAgMTI0LlxuICogIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIFhNUFAtb3ZlciBXZWJTb2NrZXQgc2VlIHRoaXMgUkZDOlxuICogIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzczOTVcbiAqL1xuXG4vKiBBbGwgb2YgdGhlIFN0cm9waGUgZ2xvYmFscyBhcmUgZGVmaW5lZCBpbiB0aGlzIHNwZWNpYWwgZnVuY3Rpb24gYmVsb3cgc29cbiAqIHRoYXQgcmVmZXJlbmNlcyB0byB0aGUgZ2xvYmFscyBiZWNvbWUgY2xvc3VyZXMuICBUaGlzIHdpbGwgZW5zdXJlIHRoYXRcbiAqIG9uIHBhZ2UgcmVsb2FkLCB0aGVzZSByZWZlcmVuY2VzIHdpbGwgc3RpbGwgYmUgYXZhaWxhYmxlIHRvIGNhbGxiYWNrc1xuICogdGhhdCBhcmUgc3RpbGwgZXhlY3V0aW5nLlxuICovXG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbihmdW5jdGlvbiAoY2FsbGJhY2spIHtcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbi8vIFRoaXMgY29kZSB3YXMgd3JpdHRlbiBieSBUeWxlciBBa2lucyBhbmQgaGFzIGJlZW4gcGxhY2VkIGluIHRoZVxuLy8gcHVibGljIGRvbWFpbi4gIEl0IHdvdWxkIGJlIG5pY2UgaWYgeW91IGxlZnQgdGhpcyBoZWFkZXIgaW50YWN0LlxuLy8gQmFzZTY0IGNvZGUgZnJvbSBUeWxlciBBa2lucyAtLSBodHRwOi8vcnVta2luLmNvbVxuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3Ryb3BoZS1iYXNlNjQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeSgpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICAgICAgcm9vdC5CYXNlNjQgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleVN0ciA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcblxuICAgIHZhciBvYmogPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIGEgc3RyaW5nIGluIGJhc2U2NFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyB0byBlbmNvZGUgaW4gYmFzZTY0LlxuICAgICAgICAgKi9cbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gICAgICAgICAgICB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgICAgICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICAgICAgY2hyMiA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICBjaHIzID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuXG4gICAgICAgICAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgICAgICAgICBlbmMyID0gKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KTtcbiAgICAgICAgICAgICAgICBlbmMzID0gKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNik7XG4gICAgICAgICAgICAgICAgZW5jNCA9IGNocjMgJiA2MztcblxuICAgICAgICAgICAgICAgIGlmIChpc05hTihjaHIyKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmMyID0gKChjaHIxICYgMykgPDwgNCk7XG4gICAgICAgICAgICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTihjaHIzKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmM0ID0gNjQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsga2V5U3RyLmNoYXJBdChlbmMxKSArIGtleVN0ci5jaGFyQXQoZW5jMikgK1xuICAgICAgICAgICAgICAgICAgICBrZXlTdHIuY2hhckF0KGVuYzMpICsga2V5U3RyLmNoYXJBdChlbmM0KTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgYmFzZTY0IHN0cmluZy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgdG8gZGVjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gICAgICAgICAgICB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgICAgICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBBLVosIGEteiwgMC05LCArLCAvLCBvciA9XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCBcIlwiKTtcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGVuYzEgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgICAgICAgICAgZW5jMiA9IGtleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgICAgICAgICBlbmMzID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICAgICAgICAgIGVuYzQgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgICAgICAgICBjaHIxID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcbiAgICAgICAgICAgICAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG4gICAgICAgICAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZW5jMyAhPSA2NCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW5jNCAhPSA2NCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gb2JqO1xufSkpO1xuXG4vKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZTosIG5vYXJnOiB0cnVlLCBsYXRlZGVmOiBmYWxzZSAqL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4vKiBTb21lIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzIGhhdmUgYmVlbiBzdHJpcHBlZCBmb3IgdXNlIHdpdGggU3Ryb3BoZSAqL1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3Ryb3BoZS1zaGExJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgICAgIHJvb3QuU0hBMSA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgU0hBLTEgb2YgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxuICovXG5mdW5jdGlvbiBjb3JlX3NoYTEoeCwgbGVuKVxue1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGxlbiAlIDMyKTtcbiAgeFsoKGxlbiArIDY0ID4+IDkpIDw8IDQpICsgMTVdID0gbGVuO1xuXG4gIHZhciB3ID0gbmV3IEFycmF5KDgwKTtcbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XG4gIHZhciBlID0gLTEwMDk1ODk3NzY7XG5cbiAgdmFyIGksIGosIHQsIG9sZGEsIG9sZGIsIG9sZGMsIG9sZGQsIG9sZGU7XG4gIGZvciAoaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIG9sZGEgPSBhO1xuICAgIG9sZGIgPSBiO1xuICAgIG9sZGMgPSBjO1xuICAgIG9sZGQgPSBkO1xuICAgIG9sZGUgPSBlO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IDgwOyBqKyspXG4gICAge1xuICAgICAgaWYgKGogPCAxNikgeyB3W2pdID0geFtpICsgal07IH1cbiAgICAgIGVsc2UgeyB3W2pdID0gcm9sKHdbai0zXSBeIHdbai04XSBeIHdbai0xNF0gXiB3W2otMTZdLCAxKTsgfVxuICAgICAgdCA9IHNhZmVfYWRkKHNhZmVfYWRkKHJvbChhLCA1KSwgc2hhMV9mdChqLCBiLCBjLCBkKSksXG4gICAgICAgICAgICAgICAgICAgICAgIHNhZmVfYWRkKHNhZmVfYWRkKGUsIHdbal0pLCBzaGExX2t0KGopKSk7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IHJvbChiLCAzMCk7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgICBlID0gc2FmZV9hZGQoZSwgb2xkZSk7XG4gIH1cbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlXTtcbn1cblxuLypcbiAqIFBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIHRyaXBsZXQgY29tYmluYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50XG4gKiBpdGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2hhMV9mdCh0LCBiLCBjLCBkKVxue1xuICBpZiAodCA8IDIwKSB7IHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKTsgfVxuICBpZiAodCA8IDQwKSB7IHJldHVybiBiIF4gYyBeIGQ7IH1cbiAgaWYgKHQgPCA2MCkgeyByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpOyB9XG4gIHJldHVybiBiIF4gYyBeIGQ7XG59XG5cbi8qXG4gKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGFkZGl0aXZlIGNvbnN0YW50IGZvciB0aGUgY3VycmVudCBpdGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2hhMV9rdCh0KVxue1xuICByZXR1cm4gKHQgPCAyMCkgPyAgMTUxODUwMDI0OSA6ICh0IDwgNDApID8gIDE4NTk3NzUzOTMgOlxuICAgICAgICAgKHQgPCA2MCkgPyAtMTg5NDAwNzU4OCA6IC04OTk0OTc1MTQ7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIEhNQUMtU0hBMSBvZiBhIGtleSBhbmQgc29tZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSlcbntcbiAgdmFyIGJrZXkgPSBzdHIyYmluYihrZXkpO1xuICBpZiAoYmtleS5sZW5ndGggPiAxNikgeyBia2V5ID0gY29yZV9zaGExKGJrZXksIGtleS5sZW5ndGggKiA4KTsgfVxuXG4gIHZhciBpcGFkID0gbmV3IEFycmF5KDE2KSwgb3BhZCA9IG5ldyBBcnJheSgxNik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAge1xuICAgIGlwYWRbaV0gPSBia2V5W2ldIF4gMHgzNjM2MzYzNjtcbiAgICBvcGFkW2ldID0gYmtleVtpXSBeIDB4NUM1QzVDNUM7XG4gIH1cblxuICB2YXIgaGFzaCA9IGNvcmVfc2hhMShpcGFkLmNvbmNhdChzdHIyYmluYihkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogOCk7XG4gIHJldHVybiBjb3JlX3NoYTEob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDE2MCk7XG59XG5cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxue1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiByb2wobnVtLCBjbnQpXG57XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gOC1iaXQgb3IgMTYtYml0IHN0cmluZyB0byBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzXG4gKiBJbiA4LWJpdCBmdW5jdGlvbiwgY2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGktYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiBzdHIyYmluYihzdHIpXG57XG4gIHZhciBiaW4gPSBbXTtcbiAgdmFyIG1hc2sgPSAyNTU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aCAqIDg7IGkgKz0gOClcbiAge1xuICAgIGJpbltpPj41XSB8PSAoc3RyLmNoYXJDb2RlQXQoaSAvIDgpICYgbWFzaykgPDwgKDI0IC0gaSUzMik7XG4gIH1cbiAgcmV0dXJuIGJpbjtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcyB0byBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBiaW5iMnN0cihiaW4pXG57XG4gIHZhciBzdHIgPSBcIlwiO1xuICB2YXIgbWFzayA9IDI1NTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoICogMzI7IGkgKz0gOClcbiAge1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChiaW5baT4+NV0gPj4+ICgyNCAtIGklMzIpKSAmIG1hc2spO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBiYXNlLTY0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBiaW5iMmI2NChiaW5hcnJheSlcbntcbiAgdmFyIHRhYiA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdmFyIHRyaXBsZXQsIGo7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmluYXJyYXkubGVuZ3RoICogNDsgaSArPSAzKVxuICB7XG4gICAgdHJpcGxldCA9ICgoKGJpbmFycmF5W2kgICA+PiAyXSA+PiA4ICogKDMgLSAgaSAgICU0KSkgJiAweEZGKSA8PCAxNikgfFxuICAgICAgICAgICAgICAoKChiaW5hcnJheVtpKzEgPj4gMl0gPj4gOCAqICgzIC0gKGkrMSklNCkpICYgMHhGRikgPDwgOCApIHxcbiAgICAgICAgICAgICAgICgoYmluYXJyYXlbaSsyID4+IDJdID4+IDggKiAoMyAtIChpKzIpJTQpKSAmIDB4RkYpO1xuICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspXG4gICAge1xuICAgICAgaWYgKGkgKiA4ICsgaiAqIDYgPiBiaW5hcnJheS5sZW5ndGggKiAzMikgeyBzdHIgKz0gXCI9XCI7IH1cbiAgICAgIGVsc2UgeyBzdHIgKz0gdGFiLmNoYXJBdCgodHJpcGxldCA+PiA2KigzLWopKSAmIDB4M0YpOyB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8qXG4gKiBUaGVzZSBhcmUgdGhlIGZ1bmN0aW9ucyB5b3UnbGwgdXN1YWxseSB3YW50IHRvIGNhbGxcbiAqIFRoZXkgdGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIGhleCBvciBiYXNlLTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5yZXR1cm4ge1xuICAgIGI2NF9obWFjX3NoYTE6ICBmdW5jdGlvbiAoa2V5LCBkYXRhKXsgcmV0dXJuIGJpbmIyYjY0KGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSkpOyB9LFxuICAgIGI2NF9zaGExOiAgICAgICBmdW5jdGlvbiAocykgeyByZXR1cm4gYmluYjJiNjQoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogOCkpOyB9LFxuICAgIGJpbmIyc3RyOiAgICAgICBiaW5iMnN0cixcbiAgICBjb3JlX2htYWNfc2hhMTogY29yZV9obWFjX3NoYTEsXG4gICAgc3RyX2htYWNfc2hhMTogIGZ1bmN0aW9uIChrZXksIGRhdGEpeyByZXR1cm4gYmluYjJzdHIoY29yZV9obWFjX3NoYTEoa2V5LCBkYXRhKSk7IH0sXG4gICAgc3RyX3NoYTE6ICAgICAgIGZ1bmN0aW9uIChzKSB7IHJldHVybiBiaW5iMnN0cihjb3JlX3NoYTEoc3RyMmJpbmIocykscy5sZW5ndGggKiA4KSk7IH0sXG59O1xufSkpO1xuXG4vKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4xIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuXG4vKlxuICogRXZlcnl0aGluZyB0aGF0IGlzbid0IHVzZWQgYnkgU3Ryb3BoZSBoYXMgYmVlbiBzdHJpcHBlZCBoZXJlIVxuICovXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdzdHJvcGhlLW1kNScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgICAgICByb290Lk1ENSA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIChiKSB7XG4gICAgLypcbiAgICAgKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gICAgICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAgICAgKi9cbiAgICB2YXIgc2FmZV9hZGQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICAgICAgICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gICAgICAgIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAgICAgKi9cbiAgICB2YXIgYml0X3JvbCA9IGZ1bmN0aW9uIChudW0sIGNudCkge1xuICAgICAgICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogQ29udmVydCBhIHN0cmluZyB0byBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gICAgICovXG4gICAgdmFyIHN0cjJiaW5sID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB2YXIgYmluID0gW107XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoICogODsgaSArPSA4KVxuICAgICAgICB7XG4gICAgICAgICAgICBiaW5baT4+NV0gfD0gKHN0ci5jaGFyQ29kZUF0KGkgLyA4KSAmIDI1NSkgPDwgKGklMzIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW47XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGEgc3RyaW5nXG4gICAgICovXG4gICAgdmFyIGJpbmwyc3RyID0gZnVuY3Rpb24gKGJpbikge1xuICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGJpbi5sZW5ndGggKiAzMjsgaSArPSA4KVxuICAgICAgICB7XG4gICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYmluW2k+PjVdID4+PiAoaSAlIDMyKSkgJiAyNTUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGEgaGV4IHN0cmluZy5cbiAgICAgKi9cbiAgICB2YXIgYmlubDJoZXggPSBmdW5jdGlvbiAoYmluYXJyYXkpIHtcbiAgICAgICAgdmFyIGhleF90YWIgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiaW5hcnJheS5sZW5ndGggKiA0OyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0ciArPSBoZXhfdGFiLmNoYXJBdCgoYmluYXJyYXlbaT4+Ml0gPj4gKChpJTQpKjgrNCkpICYgMHhGKSArXG4gICAgICAgICAgICAgICAgaGV4X3RhYi5jaGFyQXQoKGJpbmFycmF5W2k+PjJdID4+ICgoaSU0KSo4ICApKSAmIDB4Rik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICAgICAqL1xuICAgIHZhciBtZDVfY21uID0gZnVuY3Rpb24gKHEsIGEsIGIsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIHNhZmVfYWRkKGJpdF9yb2woc2FmZV9hZGQoc2FmZV9hZGQoYSwgcSksc2FmZV9hZGQoeCwgdCkpLCBzKSxiKTtcbiAgICB9O1xuXG4gICAgdmFyIG1kNV9mZiA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICAgIHJldHVybiBtZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgICB9O1xuXG4gICAgdmFyIG1kNV9nZyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICAgIHJldHVybiBtZDVfY21uKChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgICB9O1xuXG4gICAgdmFyIG1kNV9oaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICAgIHJldHVybiBtZDVfY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG4gICAgfTtcblxuICAgIHZhciBtZDVfaWkgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gbWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxuICAgICAqL1xuICAgIHZhciBjb3JlX21kNSA9IGZ1bmN0aW9uICh4LCBsZW4pIHtcbiAgICAgICAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgICAgICAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoKGxlbikgJSAzMik7XG4gICAgICAgIHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlbjtcblxuICAgICAgICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICAgICAgICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gICAgICAgIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gICAgICAgIHZhciBkID0gIDI3MTczMzg3ODtcblxuICAgICAgICB2YXIgb2xkYSwgb2xkYiwgb2xkYywgb2xkZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAgICAgICAge1xuICAgICAgICAgICAgb2xkYSA9IGE7XG4gICAgICAgICAgICBvbGRiID0gYjtcbiAgICAgICAgICAgIG9sZGMgPSBjO1xuICAgICAgICAgICAgb2xkZCA9IGQ7XG5cbiAgICAgICAgICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyAwXSwgNyAsIC02ODA4NzY5MzYpO1xuICAgICAgICAgICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgICAgICAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE3LCAgNjA2MTA1ODE5KTtcbiAgICAgICAgICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICAgICAgICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA0XSwgNyAsIC0xNzY0MTg4OTcpO1xuICAgICAgICAgICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDVdLCAxMiwgIDEyMDAwODA0MjYpO1xuICAgICAgICAgICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgICAgICAgICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICAgICAgICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA4XSwgNyAsICAxNzcwMDM1NDE2KTtcbiAgICAgICAgICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICAgICAgICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTcsIC00MjA2Myk7XG4gICAgICAgICAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgICAgICAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDcgLCAgMTgwNDYwMzY4Mik7XG4gICAgICAgICAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgICAgICAgICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgICAgICAgICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xuXG4gICAgICAgICAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDUgLCAtMTY1Nzk2NTEwKTtcbiAgICAgICAgICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyA2XSwgOSAsIC0xMDY5NTAxNjMyKTtcbiAgICAgICAgICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzExXSwgMTQsICA2NDM3MTc3MTMpO1xuICAgICAgICAgICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgICAgICAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDUgLCAtNzAxNTU4NjkxKTtcbiAgICAgICAgICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzEwXSwgOSAsICAzODAxNjA4Myk7XG4gICAgICAgICAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICAgICAgICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgICAgICAgICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDldLCA1ICwgIDU2ODQ0NjQzOCk7XG4gICAgICAgICAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxNF0sIDkgLCAtMTAxOTgwMzY5MCk7XG4gICAgICAgICAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICAgICAgICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA4XSwgMjAsICAxMTYzNTMxNTAxKTtcbiAgICAgICAgICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKzEzXSwgNSAsIC0xNDQ0NjgxNDY3KTtcbiAgICAgICAgICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyAyXSwgOSAsIC01MTQwMzc4NCk7XG4gICAgICAgICAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE0LCAgMTczNTMyODQ3Myk7XG4gICAgICAgICAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG5cbiAgICAgICAgICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA1XSwgNCAsIC0zNzg1NTgpO1xuICAgICAgICAgICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgICAgICAgICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTFdLCAxNiwgIDE4MzkwMzA1NjIpO1xuICAgICAgICAgICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICAgICAgICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyAxXSwgNCAsIC0xNTMwOTkyMDYwKTtcbiAgICAgICAgICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA0XSwgMTEsICAxMjcyODkzMzUzKTtcbiAgICAgICAgICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgICAgICAgICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgICAgICAgICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krMTNdLCA0ICwgIDY4MTI3OTE3NCk7XG4gICAgICAgICAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICAgICAgICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgICAgICAgICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDZdLCAyMywgIDc2MDI5MTg5KTtcbiAgICAgICAgICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA5XSwgNCAsIC02NDAzNjQ0ODcpO1xuICAgICAgICAgICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgICAgICAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE2LCAgNTMwNzQyNTIwKTtcbiAgICAgICAgICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuXG4gICAgICAgICAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDYgLCAtMTk4NjMwODQ0KTtcbiAgICAgICAgICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcbiAgICAgICAgICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICAgICAgICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgICAgICAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDYgLCAgMTcwMDQ4NTU3MSk7XG4gICAgICAgICAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgICAgICAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgICAgICAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgICAgICAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDYgLCAgMTg3MzMxMzM1OSk7XG4gICAgICAgICAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgICAgICAgICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgICAgICAgICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krMTNdLCAyMSwgIDEzMDkxNTE2NDkpO1xuICAgICAgICAgICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDRdLCA2ICwgLTE0NTUyMzA3MCk7XG4gICAgICAgICAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgICAgICAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE1LCAgNzE4Nzg3MjU5KTtcbiAgICAgICAgICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXG4gICAgICAgICAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XG4gICAgICAgICAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgICAgICAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgICAgICAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbiAgICB9O1xuXG4gICAgdmFyIG9iaiA9IHtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlc2UgYXJlIHRoZSBmdW5jdGlvbnMgeW91J2xsIHVzdWFsbHkgd2FudCB0byBjYWxsLlxuICAgICAgICAgKiBUaGV5IHRha2Ugc3RyaW5nIGFyZ3VtZW50cyBhbmQgcmV0dXJuIGVpdGhlciBoZXggb3IgYmFzZS02NCBlbmNvZGVkXG4gICAgICAgICAqIHN0cmluZ3MuXG4gICAgICAgICAqL1xuICAgICAgICBoZXhkaWdlc3Q6IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gYmlubDJoZXgoY29yZV9tZDUoc3RyMmJpbmwocyksIHMubGVuZ3RoICogOCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc2g6IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gYmlubDJzdHIoY29yZV9tZDUoc3RyMmJpbmwocyksIHMubGVuZ3RoICogOCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gb2JqO1xufSkpO1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3Ryb3BoZS11dGlscycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgICAgICByb290LnN0cm9waGVVdGlscyA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB1dGlscyA9IHtcblxuICAgICAgICB1dGYxNnRvODogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgdmFyIGksIGM7XG4gICAgICAgICAgICB2YXIgb3V0ID0gXCJcIjtcbiAgICAgICAgICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGlmICgoYyA+PSAweDAwMDApICYmIChjIDw9IDB4MDA3RikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID4gMHgwN0ZGKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RTAgfCAoKGMgPj4gMTIpICYgMHgwRikpO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgKChjID4+ICA2KSAmIDB4M0YpKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8ICgoYyA+PiAgMCkgJiAweDNGKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhDMCB8ICgoYyA+PiAgNikgJiAweDFGKSk7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGMgPj4gIDApICYgMHgzRikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkQ29va2llczogZnVuY3Rpb24gKGNvb2tpZXMpIHtcbiAgICAgICAgICAgIC8qIFBhcmFtZXRlcnM6XG4gICAgICAgICAgICAgKiAgKE9iamVjdCkgY29va2llcyAtIGVpdGhlciBhIG1hcCBvZiBjb29raWUgbmFtZXNcbiAgICAgICAgICAgICAqICAgIHRvIHN0cmluZyB2YWx1ZXMgb3IgdG8gbWFwcyBvZiBjb29raWUgdmFsdWVzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEZvciBleGFtcGxlOlxuICAgICAgICAgICAgICogeyBcIm15Q29va2llXCI6IFwiMTIzNFwiIH1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBvcjpcbiAgICAgICAgICAgICAqIHsgXCJteUNvb2tpZVwiOiB7XG4gICAgICAgICAgICAgKiAgICAgIFwidmFsdWVcIjogXCIxMjM0XCIsXG4gICAgICAgICAgICAgKiAgICAgIFwiZG9tYWluXCI6IFwiLmV4YW1wbGUub3JnXCIsXG4gICAgICAgICAgICAgKiAgICAgIFwicGF0aFwiOiBcIi9cIixcbiAgICAgICAgICAgICAqICAgICAgXCJleHBpcmVzXCI6IGV4cGlyYXRpb25EYXRlXG4gICAgICAgICAgICAgKiAgICAgIH1cbiAgICAgICAgICAgICAqICB9XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIFRoZXNlIHZhbHVlcyBnZXQgcGFzc2VkIHRvIFN0cm9waGUuQ29ubmVjdGlvbiB2aWFcbiAgICAgICAgICAgICAqICAgb3B0aW9ucy5jb29raWVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBjb29raWVOYW1lLCBjb29raWVPYmosIGlzT2JqLCBjb29raWVWYWx1ZSwgZXhwaXJlcywgZG9tYWluLCBwYXRoO1xuICAgICAgICAgICAgZm9yIChjb29raWVOYW1lIGluIChjb29raWVzIHx8IHt9KSkge1xuICAgICAgICAgICAgICAgIGV4cGlyZXMgPSAnJztcbiAgICAgICAgICAgICAgICBkb21haW4gPSAnJztcbiAgICAgICAgICAgICAgICBwYXRoID0gJyc7XG4gICAgICAgICAgICAgICAgY29va2llT2JqID0gY29va2llc1tjb29raWVOYW1lXTtcbiAgICAgICAgICAgICAgICBpc09iaiA9IHR5cGVvZiBjb29raWVPYmogPT0gXCJvYmplY3RcIjtcbiAgICAgICAgICAgICAgICBjb29raWVWYWx1ZSA9IGVzY2FwZSh1bmVzY2FwZShpc09iaiA/IGNvb2tpZU9iai52YWx1ZSA6IGNvb2tpZU9iaikpO1xuICAgICAgICAgICAgICAgIGlmIChpc09iaikge1xuICAgICAgICAgICAgICAgICAgICBleHBpcmVzID0gY29va2llT2JqLmV4cGlyZXMgPyBcIjtleHBpcmVzPVwiK2Nvb2tpZU9iai5leHBpcmVzIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9IGNvb2tpZU9iai5kb21haW4gPyBcIjtkb21haW49XCIrY29va2llT2JqLmRvbWFpbiA6ICcnO1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gY29va2llT2JqLnBhdGggPyBcIjtwYXRoPVwiK2Nvb2tpZU9iai5wYXRoIDogJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgICAgIGNvb2tpZU5hbWUrJz0nK2Nvb2tpZVZhbHVlICsgZXhwaXJlcyArIGRvbWFpbiArIHBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB1dGlscztcbn0pKTtcblxuLypcbiAgICBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgbGljZW5zZS5cbiAgICBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG5cbiAgICBDb3B5cmlnaHQgMjAwNi0yMDA4LCBPR0csIExMQ1xuKi9cblxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWU6LCBub2FyZzogdHJ1ZSwgbGF0ZWRlZjogdHJ1ZSAqL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3Ryb3BoZS1wb2x5ZmlsbCcsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeSgpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuLyoqIEZ1bmN0aW9uOiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICogIEJpbmQgYSBmdW5jdGlvbiB0byBhbiBpbnN0YW5jZS5cbiAqXG4gKiAgVGhpcyBGdW5jdGlvbiBvYmplY3QgZXh0ZW5zaW9uIG1ldGhvZCBjcmVhdGVzIGEgYm91bmQgbWV0aG9kIHNpbWlsYXJcbiAqICB0byB0aG9zZSBpbiBQeXRob24uICBUaGlzIG1lYW5zIHRoYXQgdGhlICd0aGlzJyBvYmplY3Qgd2lsbCBwb2ludFxuICogIHRvIHRoZSBpbnN0YW5jZSB5b3Ugd2FudC4gIFNlZSA8TURDJ3MgYmluZCgpIGRvY3VtZW50YXRpb24gYXQgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZD5cbiAqICBhbmQgPEJvdW5kIEZ1bmN0aW9ucyBhbmQgRnVuY3Rpb24gSW1wb3J0cyBpbiBKYXZhU2NyaXB0IGF0IGh0dHA6Ly9iZW5qYW1pbi5zbWVkYmVyZ3MudXMvYmxvZy8yMDA3LTAxLTAzL2JvdW5kLWZ1bmN0aW9ucy1hbmQtZnVuY3Rpb24taW1wb3J0cy1pbi1qYXZhc2NyaXB0Lz5cbiAqICBmb3IgYSBjb21wbGV0ZSBleHBsYW5hdGlvbi5cbiAqXG4gKiAgVGhpcyBleHRlbnNpb24gYWxyZWFkeSBleGlzdHMgaW4gc29tZSBicm93c2VycyAobmFtZWx5LCBGaXJlZm94IDMpLCBidXRcbiAqICB3ZSBwcm92aWRlIGl0IHRvIHN1cHBvcnQgdGhvc2UgdGhhdCBkb24ndC5cbiAqXG4gKiAgUGFyYW1ldGVyczpcbiAqICAgIChPYmplY3QpIG9iaiAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlY29tZSAndGhpcycgaW4gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICogICAgKE9iamVjdCkgYXJnTiAtIEFuIG9wdGlvbiBhcmd1bWVudCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZVxuICogICAgICBhcmd1bWVudHMgZ2l2ZW4gZm9yIHRoZSBmdW5jdGlvbiBjYWxsXG4gKlxuICogIFJldHVybnM6XG4gKiAgICBUaGUgYm91bmQgZnVuY3Rpb24uXG4gKi9cbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChvYmogLyosIGFyZzEsIGFyZzIsIC4uLiAqLykge1xuICAgICAgICB2YXIgZnVuYyA9IHRoaXM7XG4gICAgICAgIHZhciBfc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gICAgICAgIHZhciBfY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbiAgICAgICAgdmFyIF9hcmdzID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iaiA/IG9iaiA6IHRoaXMsIF9jb25jYXQuY2FsbChfYXJncywgX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpO1xuICAgICAgICB9O1xuICAgIH07XG59XG5cbi8qKiBGdW5jdGlvbjogQXJyYXkuaXNBcnJheVxuICogIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgdGhlIEVTNSBBcnJheS5pc0FycmF5IG1ldGhvZC5cbiAqL1xuaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbn1cblxuLyoqIEZ1bmN0aW9uOiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZlxuICogIFJldHVybiB0aGUgaW5kZXggb2YgYW4gb2JqZWN0IGluIGFuIGFycmF5LlxuICpcbiAqICBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBzdXBwbGllZCBieSBzb21lIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb25zLCBzb1xuICogIHdlIHByb3ZpZGUgaXQgaWYgaXQgaXMgbWlzc2luZy4gIFRoaXMgY29kZSBpcyBmcm9tOlxuICogIGh0dHA6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvRW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2U6T2JqZWN0czpBcnJheTppbmRleE9mXG4gKlxuICogIFBhcmFtZXRlcnM6XG4gKiAgICAoT2JqZWN0KSBlbHQgLSBUaGUgb2JqZWN0IHRvIGxvb2sgZm9yLlxuICogICAgKEludGVnZXIpIGZyb20gLSBUaGUgaW5kZXggZnJvbSB3aGljaCB0byBzdGFydCBsb29raW5nLiAob3B0aW9uYWwpLlxuICpcbiAqICBSZXR1cm5zOlxuICogICAgVGhlIGluZGV4IG9mIGVsdCBpbiB0aGUgYXJyYXkgb3IgLTEgaWYgbm90IGZvdW5kLlxuICovXG5pZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24oZWx0IC8qLCBmcm9tKi8pIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBmcm9tID0gTnVtYmVyKGFyZ3VtZW50c1sxXSkgfHwgMDtcbiAgICAgICAgICAgIGZyb20gPSAoZnJvbSA8IDApID8gTWF0aC5jZWlsKGZyb20pIDogTWF0aC5mbG9vcihmcm9tKTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgICAgICAgIGZyb20gKz0gbGVuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKDsgZnJvbSA8IGxlbjsgZnJvbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gaW4gdGhpcyAmJiB0aGlzW2Zyb21dID09PSBlbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cbn0pKTtcblxuXG4vKiogRnVuY3Rpb246IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoXG4gKlxuICogIFRoaXMgZnVuY3Rpb24gaXMgbm90IGF2YWlsYWJsZSBpbiBJRSA8IDlcbiAqXG4gKiAgU2VlIDxmb3JFYWNoIG9uIGRldmVsb3Blci5tb3ppbGxhLm9yZyBhdCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoPlxuICovXG5pZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgVCwgaztcbiAgICAgICAgaWYgKHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyB0aGlzIGlzIG51bGwgb3Igbm90IGRlZmluZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDEuIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0b09iamVjdCgpIHBhc3NpbmcgdGhlXG4gICAgICAgIC8vIHx0aGlzfCB2YWx1ZSBhcyB0aGUgYXJndW1lbnQuXG4gICAgICAgIHZhciBPID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAvLyAyLiBMZXQgbGVuVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQoKSBpbnRlcm5hbFxuICAgICAgICAvLyBtZXRob2Qgb2YgTyB3aXRoIHRoZSBhcmd1bWVudCBcImxlbmd0aFwiLlxuICAgICAgICAvLyAzLiBMZXQgbGVuIGJlIHRvVWludDMyKGxlblZhbHVlKS5cbiAgICAgICAgdmFyIGxlbiA9IE8ubGVuZ3RoID4+PiAwO1xuICAgICAgICAvLyA0LiBJZiBpc0NhbGxhYmxlKGNhbGxiYWNrKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICAvLyBTZWU6IGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuMTFcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDUuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldFxuICAgICAgICAvLyBUIGJlIHVuZGVmaW5lZC5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBUID0gdGhpc0FyZztcbiAgICAgICAgfVxuICAgICAgICAvLyA2LiBMZXQgayBiZSAwXG4gICAgICAgIGsgPSAwO1xuICAgICAgICAvLyA3LiBSZXBlYXQsIHdoaWxlIGsgPCBsZW5cbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgIHZhciBrVmFsdWU7XG4gICAgICAgICAgICAvLyBhLiBMZXQgUGsgYmUgVG9TdHJpbmcoaykuXG4gICAgICAgICAgICAvLyAgICAgICAgVGhpcyBpcyBpbXBsaWNpdCBmb3IgTEhTIG9wZXJhbmRzIG9mIHRoZSBpbiBvcGVyYXRvclxuICAgICAgICAgICAgLy8gYi4gTGV0IGtQcmVzZW50IGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgSGFzUHJvcGVydHlcbiAgICAgICAgICAgIC8vICAgICAgICBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxuICAgICAgICAgICAgLy8gICAgICAgIFRoaXMgc3RlcCBjYW4gYmUgY29tYmluZWQgd2l0aCBjXG4gICAgICAgICAgICAvLyBjLiBJZiBrUHJlc2VudCBpcyB0cnVlLCB0aGVuXG4gICAgICAgICAgICBpZiAoayBpbiBPKSB7XG4gICAgICAgICAgICAgICAgLy8gaS4gTGV0IGtWYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldCBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZCBvZiBPIHdpdGggYXJndW1lbnQgUGsuXG4gICAgICAgICAgICAgICAga1ZhbHVlID0gT1trXTtcbiAgICAgICAgICAgICAgICAvLyBpaS4gQ2FsbCB0aGUgQ2FsbCBpbnRlcm5hbCBtZXRob2Qgb2YgY2FsbGJhY2sgd2l0aCBUIGFzXG4gICAgICAgICAgICAgICAgLy8gdGhlIHRoaXMgdmFsdWUgYW5kIGFyZ3VtZW50IGxpc3QgY29udGFpbmluZyBrVmFsdWUsIGssIGFuZCBPLlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoVCwga1ZhbHVlLCBrLCBPKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGQuIEluY3JlYXNlIGsgYnkgMS5cbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICAvLyA4LiByZXR1cm4gdW5kZWZpbmVkXG4gICAgfTtcbn1cblxuLypcbiAgICBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgbGljZW5zZS5cbiAgICBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG5cbiAgICBDb3B5cmlnaHQgMjAwNi0yMDA4LCBPR0csIExMQ1xuKi9cblxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWU6LCBub2FyZzogdHJ1ZSwgbGF0ZWRlZjogdHJ1ZSAqL1xuLypnbG9iYWwgZGVmaW5lLCBkb2N1bWVudCwgd2luZG93LCBzZXRUaW1lb3V0LCBjbGVhclRpbWVvdXQsIEFjdGl2ZVhPYmplY3QsIERPTVBhcnNlciAqL1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3Ryb3BoZS1jb3JlJywgW1xuICAgICAgICAgICAgJ3N0cm9waGUtc2hhMScsXG4gICAgICAgICAgICAnc3Ryb3BoZS1iYXNlNjQnLFxuICAgICAgICAgICAgJ3N0cm9waGUtbWQ1JyxcbiAgICAgICAgICAgICdzdHJvcGhlLXV0aWxzJyxcbiAgICAgICAgICAgIFwic3Ryb3BoZS1wb2x5ZmlsbFwiXG4gICAgICAgIF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgICAgICB2YXIgbyA9IGZhY3Rvcnkocm9vdC5TSEExLCByb290LkJhc2U2NCwgcm9vdC5NRDUsIHJvb3Quc3Ryb3BoZVV0aWxzKTtcbiAgICAgICAgd2luZG93LlN0cm9waGUgPSAgICAgICAgby5TdHJvcGhlO1xuICAgICAgICB3aW5kb3cuJGJ1aWxkID0gICAgICAgICBvLiRidWlsZDtcbiAgICAgICAgd2luZG93LiRpcSA9ICAgICAgICAgICAgby4kaXE7XG4gICAgICAgIHdpbmRvdy4kbXNnID0gICAgICAgICAgIG8uJG1zZztcbiAgICAgICAgd2luZG93LiRwcmVzID0gICAgICAgICAgby4kcHJlcztcbiAgICAgICAgd2luZG93LlNIQTEgPSAgICAgICAgICAgby5TSEExO1xuICAgICAgICB3aW5kb3cuQmFzZTY0ID0gICAgICAgICBvLkJhc2U2NDtcbiAgICAgICAgd2luZG93Lk1ENSA9ICAgICAgICAgICAgby5NRDU7XG4gICAgICAgIHdpbmRvdy5iNjRfaG1hY19zaGExID0gIG8uU0hBMS5iNjRfaG1hY19zaGExO1xuICAgICAgICB3aW5kb3cuYjY0X3NoYTEgPSAgICAgICBvLlNIQTEuYjY0X3NoYTE7XG4gICAgICAgIHdpbmRvdy5zdHJfaG1hY19zaGExID0gIG8uU0hBMS5zdHJfaG1hY19zaGExO1xuICAgICAgICB3aW5kb3cuc3RyX3NoYTEgPSAgICAgICBvLlNIQTEuc3RyX3NoYTE7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoU0hBMSwgQmFzZTY0LCBNRDUsIHV0aWxzKSB7XG5cbnZhciBTdHJvcGhlO1xuXG4vKiogRnVuY3Rpb246ICRidWlsZFxuICogIENyZWF0ZSBhIFN0cm9waGUuQnVpbGRlci5cbiAqICBUaGlzIGlzIGFuIGFsaWFzIGZvciAnbmV3IFN0cm9waGUuQnVpbGRlcihuYW1lLCBhdHRycyknLlxuICpcbiAqICBQYXJhbWV0ZXJzOlxuICogICAgKFN0cmluZykgbmFtZSAtIFRoZSByb290IGVsZW1lbnQgbmFtZS5cbiAqICAgIChPYmplY3QpIGF0dHJzIC0gVGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSByb290IGVsZW1lbnQgaW4gb2JqZWN0IG5vdGF0aW9uLlxuICpcbiAqICBSZXR1cm5zOlxuICogICAgQSBuZXcgU3Ryb3BoZS5CdWlsZGVyIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gJGJ1aWxkKG5hbWUsIGF0dHJzKSB7IHJldHVybiBuZXcgU3Ryb3BoZS5CdWlsZGVyKG5hbWUsIGF0dHJzKTsgfVxuXG4vKiogRnVuY3Rpb246ICRtc2dcbiAqICBDcmVhdGUgYSBTdHJvcGhlLkJ1aWxkZXIgd2l0aCBhIDxtZXNzYWdlLz4gZWxlbWVudCBhcyB0aGUgcm9vdC5cbiAqXG4gKiAgUGFyYW1ldGVyczpcbiAqICAgIChPYmplY3QpIGF0dHJzIC0gVGhlIDxtZXNzYWdlLz4gZWxlbWVudCBhdHRyaWJ1dGVzIGluIG9iamVjdCBub3RhdGlvbi5cbiAqXG4gKiAgUmV0dXJuczpcbiAqICAgIEEgbmV3IFN0cm9waGUuQnVpbGRlciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uICRtc2coYXR0cnMpIHsgcmV0dXJuIG5ldyBTdHJvcGhlLkJ1aWxkZXIoXCJtZXNzYWdlXCIsIGF0dHJzKTsgfVxuXG4vKiogRnVuY3Rpb246ICRpcVxuICogIENyZWF0ZSBhIFN0cm9waGUuQnVpbGRlciB3aXRoIGFuIDxpcS8+IGVsZW1lbnQgYXMgdGhlIHJvb3QuXG4gKlxuICogIFBhcmFtZXRlcnM6XG4gKiAgICAoT2JqZWN0KSBhdHRycyAtIFRoZSA8aXEvPiBlbGVtZW50IGF0dHJpYnV0ZXMgaW4gb2JqZWN0IG5vdGF0aW9uLlxuICpcbiAqICBSZXR1cm5zOlxuICogICAgQSBuZXcgU3Ryb3BoZS5CdWlsZGVyIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gJGlxKGF0dHJzKSB7IHJldHVybiBuZXcgU3Ryb3BoZS5CdWlsZGVyKFwiaXFcIiwgYXR0cnMpOyB9XG5cbi8qKiBGdW5jdGlvbjogJHByZXNcbiAqICBDcmVhdGUgYSBTdHJvcGhlLkJ1aWxkZXIgd2l0aCBhIDxwcmVzZW5jZS8+IGVsZW1lbnQgYXMgdGhlIHJvb3QuXG4gKlxuICogIFBhcmFtZXRlcnM6XG4gKiAgICAoT2JqZWN0KSBhdHRycyAtIFRoZSA8cHJlc2VuY2UvPiBlbGVtZW50IGF0dHJpYnV0ZXMgaW4gb2JqZWN0IG5vdGF0aW9uLlxuICpcbiAqICBSZXR1cm5zOlxuICogICAgQSBuZXcgU3Ryb3BoZS5CdWlsZGVyIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gJHByZXMoYXR0cnMpIHsgcmV0dXJuIG5ldyBTdHJvcGhlLkJ1aWxkZXIoXCJwcmVzZW5jZVwiLCBhdHRycyk7IH1cblxuLyoqIENsYXNzOiBTdHJvcGhlXG4gKiAgQW4gb2JqZWN0IGNvbnRhaW5lciBmb3IgYWxsIFN0cm9waGUgbGlicmFyeSBmdW5jdGlvbnMuXG4gKlxuICogIFRoaXMgY2xhc3MgaXMganVzdCBhIGNvbnRhaW5lciBmb3IgYWxsIHRoZSBvYmplY3RzIGFuZCBjb25zdGFudHNcbiAqICB1c2VkIGluIHRoZSBsaWJyYXJ5LiAgSXQgaXMgbm90IG1lYW50IHRvIGJlIGluc3RhbnRpYXRlZCwgYnV0IHRvXG4gKiAgcHJvdmlkZSBhIG5hbWVzcGFjZSBmb3IgbGlicmFyeSBvYmplY3RzLCBjb25zdGFudHMsIGFuZCBmdW5jdGlvbnMuXG4gKi9cblN0cm9waGUgPSB7XG4gICAgLyoqIENvbnN0YW50OiBWRVJTSU9OXG4gICAgICogIFRoZSB2ZXJzaW9uIG9mIHRoZSBTdHJvcGhlIGxpYnJhcnkuIFVucmVsZWFzZWQgYnVpbGRzIHdpbGwgaGF2ZVxuICAgICAqICBhIHZlcnNpb24gb2YgaGVhZC1IQVNIIHdoZXJlIEhBU0ggaXMgYSBwYXJ0aWFsIHJldmlzaW9uLlxuICAgICAqL1xuICAgIFZFUlNJT046IFwiMS4yLjEwXCIsXG5cbiAgICAvKiogQ29uc3RhbnRzOiBYTVBQIE5hbWVzcGFjZSBDb25zdGFudHNcbiAgICAgKiAgQ29tbW9uIG5hbWVzcGFjZSBjb25zdGFudHMgZnJvbSB0aGUgWE1QUCBSRkNzIGFuZCBYRVBzLlxuICAgICAqXG4gICAgICogIE5TLkhUVFBCSU5EIC0gSFRUUCBCSU5EIG5hbWVzcGFjZSBmcm9tIFhFUCAxMjQuXG4gICAgICogIE5TLkJPU0ggLSBCT1NIIG5hbWVzcGFjZSBmcm9tIFhFUCAyMDYuXG4gICAgICogIE5TLkNMSUVOVCAtIE1haW4gWE1QUCBjbGllbnQgbmFtZXNwYWNlLlxuICAgICAqICBOUy5BVVRIIC0gTGVnYWN5IGF1dGhlbnRpY2F0aW9uIG5hbWVzcGFjZS5cbiAgICAgKiAgTlMuUk9TVEVSIC0gUm9zdGVyIG9wZXJhdGlvbnMgbmFtZXNwYWNlLlxuICAgICAqICBOUy5QUk9GSUxFIC0gUHJvZmlsZSBuYW1lc3BhY2UuXG4gICAgICogIE5TLkRJU0NPX0lORk8gLSBTZXJ2aWNlIGRpc2NvdmVyeSBpbmZvIG5hbWVzcGFjZSBmcm9tIFhFUCAzMC5cbiAgICAgKiAgTlMuRElTQ09fSVRFTVMgLSBTZXJ2aWNlIGRpc2NvdmVyeSBpdGVtcyBuYW1lc3BhY2UgZnJvbSBYRVAgMzAuXG4gICAgICogIE5TLk1VQyAtIE11bHRpLVVzZXIgQ2hhdCBuYW1lc3BhY2UgZnJvbSBYRVAgNDUuXG4gICAgICogIE5TLlNBU0wgLSBYTVBQIFNBU0wgbmFtZXNwYWNlIGZyb20gUkZDIDM5MjAuXG4gICAgICogIE5TLlNUUkVBTSAtIFhNUFAgU3RyZWFtcyBuYW1lc3BhY2UgZnJvbSBSRkMgMzkyMC5cbiAgICAgKiAgTlMuQklORCAtIFhNUFAgQmluZGluZyBuYW1lc3BhY2UgZnJvbSBSRkMgMzkyMC5cbiAgICAgKiAgTlMuU0VTU0lPTiAtIFhNUFAgU2Vzc2lvbiBuYW1lc3BhY2UgZnJvbSBSRkMgMzkyMC5cbiAgICAgKiAgTlMuWEhUTUxfSU0gLSBYSFRNTC1JTSBuYW1lc3BhY2UgZnJvbSBYRVAgNzEuXG4gICAgICogIE5TLlhIVE1MIC0gWEhUTUwgYm9keSBuYW1lc3BhY2UgZnJvbSBYRVAgNzEuXG4gICAgICovXG4gICAgTlM6IHtcbiAgICAgICAgSFRUUEJJTkQ6IFwiaHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvaHR0cGJpbmRcIixcbiAgICAgICAgQk9TSDogXCJ1cm46eG1wcDp4Ym9zaFwiLFxuICAgICAgICBDTElFTlQ6IFwiamFiYmVyOmNsaWVudFwiLFxuICAgICAgICBBVVRIOiBcImphYmJlcjppcTphdXRoXCIsXG4gICAgICAgIFJPU1RFUjogXCJqYWJiZXI6aXE6cm9zdGVyXCIsXG4gICAgICAgIFBST0ZJTEU6IFwiamFiYmVyOmlxOnByb2ZpbGVcIixcbiAgICAgICAgRElTQ09fSU5GTzogXCJodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9kaXNjbyNpbmZvXCIsXG4gICAgICAgIERJU0NPX0lURU1TOiBcImh0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL2Rpc2NvI2l0ZW1zXCIsXG4gICAgICAgIE1VQzogXCJodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWNcIixcbiAgICAgICAgU0FTTDogXCJ1cm46aWV0ZjpwYXJhbXM6eG1sOm5zOnhtcHAtc2FzbFwiLFxuICAgICAgICBTVFJFQU06IFwiaHR0cDovL2V0aGVyeC5qYWJiZXIub3JnL3N0cmVhbXNcIixcbiAgICAgICAgRlJBTUlORzogXCJ1cm46aWV0ZjpwYXJhbXM6eG1sOm5zOnhtcHAtZnJhbWluZ1wiLFxuICAgICAgICBCSU5EOiBcInVybjppZXRmOnBhcmFtczp4bWw6bnM6eG1wcC1iaW5kXCIsXG4gICAgICAgIFNFU1NJT046IFwidXJuOmlldGY6cGFyYW1zOnhtbDpuczp4bXBwLXNlc3Npb25cIixcbiAgICAgICAgVkVSU0lPTjogXCJqYWJiZXI6aXE6dmVyc2lvblwiLFxuICAgICAgICBTVEFOWkFTOiBcInVybjppZXRmOnBhcmFtczp4bWw6bnM6eG1wcC1zdGFuemFzXCIsXG4gICAgICAgIFhIVE1MX0lNOiBcImh0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL3hodG1sLWltXCIsXG4gICAgICAgIFhIVE1MOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIlxuICAgIH0sXG5cbiAgICAvKiogQ29uc3RhbnRzOiBYSFRNTF9JTSBOYW1lc3BhY2VcbiAgICAgKiAgY29udGFpbnMgYWxsb3dlZCB0YWdzLCB0YWcgYXR0cmlidXRlcywgYW5kIGNzcyBwcm9wZXJ0aWVzLlxuICAgICAqICBVc2VkIGluIHRoZSBjcmVhdGVIdG1sIGZ1bmN0aW9uIHRvIGZpbHRlciBpbmNvbWluZyBodG1sIGludG8gdGhlIGFsbG93ZWQgWEhUTUwtSU0gc3Vic2V0LlxuICAgICAqICBTZWUgaHR0cDovL3htcHAub3JnL2V4dGVuc2lvbnMveGVwLTAwNzEuaHRtbCNwcm9maWxlLXN1bW1hcnkgZm9yIHRoZSBsaXN0IG9mIHJlY29tbWVuZGVkXG4gICAgICogIGFsbG93ZWQgdGFncyBhbmQgdGhlaXIgYXR0cmlidXRlcy5cbiAgICAgKi9cbiAgICBYSFRNTDoge1xuICAgICAgICB0YWdzOiBbJ2EnLCdibG9ja3F1b3RlJywnYnInLCdjaXRlJywnZW0nLCdpbWcnLCdsaScsJ29sJywncCcsJ3NwYW4nLCdzdHJvbmcnLCd1bCcsJ2JvZHknXSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ2EnOiAgICAgICAgICBbJ2hyZWYnXSxcbiAgICAgICAgICAgICdibG9ja3F1b3RlJzogWydzdHlsZSddLFxuICAgICAgICAgICAgJ2JyJzogICAgICAgICBbXSxcbiAgICAgICAgICAgICdjaXRlJzogICAgICAgWydzdHlsZSddLFxuICAgICAgICAgICAgJ2VtJzogICAgICAgICBbXSxcbiAgICAgICAgICAgICdpbWcnOiAgICAgICAgWydzcmMnLCAnYWx0JywgJ3N0eWxlJywgJ2hlaWdodCcsICd3aWR0aCddLFxuICAgICAgICAgICAgJ2xpJzogICAgICAgICBbJ3N0eWxlJ10sXG4gICAgICAgICAgICAnb2wnOiAgICAgICAgIFsnc3R5bGUnXSxcbiAgICAgICAgICAgICdwJzogICAgICAgICAgWydzdHlsZSddLFxuICAgICAgICAgICAgJ3NwYW4nOiAgICAgICBbJ3N0eWxlJ10sXG4gICAgICAgICAgICAnc3Ryb25nJzogICAgIFtdLFxuICAgICAgICAgICAgJ3VsJzogICAgICAgICBbJ3N0eWxlJ10sXG4gICAgICAgICAgICAnYm9keSc6ICAgICAgIFtdXG4gICAgICAgIH0sXG4gICAgICAgIGNzczogWydiYWNrZ3JvdW5kLWNvbG9yJywnY29sb3InLCdmb250LWZhbWlseScsJ2ZvbnQtc2l6ZScsJ2ZvbnQtc3R5bGUnLCdmb250LXdlaWdodCcsJ21hcmdpbi1sZWZ0JywnbWFyZ2luLXJpZ2h0JywndGV4dC1hbGlnbicsJ3RleHQtZGVjb3JhdGlvbiddLFxuICAgICAgICAvKiogRnVuY3Rpb246IFhIVE1MLnZhbGlkVGFnXG4gICAgICAgICAqXG4gICAgICAgICAqIFV0aWxpdHkgbWV0aG9kIHRvIGRldGVybWluZSB3aGV0aGVyIGEgdGFnIGlzIGFsbG93ZWRcbiAgICAgICAgICogaW4gdGhlIFhIVE1MX0lNIG5hbWVzcGFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogWEhUTUwgdGFnIG5hbWVzIGFyZSBjYXNlIHNlbnNpdGl2ZSBhbmQgbXVzdCBiZSBsb3dlciBjYXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsaWRUYWc6IGZ1bmN0aW9uKHRhZykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTdHJvcGhlLlhIVE1MLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnID09IFN0cm9waGUuWEhUTUwudGFnc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBGdW5jdGlvbjogWEhUTUwudmFsaWRBdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogVXRpbGl0eSBtZXRob2QgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYW4gYXR0cmlidXRlIGlzIGFsbG93ZWRcbiAgICAgICAgICogYXMgcmVjb21tZW5kZWQgcGVyIFhFUC0wMDcxXG4gICAgICAgICAqXG4gICAgICAgICAqIFhIVE1MIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZSBzZW5zaXRpdmUgYW5kIG11c3QgYmUgbG93ZXIgY2FzZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhbGlkQXR0cmlidXRlOiBmdW5jdGlvbih0YWcsIGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBTdHJvcGhlLlhIVE1MLmF0dHJpYnV0ZXNbdGFnXSAhPT0gJ3VuZGVmaW5lZCcgJiYgU3Ryb3BoZS5YSFRNTC5hdHRyaWJ1dGVzW3RhZ10ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU3Ryb3BoZS5YSFRNTC5hdHRyaWJ1dGVzW3RhZ10ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZSA9PSBTdHJvcGhlLlhIVE1MLmF0dHJpYnV0ZXNbdGFnXVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRDU1M6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFN0cm9waGUuWEhUTUwuY3NzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlID09IFN0cm9waGUuWEhUTUwuY3NzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogQ29uc3RhbnRzOiBDb25uZWN0aW9uIFN0YXR1cyBDb25zdGFudHNcbiAgICAgKiAgQ29ubmVjdGlvbiBzdGF0dXMgY29uc3RhbnRzIGZvciB1c2UgYnkgdGhlIGNvbm5lY3Rpb24gaGFuZGxlclxuICAgICAqICBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqICBTdGF0dXMuRVJST1IgLSBBbiBlcnJvciBoYXMgb2NjdXJyZWRcbiAgICAgKiAgU3RhdHVzLkNPTk5FQ1RJTkcgLSBUaGUgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgYmVpbmcgbWFkZVxuICAgICAqICBTdGF0dXMuQ09OTkZBSUwgLSBUaGUgY29ubmVjdGlvbiBhdHRlbXB0IGZhaWxlZFxuICAgICAqICBTdGF0dXMuQVVUSEVOVElDQVRJTkcgLSBUaGUgY29ubmVjdGlvbiBpcyBhdXRoZW50aWNhdGluZ1xuICAgICAqICBTdGF0dXMuQVVUSEZBSUwgLSBUaGUgYXV0aGVudGljYXRpb24gYXR0ZW1wdCBmYWlsZWRcbiAgICAgKiAgU3RhdHVzLkNPTk5FQ1RFRCAtIFRoZSBjb25uZWN0aW9uIGhhcyBzdWNjZWVkZWRcbiAgICAgKiAgU3RhdHVzLkRJU0NPTk5FQ1RFRCAtIFRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIHRlcm1pbmF0ZWRcbiAgICAgKiAgU3RhdHVzLkRJU0NPTk5FQ1RJTkcgLSBUaGUgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgYmVpbmcgdGVybWluYXRlZFxuICAgICAqICBTdGF0dXMuQVRUQUNIRUQgLSBUaGUgY29ubmVjdGlvbiBoYXMgYmVlbiBhdHRhY2hlZFxuICAgICAqICBTdGF0dXMuQ09OTlRJTUVPVVQgLSBUaGUgY29ubmVjdGlvbiBoYXMgdGltZWQgb3V0XG4gICAgICovXG4gICAgU3RhdHVzOiB7XG4gICAgICAgIEVSUk9SOiAwLFxuICAgICAgICBDT05ORUNUSU5HOiAxLFxuICAgICAgICBDT05ORkFJTDogMixcbiAgICAgICAgQVVUSEVOVElDQVRJTkc6IDMsXG4gICAgICAgIEFVVEhGQUlMOiA0LFxuICAgICAgICBDT05ORUNURUQ6IDUsXG4gICAgICAgIERJU0NPTk5FQ1RFRDogNixcbiAgICAgICAgRElTQ09OTkVDVElORzogNyxcbiAgICAgICAgQVRUQUNIRUQ6IDgsXG4gICAgICAgIFJFRElSRUNUOiA5LFxuICAgICAgICBDT05OVElNRU9VVDogMTBcbiAgICB9LFxuXG4gICAgLyoqIENvbnN0YW50czogTG9nIExldmVsIENvbnN0YW50c1xuICAgICAqICBMb2dnaW5nIGxldmVsIGluZGljYXRvcnMuXG4gICAgICpcbiAgICAgKiAgTG9nTGV2ZWwuREVCVUcgLSBEZWJ1ZyBvdXRwdXRcbiAgICAgKiAgTG9nTGV2ZWwuSU5GTyAtIEluZm9ybWF0aW9uYWwgb3V0cHV0XG4gICAgICogIExvZ0xldmVsLldBUk4gLSBXYXJuaW5nc1xuICAgICAqICBMb2dMZXZlbC5FUlJPUiAtIEVycm9yc1xuICAgICAqICBMb2dMZXZlbC5GQVRBTCAtIEZhdGFsIGVycm9yc1xuICAgICAqL1xuICAgIExvZ0xldmVsOiB7XG4gICAgICAgIERFQlVHOiAwLFxuICAgICAgICBJTkZPOiAxLFxuICAgICAgICBXQVJOOiAyLFxuICAgICAgICBFUlJPUjogMyxcbiAgICAgICAgRkFUQUw6IDRcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVDb25zdGFudHM6IERPTSBFbGVtZW50IFR5cGUgQ29uc3RhbnRzXG4gICAgICogIERPTSBlbGVtZW50IHR5cGVzLlxuICAgICAqXG4gICAgICogIEVsZW1lbnRUeXBlLk5PUk1BTCAtIE5vcm1hbCBlbGVtZW50LlxuICAgICAqICBFbGVtZW50VHlwZS5URVhUIC0gVGV4dCBkYXRhIGVsZW1lbnQuXG4gICAgICogIEVsZW1lbnRUeXBlLkZSQUdNRU5UIC0gWEhUTUwgZnJhZ21lbnQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBFbGVtZW50VHlwZToge1xuICAgICAgICBOT1JNQUw6IDEsXG4gICAgICAgIFRFWFQ6IDMsXG4gICAgICAgIENEQVRBOiA0LFxuICAgICAgICBGUkFHTUVOVDogMTFcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVDb25zdGFudHM6IFRpbWVvdXQgVmFsdWVzXG4gICAgICogIFRpbWVvdXQgdmFsdWVzIGZvciBlcnJvciBzdGF0ZXMuICBUaGVzZSB2YWx1ZXMgYXJlIGluIHNlY29uZHMuXG4gICAgICogIFRoZXNlIHNob3VsZCBub3QgYmUgY2hhbmdlZCB1bmxlc3MgeW91IGtub3cgZXhhY3RseSB3aGF0IHlvdSBhcmVcbiAgICAgKiAgZG9pbmcuXG4gICAgICpcbiAgICAgKiAgVElNRU9VVCAtIFRpbWVvdXQgbXVsdGlwbGllci4gQSB3YWl0aW5nIHJlcXVlc3Qgd2lsbCBiZSBjb25zaWRlcmVkXG4gICAgICogICAgICBmYWlsZWQgYWZ0ZXIgTWF0aC5mbG9vcihUSU1FT1VUICogd2FpdCkgc2Vjb25kcyBoYXZlIGVsYXBzZWQuXG4gICAgICogICAgICBUaGlzIGRlZmF1bHRzIHRvIDEuMSwgYW5kIHdpdGggZGVmYXVsdCB3YWl0LCA2NiBzZWNvbmRzLlxuICAgICAqICBTRUNPTkRBUllfVElNRU9VVCAtIFNlY29uZGFyeSB0aW1lb3V0IG11bHRpcGxpZXIuIEluIGNhc2VzIHdoZXJlXG4gICAgICogICAgICBTdHJvcGhlIGNhbiBkZXRlY3QgZWFybHkgZmFpbHVyZSwgaXQgd2lsbCBjb25zaWRlciB0aGUgcmVxdWVzdFxuICAgICAqICAgICAgZmFpbGVkIGlmIGl0IGRvZXNuJ3QgcmV0dXJuIGFmdGVyXG4gICAgICogICAgICBNYXRoLmZsb29yKFNFQ09OREFSWV9USU1FT1VUICogd2FpdCkgc2Vjb25kcyBoYXZlIGVsYXBzZWQuXG4gICAgICogICAgICBUaGlzIGRlZmF1bHRzIHRvIDAuMSwgYW5kIHdpdGggZGVmYXVsdCB3YWl0LCA2IHNlY29uZHMuXG4gICAgICovXG4gICAgVElNRU9VVDogMS4xLFxuICAgIFNFQ09OREFSWV9USU1FT1VUOiAwLjEsXG5cbiAgICAvKiogRnVuY3Rpb246IGFkZE5hbWVzcGFjZVxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZXh0ZW5kIHRoZSBjdXJyZW50IG5hbWVzcGFjZXMgaW5cbiAgICAgKiAgU3Ryb3BoZS5OUy4gIEl0IHRha2VzIGEga2V5IGFuZCBhIHZhbHVlIHdpdGggdGhlIGtleSBiZWluZyB0aGVcbiAgICAgKiAgbmFtZSBvZiB0aGUgbmV3IG5hbWVzcGFjZSwgd2l0aCBpdHMgYWN0dWFsIHZhbHVlLlxuICAgICAqICBGb3IgZXhhbXBsZTpcbiAgICAgKiAgU3Ryb3BoZS5hZGROYW1lc3BhY2UoJ1BVQlNVQicsIFwiaHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvcHVic3ViXCIpO1xuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cmluZykgbmFtZSAtIFRoZSBuYW1lIHVuZGVyIHdoaWNoIHRoZSBuYW1lc3BhY2Ugd2lsbCBiZVxuICAgICAqICAgICAgcmVmZXJlbmNlZCB1bmRlciBTdHJvcGhlLk5TXG4gICAgICogICAgKFN0cmluZykgdmFsdWUgLSBUaGUgYWN0dWFsIG5hbWVzcGFjZS5cbiAgICAgKi9cbiAgICBhZGROYW1lc3BhY2U6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBTdHJvcGhlLk5TW25hbWVdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogZm9yRWFjaENoaWxkXG4gICAgICogIE1hcCBhIGZ1bmN0aW9uIG92ZXIgc29tZSBvciBhbGwgY2hpbGQgZWxlbWVudHMgb2YgYSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYSBzbWFsbCBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgbWFwcGluZyBhIGZ1bmN0aW9uIG92ZXJcbiAgICAgKiAgc29tZSBvciBhbGwgb2YgdGhlIGNoaWxkcmVuIG9mIGFuIGVsZW1lbnQuICBJZiBlbGVtTmFtZSBpcyBudWxsLCBhbGxcbiAgICAgKiAgY2hpbGRyZW4gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLCBvdGhlcndpc2Ugb25seSBjaGlsZHJlblxuICAgICAqICB3aG9zZSB0YWcgbmFtZXMgbWF0Y2ggZWxlbU5hbWUgd2lsbCBiZSBwYXNzZWQuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoWE1MRWxlbWVudCkgZWxlbSAtIFRoZSBlbGVtZW50IHRvIG9wZXJhdGUgb24uXG4gICAgICogICAgKFN0cmluZykgZWxlbU5hbWUgLSBUaGUgY2hpbGQgZWxlbWVudCB0YWcgbmFtZSBmaWx0ZXIuXG4gICAgICogICAgKEZ1bmN0aW9uKSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggY2hpbGQuICBUaGlzXG4gICAgICogICAgICBmdW5jdGlvbiBzaG91bGQgdGFrZSBhIHNpbmdsZSBhcmd1bWVudCwgYSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmb3JFYWNoQ2hpbGQ6IGZ1bmN0aW9uIChlbGVtLCBlbGVtTmFtZSwgZnVuYykge1xuICAgICAgICB2YXIgaSwgY2hpbGROb2RlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBlbGVtLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09IFN0cm9waGUuRWxlbWVudFR5cGUuTk9STUFMICYmXG4gICAgICAgICAgICAgICAgKCFlbGVtTmFtZSB8fCB0aGlzLmlzVGFnRXF1YWwoY2hpbGROb2RlLCBlbGVtTmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgZnVuYyhjaGlsZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogaXNUYWdFcXVhbFxuICAgICAqICBDb21wYXJlIGFuIGVsZW1lbnQncyB0YWcgbmFtZSB3aXRoIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FzZSBzZW5zaXRpdmUuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoWE1MRWxlbWVudCkgZWwgLSBBIERPTSBlbGVtZW50LlxuICAgICAqICAgIChTdHJpbmcpIG5hbWUgLSBUaGUgZWxlbWVudCBuYW1lLlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgdHJ1ZSBpZiB0aGUgZWxlbWVudCdzIHRhZyBuYW1lIG1hdGNoZXMgX2VsXywgYW5kIGZhbHNlXG4gICAgICogICAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzVGFnRXF1YWw6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZWwudGFnTmFtZSA9PSBuYW1lO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZVZhcmlhYmxlOiBfeG1sR2VuZXJhdG9yXG4gICAgICogIF9Qcml2YXRlXyB2YXJpYWJsZSB0aGF0IGNhY2hlcyBhIERPTSBkb2N1bWVudCB0b1xuICAgICAqICBnZW5lcmF0ZSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBfeG1sR2VuZXJhdG9yOiBudWxsLFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX21ha2VHZW5lcmF0b3JcbiAgICAgKiAgX1ByaXZhdGVfIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGR1bW15IFhNTCBET00gZG9jdW1lbnQgdG8gc2VydmUgYXNcbiAgICAgKiAgYW4gZWxlbWVudCBhbmQgdGV4dCBub2RlIGdlbmVyYXRvci5cbiAgICAgKi9cbiAgICBfbWFrZUdlbmVyYXRvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9jO1xuICAgICAgICAvLyBJRTkgZG9lcyBpbXBsZW1lbnQgY3JlYXRlRG9jdW1lbnQoKTsgaG93ZXZlciwgdXNpbmcgaXQgd2lsbCBjYXVzZSB0aGUgYnJvd3NlciB0byBsZWFrIG1lbW9yeSBvbiBwYWdlIHVubG9hZC5cbiAgICAgICAgLy8gSGVyZSwgd2UgdGVzdCBmb3IgcHJlc2VuY2Ugb2YgY3JlYXRlRG9jdW1lbnQoKSBwbHVzIElFJ3MgcHJvcHJpZXRhcnkgZG9jdW1lbnRNb2RlIGF0dHJpYnV0ZSwgd2hpY2ggd291bGQgYmVcbiAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gMTAgaW4gdGhlIGNhc2Ugb2YgSUU5IGFuZCBiZWxvdy5cbiAgICAgICAgaWYgKGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCAxMCkge1xuICAgICAgICAgICAgZG9jID0gdGhpcy5fZ2V0SUVYbWxEb20oKTtcbiAgICAgICAgICAgIGRvYy5hcHBlbmRDaGlsZChkb2MuY3JlYXRlRWxlbWVudCgnc3Ryb3BoZScpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAgICAgLmNyZWF0ZURvY3VtZW50KCdqYWJiZXI6Y2xpZW50JywgJ3N0cm9waGUnLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jO1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IHhtbEdlbmVyYXRvclxuICAgICAqICBHZXQgdGhlIERPTSBkb2N1bWVudCB0byBnZW5lcmF0ZSBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIFRoZSBjdXJyZW50bHkgdXNlZCBET00gZG9jdW1lbnQuXG4gICAgICovXG4gICAgeG1sR2VuZXJhdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghU3Ryb3BoZS5feG1sR2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBTdHJvcGhlLl94bWxHZW5lcmF0b3IgPSBTdHJvcGhlLl9tYWtlR2VuZXJhdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cm9waGUuX3htbEdlbmVyYXRvcjtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2dldElFWG1sRG9tXG4gICAgICogIEdldHMgSUUgeG1sIGRvYyBvYmplY3RcbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIEEgTWljcm9zb2Z0IFhNTCBET00gT2JqZWN0XG4gICAgICogIFNlZSBBbHNvOlxuICAgICAqICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczc1NzgzNyUyOFZTLjg1JTI5LmFzcHhcbiAgICAgKi9cbiAgICBfZ2V0SUVYbWxEb20gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRvYyA9IG51bGw7XG4gICAgICAgIHZhciBkb2NTdHJpbmdzID0gW1xuICAgICAgICAgICAgXCJNc3htbDIuRE9NRG9jdW1lbnQuNi4wXCIsXG4gICAgICAgICAgICBcIk1zeG1sMi5ET01Eb2N1bWVudC41LjBcIixcbiAgICAgICAgICAgIFwiTXN4bWwyLkRPTURvY3VtZW50LjQuMFwiLFxuICAgICAgICAgICAgXCJNU1hNTDIuRE9NRG9jdW1lbnQuMy4wXCIsXG4gICAgICAgICAgICBcIk1TWE1MMi5ET01Eb2N1bWVudFwiLFxuICAgICAgICAgICAgXCJNU1hNTC5ET01Eb2N1bWVudFwiLFxuICAgICAgICAgICAgXCJNaWNyb3NvZnQuWE1MRE9NXCJcbiAgICAgICAgXTtcblxuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRvY1N0cmluZ3MubGVuZ3RoOyBkKyspIHtcbiAgICAgICAgICAgIGlmIChkb2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBuZXcgQWN0aXZlWE9iamVjdChkb2NTdHJpbmdzW2RdKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jO1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IHhtbEVsZW1lbnRcbiAgICAgKiAgQ3JlYXRlIGFuIFhNTCBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYW4gWE1MIERPTSBlbGVtZW50IGNvcnJlY3RseSBhY3Jvc3MgYWxsXG4gICAgICogIGltcGxlbWVudGF0aW9ucy4gTm90ZSB0aGF0IHRoZXNlIGFyZSBub3QgSFRNTCBET00gZWxlbWVudHMsIHdoaWNoXG4gICAgICogIGFyZW4ndCBhcHByb3ByaWF0ZSBmb3IgWE1QUCBzdGFuemFzLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cmluZykgbmFtZSAtIFRoZSBuYW1lIGZvciB0aGUgZWxlbWVudC5cbiAgICAgKiAgICAoQXJyYXl8T2JqZWN0KSBhdHRycyAtIEFuIG9wdGlvbmFsIGFycmF5IG9yIG9iamVjdCBjb250YWluaW5nXG4gICAgICogICAgICBrZXkvdmFsdWUgcGFpcnMgdG8gdXNlIGFzIGVsZW1lbnQgYXR0cmlidXRlcy4gVGhlIG9iamVjdCBzaG91bGRcbiAgICAgKiAgICAgIGJlIGluIHRoZSBmb3JtYXQgeydrZXknOiAndmFsdWUnfSBvciB7a2V5OiAndmFsdWUnfS4gVGhlIGFycmF5XG4gICAgICogICAgICBzaG91bGQgaGF2ZSB0aGUgZm9ybWF0IFtbJ2tleTEnLCAndmFsdWUxJ10sIFsna2V5MicsICd2YWx1ZTInXV0uXG4gICAgICogICAgKFN0cmluZykgdGV4dCAtIFRoZSB0ZXh0IGNoaWxkIGRhdGEgZm9yIHRoZSBlbGVtZW50LlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgQSBuZXcgWE1MIERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIHhtbEVsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICghbmFtZSkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIHZhciBub2RlID0gU3Ryb3BoZS54bWxHZW5lcmF0b3IoKS5jcmVhdGVFbGVtZW50KG5hbWUpO1xuICAgICAgICAvLyBGSVhNRTogdGhpcyBzaG91bGQgdGhyb3cgZXJyb3JzIGlmIGFyZ3MgYXJlIHRoZSB3cm9uZyB0eXBlIG9yXG4gICAgICAgIC8vIHRoZXJlIGFyZSBtb3JlIHRoYW4gdHdvIG9wdGlvbmFsIGFyZ3NcbiAgICAgICAgdmFyIGEsIGksIGs7XG4gICAgICAgIGZvciAoYSA9IDE7IGEgPCBhcmd1bWVudHMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbYV07XG4gICAgICAgICAgICBpZiAoIWFyZykgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZihhcmcpID09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YoYXJnKSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChTdHJvcGhlLnhtbFRleHROb2RlKGFyZykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoYXJnKSA9PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZihhcmcuc29ydCkgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGFyZ1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihhdHRyKSA9PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YoYXR0ci5zb3J0KSA9PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJbMV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0clsxXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0clswXSwgYXR0clsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihhcmcpID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdba10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ1trXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGssIGFyZ1trXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgLyogIEZ1bmN0aW9uOiB4bWxlc2NhcGVcbiAgICAgKiAgRXhjYXBlcyBpbnZhbGlkIHhtbCBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgIChTdHJpbmcpIHRleHQgLSB0ZXh0IHRvIGVzY2FwZS5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgICAgRXNjYXBlZCB0ZXh0LlxuICAgICAqL1xuICAgIHhtbGVzY2FwZTogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXCYvZywgXCImYW1wO1wiKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvPC9nLCAgXCImbHQ7XCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8+L2csICBcIiZndDtcIik7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLycvZywgIFwiJmFwb3M7XCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cIi9nLCAgXCImcXVvdDtcIik7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH0sXG5cbiAgICAvKiAgRnVuY3Rpb246IHhtbHVuZXNjYXBlXG4gICAgKiAgVW5leGNhcGVzIGludmFsaWQgeG1sIGNoYXJhY3RlcnMuXG4gICAgKlxuICAgICogIFBhcmFtZXRlcnM6XG4gICAgKiAgICAgKFN0cmluZykgdGV4dCAtIHRleHQgdG8gdW5lc2NhcGUuXG4gICAgKlxuICAgICogIFJldHVybnM6XG4gICAgKiAgICAgIFVuZXNjYXBlZCB0ZXh0LlxuICAgICovXG4gICAgeG1sdW5lc2NhcGU6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFwmYW1wOy9nLCBcIiZcIik7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyZsdDsvZywgIFwiPFwiKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvJmd0Oy9nLCAgXCI+XCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8mYXBvczsvZywgIFwiJ1wiKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvJnF1b3Q7L2csICBcIlxcXCJcIik7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IHhtbFRleHROb2RlXG4gICAgICogIENyZWF0ZXMgYW4gWE1MIERPTSB0ZXh0IG5vZGUuXG4gICAgICpcbiAgICAgKiAgUHJvdmlkZXMgYSBjcm9zcyBpbXBsZW1lbnRhdGlvbiB2ZXJzaW9uIG9mIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cmluZykgdGV4dCAtIFRoZSBjb250ZW50IG9mIHRoZSB0ZXh0IG5vZGUuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBBIG5ldyBYTUwgRE9NIHRleHQgbm9kZS5cbiAgICAgKi9cbiAgICB4bWxUZXh0Tm9kZTogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIFN0cm9waGUueG1sR2VuZXJhdG9yKCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogeG1sSHRtbE5vZGVcbiAgICAgKiAgQ3JlYXRlcyBhbiBYTUwgRE9NIGh0bWwgbm9kZS5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJpbmcpIGh0bWwgLSBUaGUgY29udGVudCBvZiB0aGUgaHRtbCBub2RlLlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgQSBuZXcgWE1MIERPTSB0ZXh0IG5vZGUuXG4gICAgICovXG4gICAgeG1sSHRtbE5vZGU6IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICAvL2Vuc3VyZSB0ZXh0IGlzIGVzY2FwZWRcbiAgICAgICAgaWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgICAgICBub2RlID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sLCBcInRleHQveG1sXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKTtcbiAgICAgICAgICAgIG5vZGUuYXN5bmM9XCJmYWxzZVwiO1xuICAgICAgICAgICAgbm9kZS5sb2FkWE1MKGh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IGdldFRleHRcbiAgICAgKiAgR2V0IHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IGNoaWxkcmVuIG9mIGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoWE1MRWxlbWVudCkgZWxlbSAtIEEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBBIFN0cmluZyB3aXRoIHRoZSBjb25jYXRlbmF0ZWQgdGV4dCBvZiBhbGwgdGV4dCBlbGVtZW50IGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGdldFRleHQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIGlmICghZWxlbSkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIHZhciBzdHIgPSBcIlwiO1xuICAgICAgICBpZiAoZWxlbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCAmJiBlbGVtLm5vZGVUeXBlID09XG4gICAgICAgICAgICBTdHJvcGhlLkVsZW1lbnRUeXBlLlRFWFQpIHtcbiAgICAgICAgICAgIHN0ciArPSBlbGVtLm5vZGVWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09IFN0cm9waGUuRWxlbWVudFR5cGUuVEVYVCkge1xuICAgICAgICAgICAgICAgIHN0ciArPSBlbGVtLmNoaWxkTm9kZXNbaV0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFN0cm9waGUueG1sZXNjYXBlKHN0cik7XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogY29weUVsZW1lbnRcbiAgICAgKiAgQ29weSBhbiBYTUwgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBjb3BpZXMgYSBET00gZWxlbWVudCBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cyBhbmQgcmV0dXJuc1xuICAgICAqICB0aGUgbmV3IGNvcHkuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoWE1MRWxlbWVudCkgZWxlbSAtIEEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBBIG5ldywgY29waWVkIERPTSBlbGVtZW50IHRyZWUuXG4gICAgICovXG4gICAgY29weUVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHZhciBpLCBlbDtcbiAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT0gU3Ryb3BoZS5FbGVtZW50VHlwZS5OT1JNQUwpIHtcbiAgICAgICAgICAgIGVsID0gU3Ryb3BoZS54bWxFbGVtZW50KGVsZW0udGFnTmFtZSk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoZWxlbS5hdHRyaWJ1dGVzW2ldLm5vZGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmF0dHJpYnV0ZXNbaV0udmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoU3Ryb3BoZS5jb3B5RWxlbWVudChlbGVtLmNoaWxkTm9kZXNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlbGVtLm5vZGVUeXBlID09IFN0cm9waGUuRWxlbWVudFR5cGUuVEVYVCkge1xuICAgICAgICAgICAgZWwgPSBTdHJvcGhlLnhtbEdlbmVyYXRvcigpLmNyZWF0ZVRleHROb2RlKGVsZW0ubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuXG4gICAgLyoqIEZ1bmN0aW9uOiBjcmVhdGVIdG1sXG4gICAgICogIENvcHkgYW4gSFRNTCBET00gZWxlbWVudCBpbnRvIGFuIFhNTCBET00uXG4gICAgICpcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBjb3BpZXMgYSBET00gZWxlbWVudCBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cyBhbmQgcmV0dXJuc1xuICAgICAqICB0aGUgbmV3IGNvcHkuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoSFRNTEVsZW1lbnQpIGVsZW0gLSBBIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgQSBuZXcsIGNvcGllZCBET00gZWxlbWVudCB0cmVlLlxuICAgICAqL1xuICAgIGNyZWF0ZUh0bWw6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHZhciBpLCBlbCwgaiwgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlLCBjc3MsIGNzc0F0dHJzLCBhdHRyLCBjc3NOYW1lLCBjc3NWYWx1ZTtcbiAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT0gU3Ryb3BoZS5FbGVtZW50VHlwZS5OT1JNQUwpIHtcbiAgICAgICAgICAgIHRhZyA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTsgLy8gWEhUTUwgdGFncyBtdXN0IGJlIGxvd2VyIGNhc2UuXG4gICAgICAgICAgICBpZihTdHJvcGhlLlhIVE1MLnZhbGlkVGFnKHRhZykpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBlbCA9IFN0cm9waGUueG1sRWxlbWVudCh0YWcpO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBTdHJvcGhlLlhIVE1MLmF0dHJpYnV0ZXNbdGFnXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlID0gU3Ryb3BoZS5YSFRNTC5hdHRyaWJ1dGVzW3RhZ11baV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVsZW0uZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0cmlidXRlID09ICdzdHlsZScgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHZhbHVlLmNzc1RleHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5jc3NUZXh0OyAvLyB3ZSdyZSBkZWFsaW5nIHdpdGggSUUsIG5lZWQgdG8gZ2V0IENTUyBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGludmFsaWQgY3NzIHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0cmlidXRlID09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NBdHRycyA9IHZhbHVlLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgY3NzQXR0cnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGNzc0F0dHJzW2pdLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc05hbWUgPSBhdHRyWzBdLnJlcGxhY2UoL15cXHMqLywgXCJcIikucmVwbGFjZSgvXFxzKiQvLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihTdHJvcGhlLlhIVE1MLnZhbGlkQ1NTKGNzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NWYWx1ZSA9IGF0dHJbMV0ucmVwbGFjZSgvXlxccyovLCBcIlwiKS5yZXBsYWNlKC9cXHMqJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnB1c2goY3NzTmFtZSArICc6ICcgKyBjc3NWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY3NzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjc3Muam9pbignOyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsZW0uY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoU3Ryb3BoZS5jcmVhdGVIdG1sKGVsZW0uY2hpbGROb2Rlc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7IC8vIGludmFsaWQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgIGVsID0gU3Ryb3BoZS54bWxUZXh0Tm9kZSgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IFN0cm9waGUueG1sR2VuZXJhdG9yKCkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoU3Ryb3BoZS5jcmVhdGVIdG1sKGVsZW0uY2hpbGROb2Rlc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlbGVtLm5vZGVUeXBlID09IFN0cm9waGUuRWxlbWVudFR5cGUuRlJBR01FTlQpIHtcbiAgICAgICAgICAgIGVsID0gU3Ryb3BoZS54bWxHZW5lcmF0b3IoKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoU3Ryb3BoZS5jcmVhdGVIdG1sKGVsZW0uY2hpbGROb2Rlc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW0ubm9kZVR5cGUgPT0gU3Ryb3BoZS5FbGVtZW50VHlwZS5URVhUKSB7XG4gICAgICAgICAgICBlbCA9IFN0cm9waGUueG1sVGV4dE5vZGUoZWxlbS5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiBlc2NhcGVOb2RlXG4gICAgICogIEVzY2FwZSB0aGUgbm9kZSBwYXJ0IChhbHNvIGNhbGxlZCBsb2NhbCBwYXJ0KSBvZiBhIEpJRC5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJpbmcpIG5vZGUgLSBBIG5vZGUgKG9yIGxvY2FsIHBhcnQpLlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgQW4gZXNjYXBlZCBub2RlIChvciBsb2NhbCBwYXJ0KS5cbiAgICAgKi9cbiAgICBlc2NhcGVOb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09IFwic3RyaW5nXCIpIHsgcmV0dXJuIG5vZGU7IH1cbiAgICAgICAgcmV0dXJuIG5vZGUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCAgXCJcXFxcNWNcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8gL2csICAgXCJcXFxcMjBcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFwiL2csICBcIlxcXFwyMlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcJi9nLCAgXCJcXFxcMjZcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCcvZywgIFwiXFxcXDI3XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwvL2csICBcIlxcXFwyZlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzovZywgICBcIlxcXFwzYVwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgICBcIlxcXFwzY1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLz4vZywgICBcIlxcXFwzZVwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL0AvZywgICBcIlxcXFw0MFwiKTtcbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiB1bmVzY2FwZU5vZGVcbiAgICAgKiAgVW5lc2NhcGUgYSBub2RlIHBhcnQgKGFsc28gY2FsbGVkIGxvY2FsIHBhcnQpIG9mIGEgSklELlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cmluZykgbm9kZSAtIEEgbm9kZSAob3IgbG9jYWwgcGFydCkuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBBbiB1bmVzY2FwZWQgbm9kZSAob3IgbG9jYWwgcGFydCkuXG4gICAgICovXG4gICAgdW5lc2NhcGVOb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09IFwic3RyaW5nXCIpIHsgcmV0dXJuIG5vZGU7IH1cbiAgICAgICAgcmV0dXJuIG5vZGUucmVwbGFjZSgvXFxcXDIwL2csIFwiIFwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwyMi9nLCAnXCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwyNi9nLCBcIiZcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcMjcvZywgXCInXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXDJmL2csIFwiL1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwzYS9nLCBcIjpcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcM2MvZywgXCI8XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXDNlL2csIFwiPlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFw0MC9nLCBcIkBcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcNWMvZywgXCJcXFxcXCIpO1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IGdldE5vZGVGcm9tSmlkXG4gICAgICogIEdldCB0aGUgbm9kZSBwb3J0aW9uIG9mIGEgSklEIFN0cmluZy5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJpbmcpIGppZCAtIEEgSklELlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgQSBTdHJpbmcgY29udGFpbmluZyB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBnZXROb2RlRnJvbUppZDogZnVuY3Rpb24gKGppZCkge1xuICAgICAgICBpZiAoamlkLmluZGV4T2YoXCJAXCIpIDwgMCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICByZXR1cm4gamlkLnNwbGl0KFwiQFwiKVswXTtcbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiBnZXREb21haW5Gcm9tSmlkXG4gICAgICogIEdldCB0aGUgZG9tYWluIHBvcnRpb24gb2YgYSBKSUQgU3RyaW5nLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cmluZykgamlkIC0gQSBKSUQuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBBIFN0cmluZyBjb250YWluaW5nIHRoZSBkb21haW4uXG4gICAgICovXG4gICAgZ2V0RG9tYWluRnJvbUppZDogZnVuY3Rpb24gKGppZCkge1xuICAgICAgICB2YXIgYmFyZSA9IFN0cm9waGUuZ2V0QmFyZUppZEZyb21KaWQoamlkKTtcbiAgICAgICAgaWYgKGJhcmUuaW5kZXhPZihcIkBcIikgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFyZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGJhcmUuc3BsaXQoXCJAXCIpO1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKDAsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJ0AnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IGdldFJlc291cmNlRnJvbUppZFxuICAgICAqICBHZXQgdGhlIHJlc291cmNlIHBvcnRpb24gb2YgYSBKSUQgU3RyaW5nLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cmluZykgamlkIC0gQSBKSUQuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBBIFN0cmluZyBjb250YWluaW5nIHRoZSByZXNvdXJjZS5cbiAgICAgKi9cbiAgICBnZXRSZXNvdXJjZUZyb21KaWQ6IGZ1bmN0aW9uIChqaWQpIHtcbiAgICAgICAgdmFyIHMgPSBqaWQuc3BsaXQoXCIvXCIpO1xuICAgICAgICBpZiAocy5sZW5ndGggPCAyKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHMuc3BsaWNlKDAsIDEpO1xuICAgICAgICByZXR1cm4gcy5qb2luKCcvJyk7XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogZ2V0QmFyZUppZEZyb21KaWRcbiAgICAgKiAgR2V0IHRoZSBiYXJlIEpJRCBmcm9tIGEgSklEIFN0cmluZy5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJpbmcpIGppZCAtIEEgSklELlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgQSBTdHJpbmcgY29udGFpbmluZyB0aGUgYmFyZSBKSUQuXG4gICAgICovXG4gICAgZ2V0QmFyZUppZEZyb21KaWQ6IGZ1bmN0aW9uIChqaWQpIHtcbiAgICAgICAgcmV0dXJuIGppZCA/IGppZC5zcGxpdChcIi9cIilbMF0gOiBudWxsO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfaGFuZGxlRXJyb3JcbiAgICAgKiAgX1ByaXZhdGVfIGZ1bmN0aW9uIHRoYXQgcHJvcGVybHkgbG9ncyBhbiBlcnJvciB0byB0aGUgY29uc29sZVxuICAgICAqL1xuICAgIF9oYW5kbGVFcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlLnN0YWNrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBTdHJvcGhlLmZhdGFsKGUuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnNvdXJjZVVSTCkge1xuICAgICAgICAgICAgU3Ryb3BoZS5mYXRhbChcImVycm9yOiBcIiArIHRoaXMuaGFuZGxlciArIFwiIFwiICsgZS5zb3VyY2VVUkwgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGUubGluZSArIFwiIC0gXCIgKyBlLm5hbWUgKyBcIjogXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZmlsZU5hbWUpIHtcbiAgICAgICAgICAgIFN0cm9waGUuZmF0YWwoXCJlcnJvcjogXCIgKyB0aGlzLmhhbmRsZXIgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGUuZmlsZU5hbWUgKyBcIjpcIiArIGUubGluZU51bWJlciArIFwiIC0gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBlLm5hbWUgKyBcIjogXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgU3Ryb3BoZS5mYXRhbChcImVycm9yOiBcIiArIGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiBsb2dcbiAgICAgKiAgVXNlciBvdmVycmlkZWFibGUgbG9nZ2luZyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgU3Ryb3BoZSBsaWJyYXJ5IGNhbGxzIGFueVxuICAgICAqICBvZiB0aGUgbG9nZ2luZyBmdW5jdGlvbnMuICBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzXG4gICAgICogIGZ1bmN0aW9uIGRvZXMgbm90aGluZy4gIElmIGNsaWVudCBjb2RlIHdpc2hlcyB0byBoYW5kbGUgdGhlIGxvZ2dpbmdcbiAgICAgKiAgbWVzc2FnZXMsIGl0IHNob3VsZCBvdmVycmlkZSB0aGlzIHdpdGhcbiAgICAgKiAgPiBTdHJvcGhlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgbXNnKSB7XG4gICAgICogID4gICAodXNlciBjb2RlIGhlcmUpXG4gICAgICogID4gfTtcbiAgICAgKlxuICAgICAqICBQbGVhc2Ugbm90ZSB0aGF0IGRhdGEgc2VudCBhbmQgcmVjZWl2ZWQgb3ZlciB0aGUgd2lyZSBpcyBsb2dnZWRcbiAgICAgKiAgdmlhIFN0cm9waGUuQ29ubmVjdGlvbi5yYXdJbnB1dCgpIGFuZCBTdHJvcGhlLkNvbm5lY3Rpb24ucmF3T3V0cHV0KCkuXG4gICAgICpcbiAgICAgKiAgVGhlIGRpZmZlcmVudCBsZXZlbHMgYW5kIHRoZWlyIG1lYW5pbmdzIGFyZVxuICAgICAqXG4gICAgICogICAgREVCVUcgLSBNZXNzYWdlcyB1c2VmdWwgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAgICAgKiAgICBJTkZPIC0gSW5mb3JtYXRpb25hbCBtZXNzYWdlcy4gIFRoaXMgaXMgbW9zdGx5IGluZm9ybWF0aW9uIGxpa2VcbiAgICAgKiAgICAgICdkaXNjb25uZWN0IHdhcyBjYWxsZWQnIG9yICdTQVNMIGF1dGggc3VjY2VlZGVkJy5cbiAgICAgKiAgICBXQVJOIC0gV2FybmluZ3MgYWJvdXQgcG90ZW50aWFsIHByb2JsZW1zLiAgVGhpcyBpcyBtb3N0bHkgdXNlZFxuICAgICAqICAgICAgdG8gcmVwb3J0IHRyYW5zaWVudCBjb25uZWN0aW9uIGVycm9ycyBsaWtlIHJlcXVlc3QgdGltZW91dHMuXG4gICAgICogICAgRVJST1IgLSBTb21lIGVycm9yIG9jY3VycmVkLlxuICAgICAqICAgIEZBVEFMIC0gQSBub24tcmVjb3ZlcmFibGUgZmF0YWwgZXJyb3Igb2NjdXJyZWQuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoSW50ZWdlcikgbGV2ZWwgLSBUaGUgbG9nIGxldmVsIG9mIHRoZSBsb2cgbWVzc2FnZS4gIFRoaXMgd2lsbFxuICAgICAqICAgICAgYmUgb25lIG9mIHRoZSB2YWx1ZXMgaW4gU3Ryb3BoZS5Mb2dMZXZlbC5cbiAgICAgKiAgICAoU3RyaW5nKSBtc2cgLSBUaGUgbG9nIG1lc3NhZ2UuXG4gICAgICovXG4gICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgIGxvZzogZnVuY3Rpb24gKGxldmVsLCBtc2cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAgIC8qKiBGdW5jdGlvbjogZGVidWdcbiAgICAgKiAgTG9nIGEgbWVzc2FnZSBhdCB0aGUgU3Ryb3BoZS5Mb2dMZXZlbC5ERUJVRyBsZXZlbC5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJpbmcpIG1zZyAtIFRoZSBsb2cgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBkZWJ1ZzogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIHRoaXMubG9nKHRoaXMuTG9nTGV2ZWwuREVCVUcsIG1zZyk7XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogaW5mb1xuICAgICAqICBMb2cgYSBtZXNzYWdlIGF0IHRoZSBTdHJvcGhlLkxvZ0xldmVsLklORk8gbGV2ZWwuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoU3RyaW5nKSBtc2cgLSBUaGUgbG9nIG1lc3NhZ2UuXG4gICAgICovXG4gICAgaW5mbzogZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aGlzLmxvZyh0aGlzLkxvZ0xldmVsLklORk8sIG1zZyk7XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogd2FyblxuICAgICAqICBMb2cgYSBtZXNzYWdlIGF0IHRoZSBTdHJvcGhlLkxvZ0xldmVsLldBUk4gbGV2ZWwuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoU3RyaW5nKSBtc2cgLSBUaGUgbG9nIG1lc3NhZ2UuXG4gICAgICovXG4gICAgd2FybjogZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aGlzLmxvZyh0aGlzLkxvZ0xldmVsLldBUk4sIG1zZyk7XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogZXJyb3JcbiAgICAgKiAgTG9nIGEgbWVzc2FnZSBhdCB0aGUgU3Ryb3BoZS5Mb2dMZXZlbC5FUlJPUiBsZXZlbC5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJpbmcpIG1zZyAtIFRoZSBsb2cgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBlcnJvcjogZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aGlzLmxvZyh0aGlzLkxvZ0xldmVsLkVSUk9SLCBtc2cpO1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IGZhdGFsXG4gICAgICogIExvZyBhIG1lc3NhZ2UgYXQgdGhlIFN0cm9waGUuTG9nTGV2ZWwuRkFUQUwgbGV2ZWwuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoU3RyaW5nKSBtc2cgLSBUaGUgbG9nIG1lc3NhZ2UuXG4gICAgICovXG4gICAgZmF0YWw6IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhpcy5sb2codGhpcy5Mb2dMZXZlbC5GQVRBTCwgbXNnKTtcbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiBzZXJpYWxpemVcbiAgICAgKiAgUmVuZGVyIGEgRE9NIGVsZW1lbnQgYW5kIGFsbCBkZXNjZW5kYW50cyB0byBhIFN0cmluZy5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChYTUxFbGVtZW50KSBlbGVtIC0gQSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIFRoZSBzZXJpYWxpemVkIGVsZW1lbnQgdHJlZSBhcyBhIFN0cmluZy5cbiAgICAgKi9cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgaWYgKCFlbGVtKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihlbGVtLnRyZWUpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLnRyZWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gICAgICAgIHZhciBpLCBjaGlsZDtcblxuICAgICAgICBpZiAoZWxlbS5nZXRBdHRyaWJ1dGUoXCJfcmVhbG5hbWVcIikpIHtcbiAgICAgICAgICAgIG5vZGVOYW1lID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJfcmVhbG5hbWVcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBcIjxcIiArIG5vZGVOYW1lO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgaWYoZWxlbS5hdHRyaWJ1dGVzW2ldLm5vZGVOYW1lICE9IFwiX3JlYWxuYW1lXCIpIHtcbiAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIiArIGVsZW0uYXR0cmlidXRlc1tpXS5ub2RlTmFtZSArXG4gICAgICAgICAgICAgICAgICAgXCI9J1wiICsgU3Ryb3BoZS54bWxlc2NhcGUoZWxlbS5hdHRyaWJ1dGVzW2ldLnZhbHVlKSArIFwiJ1wiO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiPlwiO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsZW0uY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gZWxlbS5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIHN3aXRjaCggY2hpbGQubm9kZVR5cGUgKXtcbiAgICAgICAgICAgICAgICAgIGNhc2UgU3Ryb3BoZS5FbGVtZW50VHlwZS5OT1JNQUw6XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbCBlbGVtZW50LCBzbyByZWN1cnNlXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJvcGhlLnNlcmlhbGl6ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBTdHJvcGhlLkVsZW1lbnRUeXBlLlRFWFQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRleHQgZWxlbWVudCB0byBlc2NhcGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJvcGhlLnhtbGVzY2FwZShjaGlsZC5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgU3Ryb3BoZS5FbGVtZW50VHlwZS5DREFUQTpcbiAgICAgICAgICAgICAgICAgICAgLy8gY2RhdGEgc2VjdGlvbiBzbyBkb24ndCBlc2NhcGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIjwhW0NEQVRBW1wiK2NoaWxkLm5vZGVWYWx1ZStcIl1dPlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBcIjwvXCIgKyBub2RlTmFtZSArIFwiPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiLz5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlVmFyaWFibGU6IF9yZXF1ZXN0SWRcbiAgICAgKiAgX1ByaXZhdGVfIHZhcmlhYmxlIHRoYXQga2VlcHMgdHJhY2sgb2YgdGhlIHJlcXVlc3QgaWRzIGZvclxuICAgICAqICBjb25uZWN0aW9ucy5cbiAgICAgKi9cbiAgICBfcmVxdWVzdElkOiAwLFxuXG4gICAgLyoqIFByaXZhdGVWYXJpYWJsZTogU3Ryb3BoZS5jb25uZWN0aW9uUGx1Z2luc1xuICAgICAqICBfUHJpdmF0ZV8gdmFyaWFibGUgVXNlZCB0byBzdG9yZSBwbHVnaW4gbmFtZXMgdGhhdCBuZWVkXG4gICAgICogIGluaXRpYWxpemF0aW9uIG9uIFN0cm9waGUuQ29ubmVjdGlvbiBjb25zdHJ1Y3Rpb24uXG4gICAgICovXG4gICAgX2Nvbm5lY3Rpb25QbHVnaW5zOiB7fSxcblxuICAgIC8qKiBGdW5jdGlvbjogYWRkQ29ubmVjdGlvblBsdWdpblxuICAgICAqICBFeHRlbmRzIHRoZSBTdHJvcGhlLkNvbm5lY3Rpb24gb2JqZWN0IHdpdGggdGhlIGdpdmVuIHBsdWdpbi5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJpbmcpIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXh0ZW5zaW9uLlxuICAgICAqICAgIChPYmplY3QpIHB0eXBlIC0gVGhlIHBsdWdpbidzIHByb3RvdHlwZS5cbiAgICAgKi9cbiAgICBhZGRDb25uZWN0aW9uUGx1Z2luOiBmdW5jdGlvbiAobmFtZSwgcHR5cGUpIHtcbiAgICAgICAgU3Ryb3BoZS5fY29ubmVjdGlvblBsdWdpbnNbbmFtZV0gPSBwdHlwZTtcbiAgICB9XG59O1xuXG4vKiogQ2xhc3M6IFN0cm9waGUuQnVpbGRlclxuICogIFhNTCBET00gYnVpbGRlci5cbiAqXG4gKiAgVGhpcyBvYmplY3QgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHNpbWlsYXIgdG8gSlF1ZXJ5IGJ1dCBmb3IgYnVpbGRpbmdcbiAqICBET00gZWxlbWVudHMgZWFzaWx5IGFuZCByYXBpZGx5LiAgQWxsIHRoZSBmdW5jdGlvbnMgZXhjZXB0IGZvciB0b1N0cmluZygpXG4gKiAgYW5kIHRyZWUoKSByZXR1cm4gdGhlIG9iamVjdCwgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuICBIZXJlJ3MgYW5cbiAqICBleGFtcGxlIHVzaW5nIHRoZSAkaXEoKSBidWlsZGVyIGhlbHBlci5cbiAqICA+ICRpcSh7dG86ICd5b3UnLCBmcm9tOiAnbWUnLCB0eXBlOiAnZ2V0JywgaWQ6ICcxJ30pXG4gKiAgPiAgICAgLmMoJ3F1ZXJ5Jywge3htbG5zOiAnc3Ryb3BoZTpleGFtcGxlJ30pXG4gKiAgPiAgICAgLmMoJ2V4YW1wbGUnKVxuICogID4gICAgIC50b1N0cmluZygpXG4gKlxuICogIFRoZSBhYm92ZSBnZW5lcmF0ZXMgdGhpcyBYTUwgZnJhZ21lbnRcbiAqICA+IDxpcSB0bz0neW91JyBmcm9tPSdtZScgdHlwZT0nZ2V0JyBpZD0nMSc+XG4gKiAgPiAgIDxxdWVyeSB4bWxucz0nc3Ryb3BoZTpleGFtcGxlJz5cbiAqICA+ICAgICA8ZXhhbXBsZS8+XG4gKiAgPiAgIDwvcXVlcnk+XG4gKiAgPiA8L2lxPlxuICogIFRoZSBjb3JyZXNwb25kaW5nIERPTSBtYW5pcHVsYXRpb25zIHRvIGdldCBhIHNpbWlsYXIgZnJhZ21lbnQgd291bGQgYmVcbiAqICBhIGxvdCBtb3JlIHRlZGlvdXMgYW5kIHByb2JhYmx5IGludm9sdmUgc2V2ZXJhbCBoZWxwZXIgdmFyaWFibGVzLlxuICpcbiAqICBTaW5jZSBhZGRpbmcgY2hpbGRyZW4gbWFrZXMgbmV3IG9wZXJhdGlvbnMgb3BlcmF0ZSBvbiB0aGUgY2hpbGQsIHVwKClcbiAqICBpcyBwcm92aWRlZCB0byB0cmF2ZXJzZSB1cCB0aGUgdHJlZS4gIFRvIGFkZCB0d28gY2hpbGRyZW4sIGRvXG4gKiAgPiBidWlsZGVyLmMoJ2NoaWxkMScsIC4uLikudXAoKS5jKCdjaGlsZDInLCAuLi4pXG4gKiAgVGhlIG5leHQgb3BlcmF0aW9uIG9uIHRoZSBCdWlsZGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhlIHNlY29uZCBjaGlsZC5cbiAqL1xuXG4vKiogQ29uc3RydWN0b3I6IFN0cm9waGUuQnVpbGRlclxuICogIENyZWF0ZSBhIFN0cm9waGUuQnVpbGRlciBvYmplY3QuXG4gKlxuICogIFRoZSBhdHRyaWJ1dGVzIHNob3VsZCBiZSBwYXNzZWQgaW4gb2JqZWN0IG5vdGF0aW9uLiAgRm9yIGV4YW1wbGVcbiAqICA+IHZhciBiID0gbmV3IEJ1aWxkZXIoJ21lc3NhZ2UnLCB7dG86ICd5b3UnLCBmcm9tOiAnbWUnfSk7XG4gKiAgb3JcbiAqICA+IHZhciBiID0gbmV3IEJ1aWxkZXIoJ21lc3NzYWdlJywgeyd4bWw6bGFuZyc6ICdlbid9KTtcbiAqXG4gKiAgUGFyYW1ldGVyczpcbiAqICAgIChTdHJpbmcpIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICogICAgKE9iamVjdCkgYXR0cnMgLSBUaGUgYXR0cmlidXRlcyBmb3IgdGhlIHJvb3QgZWxlbWVudCBpbiBvYmplY3Qgbm90YXRpb24uXG4gKlxuICogIFJldHVybnM6XG4gKiAgICBBIG5ldyBTdHJvcGhlLkJ1aWxkZXIuXG4gKi9cblN0cm9waGUuQnVpbGRlciA9IGZ1bmN0aW9uIChuYW1lLCBhdHRycykge1xuICAgIC8vIFNldCBjb3JyZWN0IG5hbWVzcGFjZSBmb3IgamFiYmVyOmNsaWVudCBlbGVtZW50c1xuICAgIGlmIChuYW1lID09IFwicHJlc2VuY2VcIiB8fCBuYW1lID09IFwibWVzc2FnZVwiIHx8IG5hbWUgPT0gXCJpcVwiKSB7XG4gICAgICAgIGlmIChhdHRycyAmJiAhYXR0cnMueG1sbnMpIHtcbiAgICAgICAgICAgIGF0dHJzLnhtbG5zID0gU3Ryb3BoZS5OUy5DTElFTlQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWF0dHJzKSB7XG4gICAgICAgICAgICBhdHRycyA9IHt4bWxuczogU3Ryb3BoZS5OUy5DTElFTlR9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSG9sZHMgdGhlIHRyZWUgYmVpbmcgYnVpbHQuXG4gICAgdGhpcy5ub2RlVHJlZSA9IFN0cm9waGUueG1sRWxlbWVudChuYW1lLCBhdHRycyk7XG5cbiAgICAvLyBQb2ludHMgdG8gdGhlIGN1cnJlbnQgb3BlcmF0aW9uIG5vZGUuXG4gICAgdGhpcy5ub2RlID0gdGhpcy5ub2RlVHJlZTtcbn07XG5cblN0cm9waGUuQnVpbGRlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqIEZ1bmN0aW9uOiB0cmVlXG4gICAgICogIFJldHVybiB0aGUgRE9NIHRyZWUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXJyZW50IERPTSB0cmVlIGFzIGFuIGVsZW1lbnQgb2JqZWN0LiAgVGhpc1xuICAgICAqICBpcyBzdWl0YWJsZSBmb3IgcGFzc2luZyB0byBmdW5jdGlvbnMgbGlrZSBTdHJvcGhlLkNvbm5lY3Rpb24uc2VuZCgpLlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgVGhlIERPTSB0cmVlIGFzIGEgZWxlbWVudCBvYmplY3QuXG4gICAgICovXG4gICAgdHJlZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlVHJlZTtcbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiB0b1N0cmluZ1xuICAgICAqICBTZXJpYWxpemUgdGhlIERPTSB0cmVlIHRvIGEgU3RyaW5nLlxuICAgICAqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHN0cmluZyBzZXJpYWxpemF0aW9uIG9mIHRoZSBjdXJyZW50IERPTVxuICAgICAqICB0cmVlLiAgSXQgaXMgb2Z0ZW4gdXNlZCBpbnRlcm5hbGx5IHRvIHBhc3MgZGF0YSB0byBhXG4gICAgICogIFN0cm9waGUuUmVxdWVzdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBUaGUgc2VyaWFsaXplZCBET00gdHJlZSBpbiBhIFN0cmluZy5cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU3Ryb3BoZS5zZXJpYWxpemUodGhpcy5ub2RlVHJlZSk7XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogdXBcbiAgICAgKiAgTWFrZSB0aGUgY3VycmVudCBwYXJlbnQgZWxlbWVudCB0aGUgbmV3IGN1cnJlbnQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIG9mdGVuIHVzZWQgYWZ0ZXIgYygpIHRvIHRyYXZlcnNlIGJhY2sgdXAgdGhlIHRyZWUuXG4gICAgICogIEZvciBleGFtcGxlLCB0byBhZGQgdHdvIGNoaWxkcmVuIHRvIHRoZSBzYW1lIGVsZW1lbnRcbiAgICAgKiAgPiBidWlsZGVyLmMoJ2NoaWxkMScsIHt9KS51cCgpLmMoJ2NoaWxkMicsIHt9KTtcbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIFRoZSBTdG9waGUuQnVpbGRlciBvYmplY3QuXG4gICAgICovXG4gICAgdXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gdGhpcy5ub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IHJvb3RcbiAgICAgKiAgTWFrZSB0aGUgcm9vdCBlbGVtZW50IHRoZSBuZXcgY3VycmVudCBlbGVtZW50LlxuICAgICAqXG4gICAgICogIFdoZW4gYXQgYSBkZWVwbHkgbmVzdGVkIGVsZW1lbnQgaW4gdGhlIHRyZWUsIHRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWRcbiAgICAgKiAgdG8ganVtcCBiYWNrIHRvIHRoZSByb290IG9mIHRoZSB0cmVlLCBpbnN0ZWFkIG9mIGhhdmluZyB0byByZXBlYXRlZGx5XG4gICAgICogIGNhbGwgdXAoKS5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIFRoZSBTdG9waGUuQnVpbGRlciBvYmplY3QuXG4gICAgICovXG4gICAgcm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLm5vZGVUcmVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiBhdHRyc1xuICAgICAqICBBZGQgb3IgbW9kaWZ5IGF0dHJpYnV0ZXMgb2YgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqICBUaGUgYXR0cmlidXRlcyBzaG91bGQgYmUgcGFzc2VkIGluIG9iamVjdCBub3RhdGlvbi4gIFRoaXMgZnVuY3Rpb25cbiAgICAgKiAgZG9lcyBub3QgbW92ZSB0aGUgY3VycmVudCBlbGVtZW50IHBvaW50ZXIuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoT2JqZWN0KSBtb3JlYXR0cnMgLSBUaGUgYXR0cmlidXRlcyB0byBhZGQvbW9kaWZ5IGluIG9iamVjdCBub3RhdGlvbi5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIFRoZSBTdHJvcGhlLkJ1aWxkZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIGF0dHJzOiBmdW5jdGlvbiAobW9yZWF0dHJzKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gbW9yZWF0dHJzKSB7XG4gICAgICAgICAgICBpZiAobW9yZWF0dHJzLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vcmVhdHRyc1trXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShrLCBtb3JlYXR0cnNba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiBjXG4gICAgICogIEFkZCBhIGNoaWxkIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kIG1ha2UgaXQgdGhlIG5ldyBjdXJyZW50XG4gICAgICogIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBtb3ZlcyB0aGUgY3VycmVudCBlbGVtZW50IHBvaW50ZXIgdG8gdGhlIGNoaWxkLFxuICAgICAqICB1bmxlc3MgdGV4dCBpcyBwcm92aWRlZC4gIElmIHlvdSBuZWVkIHRvIGFkZCBhbm90aGVyIGNoaWxkLCBpdFxuICAgICAqICBpcyBuZWNlc3NhcnkgdG8gdXNlIHVwKCkgdG8gZ28gYmFjayB0byB0aGUgcGFyZW50IGluIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cmluZykgbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjaGlsZC5cbiAgICAgKiAgICAoT2JqZWN0KSBhdHRycyAtIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBjaGlsZCBpbiBvYmplY3Qgbm90YXRpb24uXG4gICAgICogICAgKFN0cmluZykgdGV4dCAtIFRoZSB0ZXh0IHRvIGFkZCB0byB0aGUgY2hpbGQuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBUaGUgU3Ryb3BoZS5CdWlsZGVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBjOiBmdW5jdGlvbiAobmFtZSwgYXR0cnMsIHRleHQpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gU3Ryb3BoZS54bWxFbGVtZW50KG5hbWUsIGF0dHJzLCB0ZXh0KTtcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB0ZXh0ICE9PVwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IGNub2RlXG4gICAgICogIEFkZCBhIGNoaWxkIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kIG1ha2UgaXQgdGhlIG5ldyBjdXJyZW50XG4gICAgICogIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyB0aGUgc2FtZSBhcyBjKCkgZXhjZXB0IHRoYXQgaW5zdGVhZCBvZiB1c2luZyBhXG4gICAgICogIG5hbWUgYW5kIGFuIGF0dHJpYnV0ZXMgb2JqZWN0IHRvIGNyZWF0ZSB0aGUgY2hpbGQgaXQgdXNlcyBhblxuICAgICAqICBleGlzdGluZyBET00gZWxlbWVudCBvYmplY3QuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoWE1MRWxlbWVudCkgZWxlbSAtIEEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBUaGUgU3Ryb3BoZS5CdWlsZGVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBjbm9kZTogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdmFyIGltcE5vZGU7XG4gICAgICAgIHZhciB4bWxHZW4gPSBTdHJvcGhlLnhtbEdlbmVyYXRvcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW1wTm9kZSA9ICh4bWxHZW4uaW1wb3J0Tm9kZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaW1wTm9kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdFbGVtID0gaW1wTm9kZSA/XG4gICAgICAgICAgICAgICAgICAgICAgeG1sR2VuLmltcG9ydE5vZGUoZWxlbSwgdHJ1ZSkgOlxuICAgICAgICAgICAgICAgICAgICAgIFN0cm9waGUuY29weUVsZW1lbnQoZWxlbSk7XG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChuZXdFbGVtKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbmV3RWxlbTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogdFxuICAgICAqICBBZGQgYSBjaGlsZCB0ZXh0IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiAgVGhpcyAqZG9lcyBub3QqIG1ha2UgdGhlIGNoaWxkIHRoZSBuZXcgY3VycmVudCBlbGVtZW50IHNpbmNlIHRoZXJlXG4gICAgICogIGFyZSBubyBjaGlsZHJlbiBvZiB0ZXh0IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cmluZykgdGV4dCAtIFRoZSB0ZXh0IGRhdGEgdG8gYXBwZW5kIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBUaGUgU3Ryb3BoZS5CdWlsZGVyIG9iamVjdC5cbiAgICAgKi9cbiAgICB0OiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB2YXIgY2hpbGQgPSBTdHJvcGhlLnhtbFRleHROb2RlKHRleHQpO1xuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiBoXG4gICAgICogIFJlcGxhY2UgY3VycmVudCBlbGVtZW50IGNvbnRlbnRzIHdpdGggdGhlIEhUTUwgcGFzc2VkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgKmRvZXMgbm90KiBtYWtlIHRoZSBjaGlsZCB0aGUgbmV3IGN1cnJlbnQgZWxlbWVudFxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cmluZykgaHRtbCAtIFRoZSBodG1sIHRvIGluc2VydCBhcyBjb250ZW50cyBvZiBjdXJyZW50IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBUaGUgU3Ryb3BoZS5CdWlsZGVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBoOiBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib2R5Jyk7XG5cbiAgICAgICAgLy8gZm9yY2UgdGhlIGJyb3dzZXIgdG8gdHJ5IGFuZCBmaXggYW55IGludmFsaWQgSFRNTCB0YWdzXG4gICAgICAgIGZyYWdtZW50LmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgICAgLy8gY29weSBjbGVhbmVkIGh0bWwgaW50byBhbiB4bWwgZG9tXG4gICAgICAgIHZhciB4aHRtbCA9IFN0cm9waGUuY3JlYXRlSHRtbChmcmFnbWVudCk7XG5cbiAgICAgICAgd2hpbGUoeGh0bWwuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoeGh0bWwuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuLyoqIFByaXZhdGVDbGFzczogU3Ryb3BoZS5IYW5kbGVyXG4gKiAgX1ByaXZhdGVfIGhlbHBlciBjbGFzcyBmb3IgbWFuYWdpbmcgc3RhbnphIGhhbmRsZXJzLlxuICpcbiAqICBBIFN0cm9waGUuSGFuZGxlciBlbmNhcHN1bGF0ZXMgYSB1c2VyIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlXG4gKiAgZXhlY3V0ZWQgd2hlbiBtYXRjaGluZyBzdGFuemFzIGFyZSByZWNlaXZlZCBieSB0aGUgY29ubmVjdGlvbi5cbiAqICBIYW5kbGVycyBjYW4gYmUgZWl0aGVyIG9uZS1vZmYgb3IgcGVyc2lzdGFudCBkZXBlbmRpbmcgb24gdGhlaXJcbiAqICByZXR1cm4gdmFsdWUuIFJldHVybmluZyB0cnVlIHdpbGwgY2F1c2UgYSBIYW5kbGVyIHRvIHJlbWFpbiBhY3RpdmUsIGFuZFxuICogIHJldHVybmluZyBmYWxzZSB3aWxsIHJlbW92ZSB0aGUgSGFuZGxlci5cbiAqXG4gKiAgVXNlcnMgd2lsbCBub3QgdXNlIFN0cm9waGUuSGFuZGxlciBvYmplY3RzIGRpcmVjdGx5LCBidXQgaW5zdGVhZCB0aGV5XG4gKiAgd2lsbCB1c2UgU3Ryb3BoZS5Db25uZWN0aW9uLmFkZEhhbmRsZXIoKSBhbmRcbiAqICBTdHJvcGhlLkNvbm5lY3Rpb24uZGVsZXRlSGFuZGxlcigpLlxuICovXG5cbi8qKiBQcml2YXRlQ29uc3RydWN0b3I6IFN0cm9waGUuSGFuZGxlclxuICogIENyZWF0ZSBhbmQgaW5pdGlhbGl6ZSBhIG5ldyBTdHJvcGhlLkhhbmRsZXIuXG4gKlxuICogIFBhcmFtZXRlcnM6XG4gKiAgICAoRnVuY3Rpb24pIGhhbmRsZXIgLSBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgcnVuLlxuICogICAgKFN0cmluZykgbnMgLSBUaGUgbmFtZXNwYWNlIHRvIG1hdGNoLlxuICogICAgKFN0cmluZykgbmFtZSAtIFRoZSBlbGVtZW50IG5hbWUgdG8gbWF0Y2guXG4gKiAgICAoU3RyaW5nKSB0eXBlIC0gVGhlIGVsZW1lbnQgdHlwZSB0byBtYXRjaC5cbiAqICAgIChTdHJpbmcpIGlkIC0gVGhlIGVsZW1lbnQgaWQgYXR0cmlidXRlIHRvIG1hdGNoLlxuICogICAgKFN0cmluZykgZnJvbSAtIFRoZSBlbGVtZW50IGZyb20gYXR0cmlidXRlIHRvIG1hdGNoLlxuICogICAgKE9iamVjdCkgb3B0aW9ucyAtIEhhbmRsZXIgb3B0aW9uc1xuICpcbiAqICBSZXR1cm5zOlxuICogICAgQSBuZXcgU3Ryb3BoZS5IYW5kbGVyIG9iamVjdC5cbiAqL1xuU3Ryb3BoZS5IYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIG5zLCBuYW1lLCB0eXBlLCBpZCwgZnJvbSwgb3B0aW9ucykge1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdGhpcy5ucyA9IG5zO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7J21hdGNoQmFyZUZyb21KaWQnOiBmYWxzZSwgJ2lnbm9yZU5hbWVzcGFjZUZyYWdtZW50JzogZmFsc2V9O1xuICAgIC8vIEJCQjogTWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBgbWF0Y2hCYXJlYCBvcHRpb25cbiAgICBpZiAodGhpcy5vcHRpb25zLm1hdGNoQmFyZSkge1xuICAgICAgICBTdHJvcGhlLndhcm4oJ1RoZSBcIm1hdGNoQmFyZVwiIG9wdGlvbiBpcyBkZXByZWNhdGVkLCB1c2UgXCJtYXRjaEJhcmVGcm9tSmlkXCIgaW5zdGVhZC4nKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLm1hdGNoQmFyZUZyb21KaWQgPSB0aGlzLm9wdGlvbnMubWF0Y2hCYXJlO1xuICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLm1hdGNoQmFyZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm1hdGNoQmFyZUZyb21KaWQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbSA/IFN0cm9waGUuZ2V0QmFyZUppZEZyb21KaWQoZnJvbSkgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgfVxuICAgIC8vIHdoZXRoZXIgdGhlIGhhbmRsZXIgaXMgYSB1c2VyIGhhbmRsZXIgb3IgYSBzeXN0ZW0gaGFuZGxlclxuICAgIHRoaXMudXNlciA9IHRydWU7XG59O1xuXG5TdHJvcGhlLkhhbmRsZXIucHJvdG90eXBlID0ge1xuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IGdldE5hbWVzcGFjZVxuICAgICAqICBSZXR1cm5zIHRoZSBYTUwgbmFtZXNwYWNlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LlxuICAgICAqICBJZiBgaWdub3JlTmFtZXNwYWNlRnJhZ21lbnRgIHdhcyBwYXNzZWQgaW4gZm9yIHRoaXMgaGFuZGxlciwgdGhlbiB0aGVcbiAgICAgKiAgVVJMIGZyYWdtZW50IHdpbGwgYmUgc3RyaXBwZWQuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoWE1MRWxlbWVudCkgZWxlbSAtIFRoZSBYTUwgZWxlbWVudCB3aXRoIHRoZSBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBUaGUgbmFtZXNwYWNlLCB3aXRoIG9wdGlvbmFsbHkgdGhlIGZyYWdtZW50IHN0cmlwcGVkLlxuICAgICAqL1xuICAgIGdldE5hbWVzcGFjZTogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdmFyIGVsTmFtZXNwYWNlID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiKTtcbiAgICAgICAgaWYgKGVsTmFtZXNwYWNlICYmIHRoaXMub3B0aW9ucy5pZ25vcmVOYW1lc3BhY2VGcmFnbWVudCkge1xuICAgICAgICAgICAgZWxOYW1lc3BhY2UgPSBlbE5hbWVzcGFjZS5zcGxpdCgnIycpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbE5hbWVzcGFjZTtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogbmFtZXNwYWNlTWF0Y2hcbiAgICAgKiAgVGVzdHMgaWYgYSBzdGFuemEgbWF0Y2hlcyB0aGUgbmFtZXNwYWNlIHNldCBmb3IgdGhpcyBTdHJvcGhlLkhhbmRsZXIuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoWE1MRWxlbWVudCkgZWxlbSAtIFRoZSBYTUwgZWxlbWVudCB0byB0ZXN0LlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgdHJ1ZSBpZiB0aGUgc3RhbnphIG1hdGNoZXMgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBuYW1lc3BhY2VNYXRjaDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdmFyIG5zTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLm5zKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIFN0cm9waGUuZm9yRWFjaENoaWxkKGVsZW0sIG51bGwsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuZ2V0TmFtZXNwYWNlKGVsZW0pID09PSB0aGF0Lm5zKSB7XG4gICAgICAgICAgICAgICAgICAgIG5zTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbnNNYXRjaCA9IG5zTWF0Y2ggfHwgdGhpcy5nZXROYW1lc3BhY2UoZWxlbSkgPT09IHRoaXMubnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5zTWF0Y2g7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IGlzTWF0Y2hcbiAgICAgKiAgVGVzdHMgaWYgYSBzdGFuemEgbWF0Y2hlcyB0aGUgU3Ryb3BoZS5IYW5kbGVyLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFhNTEVsZW1lbnQpIGVsZW0gLSBUaGUgWE1MIGVsZW1lbnQgdG8gdGVzdC5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIHRydWUgaWYgdGhlIHN0YW56YSBtYXRjaGVzIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNNYXRjaDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdmFyIGZyb20gPSBlbGVtLmdldEF0dHJpYnV0ZSgnZnJvbScpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1hdGNoQmFyZUZyb21KaWQpIHtcbiAgICAgICAgICAgIGZyb20gPSBTdHJvcGhlLmdldEJhcmVKaWRGcm9tSmlkKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtX3R5cGUgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG4gICAgICAgIGlmICh0aGlzLm5hbWVzcGFjZU1hdGNoKGVsZW0pICYmXG4gICAgICAgICAgICAoIXRoaXMubmFtZSB8fCBTdHJvcGhlLmlzVGFnRXF1YWwoZWxlbSwgdGhpcy5uYW1lKSkgJiZcbiAgICAgICAgICAgICghdGhpcy50eXBlIHx8IChBcnJheS5pc0FycmF5KHRoaXMudHlwZSkgPyB0aGlzLnR5cGUuaW5kZXhPZihlbGVtX3R5cGUpICE9IC0xIDogZWxlbV90eXBlID09IHRoaXMudHlwZSkpICYmXG4gICAgICAgICAgICAoIXRoaXMuaWQgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PSB0aGlzLmlkKSAmJlxuICAgICAgICAgICAgKCF0aGlzLmZyb20gfHwgZnJvbSA9PSB0aGlzLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBydW5cbiAgICAgKiAgUnVuIHRoZSBjYWxsYmFjayBvbiBhIG1hdGNoaW5nIHN0YW56YS5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChYTUxFbGVtZW50KSBlbGVtIC0gVGhlIERPTSBlbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICAgICAqICAgICAgU3Ryb3BoZS5IYW5kbGVyLlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgQSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGhhbmRsZXIgc2hvdWxkIHJlbWFpbiBhY3RpdmUuXG4gICAgICovXG4gICAgcnVuOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuaGFuZGxlcihlbGVtKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgU3Ryb3BoZS5faGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IHRvU3RyaW5nXG4gICAgICogIEdldCBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgU3Ryb3BoZS5IYW5kbGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIEEgU3RyaW5nLlxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIntIYW5kbGVyOiBcIiArIHRoaXMuaGFuZGxlciArIFwiKFwiICsgdGhpcy5uYW1lICsgXCIsXCIgK1xuICAgICAgICAgICAgdGhpcy5pZCArIFwiLFwiICsgdGhpcy5ucyArIFwiKX1cIjtcbiAgICB9XG59O1xuXG4vKiogUHJpdmF0ZUNsYXNzOiBTdHJvcGhlLlRpbWVkSGFuZGxlclxuICogIF9Qcml2YXRlXyBoZWxwZXIgY2xhc3MgZm9yIG1hbmFnaW5nIHRpbWVkIGhhbmRsZXJzLlxuICpcbiAqICBBIFN0cm9waGUuVGltZWRIYW5kbGVyIGVuY2Fwc3VsYXRlcyBhIHVzZXIgcHJvdmlkZWQgY2FsbGJhY2sgdGhhdFxuICogIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYSBjZXJ0YWluIHBlcmlvZCBvZiB0aW1lIG9yIGF0IHJlZ3VsYXJcbiAqICBpbnRlcnZhbHMuICBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFjayBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlXG4gKiAgU3Ryb3BoZS5UaW1lZEhhbmRsZXIgd2lsbCBjb250aW51ZSB0byBmaXJlLlxuICpcbiAqICBVc2VycyB3aWxsIG5vdCB1c2UgU3Ryb3BoZS5UaW1lZEhhbmRsZXIgb2JqZWN0cyBkaXJlY3RseSwgYnV0IGluc3RlYWRcbiAqICB0aGV5IHdpbGwgdXNlIFN0cm9waGUuQ29ubmVjdGlvbi5hZGRUaW1lZEhhbmRsZXIoKSBhbmRcbiAqICBTdHJvcGhlLkNvbm5lY3Rpb24uZGVsZXRlVGltZWRIYW5kbGVyKCkuXG4gKi9cblxuLyoqIFByaXZhdGVDb25zdHJ1Y3RvcjogU3Ryb3BoZS5UaW1lZEhhbmRsZXJcbiAqICBDcmVhdGUgYW5kIGluaXRpYWxpemUgYSBuZXcgU3Ryb3BoZS5UaW1lZEhhbmRsZXIgb2JqZWN0LlxuICpcbiAqICBQYXJhbWV0ZXJzOlxuICogICAgKEludGVnZXIpIHBlcmlvZCAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHRoZVxuICogICAgICBoYW5kbGVyIGlzIGNhbGxlZC5cbiAqICAgIChGdW5jdGlvbikgaGFuZGxlciAtIFRoZSBjYWxsYmFjayB0byBydW4gd2hlbiB0aGUgaGFuZGxlciBmaXJlcy4gIFRoaXNcbiAqICAgICAgZnVuY3Rpb24gc2hvdWxkIHRha2Ugbm8gYXJndW1lbnRzLlxuICpcbiAqICBSZXR1cm5zOlxuICogICAgQSBuZXcgU3Ryb3BoZS5UaW1lZEhhbmRsZXIgb2JqZWN0LlxuICovXG5TdHJvcGhlLlRpbWVkSGFuZGxlciA9IGZ1bmN0aW9uIChwZXJpb2QsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnBlcmlvZCA9IHBlcmlvZDtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHRoaXMubGFzdENhbGxlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRoaXMudXNlciA9IHRydWU7XG59O1xuXG5TdHJvcGhlLlRpbWVkSGFuZGxlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogcnVuXG4gICAgICogIFJ1biB0aGUgY2FsbGJhY2sgZm9yIHRoZSBTdHJvcGhlLlRpbWVkSGFuZGxlci5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIHRydWUgaWYgdGhlIFN0cm9waGUuVGltZWRIYW5kbGVyIHNob3VsZCBiZSBjYWxsZWQgYWdhaW4sIGFuZCBmYWxzZVxuICAgICAqICAgICAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJ1bjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxhc3RDYWxsZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcigpO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiByZXNldFxuICAgICAqICBSZXNldCB0aGUgbGFzdCBjYWxsZWQgdGltZSBmb3IgdGhlIFN0cm9waGUuVGltZWRIYW5kbGVyLlxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGFzdENhbGxlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiB0b1N0cmluZ1xuICAgICAqICBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFN0cm9waGUuVGltZWRIYW5kbGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwie1RpbWVkSGFuZGxlcjogXCIgKyB0aGlzLmhhbmRsZXIgKyBcIihcIiArIHRoaXMucGVyaW9kICtcIil9XCI7XG4gICAgfVxufTtcblxuLyoqIENsYXNzOiBTdHJvcGhlLkNvbm5lY3Rpb25cbiAqICBYTVBQIENvbm5lY3Rpb24gbWFuYWdlci5cbiAqXG4gKiAgVGhpcyBjbGFzcyBpcyB0aGUgbWFpbiBwYXJ0IG9mIFN0cm9waGUuICBJdCBtYW5hZ2VzIGEgQk9TSCBvciB3ZWJzb2NrZXRcbiAqICBjb25uZWN0aW9uIHRvIGFuIFhNUFAgc2VydmVyIGFuZCBkaXNwYXRjaGVzIGV2ZW50cyB0byB0aGUgdXNlciBjYWxsYmFja3NcbiAqICBhcyBkYXRhIGFycml2ZXMuIEl0IHN1cHBvcnRzIFNBU0wgUExBSU4sIFNBU0wgRElHRVNULU1ENSwgU0FTTCBTQ1JBTS1TSEExXG4gKiAgYW5kIGxlZ2FjeSBhdXRoZW50aWNhdGlvbi5cbiAqXG4gKiAgQWZ0ZXIgY3JlYXRpbmcgYSBTdHJvcGhlLkNvbm5lY3Rpb24gb2JqZWN0LCB0aGUgdXNlciB3aWxsIHR5cGljYWxseVxuICogIGNhbGwgY29ubmVjdCgpIHdpdGggYSB1c2VyIHN1cHBsaWVkIGNhbGxiYWNrIHRvIGhhbmRsZSBjb25uZWN0aW9uIGxldmVsXG4gKiAgZXZlbnRzIGxpa2UgYXV0aGVudGljYXRpb24gZmFpbHVyZSwgZGlzY29ubmVjdGlvbiwgb3IgY29ubmVjdGlvblxuICogIGNvbXBsZXRlLlxuICpcbiAqICBUaGUgdXNlciB3aWxsIGFsc28gaGF2ZSBzZXZlcmFsIGV2ZW50IGhhbmRsZXJzIGRlZmluZWQgYnkgdXNpbmdcbiAqICBhZGRIYW5kbGVyKCkgYW5kIGFkZFRpbWVkSGFuZGxlcigpLiAgVGhlc2Ugd2lsbCBhbGxvdyB0aGUgdXNlciBjb2RlIHRvXG4gKiAgcmVzcG9uZCB0byBpbnRlcmVzdGluZyBzdGFuemFzIG9yIGRvIHNvbWV0aGluZyBwZXJpb2RpY2FsbHkgd2l0aCB0aGVcbiAqICBjb25uZWN0aW9uLiBUaGVzZSBoYW5kbGVycyB3aWxsIGJlIGFjdGl2ZSBvbmNlIGF1dGhlbnRpY2F0aW9uIGlzXG4gKiAgZmluaXNoZWQuXG4gKlxuICogIFRvIHNlbmQgZGF0YSB0byB0aGUgY29ubmVjdGlvbiwgdXNlIHNlbmQoKS5cbiAqL1xuXG4vKiogQ29uc3RydWN0b3I6IFN0cm9waGUuQ29ubmVjdGlvblxuICogIENyZWF0ZSBhbmQgaW5pdGlhbGl6ZSBhIFN0cm9waGUuQ29ubmVjdGlvbiBvYmplY3QuXG4gKlxuICogIFRoZSB0cmFuc3BvcnQtcHJvdG9jb2wgZm9yIHRoaXMgY29ubmVjdGlvbiB3aWxsIGJlIGNob3NlbiBhdXRvbWF0aWNhbGx5XG4gKiAgYmFzZWQgb24gdGhlIGdpdmVuIHNlcnZpY2UgcGFyYW1ldGVyLiBVUkxzIHN0YXJ0aW5nIHdpdGggXCJ3czovL1wiIG9yXG4gKiAgXCJ3c3M6Ly9cIiB3aWxsIHVzZSBXZWJTb2NrZXRzLCBVUkxzIHN0YXJ0aW5nIHdpdGggXCJodHRwOi8vXCIsIFwiaHR0cHM6Ly9cIlxuICogIG9yIHdpdGhvdXQgYSBwcm90b2NvbCB3aWxsIHVzZSBCT1NILlxuICpcbiAqICBUbyBtYWtlIFN0cm9waGUgY29ubmVjdCB0byB0aGUgY3VycmVudCBob3N0IHlvdSBjYW4gbGVhdmUgb3V0IHRoZSBwcm90b2NvbFxuICogIGFuZCBob3N0IHBhcnQgYW5kIGp1c3QgcGFzcyB0aGUgcGF0aCwgZS5nLlxuICpcbiAqICA+IHZhciBjb25uID0gbmV3IFN0cm9waGUuQ29ubmVjdGlvbihcIi9odHRwLWJpbmQvXCIpO1xuICpcbiAqICBPcHRpb25zIGNvbW1vbiB0byBib3RoIFdlYnNvY2tldCBhbmQgQk9TSDpcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAgY29va2llczpcbiAqXG4gKiAgVGhlICpjb29raWVzKiBvcHRpb24gYWxsb3dzIHlvdSB0byBwYXNzIGluIGNvb2tpZXMgdG8gYmUgYWRkZWQgdG8gdGhlXG4gKiAgZG9jdW1lbnQuIFRoZXNlIGNvb2tpZXMgd2lsbCB0aGVuIGJlIGluY2x1ZGVkIGluIHRoZSBCT1NIIFhNTEh0dHBSZXF1ZXN0XG4gKiAgb3IgaW4gdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uLlxuICpcbiAqICBUaGUgcGFzc2VkIGluIHZhbHVlIG11c3QgYmUgYSBtYXAgb2YgY29va2llIG5hbWVzIGFuZCBzdHJpbmcgdmFsdWVzLlxuICpcbiAqICA+IHsgXCJteUNvb2tpZVwiOiB7XG4gKiAgPiAgICAgXCJ2YWx1ZVwiOiBcIjEyMzRcIixcbiAqICA+ICAgICBcImRvbWFpblwiOiBcIi5leGFtcGxlLm9yZ1wiLFxuICogID4gICAgIFwicGF0aFwiOiBcIi9cIixcbiAqICA+ICAgICBcImV4cGlyZXNcIjogZXhwaXJhdGlvbkRhdGVcbiAqICA+ICAgICB9XG4gKiAgPiB9XG4gKlxuICogIE5vdGUgdGhhdCBjb29raWVzIGNhbid0IGJlIHNldCBpbiB0aGlzIHdheSBmb3Igb3RoZXIgZG9tYWlucyAoaS5lLiBjcm9zcy1kb21haW4pLlxuICogIFRob3NlIGNvb2tpZXMgbmVlZCB0byBiZSBzZXQgdW5kZXIgdGhvc2UgZG9tYWlucywgZm9yIGV4YW1wbGUgdGhleSBjYW4gYmVcbiAqICBzZXQgc2VydmVyLXNpZGUgYnkgbWFraW5nIGEgWEhSIGNhbGwgdG8gdGhhdCBkb21haW4gdG8gYXNrIGl0IHRvIHNldCBhbnlcbiAqICBuZWNlc3NhcnkgY29va2llcy5cbiAqXG4gKiAgbWVjaGFuaXNtczpcbiAqXG4gKiAgVGhlICptZWNoYW5pc21zKiBvcHRpb24gYWxsb3dzIHlvdSB0byBzcGVjaWZ5IHRoZSBTQVNMIG1lY2hhbmlzbXMgdGhhdCB0aGlzXG4gKiAgaW5zdGFuY2Ugb2YgU3Ryb3BoZS5Db25uZWN0aW9uIChhbmQgdGhlcmVmb3JlIHlvdXIgWE1QUCBjbGllbnQpIHdpbGxcbiAqICBzdXBwb3J0LlxuICpcbiAqICBUaGUgdmFsdWUgbXVzdCBiZSBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggU3Ryb3BoZS5TQVNMTWVjaGFuaXNtXG4gKiAgcHJvdG90eXBlcy5cbiAqXG4gKiAgSWYgbm90aGluZyBpcyBzcGVjaWZpZWQsIHRoZW4gdGhlIGZvbGxvd2luZyBtZWNoYW5pc21zIChhbmQgdGhlaXJcbiAqICBwcmlvcml0aWVzKSBhcmUgcmVnaXN0ZXJlZDpcbiAqXG4gKiAgICAgIEVYVEVSTkFMIC0gNjBcbiAqICAgICAgT0FVVEhCRUFSRVIgLSA1MFxuICogICAgICBTQ1JBTS1TSEExIC0gNDBcbiAqICAgICAgRElHRVNULU1ENSAtIDMwXG4gKiAgICAgIFBMQUlOIC0gMjBcbiAqICAgICAgQU5PTllNT1VTIC0gMTBcbiAqXG4gKiAgV2ViU29ja2V0IG9wdGlvbnM6XG4gKiAgLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogIElmIHlvdSB3YW50IHRvIGNvbm5lY3QgdG8gdGhlIGN1cnJlbnQgaG9zdCB3aXRoIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24geW91XG4gKiAgY2FuIHRlbGwgU3Ryb3BoZSB0byB1c2UgV2ViU29ja2V0cyB0aHJvdWdoIGEgXCJwcm90b2NvbFwiIGF0dHJpYnV0ZSBpbiB0aGVcbiAqICBvcHRpb25hbCBvcHRpb25zIHBhcmFtZXRlci4gVmFsaWQgdmFsdWVzIGFyZSBcIndzXCIgZm9yIFdlYlNvY2tldCBhbmQgXCJ3c3NcIlxuICogIGZvciBTZWN1cmUgV2ViU29ja2V0LlxuICogIFNvIHRvIGNvbm5lY3QgdG8gXCJ3c3M6Ly9DVVJSRU5UX0hPU1ROQU1FL3htcHAtd2Vic29ja2V0XCIgeW91IHdvdWxkIGNhbGxcbiAqXG4gKiAgPiB2YXIgY29ubiA9IG5ldyBTdHJvcGhlLkNvbm5lY3Rpb24oXCIveG1wcC13ZWJzb2NrZXQvXCIsIHtwcm90b2NvbDogXCJ3c3NcIn0pO1xuICpcbiAqICBOb3RlIHRoYXQgcmVsYXRpdmUgVVJMcyBfTk9UXyBzdGFydGluZyB3aXRoIGEgXCIvXCIgd2lsbCBhbHNvIGluY2x1ZGUgdGhlIHBhdGhcbiAqICBvZiB0aGUgY3VycmVudCBzaXRlLlxuICpcbiAqICBBbHNvIGJlY2F1c2UgZG93bmdyYWRpbmcgc2VjdXJpdHkgaXMgbm90IHBlcm1pdHRlZCBieSBicm93c2Vycywgd2hlbiB1c2luZ1xuICogIHJlbGF0aXZlIFVSTHMgYm90aCBCT1NIIGFuZCBXZWJTb2NrZXQgY29ubmVjdGlvbnMgd2lsbCB1c2UgdGhlaXIgc2VjdXJlXG4gKiAgdmFyaWFudHMgaWYgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiB0byB0aGUgc2l0ZSBpcyBhbHNvIHNlY3VyZSAoaHR0cHMpLlxuICpcbiAqICBCT1NIIG9wdGlvbnM6XG4gKiAgLS0tLS0tLS0tLS0tLVxuICpcbiAqICBCeSBhZGRpbmcgXCJzeW5jXCIgdG8gdGhlIG9wdGlvbnMsIHlvdSBjYW4gY29udHJvbCBpZiByZXF1ZXN0cyB3aWxsXG4gKiAgYmUgbWFkZSBzeW5jaHJvbm91c2x5IG9yIG5vdC4gVGhlIGRlZmF1bHQgYmVoYXZpb3VyIGlzIGFzeW5jaHJvbm91cy5cbiAqICBJZiB5b3Ugd2FudCB0byBtYWtlIHJlcXVlc3RzIHN5bmNocm9ub3VzLCBtYWtlIFwic3luY1wiIGV2YWx1YXRlIHRvIHRydWUuXG4gKiAgPiB2YXIgY29ubiA9IG5ldyBTdHJvcGhlLkNvbm5lY3Rpb24oXCIvaHR0cC1iaW5kL1wiLCB7c3luYzogdHJ1ZX0pO1xuICpcbiAqICBZb3UgY2FuIGFsc28gdG9nZ2xlIHRoaXMgb24gYW4gYWxyZWFkeSBlc3RhYmxpc2hlZCBjb25uZWN0aW9uLlxuICogID4gY29ubi5vcHRpb25zLnN5bmMgPSB0cnVlO1xuICpcbiAqICBUaGUgKmN1c3RvbUhlYWRlcnMqIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGN1c3RvbSBIVFRQIGhlYWRlcnMgdG8gYmVcbiAqICBpbmNsdWRlZCBpbiB0aGUgWE1MSHR0cFJlcXVlc3RzIG1hZGUuXG4gKlxuICogIFRoZSAqa2VlcGFsaXZlKiBvcHRpb24gY2FuIGJlIHVzZWQgdG8gaW5zdHJ1Y3QgU3Ryb3BoZSB0byBtYWludGFpbiB0aGVcbiAqICBjdXJyZW50IEJPU0ggc2Vzc2lvbiBhY3Jvc3MgaW50ZXJydXB0aW9ucyBzdWNoIGFzIHdlYnBhZ2UgcmVsb2Fkcy5cbiAqXG4gKiAgSXQgd2lsbCBkbyB0aGlzIGJ5IGNhY2hpbmcgdGhlIHNlc3Npb25zIHRva2VucyBpbiBzZXNzaW9uU3RvcmFnZSwgYW5kIHdoZW5cbiAqICBcInJlc3RvcmVcIiBpcyBjYWxsZWQgaXQgd2lsbCBjaGVjayB3aGV0aGVyIHRoZXJlIGFyZSBjYWNoZWQgdG9rZW5zIHdpdGhcbiAqICB3aGljaCBpdCBjYW4gcmVzdW1lIGFuIGV4aXN0aW5nIHNlc3Npb24uXG4gKlxuICogIFRoZSAqd2l0aENyZWRlbnRpYWxzKiBvcHRpb24gc2hvdWxkIHJlY2VpdmUgYSBCb29sZWFuIHZhbHVlIGFuZCBpcyB1c2VkIHRvXG4gKiAgaW5kaWNhdGUgd2V0aGVyIGNvb2tpZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIGFqYXggcmVxdWVzdHMgKGJ5IGRlZmF1bHRcbiAqICB0aGV5J3JlIG5vdCkuXG4gKiAgU2V0IHRoaXMgdmFsdWUgdG8gdHJ1ZSBpZiB5b3UgYXJlIGNvbm5lY3RpbmcgdG8gYSBCT1NIIHNlcnZpY2VcbiAqICBhbmQgZm9yIHNvbWUgcmVhc29uIG5lZWQgdG8gc2VuZCBjb29raWVzIHRvIGl0LlxuICogIEluIG9yZGVyIGZvciB0aGlzIHRvIHdvcmsgY3Jvc3MtZG9tYWluLCB0aGUgc2VydmVyIG11c3QgYWxzbyBlbmFibGVcbiAqICBjcmVkZW50aWFscyBieSBzZXR0aW5nIHRoZSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFscyByZXNwb25zZSBoZWFkZXJcbiAqICB0byBcInRydWVcIi4gRm9yIG1vc3QgdXNlY2FzZXMgaG93ZXZlciB0aGlzIHNldHRpbmcgc2hvdWxkIGJlIGZhbHNlICh3aGljaFxuICogIGlzIHRoZSBkZWZhdWx0KS5cbiAqICBBZGRpdGlvbmFsbHksIHdoZW4gdXNpbmcgQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHMsIHRoZVxuICogIEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiBoZWFkZXIgY2FuJ3QgYmUgc2V0IHRvIHRoZSB3aWxkY2FyZCBcIipcIiwgYnV0XG4gKiAgaW5zdGVhZCBtdXN0IGJlIHJlc3RyaWN0ZWQgdG8gYWN0dWFsIGRvbWFpbnMuXG4gKlxuICogIFRoZSAqY29udGVudFR5cGUqIG9wdGlvbiBjYW4gYmUgc2V0IHRvIGNoYW5nZSB0aGUgZGVmYXVsdCBDb250ZW50LVR5cGVcbiAqICBvZiBcInRleHQveG1sOyBjaGFyc2V0PXV0Zi04XCIsIHdoaWNoIGNhbiBiZSB1c2VmdWwgdG8gcmVkdWNlIHRoZSBhbW91bnQgb2ZcbiAqICBDT1JTIHByZWZsaWdodCByZXF1ZXN0cyB0aGF0IGFyZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gKlxuICogIFBhcmFtZXRlcnM6XG4gKiAgICAoU3RyaW5nKSBzZXJ2aWNlIC0gVGhlIEJPU0ggb3IgV2ViU29ja2V0IHNlcnZpY2UgVVJMLlxuICogICAgKE9iamVjdCkgb3B0aW9ucyAtIEEgaGFzaCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqXG4gKiAgUmV0dXJuczpcbiAqICAgIEEgbmV3IFN0cm9waGUuQ29ubmVjdGlvbiBvYmplY3QuXG4gKi9cblN0cm9waGUuQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChzZXJ2aWNlLCBvcHRpb25zKSB7XG4gICAgLy8gVGhlIHNlcnZpY2UgVVJMXG4gICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAvLyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBwcm90byA9IHRoaXMub3B0aW9ucy5wcm90b2NvbCB8fCBcIlwiO1xuXG4gICAgLy8gU2VsZWN0IHByb3RvY2FsIGJhc2VkIG9uIHNlcnZpY2Ugb3Igb3B0aW9uc1xuICAgIGlmIChzZXJ2aWNlLmluZGV4T2YoXCJ3czpcIikgPT09IDAgfHwgc2VydmljZS5pbmRleE9mKFwid3NzOlwiKSA9PT0gMCB8fFxuICAgICAgICAgICAgcHJvdG8uaW5kZXhPZihcIndzXCIpID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Byb3RvID0gbmV3IFN0cm9waGUuV2Vic29ja2V0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb3RvID0gbmV3IFN0cm9waGUuQm9zaCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY29ubmVjdGVkIEpJRC4gKi9cbiAgICB0aGlzLmppZCA9IFwiXCI7XG4gICAgLyogdGhlIEpJRHMgZG9tYWluICovXG4gICAgdGhpcy5kb21haW4gPSBudWxsO1xuICAgIC8qIHN0cmVhbTpmZWF0dXJlcyAqL1xuICAgIHRoaXMuZmVhdHVyZXMgPSBudWxsO1xuXG4gICAgLy8gU0FTTFxuICAgIHRoaXMuX3Nhc2xfZGF0YSA9IHt9O1xuICAgIHRoaXMuZG9fc2Vzc2lvbiA9IGZhbHNlO1xuICAgIHRoaXMuZG9fYmluZCA9IGZhbHNlO1xuXG4gICAgLy8gaGFuZGxlciBsaXN0c1xuICAgIHRoaXMudGltZWRIYW5kbGVycyA9IFtdO1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICB0aGlzLnJlbW92ZVRpbWVkcyA9IFtdO1xuICAgIHRoaXMucmVtb3ZlSGFuZGxlcnMgPSBbXTtcbiAgICB0aGlzLmFkZFRpbWVkcyA9IFtdO1xuICAgIHRoaXMuYWRkSGFuZGxlcnMgPSBbXTtcbiAgICB0aGlzLnByb3RvY29sRXJyb3JIYW5kbGVycyA9IHtcbiAgICAgICAgJ0hUVFAnOiB7fSxcbiAgICAgICAgJ3dlYnNvY2tldCc6IHt9XG4gICAgfTtcblxuICAgIHRoaXMuX2lkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICB0aGlzLl9kaXNjb25uZWN0VGltZW91dCA9IG51bGw7XG5cbiAgICB0aGlzLmF1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGlzY29ubmVjdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZG9fYXV0aGVudGljYXRpb24gPSB0cnVlO1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5yZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgIHRoaXMuX3VuaXF1ZUlkID0gMDtcblxuICAgIHRoaXMuX3Nhc2xfc3VjY2Vzc19oYW5kbGVyID0gbnVsbDtcbiAgICB0aGlzLl9zYXNsX2ZhaWx1cmVfaGFuZGxlciA9IG51bGw7XG4gICAgdGhpcy5fc2FzbF9jaGFsbGVuZ2VfaGFuZGxlciA9IG51bGw7XG5cbiAgICAvLyBNYXggcmV0cmllcyBiZWZvcmUgZGlzY29ubmVjdGluZ1xuICAgIHRoaXMubWF4UmV0cmllcyA9IDU7XG5cbiAgICAvLyBDYWxsIG9uSWRsZSBjYWxsYmFjayBldmVyeSAxLzEwdGggb2YgYSBzZWNvbmRcbiAgICAvLyBYWFg6IHNldFRpbWVvdXQgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IHdpdGggZnVuY3Rpb24gZXhwcmVzc2lvbnMgKDIzOTc0YmMxKVxuICAgIHRoaXMuX2lkbGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fb25JZGxlKCk7XG4gICAgfS5iaW5kKHRoaXMpLCAxMDApO1xuXG4gICAgdXRpbHMuYWRkQ29va2llcyh0aGlzLm9wdGlvbnMuY29va2llcyk7XG4gICAgdGhpcy5yZWdpc3RlclNBU0xNZWNoYW5pc21zKHRoaXMub3B0aW9ucy5tZWNoYW5pc21zKTtcblxuICAgIC8vIGluaXRpYWxpemUgcGx1Z2luc1xuICAgIGZvciAodmFyIGsgaW4gU3Ryb3BoZS5fY29ubmVjdGlvblBsdWdpbnMpIHtcbiAgICAgICAgaWYgKFN0cm9waGUuX2Nvbm5lY3Rpb25QbHVnaW5zLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICB2YXIgcHR5cGUgPSBTdHJvcGhlLl9jb25uZWN0aW9uUGx1Z2luc1trXTtcbiAgICAgICAgICAgIC8vIGpzbGludCBjb21wbGFpbnRzIGFib3V0IHRoZSBiZWxvdyBsaW5lLCBidXQgdGhpcyBpcyBmaW5lXG4gICAgICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uICgpIHt9OyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIEYucHJvdG90eXBlID0gcHR5cGU7XG4gICAgICAgICAgICB0aGlzW2tdID0gbmV3IEYoKTtcbiAgICAgICAgICAgIHRoaXNba10uaW5pdCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblN0cm9waGUuQ29ubmVjdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgLyoqIEZ1bmN0aW9uOiByZXNldFxuICAgICAqICBSZXNldCB0aGUgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYSBjb25uZWN0aW9uIGlzIGRpc2Nvbm5lY3RlZFxuICAgICAqICBiZWZvcmUgdGhhdCBjb25uZWN0aW9uIGlzIHJldXNlZC5cbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wcm90by5fcmVzZXQoKTtcblxuICAgICAgICAvLyBTQVNMXG4gICAgICAgIHRoaXMuZG9fc2Vzc2lvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvX2JpbmQgPSBmYWxzZTtcblxuICAgICAgICAvLyBoYW5kbGVyIGxpc3RzXG4gICAgICAgIHRoaXMudGltZWRIYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMucmVtb3ZlVGltZWRzID0gW107XG4gICAgICAgIHRoaXMucmVtb3ZlSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRUaW1lZHMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRIYW5kbGVycyA9IFtdO1xuXG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICAgICAgdGhpcy5fdW5pcXVlSWQgPSAwO1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IHBhdXNlXG4gICAgICogIFBhdXNlIHRoZSByZXF1ZXN0IG1hbmFnZXIuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHByZXZlbnQgU3Ryb3BoZSBmcm9tIHNlbmRpbmcgYW55IG1vcmUgcmVxdWVzdHMgdG8gdGhlXG4gICAgICogIHNlcnZlci4gIFRoaXMgaXMgdmVyeSB1c2VmdWwgZm9yIHRlbXBvcmFyaWx5IHBhdXNpbmdcbiAgICAgKiAgQk9TSC1Db25uZWN0aW9ucyB3aGlsZSBhIGxvdCBvZiBzZW5kKCkgY2FsbHMgYXJlIGhhcHBlbmluZyBxdWlja2x5LlxuICAgICAqICBUaGlzIGNhdXNlcyBTdHJvcGhlIHRvIHNlbmQgdGhlIGRhdGEgaW4gYSBzaW5nbGUgcmVxdWVzdCwgc2F2aW5nXG4gICAgICogIG1hbnkgcmVxdWVzdCB0cmlwcy5cbiAgICAgKi9cbiAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogcmVzdW1lXG4gICAgICogIFJlc3VtZSB0aGUgcmVxdWVzdCBtYW5hZ2VyLlxuICAgICAqXG4gICAgICogIFRoaXMgcmVzdW1lcyBhZnRlciBwYXVzZSgpIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKi9cbiAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiBnZXRVbmlxdWVJZFxuICAgICAqICBHZW5lcmF0ZSBhIHVuaXF1ZSBJRCBmb3IgdXNlIGluIDxpcS8+IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogIEFsbCA8aXEvPiBzdGFuemFzIGFyZSByZXF1aXJlZCB0byBoYXZlIHVuaXF1ZSBpZCBhdHRyaWJ1dGVzLiAgVGhpc1xuICAgICAqICBmdW5jdGlvbiBtYWtlcyBjcmVhdGluZyB0aGVzZSBlYXN5LiAgRWFjaCBjb25uZWN0aW9uIGluc3RhbmNlIGhhc1xuICAgICAqICBhIGNvdW50ZXIgd2hpY2ggc3RhcnRzIGZyb20gemVybywgYW5kIHRoZSB2YWx1ZSBvZiB0aGlzIGNvdW50ZXJcbiAgICAgKiAgcGx1cyBhIGNvbG9uIGZvbGxvd2VkIGJ5IHRoZSBzdWZmaXggYmVjb21lcyB0aGUgdW5pcXVlIGlkLiBJZiBub1xuICAgICAqICBzdWZmaXggaXMgc3VwcGxpZWQsIHRoZSBjb3VudGVyIGlzIHVzZWQgYXMgdGhlIHVuaXF1ZSBpZC5cbiAgICAgKlxuICAgICAqICBTdWZmaXhlcyBhcmUgdXNlZCB0byBtYWtlIGRlYnVnZ2luZyBlYXNpZXIgd2hlbiByZWFkaW5nIHRoZSBzdHJlYW1cbiAgICAgKiAgZGF0YSwgYW5kIHRoZWlyIHVzZSBpcyByZWNvbW1lbmRlZC4gIFRoZSBjb3VudGVyIHJlc2V0cyB0byAwIGZvclxuICAgICAqICBldmVyeSBuZXcgY29ubmVjdGlvbiBmb3IgdGhlIHNhbWUgcmVhc29uLiAgRm9yIGNvbm5lY3Rpb25zIHRvIHRoZVxuICAgICAqICBzYW1lIHNlcnZlciB0aGF0IGF1dGhlbnRpY2F0ZSB0aGUgc2FtZSB3YXksIGFsbCB0aGUgaWRzIHNob3VsZCBiZVxuICAgICAqICB0aGUgc2FtZSwgd2hpY2ggbWFrZXMgaXQgZWFzeSB0byBzZWUgY2hhbmdlcy4gIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgICAqICBhdXRvbWF0ZWQgdGVzdGluZyBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cmluZykgc3VmZml4IC0gQSBvcHRpb25hbCBzdWZmaXggdG8gYXBwZW5kIHRvIHRoZSBpZC5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIEEgdW5pcXVlIHN0cmluZyB0byBiZSB1c2VkIGZvciB0aGUgaWQgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGdldFVuaXF1ZUlkOiBmdW5jdGlvbihzdWZmaXgpIHtcbiAgICAgICAgdmFyIHV1aWQgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCxcbiAgICAgICAgICAgICAgICB2ID0gYyA9PSAneCcgPyByIDogciAmIDB4MyB8IDB4ODtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2Yoc3VmZml4KSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZihzdWZmaXgpID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1dWlkICsgXCI6XCIgKyBzdWZmaXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXVpZCArIFwiXCI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiBhZGRQcm90b2NvbEVycm9ySGFuZGxlclxuICAgICAqICBSZWdpc3RlciBhIGhhbmRsZXIgZnVuY3Rpb24gZm9yIHdoZW4gYSBwcm90b2NvbCAod2Vic29ja2VyIG9yIEhUVFApXG4gICAgICogIGVycm9yIG9jY3Vycy5cbiAgICAgKlxuICAgICAqICBOT1RFOiBDdXJyZW50bHkgb25seSBIVFRQIGVycm9ycyBmb3IgQk9TSCByZXF1ZXN0cyBhcmUgaGFuZGxlZC5cbiAgICAgKiAgUGF0Y2hlcyB0aGF0IGhhbmRsZSB3ZWJzb2NrZXQgZXJyb3JzIHdvdWxkIGJlIHZlcnkgd2VsY29tZS5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJpbmcpIHByb3RvY29sIC0gJ0hUVFAnIG9yICd3ZWJzb2NrZXQnIFxuICAgICAqICAgIChJbnRlZ2VyKSBzdGF0dXNfY29kZSAtIEVycm9yIHN0YXR1cyBjb2RlIChlLmcgNTAwLCA0MDAgb3IgNDA0KVxuICAgICAqICAgIChGdW5jdGlvbikgY2FsbGJhY2sgLSBGdW5jdGlvbiB0aGF0IHdpbGwgZmlyZSBvbiBIdHRwIGVycm9yXG4gICAgICpcbiAgICAgKiAgRXhhbXBsZTpcbiAgICAgKiAgZnVuY3Rpb24gb25FcnJvcihlcnJfY29kZSl7XG4gICAgICogICAgLy9kbyBzdHVmZlxuICAgICAqICB9XG4gICAgICpcbiAgICAgKiAgdmFyIGNvbm4gPSBTdHJvcGhlLmNvbm5lY3QoJ2h0dHA6Ly9leGFtcGxlLmNvbS9odHRwLWJpbmQnKTtcbiAgICAgKiAgY29ubi5hZGRQcm90b2NvbEVycm9ySGFuZGxlcignSFRUUCcsIDUwMCwgb25FcnJvcik7XG4gICAgICogIC8vIFRyaWdnZXJzIEhUVFAgNTAwIGVycm9yIGFuZCBvbkVycm9yIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWRcbiAgICAgKiAgY29ubi5jb25uZWN0KCd1c2VyX2ppZEBpbmNvcnJlY3RfamFiYmVyX2hvc3QnLCAnc2VjcmV0Jywgb25Db25uZWN0KTtcbiAgICAgKi9cbiAgICBhZGRQcm90b2NvbEVycm9ySGFuZGxlcjogZnVuY3Rpb24ocHJvdG9jb2wsIHN0YXR1c19jb2RlLCBjYWxsYmFjayl7XG4gICAgICAgIHRoaXMucHJvdG9jb2xFcnJvckhhbmRsZXJzW3Byb3RvY29sXVtzdGF0dXNfY29kZV0gPSBjYWxsYmFjaztcbiAgICB9LFxuXG5cbiAgICAvKiogRnVuY3Rpb246IGNvbm5lY3RcbiAgICAgKiAgU3RhcnRzIHRoZSBjb25uZWN0aW9uIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiAgQXMgdGhlIGNvbm5lY3Rpb24gcHJvY2VzcyBwcm9jZWVkcywgdGhlIHVzZXIgc3VwcGxpZWQgY2FsbGJhY2sgd2lsbFxuICAgICAqICBiZSB0cmlnZ2VyZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBzdGF0dXMgdXBkYXRlcy4gIFRoZSBjYWxsYmFja1xuICAgICAqICBzaG91bGQgdGFrZSB0d28gYXJndW1lbnRzIC0gdGhlIHN0YXR1cyBjb2RlIGFuZCB0aGUgZXJyb3IgY29uZGl0aW9uLlxuICAgICAqXG4gICAgICogIFRoZSBzdGF0dXMgY29kZSB3aWxsIGJlIG9uZSBvZiB0aGUgdmFsdWVzIGluIHRoZSBTdHJvcGhlLlN0YXR1c1xuICAgICAqICBjb25zdGFudHMuICBUaGUgZXJyb3IgY29uZGl0aW9uIHdpbGwgYmUgb25lIG9mIHRoZSBjb25kaXRpb25zXG4gICAgICogIGRlZmluZWQgaW4gUkZDIDM5MjAgb3IgdGhlIGNvbmRpdGlvbiAnc3Ryb3BoZS1wYXJzZXJlcnJvcicuXG4gICAgICpcbiAgICAgKiAgVGhlIFBhcmFtZXRlcnMgX3dhaXRfLCBfaG9sZF8gYW5kIF9yb3V0ZV8gYXJlIG9wdGlvbmFsIGFuZCBvbmx5IHJlbGV2YW50XG4gICAgICogIGZvciBCT1NIIGNvbm5lY3Rpb25zLiBQbGVhc2Ugc2VlIFhFUCAxMjQgZm9yIGEgbW9yZSBkZXRhaWxlZCBleHBsYW5hdGlvblxuICAgICAqICBvZiB0aGUgb3B0aW9uYWwgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJpbmcpIGppZCAtIFRoZSB1c2VyJ3MgSklELiAgVGhpcyBtYXkgYmUgYSBiYXJlIEpJRCxcbiAgICAgKiAgICAgIG9yIGEgZnVsbCBKSUQuICBJZiBhIG5vZGUgaXMgbm90IHN1cHBsaWVkLCBTQVNMIEFOT05ZTU9VU1xuICAgICAqICAgICAgYXV0aGVudGljYXRpb24gd2lsbCBiZSBhdHRlbXB0ZWQuXG4gICAgICogICAgKFN0cmluZykgcGFzcyAtIFRoZSB1c2VyJ3MgcGFzc3dvcmQuXG4gICAgICogICAgKEZ1bmN0aW9uKSBjYWxsYmFjayAtIFRoZSBjb25uZWN0IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqICAgIChJbnRlZ2VyKSB3YWl0IC0gVGhlIG9wdGlvbmFsIEhUVFBCSU5EIHdhaXQgdmFsdWUuICBUaGlzIGlzIHRoZVxuICAgICAqICAgICAgdGltZSB0aGUgc2VydmVyIHdpbGwgd2FpdCBiZWZvcmUgcmV0dXJuaW5nIGFuIGVtcHR5IHJlc3VsdCBmb3JcbiAgICAgKiAgICAgIGEgcmVxdWVzdC4gIFRoZSBkZWZhdWx0IHNldHRpbmcgb2YgNjAgc2Vjb25kcyBpcyByZWNvbW1lbmRlZC5cbiAgICAgKiAgICAoSW50ZWdlcikgaG9sZCAtIFRoZSBvcHRpb25hbCBIVFRQQklORCBob2xkIHZhbHVlLiAgVGhpcyBpcyB0aGVcbiAgICAgKiAgICAgIG51bWJlciBvZiBjb25uZWN0aW9ucyB0aGUgc2VydmVyIHdpbGwgaG9sZCBhdCBvbmUgdGltZS4gIFRoaXNcbiAgICAgKiAgICAgIHNob3VsZCBhbG1vc3QgYWx3YXlzIGJlIHNldCB0byAxICh0aGUgZGVmYXVsdCkuXG4gICAgICogICAgKFN0cmluZykgcm91dGUgLSBUaGUgb3B0aW9uYWwgcm91dGUgdmFsdWUuXG4gICAgICogICAgKFN0cmluZykgYXV0aGNpZCAtIFRoZSBvcHRpb25hbCBhbHRlcm5hdGl2ZSBhdXRoZW50aWNhdGlvbiBpZGVudGl0eVxuICAgICAqICAgICAgKHVzZXJuYW1lKSBpZiBpbnRlbmRpbmcgdG8gaW1wZXJzb25hdGUgYW5vdGhlciB1c2VyLlxuICAgICAqICAgICAgV2hlbiB1c2luZyB0aGUgU0FTTC1FWFRFUk5BTCBhdXRoZW50aWNhdGlvbiBtZWNoYW5pc20sIGZvciBleGFtcGxlXG4gICAgICogICAgICB3aXRoIGNsaWVudCBjZXJ0aWZpY2F0ZXMsIHRoZW4gdGhlIGF1dGhjaWQgdmFsdWUgaXMgdXNlZCB0b1xuICAgICAqICAgICAgZGV0ZXJtaW5lIHdoZXRoZXIgYW4gYXV0aG9yaXphdGlvbiBKSUQgKGF1dGh6aWQpIHNob3VsZCBiZSBzZW50IHRvXG4gICAgICogICAgICB0aGUgc2VydmVyLiBUaGUgYXV0aHppZCBzaG91bGQgbm90IGJlIHNlbnQgdG8gdGhlIHNlcnZlciBpZiB0aGVcbiAgICAgKiAgICAgIGF1dGh6aWQgYW5kIGF1dGhjaWQgYXJlIHRoZSBzYW1lLiBTbyB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgc2VudFxuICAgICAqICAgICAgKGZvciBleGFtcGxlIHdoZW4gdGhlIEpJRCBpcyBhbHJlYWR5IGNvbnRhaW5lZCBpbiB0aGUgY2xpZW50XG4gICAgICogICAgICBjZXJ0aWZpY2F0ZSksIHNldCBhdXRoY2lkIHRvIHRoYXQgc2FtZSBKSUQuIFNlZSBYRVAtMTc4IGZvciBtb3JlXG4gICAgICogICAgICBkZXRhaWxzLlxuICAgICAqL1xuICAgIGNvbm5lY3Q6IGZ1bmN0aW9uIChqaWQsIHBhc3MsIGNhbGxiYWNrLCB3YWl0LCBob2xkLCByb3V0ZSwgYXV0aGNpZCkge1xuICAgICAgICB0aGlzLmppZCA9IGppZDtcbiAgICAgICAgLyoqIFZhcmlhYmxlOiBhdXRoemlkXG4gICAgICAgICAqICBBdXRob3JpemF0aW9uIGlkZW50aXR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRoemlkID0gU3Ryb3BoZS5nZXRCYXJlSmlkRnJvbUppZCh0aGlzLmppZCk7XG5cbiAgICAgICAgLyoqIFZhcmlhYmxlOiBhdXRoY2lkXG4gICAgICAgICAqICBBdXRoZW50aWNhdGlvbiBpZGVudGl0eSAoVXNlciBuYW1lKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0aGNpZCA9IGF1dGhjaWQgfHwgU3Ryb3BoZS5nZXROb2RlRnJvbUppZCh0aGlzLmppZCk7XG5cbiAgICAgICAgLyoqIFZhcmlhYmxlOiBwYXNzXG4gICAgICAgICAqICBBdXRoZW50aWNhdGlvbiBpZGVudGl0eSAoVXNlciBwYXNzd29yZCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhc3MgPSBwYXNzO1xuXG4gICAgICAgIC8qKiBWYXJpYWJsZTogc2VydnR5cGVcbiAgICAgICAgICogIERpZ2VzdCBNRDUgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VydnR5cGUgPSBcInhtcHBcIjtcblxuICAgICAgICB0aGlzLmNvbm5lY3RfY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc3RvcmVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gcGFyc2UgamlkIGZvciBkb21haW5cbiAgICAgICAgdGhpcy5kb21haW4gPSBTdHJvcGhlLmdldERvbWFpbkZyb21KaWQodGhpcy5qaWQpO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZUNvbm5lY3RTdGF0dXMoU3Ryb3BoZS5TdGF0dXMuQ09OTkVDVElORywgbnVsbCk7XG5cbiAgICAgICAgdGhpcy5fcHJvdG8uX2Nvbm5lY3Qod2FpdCwgaG9sZCwgcm91dGUpO1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IGF0dGFjaFxuICAgICAqICBBdHRhY2ggdG8gYW4gYWxyZWFkeSBjcmVhdGVkIGFuZCBhdXRoZW50aWNhdGVkIEJPU0ggc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIGFsbG93IFN0cm9waGUgdG8gYXR0YWNoIHRvIEJPU0hcbiAgICAgKiAgc2Vzc2lvbnMgd2hpY2ggaGF2ZSBiZWVuIGNyZWF0ZWQgZXh0ZXJuYWxseSwgcGVyaGFwcyBieSBhIFdlYlxuICAgICAqICBhcHBsaWNhdGlvbi4gIFRoaXMgaXMgb2Z0ZW4gdXNlZCB0byBzdXBwb3J0IGF1dG8tbG9naW4gdHlwZSBmZWF0dXJlc1xuICAgICAqICB3aXRob3V0IHB1dHRpbmcgdXNlciBjcmVkZW50aWFscyBpbnRvIHRoZSBwYWdlLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cmluZykgamlkIC0gVGhlIGZ1bGwgSklEIHRoYXQgaXMgYm91bmQgYnkgdGhlIHNlc3Npb24uXG4gICAgICogICAgKFN0cmluZykgc2lkIC0gVGhlIFNJRCBvZiB0aGUgQk9TSCBzZXNzaW9uLlxuICAgICAqICAgIChTdHJpbmcpIHJpZCAtIFRoZSBjdXJyZW50IFJJRCBvZiB0aGUgQk9TSCBzZXNzaW9uLiAgVGhpcyBSSURcbiAgICAgKiAgICAgIHdpbGwgYmUgdXNlZCBieSB0aGUgbmV4dCByZXF1ZXN0LlxuICAgICAqICAgIChGdW5jdGlvbikgY2FsbGJhY2sgVGhlIGNvbm5lY3QgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogICAgKEludGVnZXIpIHdhaXQgLSBUaGUgb3B0aW9uYWwgSFRUUEJJTkQgd2FpdCB2YWx1ZS4gIFRoaXMgaXMgdGhlXG4gICAgICogICAgICB0aW1lIHRoZSBzZXJ2ZXIgd2lsbCB3YWl0IGJlZm9yZSByZXR1cm5pbmcgYW4gZW1wdHkgcmVzdWx0IGZvclxuICAgICAqICAgICAgYSByZXF1ZXN0LiAgVGhlIGRlZmF1bHQgc2V0dGluZyBvZiA2MCBzZWNvbmRzIGlzIHJlY29tbWVuZGVkLlxuICAgICAqICAgICAgT3RoZXIgc2V0dGluZ3Mgd2lsbCByZXF1aXJlIHR3ZWFrcyB0byB0aGUgU3Ryb3BoZS5USU1FT1VUIHZhbHVlLlxuICAgICAqICAgIChJbnRlZ2VyKSBob2xkIC0gVGhlIG9wdGlvbmFsIEhUVFBCSU5EIGhvbGQgdmFsdWUuICBUaGlzIGlzIHRoZVxuICAgICAqICAgICAgbnVtYmVyIG9mIGNvbm5lY3Rpb25zIHRoZSBzZXJ2ZXIgd2lsbCBob2xkIGF0IG9uZSB0aW1lLiAgVGhpc1xuICAgICAqICAgICAgc2hvdWxkIGFsbW9zdCBhbHdheXMgYmUgc2V0IHRvIDEgKHRoZSBkZWZhdWx0KS5cbiAgICAgKiAgICAoSW50ZWdlcikgd2luZCAtIFRoZSBvcHRpb25hbCBIVFRCSU5EIHdpbmRvdyB2YWx1ZS4gIFRoaXMgaXMgdGhlXG4gICAgICogICAgICBhbGxvd2VkIHJhbmdlIG9mIHJlcXVlc3QgaWRzIHRoYXQgYXJlIHZhbGlkLiAgVGhlIGRlZmF1bHQgaXMgNS5cbiAgICAgKi9cbiAgICBhdHRhY2g6IGZ1bmN0aW9uIChqaWQsIHNpZCwgcmlkLCBjYWxsYmFjaywgd2FpdCwgaG9sZCwgd2luZCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvdG8gaW5zdGFuY2VvZiBTdHJvcGhlLkJvc2gpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvLl9hdHRhY2goamlkLCBzaWQsIHJpZCwgY2FsbGJhY2ssIHdhaXQsIGhvbGQsIHdpbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTdHJvcGhlU2Vzc2lvbkVycm9yJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhlIFwiYXR0YWNoXCIgbWV0aG9kIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBhIEJPU0ggY29ubmVjdGlvbi4nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogcmVzdG9yZVxuICAgICAqICBBdHRlbXB0IHRvIHJlc3RvcmUgYSBjYWNoZWQgQk9TSCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VmdWwgaW4gY29uanVuY3Rpb24gd2l0aCBwcm92aWRpbmcgdGhlXG4gICAgICogIFwia2VlcGFsaXZlXCI6dHJ1ZSBvcHRpb24gd2hlbiBpbnN0YW50aWF0aW5nIGEgbmV3IFN0cm9waGUuQ29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqICBXaGVuIFwia2VlcGFsaXZlXCIgaXMgc2V0IHRvIHRydWUsIFN0cm9waGUgd2lsbCBjYWNoZSB0aGUgQk9TSCB0b2tlbnNcbiAgICAgKiAgUklEIChSZXF1ZXN0IElEKSBhbmQgU0lEIChTZXNzaW9uIElEKSBhbmQgdGhlbiB3aGVuIHRoaXMgZnVuY3Rpb24gaXNcbiAgICAgKiAgY2FsbGVkLCBpdCB3aWxsIGF0dGVtcHQgdG8gcmVzdG9yZSB0aGUgc2Vzc2lvbiBmcm9tIHRob3NlIGNhY2hlZFxuICAgICAqICB0b2tlbnMuXG4gICAgICpcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBtdXN0IHRoZXJlZm9yZSBiZSBjYWxsZWQgaW5zdGVhZCBvZiBjb25uZWN0IG9yIGF0dGFjaC5cbiAgICAgKlxuICAgICAqICBGb3IgYW4gZXhhbXBsZSBvbiBob3cgdG8gdXNlIGl0LCBwbGVhc2Ugc2VlIGV4YW1wbGVzL3Jlc3RvcmUuanNcbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJpbmcpIGppZCAtIFRoZSB1c2VyJ3MgSklELiAgVGhpcyBtYXkgYmUgYSBiYXJlIEpJRCBvciBhIGZ1bGwgSklELlxuICAgICAqICAgIChGdW5jdGlvbikgY2FsbGJhY2sgLSBUaGUgY29ubmVjdCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiAgICAoSW50ZWdlcikgd2FpdCAtIFRoZSBvcHRpb25hbCBIVFRQQklORCB3YWl0IHZhbHVlLiAgVGhpcyBpcyB0aGVcbiAgICAgKiAgICAgIHRpbWUgdGhlIHNlcnZlciB3aWxsIHdhaXQgYmVmb3JlIHJldHVybmluZyBhbiBlbXB0eSByZXN1bHQgZm9yXG4gICAgICogICAgICBhIHJlcXVlc3QuICBUaGUgZGVmYXVsdCBzZXR0aW5nIG9mIDYwIHNlY29uZHMgaXMgcmVjb21tZW5kZWQuXG4gICAgICogICAgKEludGVnZXIpIGhvbGQgLSBUaGUgb3B0aW9uYWwgSFRUUEJJTkQgaG9sZCB2YWx1ZS4gIFRoaXMgaXMgdGhlXG4gICAgICogICAgICBudW1iZXIgb2YgY29ubmVjdGlvbnMgdGhlIHNlcnZlciB3aWxsIGhvbGQgYXQgb25lIHRpbWUuICBUaGlzXG4gICAgICogICAgICBzaG91bGQgYWxtb3N0IGFsd2F5cyBiZSBzZXQgdG8gMSAodGhlIGRlZmF1bHQpLlxuICAgICAqICAgIChJbnRlZ2VyKSB3aW5kIC0gVGhlIG9wdGlvbmFsIEhUVEJJTkQgd2luZG93IHZhbHVlLiAgVGhpcyBpcyB0aGVcbiAgICAgKiAgICAgIGFsbG93ZWQgcmFuZ2Ugb2YgcmVxdWVzdCBpZHMgdGhhdCBhcmUgdmFsaWQuICBUaGUgZGVmYXVsdCBpcyA1LlxuICAgICAqL1xuICAgIHJlc3RvcmU6IGZ1bmN0aW9uIChqaWQsIGNhbGxiYWNrLCB3YWl0LCBob2xkLCB3aW5kKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXNzaW9uQ2FjaGluZ1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm90by5fcmVzdG9yZShqaWQsIGNhbGxiYWNrLCB3YWl0LCBob2xkLCB3aW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU3Ryb3BoZVNlc3Npb25FcnJvcicsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBcInJlc3RvcmVcIiBtZXRob2QgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGEgQk9TSCBjb25uZWN0aW9uLidcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX3Nlc3Npb25DYWNoaW5nU3VwcG9ydGVkXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgc2Vzc2lvblN0b3JhZ2UgYW5kIEpTT04gYXJlIHN1cHBvcnRlZCBhbmQgd2hldGhlciB3ZSdyZVxuICAgICAqIHVzaW5nIEJPU0guXG4gICAgICovXG4gICAgX3Nlc3Npb25DYWNoaW5nU3VwcG9ydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm90byBpbnN0YW5jZW9mIFN0cm9waGUuQm9zaCkge1xuICAgICAgICAgICAgaWYgKCFKU09OKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnX3N0cm9waGVfJywgJ19zdHJvcGhlXycpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKCdfc3Ryb3BoZV8nKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogeG1sSW5wdXRcbiAgICAgKiAgVXNlciBvdmVycmlkZWFibGUgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBYTUwgZGF0YSBjb21pbmcgaW50byB0aGVcbiAgICAgKiAgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGUgZGVmYXVsdCBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuICBVc2VyIGNvZGUgY2FuIG92ZXJyaWRlIHRoaXMgd2l0aFxuICAgICAqICA+IFN0cm9waGUuQ29ubmVjdGlvbi54bWxJbnB1dCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICogID4gICAodXNlciBjb2RlKVxuICAgICAqICA+IH07XG4gICAgICpcbiAgICAgKiAgRHVlIHRvIGxpbWl0YXRpb25zIG9mIGN1cnJlbnQgQnJvd3NlcnMnIFhNTC1QYXJzZXJzIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nXG4gICAgICogIDxzdHJlYW0+IHRhZyBmb3IgV2ViU29ja2V0LUNvbm5vY3Rpb25zIHdpbGwgYmUgcGFzc2VkIGFzIHNlbGZjbG9zaW5nIGhlcmUuXG4gICAgICpcbiAgICAgKiAgQk9TSC1Db25uZWN0aW9ucyB3aWxsIGhhdmUgYWxsIHN0YW56YXMgd3JhcHBlZCBpbiBhIDxib2R5PiB0YWcuIFNlZVxuICAgICAqICA8U3Ryb3BoZS5Cb3NoLnN0cmlwPiBpZiB5b3Ugd2FudCB0byBzdHJpcCB0aGlzIHRhZy5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChYTUxFbGVtZW50KSBlbGVtIC0gVGhlIFhNTCBkYXRhIHJlY2VpdmVkIGJ5IHRoZSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIC8qIGpzaGludCB1bnVzZWQ6ZmFsc2UgKi9cbiAgICB4bWxJbnB1dDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgLyoganNoaW50IHVudXNlZDp0cnVlICovXG5cbiAgICAvKiogRnVuY3Rpb246IHhtbE91dHB1dFxuICAgICAqICBVc2VyIG92ZXJyaWRlYWJsZSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIFhNTCBkYXRhIHNlbnQgdG8gdGhlXG4gICAgICogIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgZnVuY3Rpb24gZG9lcyBub3RoaW5nLiAgVXNlciBjb2RlIGNhbiBvdmVycmlkZSB0aGlzIHdpdGhcbiAgICAgKiAgPiBTdHJvcGhlLkNvbm5lY3Rpb24ueG1sT3V0cHV0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgKiAgPiAgICh1c2VyIGNvZGUpXG4gICAgICogID4gfTtcbiAgICAgKlxuICAgICAqICBEdWUgdG8gbGltaXRhdGlvbnMgb2YgY3VycmVudCBCcm93c2VycycgWE1MLVBhcnNlcnMgdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmdcbiAgICAgKiAgPHN0cmVhbT4gdGFnIGZvciBXZWJTb2NrZXQtQ29ubm9jdGlvbnMgd2lsbCBiZSBwYXNzZWQgYXMgc2VsZmNsb3NpbmcgaGVyZS5cbiAgICAgKlxuICAgICAqICBCT1NILUNvbm5lY3Rpb25zIHdpbGwgaGF2ZSBhbGwgc3RhbnphcyB3cmFwcGVkIGluIGEgPGJvZHk+IHRhZy4gU2VlXG4gICAgICogIDxTdHJvcGhlLkJvc2guc3RyaXA+IGlmIHlvdSB3YW50IHRvIHN0cmlwIHRoaXMgdGFnLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFhNTEVsZW1lbnQpIGVsZW0gLSBUaGUgWE1MZGF0YSBzZW50IGJ5IHRoZSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIC8qIGpzaGludCB1bnVzZWQ6ZmFsc2UgKi9cbiAgICB4bWxPdXRwdXQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIC8qIGpzaGludCB1bnVzZWQ6dHJ1ZSAqL1xuXG4gICAgLyoqIEZ1bmN0aW9uOiByYXdJbnB1dFxuICAgICAqICBVc2VyIG92ZXJyaWRlYWJsZSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHJhdyBkYXRhIGNvbWluZyBpbnRvIHRoZVxuICAgICAqICBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIGRvZXMgbm90aGluZy4gIFVzZXIgY29kZSBjYW4gb3ZlcnJpZGUgdGhpcyB3aXRoXG4gICAgICogID4gU3Ryb3BoZS5Db25uZWN0aW9uLnJhd0lucHV0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgKiAgPiAgICh1c2VyIGNvZGUpXG4gICAgICogID4gfTtcbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJpbmcpIGRhdGEgLSBUaGUgZGF0YSByZWNlaXZlZCBieSB0aGUgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICAvKiBqc2hpbnQgdW51c2VkOmZhbHNlICovXG4gICAgcmF3SW5wdXQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIC8qIGpzaGludCB1bnVzZWQ6dHJ1ZSAqL1xuXG4gICAgLyoqIEZ1bmN0aW9uOiByYXdPdXRwdXRcbiAgICAgKiAgVXNlciBvdmVycmlkZWFibGUgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyByYXcgZGF0YSBzZW50IHRvIHRoZVxuICAgICAqICBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIGRvZXMgbm90aGluZy4gIFVzZXIgY29kZSBjYW4gb3ZlcnJpZGUgdGhpcyB3aXRoXG4gICAgICogID4gU3Ryb3BoZS5Db25uZWN0aW9uLnJhd091dHB1dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICogID4gICAodXNlciBjb2RlKVxuICAgICAqICA+IH07XG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoU3RyaW5nKSBkYXRhIC0gVGhlIGRhdGEgc2VudCBieSB0aGUgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICAvKiBqc2hpbnQgdW51c2VkOmZhbHNlICovXG4gICAgcmF3T3V0cHV0OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICAvKiBqc2hpbnQgdW51c2VkOnRydWUgKi9cblxuICAgIC8qKiBGdW5jdGlvbjogbmV4dFZhbGlkUmlkXG4gICAgICogIFVzZXIgb3ZlcnJpZGVhYmxlIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIG5ldyB2YWxpZCByaWQuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgZnVuY3Rpb24gZG9lcyBub3RoaW5nLiBVc2VyIGNvZGUgY2FuIG92ZXJyaWRlIHRoaXMgd2l0aFxuICAgICAqICA+IFN0cm9waGUuQ29ubmVjdGlvbi5uZXh0VmFsaWRSaWQgPSBmdW5jdGlvbiAocmlkKSB7XG4gICAgICogID4gICAgKHVzZXIgY29kZSlcbiAgICAgKiAgPiB9O1xuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKE51bWJlcikgcmlkIC0gVGhlIG5leHQgdmFsaWQgcmlkXG4gICAgICovXG4gICAgLyoganNoaW50IHVudXNlZDpmYWxzZSAqL1xuICAgIG5leHRWYWxpZFJpZDogZnVuY3Rpb24gKHJpZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICAvKiBqc2hpbnQgdW51c2VkOnRydWUgKi9cblxuICAgIC8qKiBGdW5jdGlvbjogc2VuZFxuICAgICAqICBTZW5kIGEgc3RhbnphLlxuICAgICAqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIHB1c2ggZGF0YSBvbnRvIHRoZSBzZW5kIHF1ZXVlIHRvXG4gICAgICogIGdvIG91dCBvdmVyIHRoZSB3aXJlLiAgV2hlbmV2ZXIgYSByZXF1ZXN0IGlzIHNlbnQgdG8gdGhlIEJPU0hcbiAgICAgKiAgc2VydmVyLCBhbGwgcGVuZGluZyBkYXRhIGlzIHNlbnQgYW5kIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFhNTEVsZW1lbnQgfFxuICAgICAqICAgICBbWE1MRWxlbWVudF0gfFxuICAgICAqICAgICBTdHJvcGhlLkJ1aWxkZXIpIGVsZW0gLSBUaGUgc3RhbnphIHRvIHNlbmQuXG4gICAgICovXG4gICAgc2VuZDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgaWYgKGVsZW0gPT09IG51bGwpIHsgcmV0dXJuIDsgfVxuICAgICAgICBpZiAodHlwZW9mKGVsZW0uc29ydCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVEYXRhKGVsZW1baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihlbGVtLnRyZWUpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlRGF0YShlbGVtLnRyZWUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZURhdGEoZWxlbSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wcm90by5fc2VuZCgpO1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IGZsdXNoXG4gICAgICogIEltbWVkaWF0ZWx5IHNlbmQgYW55IHBlbmRpbmcgb3V0Z29pbmcgZGF0YS5cbiAgICAgKlxuICAgICAqICBOb3JtYWxseSBzZW5kKCkgcXVldWVzIG91dGdvaW5nIGRhdGEgdW50aWwgdGhlIG5leHQgaWRsZSBwZXJpb2RcbiAgICAgKiAgKDEwMG1zKSwgd2hpY2ggb3B0aW1pemVzIG5ldHdvcmsgdXNlIGluIHRoZSBjb21tb24gY2FzZXMgd2hlblxuICAgICAqICBzZXZlcmFsIHNlbmQoKXMgYXJlIGNhbGxlZCBpbiBzdWNjZXNzaW9uLiBmbHVzaCgpIGNhbiBiZSB1c2VkIHRvXG4gICAgICogIGltbWVkaWF0ZWx5IHNlbmQgYWxsIHBlbmRpbmcgZGF0YS5cbiAgICAgKi9cbiAgICBmbHVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjYW5jZWwgdGhlIHBlbmRpbmcgaWRsZSBwZXJpb2QgYW5kIHJ1biB0aGUgaWRsZSBmdW5jdGlvblxuICAgICAgICAvLyBpbW1lZGlhdGVseVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faWRsZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLl9vbklkbGUoKTtcbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiBzZW5kSVFcbiAgICAgKiAgSGVscGVyIGZ1bmN0aW9uIHRvIHNlbmQgSVEgc3Rhbnphcy5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChYTUxFbGVtZW50KSBlbGVtIC0gVGhlIHN0YW56YSB0byBzZW5kLlxuICAgICAqICAgIChGdW5jdGlvbikgY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0LlxuICAgICAqICAgIChGdW5jdGlvbikgZXJyYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgYSBmYWlsZWQgb3IgdGltZWRcbiAgICAgKiAgICAgIG91dCByZXF1ZXN0LiAgT24gdGltZW91dCwgdGhlIHN0YW56YSB3aWxsIGJlIG51bGwuXG4gICAgICogICAgKEludGVnZXIpIHRpbWVvdXQgLSBUaGUgdGltZSBzcGVjaWZpZWQgaW4gbWlsbGlzZWNvbmRzIGZvciBhXG4gICAgICogICAgICB0aW1lb3V0IHRvIG9jY3VyLlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgVGhlIGlkIHVzZWQgdG8gc2VuZCB0aGUgSVEuXG4gICAgKi9cbiAgICBzZW5kSVE6IGZ1bmN0aW9uKGVsZW0sIGNhbGxiYWNrLCBlcnJiYWNrLCB0aW1lb3V0KSB7XG4gICAgICAgIHZhciB0aW1lb3V0SGFuZGxlciA9IG51bGw7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICBpZiAodHlwZW9mKGVsZW0udHJlZSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW0udHJlZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZCA9IGVsZW0uZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICBpZiAoIWlkKSB7IC8vIGluamVjdCBpZCBpZiBub3QgZm91bmRcbiAgICAgICAgICAgIGlkID0gdGhpcy5nZXRVbmlxdWVJZChcInNlbmRJUVwiKTtcbiAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmFkZEhhbmRsZXIoZnVuY3Rpb24gKHN0YW56YSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRpbWVvdXQgaGFuZGxlciBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgICAgIGlmICh0aW1lb3V0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRoYXQuZGVsZXRlVGltZWRIYW5kbGVyKHRpbWVvdXRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpcXR5cGUgPSBzdGFuemEuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICBpZiAoaXF0eXBlID09ICdyZXN1bHQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHN0YW56YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpcXR5cGUgPT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIGlmIChlcnJiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycmJhY2soc3RhbnphKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJvcGhlRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJHb3QgYmFkIElRIHR5cGUgb2YgXCIgKyBpcXR5cGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBudWxsLCAnaXEnLCBbJ2Vycm9yJywgJ3Jlc3VsdCddLCBpZCk7XG5cbiAgICAgICAgLy8gaWYgdGltZW91dCBzcGVjaWZpZWQsIHNldCB1cCBhIHRpbWVvdXQgaGFuZGxlci5cbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRpbWVvdXRIYW5kbGVyID0gdGhpcy5hZGRUaW1lZEhhbmRsZXIodGltZW91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGdldCByaWQgb2Ygbm9ybWFsIGhhbmRsZXJcbiAgICAgICAgICAgICAgICB0aGF0LmRlbGV0ZUhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCBlcnJiYWNrIG9uIHRpbWVvdXQgd2l0aCBudWxsIHN0YW56YVxuICAgICAgICAgICAgICAgIGlmIChlcnJiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycmJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZChlbGVtKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfcXVldWVEYXRhXG4gICAgICogIFF1ZXVlIG91dGdvaW5nIGRhdGEgZm9yIGxhdGVyIHNlbmRpbmcuICBBbHNvIGVuc3VyZXMgdGhhdCB0aGUgZGF0YVxuICAgICAqICBpcyBhIERPTUVsZW1lbnQuXG4gICAgICovXG4gICAgX3F1ZXVlRGF0YTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHxcbiAgICAgICAgICAgICFlbGVtZW50LnRhZ05hbWUgfHxcbiAgICAgICAgICAgICFlbGVtZW50LmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlN0cm9waGVFcnJvclwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ2Fubm90IHF1ZXVlIG5vbi1ET01FbGVtZW50LlwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGEucHVzaChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX3NlbmRSZXN0YXJ0XG4gICAgICogIFNlbmQgYW4geG1wcDpyZXN0YXJ0IHN0YW56YS5cbiAgICAgKi9cbiAgICBfc2VuZFJlc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKFwicmVzdGFydFwiKTtcbiAgICAgICAgdGhpcy5fcHJvdG8uX3NlbmRSZXN0YXJ0KCk7XG4gICAgICAgIC8vIFhYWDogc2V0VGltZW91dCBzaG91bGQgYmUgY2FsbGVkIG9ubHkgd2l0aCBmdW5jdGlvbiBleHByZXNzaW9ucyAoMjM5NzRiYzEpXG4gICAgICAgIHRoaXMuX2lkbGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX29uSWRsZSgpO1xuICAgICAgICB9LmJpbmQodGhpcyksIDEwMCk7XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogYWRkVGltZWRIYW5kbGVyXG4gICAgICogIEFkZCBhIHRpbWVkIGhhbmRsZXIgdG8gdGhlIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBhZGRzIGEgdGltZWQgaGFuZGxlci4gIFRoZSBwcm92aWRlZCBoYW5kbGVyIHdpbGxcbiAgICAgKiAgYmUgY2FsbGVkIGV2ZXJ5IHBlcmlvZCBtaWxsaXNlY29uZHMgdW50aWwgaXQgcmV0dXJucyBmYWxzZSxcbiAgICAgKiAgdGhlIGNvbm5lY3Rpb24gaXMgdGVybWluYXRlZCwgb3IgdGhlIGhhbmRsZXIgaXMgcmVtb3ZlZC4gIEhhbmRsZXJzXG4gICAgICogIHRoYXQgd2lzaCB0byBjb250aW51ZSBiZWluZyBpbnZva2VkIHNob3VsZCByZXR1cm4gdHJ1ZS5cbiAgICAgKlxuICAgICAqICBCZWNhdXNlIG9mIG1ldGhvZCBiaW5kaW5nIGl0IGlzIG5lY2Vzc2FyeSB0byBzYXZlIHRoZSByZXN1bHQgb2ZcbiAgICAgKiAgdGhpcyBmdW5jdGlvbiBpZiB5b3Ugd2lzaCB0byByZW1vdmUgYSBoYW5kbGVyIHdpdGhcbiAgICAgKiAgZGVsZXRlVGltZWRIYW5kbGVyKCkuXG4gICAgICpcbiAgICAgKiAgTm90ZSB0aGF0IHVzZXIgaGFuZGxlcnMgYXJlIG5vdCBhY3RpdmUgdW50aWwgYXV0aGVudGljYXRpb24gaXNcbiAgICAgKiAgc3VjY2Vzc2Z1bC5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChJbnRlZ2VyKSBwZXJpb2QgLSBUaGUgcGVyaW9kIG9mIHRoZSBoYW5kbGVyLlxuICAgICAqICAgIChGdW5jdGlvbikgaGFuZGxlciAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBoYW5kbGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIGl0LlxuICAgICAqL1xuICAgIGFkZFRpbWVkSGFuZGxlcjogZnVuY3Rpb24gKHBlcmlvZCwgaGFuZGxlcikge1xuICAgICAgICB2YXIgdGhhbmQgPSBuZXcgU3Ryb3BoZS5UaW1lZEhhbmRsZXIocGVyaW9kLCBoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5hZGRUaW1lZHMucHVzaCh0aGFuZCk7XG4gICAgICAgIHJldHVybiB0aGFuZDtcbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiBkZWxldGVUaW1lZEhhbmRsZXJcbiAgICAgKiAgRGVsZXRlIGEgdGltZWQgaGFuZGxlciBmb3IgYSBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gcmVtb3ZlcyBhIHRpbWVkIGhhbmRsZXIgZnJvbSB0aGUgY29ubmVjdGlvbi4gIFRoZVxuICAgICAqICBoYW5kUmVmIHBhcmFtZXRlciBpcyAqbm90KiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGFkZFRpbWVkSGFuZGxlcigpLFxuICAgICAqICBidXQgaXMgdGhlIHJlZmVyZW5jZSByZXR1cm5lZCBmcm9tIGFkZFRpbWVkSGFuZGxlcigpLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cm9waGUuVGltZWRIYW5kbGVyKSBoYW5kUmVmIC0gVGhlIGhhbmRsZXIgcmVmZXJlbmNlLlxuICAgICAqL1xuICAgIGRlbGV0ZVRpbWVkSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRSZWYpIHtcbiAgICAgICAgLy8gdGhpcyBtdXN0IGJlIGRvbmUgaW4gdGhlIElkbGUgbG9vcCBzbyB0aGF0IHdlIGRvbid0IGNoYW5nZVxuICAgICAgICAvLyB0aGUgaGFuZGxlcnMgZHVyaW5nIGl0ZXJhdGlvblxuICAgICAgICB0aGlzLnJlbW92ZVRpbWVkcy5wdXNoKGhhbmRSZWYpO1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IGFkZEhhbmRsZXJcbiAgICAgKiAgQWRkIGEgc3RhbnphIGhhbmRsZXIgZm9yIHRoZSBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gYWRkcyBhIHN0YW56YSBoYW5kbGVyIHRvIHRoZSBjb25uZWN0aW9uLiAgVGhlXG4gICAgICogIGhhbmRsZXIgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgZm9yIGFueSBzdGFuemEgdGhhdCBtYXRjaGVzXG4gICAgICogIHRoZSBwYXJhbWV0ZXJzLiAgTm90ZSB0aGF0IGlmIG11bHRpcGxlIHBhcmFtZXRlcnMgYXJlIHN1cHBsaWVkLFxuICAgICAqICB0aGV5IG11c3QgYWxsIG1hdGNoIGZvciB0aGUgaGFuZGxlciB0byBiZSBpbnZva2VkLlxuICAgICAqXG4gICAgICogIFRoZSBoYW5kbGVyIHdpbGwgcmVjZWl2ZSB0aGUgc3RhbnphIHRoYXQgdHJpZ2dlcmVkIGl0IGFzIGl0cyBhcmd1bWVudC5cbiAgICAgKiAgKlRoZSBoYW5kbGVyIHNob3VsZCByZXR1cm4gdHJ1ZSBpZiBpdCBpcyB0byBiZSBpbnZva2VkIGFnYWluO1xuICAgICAqICByZXR1cm5pbmcgZmFsc2Ugd2lsbCByZW1vdmUgdGhlIGhhbmRsZXIgYWZ0ZXIgaXQgcmV0dXJucy4qXG4gICAgICpcbiAgICAgKiAgQXMgYSBjb252ZW5pZW5jZSwgdGhlIG5zIHBhcmFtZXRlcnMgYXBwbGllcyB0byB0aGUgdG9wIGxldmVsIGVsZW1lbnRcbiAgICAgKiAgYW5kIGFsc28gYW55IG9mIGl0cyBpbW1lZGlhdGUgY2hpbGRyZW4uICBUaGlzIGlzIHByaW1hcmlseSB0byBtYWtlXG4gICAgICogIG1hdGNoaW5nIC9pcS9xdWVyeSBlbGVtZW50cyBlYXN5LlxuICAgICAqXG4gICAgICogIE9wdGlvbnNcbiAgICAgKiAgfn5+fn5+flxuICAgICAqICBXaXRoIHRoZSBvcHRpb25zIGFyZ3VtZW50LCB5b3UgY2FuIHNwZWNpZnkgYm9vbGVhbiBmbGFncyB0aGF0IGFmZmVjdCBob3dcbiAgICAgKiAgbWF0Y2hlcyBhcmUgYmVpbmcgZG9uZS5cbiAgICAgKlxuICAgICAqICBDdXJyZW50bHkgdHdvIGZsYWdzIGV4aXN0OlxuICAgICAqXG4gICAgICogIC0gbWF0Y2hCYXJlRnJvbUppZDpcbiAgICAgKiAgICAgIFdoZW4gc2V0IHRvIHRydWUsIHRoZSBmcm9tIHBhcmFtZXRlciBhbmQgdGhlXG4gICAgICogICAgICBmcm9tIGF0dHJpYnV0ZSBvbiB0aGUgc3RhbnphIHdpbGwgYmUgbWF0Y2hlZCBhcyBiYXJlIEpJRHMgaW5zdGVhZFxuICAgICAqICAgICAgb2YgZnVsbCBKSURzLiBUbyB1c2UgdGhpcywgcGFzcyB7bWF0Y2hCYXJlRnJvbUppZDogdHJ1ZX0gYXMgdGhlXG4gICAgICogICAgICB2YWx1ZSBvZiBvcHRpb25zLiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgbWF0Y2hCYXJlRnJvbUppZCBpcyBmYWxzZS5cbiAgICAgKlxuICAgICAqICAtIGlnbm9yZU5hbWVzcGFjZUZyYWdtZW50OlxuICAgICAqICAgICAgV2hlbiBzZXQgdG8gdHJ1ZSwgYSBmcmFnbWVudCBzcGVjaWZpZWQgb24gdGhlIHN0YW56YSdzIG5hbWVzcGFjZVxuICAgICAqICAgICAgVVJMIHdpbGwgYmUgaWdub3JlZCB3aGVuIGl0J3MgbWF0Y2hlZCB3aXRoIHRoZSBvbmUgY29uZmlndXJlZCBmb3JcbiAgICAgKiAgICAgIHRoZSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogICAgICBUaGlzIG1lYW5zIHRoYXQgaWYgeW91IHJlZ2lzdGVyIGxpa2UgdGhpczpcbiAgICAgKiAgICAgID4gICBjb25uZWN0aW9uLmFkZEhhbmRsZXIoXG4gICAgICogICAgICA+ICAgICAgIGhhbmRsZXIsXG4gICAgICogICAgICA+ICAgICAgICdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWMnLFxuICAgICAqICAgICAgPiAgICAgICBudWxsLCBudWxsLCBudWxsLCBudWxsLFxuICAgICAqICAgICAgPiAgICAgICB7J2lnbm9yZU5hbWVzcGFjZUZyYWdtZW50JzogdHJ1ZX1cbiAgICAgKiAgICAgID4gICApO1xuICAgICAqXG4gICAgICogICAgICBUaGVuIGEgc3RhbnphIHdpdGggWE1MIG5hbWVzcGFjZSBvZlxuICAgICAqICAgICAgJ2h0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL211YyN1c2VyJyB3aWxsIGFsc28gYmUgbWF0Y2hlZC4gSWZcbiAgICAgKiAgICAgICdpZ25vcmVOYW1lc3BhY2VGcmFnbWVudCcgaXMgZmFsc2UsIHRoZW4gb25seSBzdGFuemFzIHdpdGhcbiAgICAgKiAgICAgICdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWMnIHdpbGwgYmUgbWF0Y2hlZC5cbiAgICAgKlxuICAgICAqICBEZWxldGluZyB0aGUgaGFuZGxlclxuICAgICAqICB+fn5+fn5+fn5+fn5+fn5+fn5+flxuICAgICAqICBUaGUgcmV0dXJuIHZhbHVlIHNob3VsZCBiZSBzYXZlZCBpZiB5b3Ugd2lzaCB0byByZW1vdmUgdGhlIGhhbmRsZXJcbiAgICAgKiAgd2l0aCBkZWxldGVIYW5kbGVyKCkuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoRnVuY3Rpb24pIGhhbmRsZXIgLSBUaGUgdXNlciBjYWxsYmFjay5cbiAgICAgKiAgICAoU3RyaW5nKSBucyAtIFRoZSBuYW1lc3BhY2UgdG8gbWF0Y2guXG4gICAgICogICAgKFN0cmluZykgbmFtZSAtIFRoZSBzdGFuemEgbmFtZSB0byBtYXRjaC5cbiAgICAgKiAgICAoU3RyaW5nfEFycmF5KSB0eXBlIC0gVGhlIHN0YW56YSB0eXBlIChvciB0eXBlcyBpZiBhbiBhcnJheSkgdG8gbWF0Y2guXG4gICAgICogICAgKFN0cmluZykgaWQgLSBUaGUgc3RhbnphIGlkIGF0dHJpYnV0ZSB0byBtYXRjaC5cbiAgICAgKiAgICAoU3RyaW5nKSBmcm9tIC0gVGhlIHN0YW56YSBmcm9tIGF0dHJpYnV0ZSB0byBtYXRjaC5cbiAgICAgKiAgICAoU3RyaW5nKSBvcHRpb25zIC0gVGhlIGhhbmRsZXIgb3B0aW9uc1xuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgQSByZWZlcmVuY2UgdG8gdGhlIGhhbmRsZXIgdGhhdCBjYW4gYmUgdXNlZCB0byByZW1vdmUgaXQuXG4gICAgICovXG4gICAgYWRkSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIsIG5zLCBuYW1lLCB0eXBlLCBpZCwgZnJvbSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaGFuZCA9IG5ldyBTdHJvcGhlLkhhbmRsZXIoaGFuZGxlciwgbnMsIG5hbWUsIHR5cGUsIGlkLCBmcm9tLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5hZGRIYW5kbGVycy5wdXNoKGhhbmQpO1xuICAgICAgICByZXR1cm4gaGFuZDtcbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiBkZWxldGVIYW5kbGVyXG4gICAgICogIERlbGV0ZSBhIHN0YW56YSBoYW5kbGVyIGZvciBhIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiByZW1vdmVzIGEgc3RhbnphIGhhbmRsZXIgZnJvbSB0aGUgY29ubmVjdGlvbi4gIFRoZVxuICAgICAqICBoYW5kUmVmIHBhcmFtZXRlciBpcyAqbm90KiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGFkZEhhbmRsZXIoKSxcbiAgICAgKiAgYnV0IGlzIHRoZSByZWZlcmVuY2UgcmV0dXJuZWQgZnJvbSBhZGRIYW5kbGVyKCkuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoU3Ryb3BoZS5IYW5kbGVyKSBoYW5kUmVmIC0gVGhlIGhhbmRsZXIgcmVmZXJlbmNlLlxuICAgICAqL1xuICAgIGRlbGV0ZUhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kUmVmKSB7XG4gICAgICAgIC8vIHRoaXMgbXVzdCBiZSBkb25lIGluIHRoZSBJZGxlIGxvb3Agc28gdGhhdCB3ZSBkb24ndCBjaGFuZ2VcbiAgICAgICAgLy8gdGhlIGhhbmRsZXJzIGR1cmluZyBpdGVyYXRpb25cbiAgICAgICAgdGhpcy5yZW1vdmVIYW5kbGVycy5wdXNoKGhhbmRSZWYpO1xuICAgICAgICAvLyBJZiBhIGhhbmRsZXIgaXMgYmVpbmcgZGVsZXRlZCB3aGlsZSBpdCBpcyBiZWluZyBhZGRlZCxcbiAgICAgICAgLy8gcHJldmVudCBpdCBmcm9tIGdldHRpbmcgYWRkZWRcbiAgICAgICAgdmFyIGkgPSB0aGlzLmFkZEhhbmRsZXJzLmluZGV4T2YoaGFuZFJlZik7XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSGFuZGxlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogcmVnaXN0ZXJTQVNMTWVjaGFuaXNtc1xuICAgICAqXG4gICAgICogUmVnaXN0ZXIgdGhlIFNBU0wgbWVjaGFuaXNtcyB3aGljaCB3aWxsIGJlIHN1cHBvcnRlZCBieSB0aGlzIGluc3RhbmNlIG9mXG4gICAgICogU3Ryb3BoZS5Db25uZWN0aW9uIChpLmUuIHdoaWNoIHRoaXMgWE1QUCBjbGllbnQgd2lsbCBzdXBwb3J0KS5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChBcnJheSkgbWVjaGFuaXNtcyAtIEFycmF5IG9mIG9iamVjdHMgd2l0aCBTdHJvcGhlLlNBU0xNZWNoYW5pc20gcHJvdG90eXBlc1xuICAgICAqXG4gICAgICovXG4gICAgcmVnaXN0ZXJTQVNMTWVjaGFuaXNtczogZnVuY3Rpb24gKG1lY2hhbmlzbXMpIHtcbiAgICAgICAgdGhpcy5tZWNoYW5pc21zID0ge307XG4gICAgICAgIG1lY2hhbmlzbXMgPSBtZWNoYW5pc21zIHx8IFtcbiAgICAgICAgICAgIFN0cm9waGUuU0FTTEFub255bW91cyxcbiAgICAgICAgICAgIFN0cm9waGUuU0FTTEV4dGVybmFsLFxuICAgICAgICAgICAgU3Ryb3BoZS5TQVNMTUQ1LFxuICAgICAgICAgICAgU3Ryb3BoZS5TQVNMT0F1dGhCZWFyZXIsXG4gICAgICAgICAgICBTdHJvcGhlLlNBU0xQbGFpbixcbiAgICAgICAgICAgIFN0cm9waGUuU0FTTFNIQTFcbiAgICAgICAgXTtcbiAgICAgICAgbWVjaGFuaXNtcy5mb3JFYWNoKHRoaXMucmVnaXN0ZXJTQVNMTWVjaGFuaXNtLmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IHJlZ2lzdGVyU0FTTE1lY2hhbmlzbVxuICAgICAqXG4gICAgICogUmVnaXN0ZXIgYSBzaW5nbGUgU0FTTCBtZWNoYW5pc20sIHRvIGJlIHN1cHBvcnRlZCBieSB0aGlzIGNsaWVudC5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChPYmplY3QpIG1lY2hhbmlzbSAtIE9iamVjdCB3aXRoIGEgU3Ryb3BoZS5TQVNMTWVjaGFuaXNtIHByb3RvdHlwZVxuICAgICAqXG4gICAgICovXG4gICAgcmVnaXN0ZXJTQVNMTWVjaGFuaXNtOiBmdW5jdGlvbiAobWVjaGFuaXNtKSB7XG4gICAgICAgIHRoaXMubWVjaGFuaXNtc1ttZWNoYW5pc20ucHJvdG90eXBlLm5hbWVdID0gbWVjaGFuaXNtO1xuICAgIH0sXG5cbiAgICAvKiogRnVuY3Rpb246IGRpc2Nvbm5lY3RcbiAgICAgKiAgU3RhcnQgdGhlIGdyYWNlZnVsIGRpc2Nvbm5lY3Rpb24gcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIHN0YXJ0cyB0aGUgZGlzY29ubmVjdGlvbiBwcm9jZXNzLiAgVGhpcyBwcm9jZXNzIHN0YXJ0c1xuICAgICAqICBieSBzZW5kaW5nIHVuYXZhaWxhYmxlIHByZXNlbmNlIGFuZCBzZW5kaW5nIEJPU0ggYm9keSBvZiB0eXBlXG4gICAgICogIHRlcm1pbmF0ZS4gIEEgdGltZW91dCBoYW5kbGVyIG1ha2VzIHN1cmUgdGhhdCBkaXNjb25uZWN0aW9uIGhhcHBlbnNcbiAgICAgKiAgZXZlbiBpZiB0aGUgQk9TSCBzZXJ2ZXIgZG9lcyBub3QgcmVzcG9uZC5cbiAgICAgKiAgSWYgdGhlIENvbm5lY3Rpb24gb2JqZWN0IGlzbid0IGNvbm5lY3RlZCwgYXQgbGVhc3QgdHJpZXMgdG8gYWJvcnQgYWxsIHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgKiAgc28gdGhlIGNvbm5lY3Rpb24gb2JqZWN0IHdvbid0IGdlbmVyYXRlIHN1Y2Nlc3NmdWwgcmVxdWVzdHMgKHdoaWNoIHdlcmUgYWxyZWFkeSBvcGVuZWQpLlxuICAgICAqXG4gICAgICogIFRoZSB1c2VyIHN1cHBsaWVkIGNvbm5lY3Rpb24gY2FsbGJhY2sgd2lsbCBiZSBub3RpZmllZCBvZiB0aGVcbiAgICAgKiAgcHJvZ3Jlc3MgYXMgdGhpcyBwcm9jZXNzIGhhcHBlbnMuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoU3RyaW5nKSByZWFzb24gLSBUaGUgcmVhc29uIHRoZSBkaXNjb25uZWN0IGlzIG9jY3VyaW5nLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlQ29ubmVjdFN0YXR1cyhTdHJvcGhlLlN0YXR1cy5ESVNDT05ORUNUSU5HLCByZWFzb24pO1xuXG4gICAgICAgIFN0cm9waGUuaW5mbyhcIkRpc2Nvbm5lY3Qgd2FzIGNhbGxlZCBiZWNhdXNlOiBcIiArIHJlYXNvbik7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdmFyIHByZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRoZW50aWNhdGVkKSB7XG4gICAgICAgICAgICAgICAgcHJlcyA9ICRwcmVzKHtcbiAgICAgICAgICAgICAgICAgICAgeG1sbnM6IFN0cm9waGUuTlMuQ0xJRU5ULFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndW5hdmFpbGFibGUnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXR1cCB0aW1lb3V0IGhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RUaW1lb3V0ID0gdGhpcy5fYWRkU3lzVGltZWRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIDMwMDAsIHRoaXMuX29uRGlzY29ubmVjdFRpbWVvdXQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLl9wcm90by5fZGlzY29ubmVjdChwcmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFN0cm9waGUuaW5mbyhcIkRpc2Nvbm5lY3Qgd2FzIGNhbGxlZCBiZWZvcmUgU3Ryb3BoZSBjb25uZWN0ZWQgdG8gdGhlIHNlcnZlclwiKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvLl9hYm9ydEFsbFJlcXVlc3RzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2NoYW5nZUNvbm5lY3RTdGF0dXNcbiAgICAgKiAgX1ByaXZhdGVfIGhlbHBlciBmdW5jdGlvbiB0aGF0IG1ha2VzIHN1cmUgcGx1Z2lucyBhbmQgdGhlIHVzZXInc1xuICAgICAqICBjYWxsYmFjayBhcmUgbm90aWZpZWQgb2YgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChJbnRlZ2VyKSBzdGF0dXMgLSB0aGUgbmV3IGNvbm5lY3Rpb24gc3RhdHVzLCBvbmUgb2YgdGhlIHZhbHVlc1xuICAgICAqICAgICAgaW4gU3Ryb3BoZS5TdGF0dXNcbiAgICAgKiAgICAoU3RyaW5nKSBjb25kaXRpb24gLSB0aGUgZXJyb3IgY29uZGl0aW9uIG9yIG51bGxcbiAgICAgKi9cbiAgICBfY2hhbmdlQ29ubmVjdFN0YXR1czogZnVuY3Rpb24gKHN0YXR1cywgY29uZGl0aW9uKSB7XG4gICAgICAgIC8vIG5vdGlmeSBhbGwgcGx1Z2lucyBsaXN0ZW5pbmcgZm9yIHN0YXR1cyBjaGFuZ2VzXG4gICAgICAgIGZvciAodmFyIGsgaW4gU3Ryb3BoZS5fY29ubmVjdGlvblBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmIChTdHJvcGhlLl9jb25uZWN0aW9uUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIHZhciBwbHVnaW4gPSB0aGlzW2tdO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3RhdHVzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLnN0YXR1c0NoYW5nZWQoc3RhdHVzLCBjb25kaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0cm9waGUuZXJyb3IoXCJcIiArIGsgKyBcIiBwbHVnaW4gY2F1c2VkIGFuIGV4Y2VwdGlvbiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2hhbmdpbmcgc3RhdHVzOiBcIiArIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3RpZnkgdGhlIHVzZXIncyBjYWxsYmFja1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0X2NhbGxiYWNrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdF9jYWxsYmFjayhzdGF0dXMsIGNvbmRpdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgU3Ryb3BoZS5faGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgU3Ryb3BoZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJVc2VyIGNvbm5lY3Rpb24gY2FsbGJhY2sgY2F1c2VkIGFuIFwiK1wiZXhjZXB0aW9uOiBcIitlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfZG9EaXNjb25uZWN0XG4gICAgICogIF9Qcml2YXRlXyBmdW5jdGlvbiB0byBkaXNjb25uZWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdGhlIGxhc3QgcGllY2Ugb2YgdGhlIGRpc2Nvbm5lY3Rpb24gbG9naWMuICBUaGlzIHJlc2V0cyB0aGVcbiAgICAgKiAgY29ubmVjdGlvbiBhbmQgYWxlcnRzIHRoZSB1c2VyJ3MgY29ubmVjdGlvbiBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBfZG9EaXNjb25uZWN0OiBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5faWRsZVRpbWVvdXQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2lkbGVUaW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbmNlbCBEaXNjb25uZWN0IFRpbWVvdXRcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2Nvbm5lY3RUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVRpbWVkSGFuZGxlcih0aGlzLl9kaXNjb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl9kaXNjb25uZWN0VGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBTdHJvcGhlLmluZm8oXCJfZG9EaXNjb25uZWN0IHdhcyBjYWxsZWRcIik7XG4gICAgICAgIHRoaXMuX3Byb3RvLl9kb0Rpc2Nvbm5lY3QoKTtcblxuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVzdG9yZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBkZWxldGUgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLnRpbWVkSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5yZW1vdmVUaW1lZHMgPSBbXTtcbiAgICAgICAgdGhpcy5yZW1vdmVIYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmFkZFRpbWVkcyA9IFtdO1xuICAgICAgICB0aGlzLmFkZEhhbmRsZXJzID0gW107XG5cbiAgICAgICAgLy8gdGVsbCB0aGUgcGFyZW50IHdlIGRpc2Nvbm5lY3RlZFxuICAgICAgICB0aGlzLl9jaGFuZ2VDb25uZWN0U3RhdHVzKFN0cm9waGUuU3RhdHVzLkRJU0NPTk5FQ1RFRCwgY29uZGl0aW9uKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2RhdGFSZWN2XG4gICAgICogIF9Qcml2YXRlXyBoYW5kbGVyIHRvIHByb2Nlc3NlcyBpbmNvbWluZyBkYXRhIGZyb20gdGhlIHRoZSBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogIEV4Y2VwdCBmb3IgX2Nvbm5lY3RfY2IgaGFuZGxpbmcgdGhlIGluaXRpYWwgY29ubmVjdGlvbiByZXF1ZXN0LFxuICAgICAqICB0aGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIGluY29taW5nIGRhdGEgZm9yIGFsbCByZXF1ZXN0cy4gIFRoaXNcbiAgICAgKiAgZnVuY3Rpb24gYWxzbyBmaXJlcyBzdGFuemEgaGFuZGxlcnMgdGhhdCBtYXRjaCBlYWNoIGluY29taW5nXG4gICAgICogIHN0YW56YS5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJvcGhlLlJlcXVlc3QpIHJlcSAtIFRoZSByZXF1ZXN0IHRoYXQgaGFzIGRhdGEgcmVhZHkuXG4gICAgICogICAgKHN0cmluZykgcmVxIC0gVGhlIHN0YW56YSBhIHJhdyBzdHJpbmcgKG9wdGlvbmEpLlxuICAgICAqL1xuICAgIF9kYXRhUmVjdjogZnVuY3Rpb24gKHJlcSwgcmF3KSB7XG4gICAgICAgIFN0cm9waGUuaW5mbyhcIl9kYXRhUmVjdiBjYWxsZWRcIik7XG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5fcHJvdG8uX3JlcVRvRGF0YShyZXEpO1xuICAgICAgICBpZiAoZWxlbSA9PT0gbnVsbCkgeyByZXR1cm47IH1cblxuICAgICAgICBpZiAodGhpcy54bWxJbnB1dCAhPT0gU3Ryb3BoZS5Db25uZWN0aW9uLnByb3RvdHlwZS54bWxJbnB1dCkge1xuICAgICAgICAgICAgaWYgKGVsZW0ubm9kZU5hbWUgPT09IHRoaXMuX3Byb3RvLnN0cmlwICYmIGVsZW0uY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnhtbElucHV0KGVsZW0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMueG1sSW5wdXQoZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmF3SW5wdXQgIT09IFN0cm9waGUuQ29ubmVjdGlvbi5wcm90b3R5cGUucmF3SW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChyYXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhd0lucHV0KHJhdyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmF3SW5wdXQoU3Ryb3BoZS5zZXJpYWxpemUoZWxlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGhhbmRsZXJzIHNjaGVkdWxlZCBmb3IgZGVsZXRpb25cbiAgICAgICAgdmFyIGksIGhhbmQ7XG4gICAgICAgIHdoaWxlICh0aGlzLnJlbW92ZUhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGhhbmQgPSB0aGlzLnJlbW92ZUhhbmRsZXJzLnBvcCgpO1xuICAgICAgICAgICAgaSA9IHRoaXMuaGFuZGxlcnMuaW5kZXhPZihoYW5kKTtcbiAgICAgICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBoYW5kbGVycyBzY2hlZHVsZWQgZm9yIGFkZGl0aW9uXG4gICAgICAgIHdoaWxlICh0aGlzLmFkZEhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaCh0aGlzLmFkZEhhbmRsZXJzLnBvcCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBncmFjZWZ1bCBkaXNjb25uZWN0XG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RpbmcgJiYgdGhpcy5fcHJvdG8uX2VtcHR5UXVldWUoKSkge1xuICAgICAgICAgICAgdGhpcy5fZG9EaXNjb25uZWN0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHlwZSA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcbiAgICAgICAgdmFyIGNvbmQsIGNvbmZsaWN0O1xuICAgICAgICBpZiAodHlwZSAhPT0gbnVsbCAmJiB0eXBlID09IFwidGVybWluYXRlXCIpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHByb2Nlc3Mgc3RhbnphcyB0aGF0IGNvbWUgaW4gYWZ0ZXIgZGlzY29ubmVjdFxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYW4gZXJyb3Igb2NjdXJyZWRcbiAgICAgICAgICAgIGNvbmQgPSBlbGVtLmdldEF0dHJpYnV0ZShcImNvbmRpdGlvblwiKTtcbiAgICAgICAgICAgIGNvbmZsaWN0ID0gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNvbmZsaWN0XCIpO1xuICAgICAgICAgICAgaWYgKGNvbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZCA9PSBcInJlbW90ZS1zdHJlYW0tZXJyb3JcIiAmJiBjb25mbGljdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmQgPSBcImNvbmZsaWN0XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUNvbm5lY3RTdGF0dXMoU3Ryb3BoZS5TdGF0dXMuQ09OTkZBSUwsIGNvbmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VDb25uZWN0U3RhdHVzKFN0cm9waGUuU3RhdHVzLkNPTk5GQUlMLCBcInVua25vd25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kb0Rpc2Nvbm5lY3QoY29uZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZW5kIGVhY2ggaW5jb21pbmcgc3RhbnphIHRocm91Z2ggdGhlIGhhbmRsZXIgY2hhaW5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBTdHJvcGhlLmZvckVhY2hDaGlsZChlbGVtLCBudWxsLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBpLCBuZXdMaXN0O1xuICAgICAgICAgICAgLy8gcHJvY2VzcyBoYW5kbGVyc1xuICAgICAgICAgICAgbmV3TGlzdCA9IHRoYXQuaGFuZGxlcnM7XG4gICAgICAgICAgICB0aGF0LmhhbmRsZXJzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kID0gbmV3TGlzdFtpXTtcbiAgICAgICAgICAgICAgICAvLyBlbmNhcHN1bGF0ZSAnaGFuZGxlci5ydW4nIG5vdCB0byBsb3NlIHRoZSB3aG9sZSBoYW5kbGVyIGxpc3QgaWZcbiAgICAgICAgICAgICAgICAvLyBvbmUgb2YgdGhlIGhhbmRsZXJzIHRocm93cyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZC5pc01hdGNoKGNoaWxkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoYXQuYXV0aGVudGljYXRlZCB8fCAhaGFuZC51c2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmQucnVuKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuaGFuZGxlcnMucHVzaChoYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuaGFuZGxlcnMucHVzaChoYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLCB3ZSBjb25zaWRlciBpdCBhcyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBTdHJvcGhlLndhcm4oJ1JlbW92aW5nIFN0cm9waGUgaGFuZGxlcnMgZHVlIHRvIHVuY2F1Z2h0IGV4Y2VwdGlvbjogJytlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuXG4gICAgLyoqIEF0dHJpYnV0ZTogbWVjaGFuaXNtc1xuICAgICAqICBTQVNMIE1lY2hhbmlzbXMgYXZhaWxhYmxlIGZvciBDb25uZWN0aW9uLlxuICAgICAqL1xuICAgIG1lY2hhbmlzbXM6IHt9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2Nvbm5lY3RfY2JcbiAgICAgKiAgX1ByaXZhdGVfIGhhbmRsZXIgZm9yIGluaXRpYWwgY29ubmVjdGlvbiByZXF1ZXN0LlxuICAgICAqXG4gICAgICogIFRoaXMgaGFuZGxlciBpcyB1c2VkIHRvIHByb2Nlc3MgdGhlIGluaXRpYWwgY29ubmVjdGlvbiByZXF1ZXN0XG4gICAgICogIHJlc3BvbnNlIGZyb20gdGhlIEJPU0ggc2VydmVyLiBJdCBpcyB1c2VkIHRvIHNldCB1cCBhdXRoZW50aWNhdGlvblxuICAgICAqICBoYW5kbGVycyBhbmQgc3RhcnQgdGhlIGF1dGhlbnRpY2F0aW9uIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiAgU0FTTCBhdXRoZW50aWNhdGlvbiB3aWxsIGJlIGF0dGVtcHRlZCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZVxuICAgICAqICB0aGUgY29kZSB3aWxsIGZhbGwgYmFjayB0byBsZWdhY3kgYXV0aGVudGljYXRpb24uXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoU3Ryb3BoZS5SZXF1ZXN0KSByZXEgLSBUaGUgY3VycmVudCByZXF1ZXN0LlxuICAgICAqICAgIChGdW5jdGlvbikgX2NhbGxiYWNrIC0gbG93IGxldmVsICh4bXBwKSBjb25uZWN0IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqICAgICAgVXNlZnVsIGZvciBwbHVnaW5zIHdpdGggdGhlaXIgb3duIHhtcHAgY29ubmVjdCBjYWxsYmFjayAod2hlbiB0aGVpcilcbiAgICAgKiAgICAgIHdhbnQgdG8gZG8gc29tZXRoaW5nIHNwZWNpYWwpLlxuICAgICAqL1xuICAgIF9jb25uZWN0X2NiOiBmdW5jdGlvbiAocmVxLCBfY2FsbGJhY2ssIHJhdykge1xuICAgICAgICBTdHJvcGhlLmluZm8oXCJfY29ubmVjdF9jYiB3YXMgY2FsbGVkXCIpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG5cbiAgICAgICAgdmFyIGJvZHlXcmFwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYm9keVdyYXAgPSB0aGlzLl9wcm90by5fcmVxVG9EYXRhKHJlcSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlICE9IFwiYmFkZm9ybWF0XCIpIHsgdGhyb3cgZTsgfVxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlQ29ubmVjdFN0YXR1cyhTdHJvcGhlLlN0YXR1cy5DT05ORkFJTCwgJ2JhZC1mb3JtYXQnKTtcbiAgICAgICAgICAgIHRoaXMuX2RvRGlzY29ubmVjdCgnYmFkLWZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYm9keVdyYXApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKHRoaXMueG1sSW5wdXQgIT09IFN0cm9waGUuQ29ubmVjdGlvbi5wcm90b3R5cGUueG1sSW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChib2R5V3JhcC5ub2RlTmFtZSA9PT0gdGhpcy5fcHJvdG8uc3RyaXAgJiYgYm9keVdyYXAuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnhtbElucHV0KGJvZHlXcmFwLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnhtbElucHV0KGJvZHlXcmFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yYXdJbnB1dCAhPT0gU3Ryb3BoZS5Db25uZWN0aW9uLnByb3RvdHlwZS5yYXdJbnB1dCkge1xuICAgICAgICAgICAgaWYgKHJhdykge1xuICAgICAgICAgICAgICAgIHRoaXMucmF3SW5wdXQocmF3KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYXdJbnB1dChTdHJvcGhlLnNlcmlhbGl6ZShib2R5V3JhcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbm5jaGVjayA9IHRoaXMuX3Byb3RvLl9jb25uZWN0X2NiKGJvZHlXcmFwKTtcbiAgICAgICAgaWYgKGNvbm5jaGVjayA9PT0gU3Ryb3BoZS5TdGF0dXMuQ09OTkZBSUwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RyZWFtOmZlYXR1cmVzIHRhZ1xuICAgICAgICB2YXIgaGFzRmVhdHVyZXM7XG4gICAgICAgIGlmIChib2R5V3JhcC5nZXRFbGVtZW50c0J5VGFnTmFtZU5TKSB7XG4gICAgICAgICAgICBoYXNGZWF0dXJlcyA9IGJvZHlXcmFwLmdldEVsZW1lbnRzQnlUYWdOYW1lTlMoU3Ryb3BoZS5OUy5TVFJFQU0sIFwiZmVhdHVyZXNcIikubGVuZ3RoID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhc0ZlYXR1cmVzID0gYm9keVdyYXAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdHJlYW06ZmVhdHVyZXNcIikubGVuZ3RoID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlXcmFwLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZmVhdHVyZXNcIikubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0ZlYXR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm90by5fbm9fYXV0aF9yZWNlaXZlZChfY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdGNoZWQgPSBbXSwgaSwgbWVjaDtcbiAgICAgICAgdmFyIG1lY2hhbmlzbXMgPSBib2R5V3JhcC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIm1lY2hhbmlzbVwiKTtcbiAgICAgICAgaWYgKG1lY2hhbmlzbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1lY2hhbmlzbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtZWNoID0gU3Ryb3BoZS5nZXRUZXh0KG1lY2hhbmlzbXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lY2hhbmlzbXNbbWVjaF0pIG1hdGNoZWQucHVzaCh0aGlzLm1lY2hhbmlzbXNbbWVjaF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGJvZHlXcmFwLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYXV0aFwiKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgbm8gbWF0Y2hpbmcgU0FTTCBtZWNoYW5pc21zIGFuZCBhbHNvIG5vIGxlZ2FjeVxuICAgICAgICAgICAgICAgIC8vIGF1dGggYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvLl9ub19hdXRoX3JlY2VpdmVkKF9jYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRvX2F1dGhlbnRpY2F0aW9uICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5hdXRoZW50aWNhdGUobWF0Y2hlZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIEZ1bmN0aW9uOiBzb3J0TWVjaGFuaXNtc0J5UHJpb3JpdHlcbiAgICAgKlxuICAgICAqICBTb3J0cyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggcHJvdG90eXBlIFNBU0xNZWNoYW5pc20gYWNjb3JkaW5nIHRvXG4gICAgICogIHRoZWlyIHByaW9yaXRpZXMuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoQXJyYXkpIG1lY2hhbmlzbXMgLSBBcnJheSBvZiBTQVNMIG1lY2hhbmlzbXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBzb3J0TWVjaGFuaXNtc0J5UHJpb3JpdHk6IGZ1bmN0aW9uIChtZWNoYW5pc21zKSB7XG4gICAgICAgIC8vIFNvcnRpbmcgbWVjaGFuaXNtcyBhY2NvcmRpbmcgdG8gcHJpb3JpdHkuXG4gICAgICAgIHZhciBpLCBqLCBoaWdoZXIsIHN3YXA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtZWNoYW5pc21zLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgaGlnaGVyID0gaTtcbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbWVjaGFuaXNtcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChtZWNoYW5pc21zW2pdLnByb3RvdHlwZS5wcmlvcml0eSA+IG1lY2hhbmlzbXNbaGlnaGVyXS5wcm90b3R5cGUucHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaGVyID0gajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGlnaGVyICE9IGkpIHtcbiAgICAgICAgICAgICAgICBzd2FwID0gbWVjaGFuaXNtc1tpXTtcbiAgICAgICAgICAgICAgICBtZWNoYW5pc21zW2ldID0gbWVjaGFuaXNtc1toaWdoZXJdO1xuICAgICAgICAgICAgICAgIG1lY2hhbmlzbXNbaGlnaGVyXSA9IHN3YXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lY2hhbmlzbXM7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9hdHRlbXB0U0FTTEF1dGhcbiAgICAgKlxuICAgICAqICBJdGVyYXRlIHRocm91Z2ggYW4gYXJyYXkgb2YgU0FTTCBtZWNoYW5pc21zIGFuZCBhdHRlbXB0IGF1dGhlbnRpY2F0aW9uXG4gICAgICogIHdpdGggdGhlIGhpZ2hlc3QgcHJpb3JpdHkgKGVuYWJsZWQpIG1lY2hhbmlzbS5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChBcnJheSkgbWVjaGFuaXNtcyAtIEFycmF5IG9mIFNBU0wgbWVjaGFuaXNtcy5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIChCb29sZWFuKSBtZWNoYW5pc21fZm91bmQgLSB0cnVlIG9yIGZhbHNlLCBkZXBlbmRpbmcgb24gd2hldGhlciBhXG4gICAgICogICAgICAgICAgdmFsaWQgU0FTTCBtZWNoYW5pc20gd2FzIGZvdW5kIHdpdGggd2hpY2ggYXV0aGVudGljYXRpb24gY291bGQgYmVcbiAgICAgKiAgICAgICAgICBzdGFydGVkLlxuICAgICAqL1xuICAgIF9hdHRlbXB0U0FTTEF1dGg6IGZ1bmN0aW9uIChtZWNoYW5pc21zKSB7XG4gICAgICAgIG1lY2hhbmlzbXMgPSB0aGlzLnNvcnRNZWNoYW5pc21zQnlQcmlvcml0eShtZWNoYW5pc21zIHx8IFtdKTtcbiAgICAgICAgdmFyIGkgPSAwLCBtZWNoYW5pc21fZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1lY2hhbmlzbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbWVjaGFuaXNtc1tpXS5wcm90b3R5cGUudGVzdCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2FzbF9zdWNjZXNzX2hhbmRsZXIgPSB0aGlzLl9hZGRTeXNIYW5kbGVyKFxuICAgICAgICAgICAgICAgIHRoaXMuX3Nhc2xfc3VjY2Vzc19jYi5iaW5kKHRoaXMpLCBudWxsLFxuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX3Nhc2xfZmFpbHVyZV9oYW5kbGVyID0gdGhpcy5fYWRkU3lzSGFuZGxlcihcbiAgICAgICAgICAgICAgICB0aGlzLl9zYXNsX2ZhaWx1cmVfY2IuYmluZCh0aGlzKSwgbnVsbCxcbiAgICAgICAgICAgICAgICBcImZhaWx1cmVcIiwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9zYXNsX2NoYWxsZW5nZV9oYW5kbGVyID0gdGhpcy5fYWRkU3lzSGFuZGxlcihcbiAgICAgICAgICAgICAgICB0aGlzLl9zYXNsX2NoYWxsZW5nZV9jYi5iaW5kKHRoaXMpLCBudWxsLFxuICAgICAgICAgICAgICAgIFwiY2hhbGxlbmdlXCIsIG51bGwsIG51bGwpO1xuXG4gICAgICAgICAgICB0aGlzLl9zYXNsX21lY2hhbmlzbSA9IG5ldyBtZWNoYW5pc21zW2ldKCk7XG4gICAgICAgICAgICB0aGlzLl9zYXNsX21lY2hhbmlzbS5vblN0YXJ0KHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgcmVxdWVzdF9hdXRoX2V4Y2hhbmdlID0gJGJ1aWxkKFwiYXV0aFwiLCB7XG4gICAgICAgICAgICAgICAgeG1sbnM6IFN0cm9waGUuTlMuU0FTTCxcbiAgICAgICAgICAgICAgICBtZWNoYW5pc206IHRoaXMuX3Nhc2xfbWVjaGFuaXNtLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Nhc2xfbWVjaGFuaXNtLmlzQ2xpZW50Rmlyc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB0aGlzLl9zYXNsX21lY2hhbmlzbS5vbkNoYWxsZW5nZSh0aGlzLCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0X2F1dGhfZXhjaGFuZ2UudChCYXNlNjQuZW5jb2RlKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbmQocmVxdWVzdF9hdXRoX2V4Y2hhbmdlLnRyZWUoKSk7XG4gICAgICAgICAgICBtZWNoYW5pc21fZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lY2hhbmlzbV9mb3VuZDtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2F0dGVtcHRMZWdhY3lBdXRoXG4gICAgICpcbiAgICAgKiAgQXR0ZW1wdCBsZWdhY3kgKGkuZS4gbm9uLVNBU0wpIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqXG4gICAgICovXG4gICAgX2F0dGVtcHRMZWdhY3lBdXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChTdHJvcGhlLmdldE5vZGVGcm9tSmlkKHRoaXMuamlkKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBhIG5vZGUsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciBub24tYW5vbnltb3VzXG4gICAgICAgICAgICAvLyBjbGllbnQgY29ubmVjdGlvbnNcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUNvbm5lY3RTdGF0dXMoXG4gICAgICAgICAgICAgICAgU3Ryb3BoZS5TdGF0dXMuQ09OTkZBSUwsXG4gICAgICAgICAgICAgICAgJ3gtc3Ryb3BoZS1iYWQtbm9uLWFub24tamlkJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgneC1zdHJvcGhlLWJhZC1ub24tYW5vbi1qaWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBsZWdhY3kgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUNvbm5lY3RTdGF0dXMoU3Ryb3BoZS5TdGF0dXMuQVVUSEVOVElDQVRJTkcsIG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fYWRkU3lzSGFuZGxlcihcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRoMV9jYi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIG51bGwsIG51bGwsIG51bGwsIFwiX2F1dGhfMVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5zZW5kKCRpcSh7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogXCJnZXRcIixcbiAgICAgICAgICAgICAgICAgICAgJ3RvJzogdGhpcy5kb21haW4sXG4gICAgICAgICAgICAgICAgICAgICdpZCc6IFwiX2F1dGhfMVwiXG4gICAgICAgICAgICAgICAgfSkuYyhcInF1ZXJ5XCIsIHt4bWxuczogU3Ryb3BoZS5OUy5BVVRIfSlcbiAgICAgICAgICAgICAgICAuYyhcInVzZXJuYW1lXCIsIHt9KS50KFN0cm9waGUuZ2V0Tm9kZUZyb21KaWQodGhpcy5qaWQpKVxuICAgICAgICAgICAgICAgIC50cmVlKCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBGdW5jdGlvbjogYXV0aGVudGljYXRlXG4gICAgICogU2V0IHVwIGF1dGhlbnRpY2F0aW9uXG4gICAgICpcbiAgICAgKiAgQ29udGludWVzIHRoZSBpbml0aWFsIGNvbm5lY3Rpb24gcmVxdWVzdCBieSBzZXR0aW5nIHVwIGF1dGhlbnRpY2F0aW9uXG4gICAgICogIGhhbmRsZXJzIGFuZCBzdGFydGluZyB0aGUgYXV0aGVudGljYXRpb24gcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqICBTQVNMIGF1dGhlbnRpY2F0aW9uIHdpbGwgYmUgYXR0ZW1wdGVkIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlXG4gICAgICogIHRoZSBjb2RlIHdpbGwgZmFsbCBiYWNrIHRvIGxlZ2FjeSBhdXRoZW50aWNhdGlvbi5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChBcnJheSkgbWF0Y2hlZCAtIEFycmF5IG9mIFNBU0wgbWVjaGFuaXNtcyBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBhdXRoZW50aWNhdGU6IGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdFNBU0xBdXRoKG1hdGNoZWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0TGVnYWN5QXV0aCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9zYXNsX2NoYWxsZW5nZV9jYlxuICAgICAqICBfUHJpdmF0ZV8gaGFuZGxlciBmb3IgdGhlIFNBU0wgY2hhbGxlbmdlXG4gICAgICpcbiAgICAgKi9cbiAgICBfc2FzbF9jaGFsbGVuZ2VfY2I6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHZhciBjaGFsbGVuZ2UgPSBCYXNlNjQuZGVjb2RlKFN0cm9waGUuZ2V0VGV4dChlbGVtKSk7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB0aGlzLl9zYXNsX21lY2hhbmlzbS5vbkNoYWxsZW5nZSh0aGlzLCBjaGFsbGVuZ2UpO1xuICAgICAgdmFyIHN0YW56YSA9ICRidWlsZCgncmVzcG9uc2UnLCB7XG4gICAgICAgICAgJ3htbG5zJzogU3Ryb3BoZS5OUy5TQVNMXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXNwb25zZSAhPT0gXCJcIikge1xuICAgICAgICBzdGFuemEudChCYXNlNjQuZW5jb2RlKHJlc3BvbnNlKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNlbmQoc3RhbnphLnRyZWUoKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2F1dGgxX2NiXG4gICAgICogIF9Qcml2YXRlXyBoYW5kbGVyIGZvciBsZWdhY3kgYXV0aGVudGljYXRpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBoYW5kbGVyIGlzIGNhbGxlZCBpbiByZXNwb25zZSB0byB0aGUgaW5pdGlhbCA8aXEgdHlwZT0nZ2V0Jy8+XG4gICAgICogIGZvciBsZWdhY3kgYXV0aGVudGljYXRpb24uICBJdCBidWlsZHMgYW4gYXV0aGVudGljYXRpb24gPGlxLz4gYW5kXG4gICAgICogIHNlbmRzIGl0LCBjcmVhdGluZyBhIGhhbmRsZXIgKGNhbGxpbmcgYmFjayB0byBfYXV0aDJfY2IoKSkgdG9cbiAgICAgKiAgaGFuZGxlIHRoZSByZXN1bHRcbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChYTUxFbGVtZW50KSBlbGVtIC0gVGhlIHN0YW56YSB0aGF0IHRyaWdnZXJlZCB0aGUgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBmYWxzZSB0byByZW1vdmUgdGhlIGhhbmRsZXIuXG4gICAgICovXG4gICAgLyoganNoaW50IHVudXNlZDpmYWxzZSAqL1xuICAgIF9hdXRoMV9jYjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgLy8gYnVpbGQgcGxhaW50ZXh0IGF1dGggaXFcbiAgICAgICAgdmFyIGlxID0gJGlxKHt0eXBlOiBcInNldFwiLCBpZDogXCJfYXV0aF8yXCJ9KVxuICAgICAgICAgICAgLmMoJ3F1ZXJ5Jywge3htbG5zOiBTdHJvcGhlLk5TLkFVVEh9KVxuICAgICAgICAgICAgLmMoJ3VzZXJuYW1lJywge30pLnQoU3Ryb3BoZS5nZXROb2RlRnJvbUppZCh0aGlzLmppZCkpXG4gICAgICAgICAgICAudXAoKVxuICAgICAgICAgICAgLmMoJ3Bhc3N3b3JkJykudCh0aGlzLnBhc3MpO1xuXG4gICAgICAgIGlmICghU3Ryb3BoZS5nZXRSZXNvdXJjZUZyb21KaWQodGhpcy5qaWQpKSB7XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgdXNlciBoYXMgbm90IHN1cHBsaWVkIGEgcmVzb3VyY2UsIHdlIHBpY2tcbiAgICAgICAgICAgIC8vIGEgZGVmYXVsdCBvbmUgaGVyZS4gIHVubGlrZSBvdGhlciBhdXRoIG1ldGhvZHMsIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIC8vIGNhbm5vdCBkbyB0aGlzIGZvciB1cy5cbiAgICAgICAgICAgIHRoaXMuamlkID0gU3Ryb3BoZS5nZXRCYXJlSmlkRnJvbUppZCh0aGlzLmppZCkgKyAnL3N0cm9waGUnO1xuICAgICAgICB9XG4gICAgICAgIGlxLnVwKCkuYygncmVzb3VyY2UnLCB7fSkudChTdHJvcGhlLmdldFJlc291cmNlRnJvbUppZCh0aGlzLmppZCkpO1xuXG4gICAgICAgIHRoaXMuX2FkZFN5c0hhbmRsZXIodGhpcy5fYXV0aDJfY2IuYmluZCh0aGlzKSwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBcIl9hdXRoXzJcIik7XG4gICAgICAgIHRoaXMuc2VuZChpcS50cmVlKCkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKiBqc2hpbnQgdW51c2VkOnRydWUgKi9cblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9zYXNsX3N1Y2Nlc3NfY2JcbiAgICAgKiAgX1ByaXZhdGVfIGhhbmRsZXIgZm9yIHN1Y2Nlc2Z1bCBTQVNMIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFhNTEVsZW1lbnQpIGVsZW0gLSBUaGUgbWF0Y2hpbmcgc3RhbnphLlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgZmFsc2UgdG8gcmVtb3ZlIHRoZSBoYW5kbGVyLlxuICAgICAqL1xuICAgIF9zYXNsX3N1Y2Nlc3NfY2I6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIGlmICh0aGlzLl9zYXNsX2RhdGFbXCJzZXJ2ZXItc2lnbmF0dXJlXCJdKSB7XG4gICAgICAgICAgICB2YXIgc2VydmVyU2lnbmF0dXJlO1xuICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBCYXNlNjQuZGVjb2RlKFN0cm9waGUuZ2V0VGV4dChlbGVtKSk7XG4gICAgICAgICAgICB2YXIgYXR0cmliTWF0Y2ggPSAvKFthLXpdKyk9KFteLF0rKSgsfCQpLztcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gc3VjY2Vzcy5tYXRjaChhdHRyaWJNYXRjaCk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlc1sxXSA9PSBcInZcIikge1xuICAgICAgICAgICAgICAgIHNlcnZlclNpZ25hdHVyZSA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXJ2ZXJTaWduYXR1cmUgIT0gdGhpcy5fc2FzbF9kYXRhW1wic2VydmVyLXNpZ25hdHVyZVwiXSkge1xuICAgICAgICAgICAgICAvLyByZW1vdmUgb2xkIGhhbmRsZXJzXG4gICAgICAgICAgICAgIHRoaXMuZGVsZXRlSGFuZGxlcih0aGlzLl9zYXNsX2ZhaWx1cmVfaGFuZGxlcik7XG4gICAgICAgICAgICAgIHRoaXMuX3Nhc2xfZmFpbHVyZV9oYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nhc2xfY2hhbGxlbmdlX2hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZUhhbmRsZXIodGhpcy5fc2FzbF9jaGFsbGVuZ2VfaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2FzbF9jaGFsbGVuZ2VfaGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLl9zYXNsX2RhdGEgPSB7fTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Nhc2xfZmFpbHVyZV9jYihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBTdHJvcGhlLmluZm8oXCJTQVNMIGF1dGhlbnRpY2F0aW9uIHN1Y2NlZWRlZC5cIik7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Nhc2xfbWVjaGFuaXNtKSB7XG4gICAgICAgICAgdGhpcy5fc2FzbF9tZWNoYW5pc20ub25TdWNjZXNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgb2xkIGhhbmRsZXJzXG4gICAgICAgIHRoaXMuZGVsZXRlSGFuZGxlcih0aGlzLl9zYXNsX2ZhaWx1cmVfaGFuZGxlcik7XG4gICAgICAgIHRoaXMuX3Nhc2xfZmFpbHVyZV9oYW5kbGVyID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3Nhc2xfY2hhbGxlbmdlX2hhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlSGFuZGxlcih0aGlzLl9zYXNsX2NoYWxsZW5nZV9oYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMuX3Nhc2xfY2hhbGxlbmdlX2hhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cmVhbWZlYXR1cmVfaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbihoYW5kbGVycywgZWxlbSkge1xuICAgICAgICAgICAgd2hpbGUgKGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlSGFuZGxlcihoYW5kbGVycy5wb3AoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zYXNsX2F1dGgxX2NiLmJpbmQodGhpcykoZWxlbSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHN0cmVhbWZlYXR1cmVfaGFuZGxlcnMucHVzaCh0aGlzLl9hZGRTeXNIYW5kbGVyKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIHdyYXBwZXIuYmluZCh0aGlzKShzdHJlYW1mZWF0dXJlX2hhbmRsZXJzLCBlbGVtKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLCBudWxsLCBcInN0cmVhbTpmZWF0dXJlc1wiLCBudWxsLCBudWxsKSk7XG4gICAgICAgIHN0cmVhbWZlYXR1cmVfaGFuZGxlcnMucHVzaCh0aGlzLl9hZGRTeXNIYW5kbGVyKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIHdyYXBwZXIuYmluZCh0aGlzKShzdHJlYW1mZWF0dXJlX2hhbmRsZXJzLCBlbGVtKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLCBTdHJvcGhlLk5TLlNUUkVBTSwgXCJmZWF0dXJlc1wiLCBudWxsLCBudWxsKSk7XG5cbiAgICAgICAgLy8gd2UgbXVzdCBzZW5kIGFuIHhtcHA6cmVzdGFydCBub3dcbiAgICAgICAgdGhpcy5fc2VuZFJlc3RhcnQoKTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9zYXNsX2F1dGgxX2NiXG4gICAgICogIF9Qcml2YXRlXyBoYW5kbGVyIHRvIHN0YXJ0IHN0cmVhbSBiaW5kaW5nLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFhNTEVsZW1lbnQpIGVsZW0gLSBUaGUgbWF0Y2hpbmcgc3RhbnphLlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgZmFsc2UgdG8gcmVtb3ZlIHRoZSBoYW5kbGVyLlxuICAgICAqL1xuICAgIF9zYXNsX2F1dGgxX2NiOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAvLyBzYXZlIHN0cmVhbTpmZWF0dXJlcyBmb3IgZnV0dXJlIHVzYWdlXG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBlbGVtO1xuICAgICAgICB2YXIgaSwgY2hpbGQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gZWxlbS5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVOYW1lID09ICdiaW5kJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9fYmluZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlTmFtZSA9PSAnc2Vzc2lvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvX3Nlc3Npb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmRvX2JpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUNvbm5lY3RTdGF0dXMoU3Ryb3BoZS5TdGF0dXMuQVVUSEZBSUwsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWRkU3lzSGFuZGxlcih0aGlzLl9zYXNsX2JpbmRfY2IuYmluZCh0aGlzKSwgbnVsbCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgXCJfYmluZF9hdXRoXzJcIik7XG5cbiAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IFN0cm9waGUuZ2V0UmVzb3VyY2VGcm9tSmlkKHRoaXMuamlkKTtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZCgkaXEoe3R5cGU6IFwic2V0XCIsIGlkOiBcIl9iaW5kX2F1dGhfMlwifSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmMoJ2JpbmQnLCB7eG1sbnM6IFN0cm9waGUuTlMuQklORH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5jKCdyZXNvdXJjZScsIHt9KS50KHJlc291cmNlKS50cmVlKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmQoJGlxKHt0eXBlOiBcInNldFwiLCBpZDogXCJfYmluZF9hdXRoXzJcIn0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5jKCdiaW5kJywge3htbG5zOiBTdHJvcGhlLk5TLkJJTkR9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAudHJlZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9zYXNsX2JpbmRfY2JcbiAgICAgKiAgX1ByaXZhdGVfIGhhbmRsZXIgZm9yIGJpbmRpbmcgcmVzdWx0IGFuZCBzZXNzaW9uIHN0YXJ0LlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFhNTEVsZW1lbnQpIGVsZW0gLSBUaGUgbWF0Y2hpbmcgc3RhbnphLlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgZmFsc2UgdG8gcmVtb3ZlIHRoZSBoYW5kbGVyLlxuICAgICAqL1xuICAgIF9zYXNsX2JpbmRfY2I6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIGlmIChlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikgPT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBTdHJvcGhlLmluZm8oXCJTQVNMIGJpbmRpbmcgZmFpbGVkLlwiKTtcbiAgICAgICAgICAgIHZhciBjb25mbGljdCA9IGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjb25mbGljdFwiKSwgY29uZGl0aW9uO1xuICAgICAgICAgICAgaWYgKGNvbmZsaWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb24gPSAnY29uZmxpY3QnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlQ29ubmVjdFN0YXR1cyhTdHJvcGhlLlN0YXR1cy5BVVRIRkFJTCwgY29uZGl0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gLSBuZWVkIHRvIGdyYWIgZXJyb3JzXG4gICAgICAgIHZhciBiaW5kID0gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJpbmRcIik7XG4gICAgICAgIHZhciBqaWROb2RlO1xuICAgICAgICBpZiAoYmluZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBHcmFiIGppZFxuICAgICAgICAgICAgamlkTm9kZSA9IGJpbmRbMF0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJqaWRcIik7XG4gICAgICAgICAgICBpZiAoamlkTm9kZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5qaWQgPSBTdHJvcGhlLmdldFRleHQoamlkTm9kZVswXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb19zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFN5c0hhbmRsZXIodGhpcy5fc2FzbF9zZXNzaW9uX2NiLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgbnVsbCwgbnVsbCwgXCJfc2Vzc2lvbl9hdXRoXzJcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kKCRpcSh7dHlwZTogXCJzZXRcIiwgaWQ6IFwiX3Nlc3Npb25fYXV0aF8yXCJ9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jKCdzZXNzaW9uJywge3htbG5zOiBTdHJvcGhlLk5TLlNFU1NJT059KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmVlKCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUNvbm5lY3RTdGF0dXMoU3Ryb3BoZS5TdGF0dXMuQ09OTkVDVEVELCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBTdHJvcGhlLmluZm8oXCJTQVNMIGJpbmRpbmcgZmFpbGVkLlwiKTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUNvbm5lY3RTdGF0dXMoU3Ryb3BoZS5TdGF0dXMuQVVUSEZBSUwsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9zYXNsX3Nlc3Npb25fY2JcbiAgICAgKiAgX1ByaXZhdGVfIGhhbmRsZXIgdG8gZmluaXNoIHN1Y2Nlc3NmdWwgU0FTTCBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgc2V0cyBDb25uZWN0aW9uLmF1dGhlbnRpY2F0ZWQgdG8gdHJ1ZSBvbiBzdWNjZXNzLCB3aGljaFxuICAgICAqICBzdGFydHMgdGhlIHByb2Nlc3Npbmcgb2YgdXNlciBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChYTUxFbGVtZW50KSBlbGVtIC0gVGhlIG1hdGNoaW5nIHN0YW56YS5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIGZhbHNlIHRvIHJlbW92ZSB0aGUgaGFuZGxlci5cbiAgICAgKi9cbiAgICBfc2FzbF9zZXNzaW9uX2NiOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICBpZiAoZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09IFwicmVzdWx0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VDb25uZWN0U3RhdHVzKFN0cm9waGUuU3RhdHVzLkNPTk5FQ1RFRCwgbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgU3Ryb3BoZS5pbmZvKFwiU2Vzc2lvbiBjcmVhdGlvbiBmYWlsZWQuXCIpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlQ29ubmVjdFN0YXR1cyhTdHJvcGhlLlN0YXR1cy5BVVRIRkFJTCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfc2FzbF9mYWlsdXJlX2NiXG4gICAgICogIF9Qcml2YXRlXyBoYW5kbGVyIGZvciBTQVNMIGF1dGhlbnRpY2F0aW9uIGZhaWx1cmUuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoWE1MRWxlbWVudCkgZWxlbSAtIFRoZSBtYXRjaGluZyBzdGFuemEuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBmYWxzZSB0byByZW1vdmUgdGhlIGhhbmRsZXIuXG4gICAgICovXG4gICAgLyoganNoaW50IHVudXNlZDpmYWxzZSAqL1xuICAgIF9zYXNsX2ZhaWx1cmVfY2I6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIC8vIGRlbGV0ZSB1bm5lZWRlZCBoYW5kbGVyc1xuICAgICAgICBpZiAodGhpcy5fc2FzbF9zdWNjZXNzX2hhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlSGFuZGxlcih0aGlzLl9zYXNsX3N1Y2Nlc3NfaGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLl9zYXNsX3N1Y2Nlc3NfaGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Nhc2xfY2hhbGxlbmdlX2hhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlSGFuZGxlcih0aGlzLl9zYXNsX2NoYWxsZW5nZV9oYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMuX3Nhc2xfY2hhbGxlbmdlX2hhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5fc2FzbF9tZWNoYW5pc20pXG4gICAgICAgICAgdGhpcy5fc2FzbF9tZWNoYW5pc20ub25GYWlsdXJlKCk7XG4gICAgICAgIHRoaXMuX2NoYW5nZUNvbm5lY3RTdGF0dXMoU3Ryb3BoZS5TdGF0dXMuQVVUSEZBSUwsIG51bGwpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKiBqc2hpbnQgdW51c2VkOnRydWUgKi9cblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9hdXRoMl9jYlxuICAgICAqICBfUHJpdmF0ZV8gaGFuZGxlciB0byBmaW5pc2ggbGVnYWN5IGF1dGhlbnRpY2F0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgaGFuZGxlciBpcyBjYWxsZWQgd2hlbiB0aGUgcmVzdWx0IGZyb20gdGhlIGphYmJlcjppcTphdXRoXG4gICAgICogIDxpcS8+IHN0YW56YSBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChYTUxFbGVtZW50KSBlbGVtIC0gVGhlIHN0YW56YSB0aGF0IHRyaWdnZXJlZCB0aGUgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBmYWxzZSB0byByZW1vdmUgdGhlIGhhbmRsZXIuXG4gICAgICovXG4gICAgX2F1dGgyX2NiOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICBpZiAoZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09IFwicmVzdWx0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VDb25uZWN0U3RhdHVzKFN0cm9waGUuU3RhdHVzLkNPTk5FQ1RFRCwgbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlQ29ubmVjdFN0YXR1cyhTdHJvcGhlLlN0YXR1cy5BVVRIRkFJTCwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoJ2F1dGhlbnRpY2F0aW9uIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2FkZFN5c1RpbWVkSGFuZGxlclxuICAgICAqICBfUHJpdmF0ZV8gZnVuY3Rpb24gdG8gYWRkIGEgc3lzdGVtIGxldmVsIHRpbWVkIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGFkZCBhIFN0cm9waGUuVGltZWRIYW5kbGVyIGZvciB0aGVcbiAgICAgKiAgbGlicmFyeSBjb2RlLiAgU3lzdGVtIHRpbWVkIGhhbmRsZXJzIGFyZSBhbGxvd2VkIHRvIHJ1biBiZWZvcmVcbiAgICAgKiAgYXV0aGVudGljYXRpb24gaXMgY29tcGxldGUuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoSW50ZWdlcikgcGVyaW9kIC0gVGhlIHBlcmlvZCBvZiB0aGUgaGFuZGxlci5cbiAgICAgKiAgICAoRnVuY3Rpb24pIGhhbmRsZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICovXG4gICAgX2FkZFN5c1RpbWVkSGFuZGxlcjogZnVuY3Rpb24gKHBlcmlvZCwgaGFuZGxlcikge1xuICAgICAgICB2YXIgdGhhbmQgPSBuZXcgU3Ryb3BoZS5UaW1lZEhhbmRsZXIocGVyaW9kLCBoYW5kbGVyKTtcbiAgICAgICAgdGhhbmQudXNlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkZFRpbWVkcy5wdXNoKHRoYW5kKTtcbiAgICAgICAgcmV0dXJuIHRoYW5kO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfYWRkU3lzSGFuZGxlclxuICAgICAqICBfUHJpdmF0ZV8gZnVuY3Rpb24gdG8gYWRkIGEgc3lzdGVtIGxldmVsIHN0YW56YSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBTdHJvcGhlLkhhbmRsZXIgZm9yIHRoZVxuICAgICAqICBsaWJyYXJ5IGNvZGUuICBTeXN0ZW0gc3RhbnphIGhhbmRsZXJzIGFyZSBhbGxvd2VkIHRvIHJ1biBiZWZvcmVcbiAgICAgKiAgYXV0aGVudGljYXRpb24gaXMgY29tcGxldGUuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoRnVuY3Rpb24pIGhhbmRsZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogICAgKFN0cmluZykgbnMgLSBUaGUgbmFtZXNwYWNlIHRvIG1hdGNoLlxuICAgICAqICAgIChTdHJpbmcpIG5hbWUgLSBUaGUgc3RhbnphIG5hbWUgdG8gbWF0Y2guXG4gICAgICogICAgKFN0cmluZykgdHlwZSAtIFRoZSBzdGFuemEgdHlwZSBhdHRyaWJ1dGUgdG8gbWF0Y2guXG4gICAgICogICAgKFN0cmluZykgaWQgLSBUaGUgc3RhbnphIGlkIGF0dHJpYnV0ZSB0byBtYXRjaC5cbiAgICAgKi9cbiAgICBfYWRkU3lzSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIsIG5zLCBuYW1lLCB0eXBlLCBpZCkge1xuICAgICAgICB2YXIgaGFuZCA9IG5ldyBTdHJvcGhlLkhhbmRsZXIoaGFuZGxlciwgbnMsIG5hbWUsIHR5cGUsIGlkKTtcbiAgICAgICAgaGFuZC51c2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRkSGFuZGxlcnMucHVzaChoYW5kKTtcbiAgICAgICAgcmV0dXJuIGhhbmQ7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9vbkRpc2Nvbm5lY3RUaW1lb3V0XG4gICAgICogIF9Qcml2YXRlXyB0aW1lb3V0IGhhbmRsZXIgZm9yIGhhbmRsaW5nIG5vbi1ncmFjZWZ1bCBkaXNjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogIElmIHRoZSBncmFjZWZ1bCBkaXNjb25uZWN0IHByb2Nlc3MgZG9lcyBub3QgY29tcGxldGUgd2l0aGluIHRoZVxuICAgICAqICB0aW1lIGFsbG90dGVkLCB0aGlzIGhhbmRsZXIgZmluaXNoZXMgdGhlIGRpc2Nvbm5lY3QgYW55d2F5LlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgZmFsc2UgdG8gcmVtb3ZlIHRoZSBoYW5kbGVyLlxuICAgICAqL1xuICAgIF9vbkRpc2Nvbm5lY3RUaW1lb3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFN0cm9waGUuaW5mbyhcIl9vbkRpc2Nvbm5lY3RUaW1lb3V0IHdhcyBjYWxsZWRcIik7XG4gICAgICAgIHRoaXMuX2NoYW5nZUNvbm5lY3RTdGF0dXMoU3Ryb3BoZS5TdGF0dXMuQ09OTlRJTUVPVVQsIG51bGwpO1xuICAgICAgICB0aGlzLl9wcm90by5fb25EaXNjb25uZWN0VGltZW91dCgpO1xuICAgICAgICAvLyBhY3R1YWxseSBkaXNjb25uZWN0XG4gICAgICAgIHRoaXMuX2RvRGlzY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9vbklkbGVcbiAgICAgKiAgX1ByaXZhdGVfIGhhbmRsZXIgdG8gcHJvY2VzcyBldmVudHMgZHVyaW5nIGlkbGUgY3ljbGUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBoYW5kbGVyIGlzIGNhbGxlZCBldmVyeSAxMDBtcyB0byBmaXJlIHRpbWVkIGhhbmRsZXJzIHRoYXRcbiAgICAgKiAgYXJlIHJlYWR5IGFuZCBrZWVwIHBvbGwgcmVxdWVzdHMgZ29pbmcuXG4gICAgICovXG4gICAgX29uSWRsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgdGhhbmQsIHNpbmNlLCBuZXdMaXN0O1xuXG4gICAgICAgIC8vIGFkZCB0aW1lZCBoYW5kbGVycyBzY2hlZHVsZWQgZm9yIGFkZGl0aW9uXG4gICAgICAgIC8vIE5PVEU6IHdlIGFkZCBiZWZvcmUgcmVtb3ZlIGluIHRoZSBjYXNlIGEgdGltZWQgaGFuZGxlciBpc1xuICAgICAgICAvLyBhZGRlZCBhbmQgdGhlbiBkZWxldGVkIGJlZm9yZSB0aGUgbmV4dCBfb25JZGxlKCkgY2FsbC5cbiAgICAgICAgd2hpbGUgKHRoaXMuYWRkVGltZWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudGltZWRIYW5kbGVycy5wdXNoKHRoaXMuYWRkVGltZWRzLnBvcCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aW1lZCBoYW5kbGVycyB0aGF0IGhhdmUgYmVlbiBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uXG4gICAgICAgIHdoaWxlICh0aGlzLnJlbW92ZVRpbWVkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGFuZCA9IHRoaXMucmVtb3ZlVGltZWRzLnBvcCgpO1xuICAgICAgICAgICAgaSA9IHRoaXMudGltZWRIYW5kbGVycy5pbmRleE9mKHRoYW5kKTtcbiAgICAgICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVkSGFuZGxlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsbCByZWFkeSB0aW1lZCBoYW5kbGVyc1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIG5ld0xpc3QgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudGltZWRIYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhhbmQgPSB0aGlzLnRpbWVkSGFuZGxlcnNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRoZW50aWNhdGVkIHx8ICF0aGFuZC51c2VyKSB7XG4gICAgICAgICAgICAgICAgc2luY2UgPSB0aGFuZC5sYXN0Q2FsbGVkICsgdGhhbmQucGVyaW9kO1xuICAgICAgICAgICAgICAgIGlmIChzaW5jZSAtIG5vdyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGFuZC5ydW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdC5wdXNoKHRoYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0xpc3QucHVzaCh0aGFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZWRIYW5kbGVycyA9IG5ld0xpc3Q7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2lkbGVUaW1lb3V0KTtcblxuICAgICAgICB0aGlzLl9wcm90by5fb25JZGxlKCk7XG5cbiAgICAgICAgLy8gcmVhY3RpdmF0ZSB0aGUgdGltZXIgb25seSBpZiBjb25uZWN0ZWRcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAvLyBYWFg6IHNldFRpbWVvdXQgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IHdpdGggZnVuY3Rpb24gZXhwcmVzc2lvbnMgKDIzOTc0YmMxKVxuICAgICAgICAgICAgdGhpcy5faWRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uSWRsZSgpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAxMDApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqIENsYXNzOiBTdHJvcGhlLlNBU0xNZWNoYW5pc21cbiAqXG4gKiAgZW5jYXBzdWxhdGVzIFNBU0wgYXV0aGVudGljYXRpb24gbWVjaGFuaXNtcy5cbiAqXG4gKiAgVXNlciBjb2RlIG1heSBvdmVycmlkZSB0aGUgcHJpb3JpdHkgZm9yIGVhY2ggbWVjaGFuaXNtIG9yIGRpc2FibGUgaXQgY29tcGxldGVseS5cbiAqICBTZWUgPHByaW9yaXR5PiBmb3IgaW5mb3JtYXRpb24gYWJvdXQgY2hhbmdpbmcgcHJpb3JpdHkgYW5kIDx0ZXN0PiBmb3IgaW5mb3JtYXRpYW4gb25cbiAqICBob3cgdG8gZGlzYWJsZSBhIG1lY2hhbmlzbS5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgYWxsIG1lY2hhbmlzbXMgYXJlIGVuYWJsZWQgYW5kIHRoZSBwcmlvcml0aWVzIGFyZVxuICpcbiAqICBFWFRFUk5BTCAtIDYwXG4gKiAgT0FVVEhCRUFSRVIgLSA1MFxuICogIFNDUkFNLVNIQTEgLSA0MFxuICogIERJR0VTVC1NRDUgLSAzMFxuICogIFBMQUlOIC0gMjBcbiAqICBBTk9OWU1PVVMgLSAxMFxuICpcbiAqICBTZWU6IFN0cm9waGUuQ29ubmVjdGlvbi5hZGRTdXBwb3J0ZWRTQVNMTWVjaGFuaXNtc1xuICovXG5cbi8qKlxuICogUHJpdmF0ZUNvbnN0cnVjdG9yOiBTdHJvcGhlLlNBU0xNZWNoYW5pc21cbiAqIFNBU0wgYXV0aCBtZWNoYW5pc20gYWJzdHJhY3Rpb24uXG4gKlxuICogIFBhcmFtZXRlcnM6XG4gKiAgICAoU3RyaW5nKSBuYW1lIC0gU0FTTCBNZWNoYW5pc20gbmFtZS5cbiAqICAgIChCb29sZWFuKSBpc0NsaWVudEZpcnN0IC0gSWYgY2xpZW50IHNob3VsZCBzZW5kIHJlc3BvbnNlIGZpcnN0IHdpdGhvdXQgY2hhbGxlbmdlLlxuICogICAgKE51bWJlcikgcHJpb3JpdHkgLSBQcmlvcml0eS5cbiAqXG4gKiAgUmV0dXJuczpcbiAqICAgIEEgbmV3IFN0cm9waGUuU0FTTE1lY2hhbmlzbSBvYmplY3QuXG4gKi9cblN0cm9waGUuU0FTTE1lY2hhbmlzbSA9IGZ1bmN0aW9uKG5hbWUsIGlzQ2xpZW50Rmlyc3QsIHByaW9yaXR5KSB7XG4gIC8qKiBQcml2YXRlVmFyaWFibGU6IG5hbWVcbiAgICogIE1lY2hhbmlzbSBuYW1lLlxuICAgKi9cbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgLyoqIFByaXZhdGVWYXJpYWJsZTogaXNDbGllbnRGaXJzdFxuICAgKiAgSWYgY2xpZW50IHNlbmRzIHJlc3BvbnNlIHdpdGhvdXQgaW5pdGlhbCBzZXJ2ZXIgY2hhbGxlbmdlLlxuICAgKi9cbiAgdGhpcy5pc0NsaWVudEZpcnN0ID0gaXNDbGllbnRGaXJzdDtcbiAgLyoqIFZhcmlhYmxlOiBwcmlvcml0eVxuICAgKiAgRGV0ZXJtaW5lcyB3aGljaCA8U0FTTE1lY2hhbmlzbT4gaXMgY2hvc2VuIGZvciBhdXRoZW50aWNhdGlvbiAoSGlnaGVyIGlzIGJldHRlcikuXG4gICAqICBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBwcmlvcml0aXplIG1lY2hhbmlzbXMgZGlmZmVyZW50bHkuXG4gICAqXG4gICAqICBJbiB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHRoZSBwcmlvcml0aWVzIGFyZVxuICAgKlxuICAgKiAgU0NSQU0tU0hBMSAtIDQwXG4gICAqICBESUdFU1QtTUQ1IC0gMzBcbiAgICogIFBsYWluIC0gMjBcbiAgICpcbiAgICogIEV4YW1wbGU6IChUaGlzIHdpbGwgY2F1c2UgU3Ryb3BoZSB0byBjaG9vc2UgdGhlIG1lY2hhbmlzbSB0aGF0IHRoZSBzZXJ2ZXIgc2VudCBmaXJzdClcbiAgICpcbiAgICogID4gU3Ryb3BoZS5TQVNMTUQ1LnByaW9yaXR5ID0gU3Ryb3BoZS5TQVNMU0hBMS5wcmlvcml0eTtcbiAgICpcbiAgICogIFNlZSA8U0FTTCBtZWNoYW5pc21zPiBmb3IgYSBsaXN0IG9mIGF2YWlsYWJsZSBtZWNoYW5pc21zLlxuICAgKlxuICAgKi9cbiAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xufTtcblxuU3Ryb3BoZS5TQVNMTWVjaGFuaXNtLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqICBGdW5jdGlvbjogdGVzdFxuICAgKiAgQ2hlY2tzIGlmIG1lY2hhbmlzbSBhYmxlIHRvIHJ1bi5cbiAgICogIFRvIGRpc2FibGUgYSBtZWNoYW5pc20sIG1ha2UgdGhpcyByZXR1cm4gZmFsc2U7XG4gICAqXG4gICAqICBUbyBkaXNhYmxlIHBsYWluIGF1dGhlbnRpY2F0aW9uIHJ1blxuICAgKiAgPiBTdHJvcGhlLlNBU0xQbGFpbi50ZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgcmV0dXJuIGZhbHNlO1xuICAgKiAgPiB9XG4gICAqXG4gICAqICBTZWUgPFNBU0wgbWVjaGFuaXNtcz4gZm9yIGEgbGlzdCBvZiBhdmFpbGFibGUgbWVjaGFuaXNtcy5cbiAgICpcbiAgICogIFBhcmFtZXRlcnM6XG4gICAqICAgIChTdHJvcGhlLkNvbm5lY3Rpb24pIGNvbm5lY3Rpb24gLSBUYXJnZXQgQ29ubmVjdGlvbi5cbiAgICpcbiAgICogIFJldHVybnM6XG4gICAqICAgIChCb29sZWFuKSBJZiBtZWNoYW5pc20gd2FzIGFibGUgdG8gcnVuLlxuICAgKi9cbiAgLyoganNoaW50IHVudXNlZDpmYWxzZSAqL1xuICB0ZXN0OiBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8qIGpzaGludCB1bnVzZWQ6dHJ1ZSAqL1xuXG4gIC8qKiBQcml2YXRlRnVuY3Rpb246IG9uU3RhcnRcbiAgICogIENhbGxlZCBiZWZvcmUgc3RhcnRpbmcgbWVjaGFuaXNtIG9uIHNvbWUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogIFBhcmFtZXRlcnM6XG4gICAqICAgIChTdHJvcGhlLkNvbm5lY3Rpb24pIGNvbm5lY3Rpb24gLSBUYXJnZXQgQ29ubmVjdGlvbi5cbiAgICovXG4gIG9uU3RhcnQ6IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgfSxcblxuICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBvbkNoYWxsZW5nZVxuICAgKiAgQ2FsbGVkIGJ5IHByb3RvY29sIGltcGxlbWVudGF0aW9uIG9uIGluY29taW5nIGNoYWxsZW5nZS4gSWYgY2xpZW50IGlzXG4gICAqICBmaXJzdCAoaXNDbGllbnRGaXJzdCA9PSB0cnVlKSBjaGFsbGVuZ2Ugd2lsbCBiZSBudWxsIG9uIHRoZSBmaXJzdCBjYWxsLlxuICAgKlxuICAgKiAgUGFyYW1ldGVyczpcbiAgICogICAgKFN0cm9waGUuQ29ubmVjdGlvbikgY29ubmVjdGlvbiAtIFRhcmdldCBDb25uZWN0aW9uLlxuICAgKiAgICAoU3RyaW5nKSBjaGFsbGVuZ2UgLSBjdXJyZW50IGNoYWxsZW5nZSB0byBoYW5kbGUuXG4gICAqXG4gICAqICBSZXR1cm5zOlxuICAgKiAgICAoU3RyaW5nKSBNZWNoYW5pc20gcmVzcG9uc2UuXG4gICAqL1xuICAvKiBqc2hpbnQgdW51c2VkOmZhbHNlICovXG4gIG9uQ2hhbGxlbmdlOiBmdW5jdGlvbihjb25uZWN0aW9uLCBjaGFsbGVuZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3Ugc2hvdWxkIGltcGxlbWVudCBjaGFsbGVuZ2UgaGFuZGxpbmchXCIpO1xuICB9LFxuICAvKiBqc2hpbnQgdW51c2VkOnRydWUgKi9cblxuICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBvbkZhaWx1cmVcbiAgICogIFByb3RvY29sIGluZm9ybXMgbWVjaGFuaXNtIGltcGxlbWVudGF0aW9uIGFib3V0IFNBU0wgZmFpbHVyZS5cbiAgICovXG4gIG9uRmFpbHVyZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IG51bGw7XG4gIH0sXG5cbiAgLyoqIFByaXZhdGVGdW5jdGlvbjogb25TdWNjZXNzXG4gICAqICBQcm90b2NvbCBpbmZvcm1zIG1lY2hhbmlzbSBpbXBsZW1lbnRhdGlvbiBhYm91dCBTQVNMIHN1Y2Nlc3MuXG4gICAqL1xuICBvblN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBudWxsO1xuICB9XG59O1xuXG4gIC8qKiBDb25zdGFudHM6IFNBU0wgbWVjaGFuaXNtc1xuICAgKiAgQXZhaWxhYmxlIGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbXNcbiAgICpcbiAgICogIFN0cm9waGUuU0FTTEFub255bW91cyAtIFNBU0wgQU5PTllNT1VTIGF1dGhlbnRpY2F0aW9uLlxuICAgKiAgU3Ryb3BoZS5TQVNMUGxhaW4gLSBTQVNMIFBMQUlOIGF1dGhlbnRpY2F0aW9uLlxuICAgKiAgU3Ryb3BoZS5TQVNMTUQ1IC0gU0FTTCBESUdFU1QtTUQ1IGF1dGhlbnRpY2F0aW9uXG4gICAqICBTdHJvcGhlLlNBU0xTSEExIC0gU0FTTCBTQ1JBTS1TSEExIGF1dGhlbnRpY2F0aW9uXG4gICAqICBTdHJvcGhlLlNBU0xPQXV0aEJlYXJlciAtIFNBU0wgT0F1dGggQmVhcmVyIGF1dGhlbnRpY2F0aW9uXG4gICAqICBTdHJvcGhlLlNBU0xFeHRlcm5hbCAtIFNBU0wgRVhURVJOQUwgYXV0aGVudGljYXRpb25cbiAgICovXG5cbi8vIEJ1aWxkaW5nIFNBU0wgY2FsbGJhY2tzXG5cbi8qKiBQcml2YXRlQ29uc3RydWN0b3I6IFNBU0xBbm9ueW1vdXNcbiAqICBTQVNMIEFOT05ZTU9VUyBhdXRoZW50aWNhdGlvbi5cbiAqL1xuU3Ryb3BoZS5TQVNMQW5vbnltb3VzID0gZnVuY3Rpb24oKSB7fTtcblN0cm9waGUuU0FTTEFub255bW91cy5wcm90b3R5cGUgPSBuZXcgU3Ryb3BoZS5TQVNMTWVjaGFuaXNtKFwiQU5PTllNT1VTXCIsIGZhbHNlLCAxMCk7XG5cblN0cm9waGUuU0FTTEFub255bW91cy5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbi5hdXRoY2lkID09PSBudWxsO1xufTtcblxuXG4vKiogUHJpdmF0ZUNvbnN0cnVjdG9yOiBTQVNMUGxhaW5cbiAqICBTQVNMIFBMQUlOIGF1dGhlbnRpY2F0aW9uLlxuICovXG5TdHJvcGhlLlNBU0xQbGFpbiA9IGZ1bmN0aW9uKCkge307XG5TdHJvcGhlLlNBU0xQbGFpbi5wcm90b3R5cGUgPSBuZXcgU3Ryb3BoZS5TQVNMTWVjaGFuaXNtKFwiUExBSU5cIiwgdHJ1ZSwgMjApO1xuXG5TdHJvcGhlLlNBU0xQbGFpbi5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbi5hdXRoY2lkICE9PSBudWxsO1xufTtcblxuU3Ryb3BoZS5TQVNMUGxhaW4ucHJvdG90eXBlLm9uQ2hhbGxlbmdlID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgIHZhciBhdXRoX3N0ciA9IGNvbm5lY3Rpb24uYXV0aHppZDtcbiAgICBhdXRoX3N0ciA9IGF1dGhfc3RyICsgXCJcXHUwMDAwXCI7XG4gICAgYXV0aF9zdHIgPSBhdXRoX3N0ciArIGNvbm5lY3Rpb24uYXV0aGNpZDtcbiAgICBhdXRoX3N0ciA9IGF1dGhfc3RyICsgXCJcXHUwMDAwXCI7XG4gICAgYXV0aF9zdHIgPSBhdXRoX3N0ciArIGNvbm5lY3Rpb24ucGFzcztcbiAgICByZXR1cm4gdXRpbHMudXRmMTZ0bzgoYXV0aF9zdHIpO1xufTtcblxuXG4vKiogUHJpdmF0ZUNvbnN0cnVjdG9yOiBTQVNMU0hBMVxuICogIFNBU0wgU0NSQU0gU0hBIDEgYXV0aGVudGljYXRpb24uXG4gKi9cblN0cm9waGUuU0FTTFNIQTEgPSBmdW5jdGlvbigpIHt9O1xuU3Ryb3BoZS5TQVNMU0hBMS5wcm90b3R5cGUgPSBuZXcgU3Ryb3BoZS5TQVNMTWVjaGFuaXNtKFwiU0NSQU0tU0hBLTFcIiwgdHJ1ZSwgNDApO1xuXG5TdHJvcGhlLlNBU0xTSEExLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgIHJldHVybiBjb25uZWN0aW9uLmF1dGhjaWQgIT09IG51bGw7XG59O1xuXG5TdHJvcGhlLlNBU0xTSEExLnByb3RvdHlwZS5vbkNoYWxsZW5nZSA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIGNoYWxsZW5nZSwgdGVzdF9jbm9uY2UpIHtcbiAgdmFyIGNub25jZSA9IHRlc3RfY25vbmNlIHx8IE1ENS5oZXhkaWdlc3QoTWF0aC5yYW5kb20oKSAqIDEyMzQ1Njc4OTApO1xuICB2YXIgYXV0aF9zdHIgPSBcIm49XCIgKyB1dGlscy51dGYxNnRvOChjb25uZWN0aW9uLmF1dGhjaWQpO1xuICBhdXRoX3N0ciArPSBcIixyPVwiO1xuICBhdXRoX3N0ciArPSBjbm9uY2U7XG4gIGNvbm5lY3Rpb24uX3Nhc2xfZGF0YS5jbm9uY2UgPSBjbm9uY2U7XG4gIGNvbm5lY3Rpb24uX3Nhc2xfZGF0YVtcImNsaWVudC1maXJzdC1tZXNzYWdlLWJhcmVcIl0gPSBhdXRoX3N0cjtcblxuICBhdXRoX3N0ciA9IFwibiwsXCIgKyBhdXRoX3N0cjtcblxuICB0aGlzLm9uQ2hhbGxlbmdlID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIGNoYWxsZW5nZSkge1xuICAgIHZhciBub25jZSwgc2FsdCwgaXRlciwgSGksIFUsIFVfb2xkLCBpLCBrLCBwYXNzO1xuICAgIHZhciBjbGllbnRLZXksIHNlcnZlcktleSwgY2xpZW50U2lnbmF0dXJlO1xuICAgIHZhciByZXNwb25zZVRleHQgPSBcImM9Yml3cyxcIjtcbiAgICB2YXIgYXV0aE1lc3NhZ2UgPSBjb25uZWN0aW9uLl9zYXNsX2RhdGFbXCJjbGllbnQtZmlyc3QtbWVzc2FnZS1iYXJlXCJdICsgXCIsXCIgK1xuICAgICAgY2hhbGxlbmdlICsgXCIsXCI7XG4gICAgdmFyIGNub25jZSA9IGNvbm5lY3Rpb24uX3Nhc2xfZGF0YS5jbm9uY2U7XG4gICAgdmFyIGF0dHJpYk1hdGNoID0gLyhbYS16XSspPShbXixdKykoLHwkKS87XG5cbiAgICB3aGlsZSAoY2hhbGxlbmdlLm1hdGNoKGF0dHJpYk1hdGNoKSkge1xuICAgICAgdmFyIG1hdGNoZXMgPSBjaGFsbGVuZ2UubWF0Y2goYXR0cmliTWF0Y2gpO1xuICAgICAgY2hhbGxlbmdlID0gY2hhbGxlbmdlLnJlcGxhY2UobWF0Y2hlc1swXSwgXCJcIik7XG4gICAgICBzd2l0Y2ggKG1hdGNoZXNbMV0pIHtcbiAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgIG5vbmNlID0gbWF0Y2hlc1syXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICBzYWx0ID0gbWF0Y2hlc1syXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaVwiOlxuICAgICAgICBpdGVyID0gbWF0Y2hlc1syXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vbmNlLnN1YnN0cigwLCBjbm9uY2UubGVuZ3RoKSAhPT0gY25vbmNlKSB7XG4gICAgICBjb25uZWN0aW9uLl9zYXNsX2RhdGEgPSB7fTtcbiAgICAgIHJldHVybiBjb25uZWN0aW9uLl9zYXNsX2ZhaWx1cmVfY2IoKTtcbiAgICB9XG5cbiAgICByZXNwb25zZVRleHQgKz0gXCJyPVwiICsgbm9uY2U7XG4gICAgYXV0aE1lc3NhZ2UgKz0gcmVzcG9uc2VUZXh0O1xuXG4gICAgc2FsdCA9IEJhc2U2NC5kZWNvZGUoc2FsdCk7XG4gICAgc2FsdCArPSBcIlxceDAwXFx4MDBcXHgwMFxceDAxXCI7XG5cbiAgICBwYXNzID0gdXRpbHMudXRmMTZ0bzgoY29ubmVjdGlvbi5wYXNzKTtcbiAgICBIaSA9IFVfb2xkID0gU0hBMS5jb3JlX2htYWNfc2hhMShwYXNzLCBzYWx0KTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgaXRlcjsgaSsrKSB7XG4gICAgICBVID0gU0hBMS5jb3JlX2htYWNfc2hhMShwYXNzLCBTSEExLmJpbmIyc3RyKFVfb2xkKSk7XG4gICAgICBmb3IgKGsgPSAwOyBrIDwgNTsgaysrKSB7XG4gICAgICAgIEhpW2tdIF49IFVba107XG4gICAgICB9XG4gICAgICBVX29sZCA9IFU7XG4gICAgfVxuICAgIEhpID0gU0hBMS5iaW5iMnN0cihIaSk7XG5cbiAgICBjbGllbnRLZXkgPSBTSEExLmNvcmVfaG1hY19zaGExKEhpLCBcIkNsaWVudCBLZXlcIik7XG4gICAgc2VydmVyS2V5ID0gU0hBMS5zdHJfaG1hY19zaGExKEhpLCBcIlNlcnZlciBLZXlcIik7XG4gICAgY2xpZW50U2lnbmF0dXJlID0gU0hBMS5jb3JlX2htYWNfc2hhMShTSEExLnN0cl9zaGExKFNIQTEuYmluYjJzdHIoY2xpZW50S2V5KSksIGF1dGhNZXNzYWdlKTtcbiAgICBjb25uZWN0aW9uLl9zYXNsX2RhdGFbXCJzZXJ2ZXItc2lnbmF0dXJlXCJdID0gU0hBMS5iNjRfaG1hY19zaGExKHNlcnZlcktleSwgYXV0aE1lc3NhZ2UpO1xuXG4gICAgZm9yIChrID0gMDsgayA8IDU7IGsrKykge1xuICAgICAgY2xpZW50S2V5W2tdIF49IGNsaWVudFNpZ25hdHVyZVtrXTtcbiAgICB9XG5cbiAgICByZXNwb25zZVRleHQgKz0gXCIscD1cIiArIEJhc2U2NC5lbmNvZGUoU0hBMS5iaW5iMnN0cihjbGllbnRLZXkpKTtcbiAgICByZXR1cm4gcmVzcG9uc2VUZXh0O1xuICB9LmJpbmQodGhpcyk7XG5cbiAgcmV0dXJuIGF1dGhfc3RyO1xufTtcblxuXG4vKiogUHJpdmF0ZUNvbnN0cnVjdG9yOiBTQVNMTUQ1XG4gKiAgU0FTTCBESUdFU1QgTUQ1IGF1dGhlbnRpY2F0aW9uLlxuICovXG5TdHJvcGhlLlNBU0xNRDUgPSBmdW5jdGlvbigpIHt9O1xuU3Ryb3BoZS5TQVNMTUQ1LnByb3RvdHlwZSA9IG5ldyBTdHJvcGhlLlNBU0xNZWNoYW5pc20oXCJESUdFU1QtTUQ1XCIsIGZhbHNlLCAzMCk7XG5cblN0cm9waGUuU0FTTE1ENS5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbi5hdXRoY2lkICE9PSBudWxsO1xufTtcblxuLyoqIFByaXZhdGVGdW5jdGlvbjogX3F1b3RlXG4gKiAgX1ByaXZhdGVfIHV0aWxpdHkgZnVuY3Rpb24gdG8gYmFja3NsYXNoIGVzY2FwZSBhbmQgcXVvdGUgc3RyaW5ncy5cbiAqXG4gKiAgUGFyYW1ldGVyczpcbiAqICAgIChTdHJpbmcpIHN0ciAtIFRoZSBzdHJpbmcgdG8gYmUgcXVvdGVkLlxuICpcbiAqICBSZXR1cm5zOlxuICogICAgcXVvdGVkIHN0cmluZ1xuICovXG5TdHJvcGhlLlNBU0xNRDUucHJvdG90eXBlLl9xdW90ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gJ1wiJyArIHN0ci5yZXBsYWNlKC9cXFxcL2csIFwiXFxcXFxcXFxcIikucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICsgJ1wiJztcbiAgICAvL1wiIGVuZCBzdHJpbmcgd29ya2Fyb3VuZCBmb3IgZW1hY3Ncbn07XG5cblN0cm9waGUuU0FTTE1ENS5wcm90b3R5cGUub25DaGFsbGVuZ2UgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBjaGFsbGVuZ2UsIHRlc3RfY25vbmNlKSB7XG4gIHZhciBhdHRyaWJNYXRjaCA9IC8oW2Etel0rKT0oXCJbXlwiXStcInxbXixcIl0rKSg/Oix8JCkvO1xuICB2YXIgY25vbmNlID0gdGVzdF9jbm9uY2UgfHwgTUQ1LmhleGRpZ2VzdChcIlwiICsgKE1hdGgucmFuZG9tKCkgKiAxMjM0NTY3ODkwKSk7XG4gIHZhciByZWFsbSA9IFwiXCI7XG4gIHZhciBob3N0ID0gbnVsbDtcbiAgdmFyIG5vbmNlID0gXCJcIjtcbiAgdmFyIHFvcCA9IFwiXCI7XG4gIHZhciBtYXRjaGVzO1xuXG4gIHdoaWxlIChjaGFsbGVuZ2UubWF0Y2goYXR0cmliTWF0Y2gpKSB7XG4gICAgbWF0Y2hlcyA9IGNoYWxsZW5nZS5tYXRjaChhdHRyaWJNYXRjaCk7XG4gICAgY2hhbGxlbmdlID0gY2hhbGxlbmdlLnJlcGxhY2UobWF0Y2hlc1swXSwgXCJcIik7XG4gICAgbWF0Y2hlc1syXSA9IG1hdGNoZXNbMl0ucmVwbGFjZSgvXlwiKC4rKVwiJC8sIFwiJDFcIik7XG4gICAgc3dpdGNoIChtYXRjaGVzWzFdKSB7XG4gICAgY2FzZSBcInJlYWxtXCI6XG4gICAgICByZWFsbSA9IG1hdGNoZXNbMl07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibm9uY2VcIjpcbiAgICAgIG5vbmNlID0gbWF0Y2hlc1syXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJxb3BcIjpcbiAgICAgIHFvcCA9IG1hdGNoZXNbMl07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaG9zdFwiOlxuICAgICAgaG9zdCA9IG1hdGNoZXNbMl07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgZGlnZXN0X3VyaSA9IGNvbm5lY3Rpb24uc2VydnR5cGUgKyBcIi9cIiArIGNvbm5lY3Rpb24uZG9tYWluO1xuICBpZiAoaG9zdCAhPT0gbnVsbCkge1xuICAgIGRpZ2VzdF91cmkgPSBkaWdlc3RfdXJpICsgXCIvXCIgKyBob3N0O1xuICB9XG5cbiAgdmFyIGNyZWQgPSB1dGlscy51dGYxNnRvOChjb25uZWN0aW9uLmF1dGhjaWQgKyBcIjpcIiArIHJlYWxtICsgXCI6XCIgKyB0aGlzLl9jb25uZWN0aW9uLnBhc3MpO1xuICB2YXIgQTEgPSBNRDUuaGFzaChjcmVkKSArIFwiOlwiICsgbm9uY2UgKyBcIjpcIiArIGNub25jZTtcbiAgdmFyIEEyID0gJ0FVVEhFTlRJQ0FURTonICsgZGlnZXN0X3VyaTtcblxuICB2YXIgcmVzcG9uc2VUZXh0ID0gXCJcIjtcbiAgcmVzcG9uc2VUZXh0ICs9ICdjaGFyc2V0PXV0Zi04LCc7XG4gIHJlc3BvbnNlVGV4dCArPSAndXNlcm5hbWU9JyArIHRoaXMuX3F1b3RlKHV0aWxzLnV0ZjE2dG84KGNvbm5lY3Rpb24uYXV0aGNpZCkpICsgJywnO1xuICByZXNwb25zZVRleHQgKz0gJ3JlYWxtPScgKyB0aGlzLl9xdW90ZShyZWFsbSkgKyAnLCc7XG4gIHJlc3BvbnNlVGV4dCArPSAnbm9uY2U9JyArIHRoaXMuX3F1b3RlKG5vbmNlKSArICcsJztcbiAgcmVzcG9uc2VUZXh0ICs9ICduYz0wMDAwMDAwMSwnO1xuICByZXNwb25zZVRleHQgKz0gJ2Nub25jZT0nICsgdGhpcy5fcXVvdGUoY25vbmNlKSArICcsJztcbiAgcmVzcG9uc2VUZXh0ICs9ICdkaWdlc3QtdXJpPScgKyB0aGlzLl9xdW90ZShkaWdlc3RfdXJpKSArICcsJztcbiAgcmVzcG9uc2VUZXh0ICs9ICdyZXNwb25zZT0nICsgTUQ1LmhleGRpZ2VzdChNRDUuaGV4ZGlnZXN0KEExKSArIFwiOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25jZSArIFwiOjAwMDAwMDAxOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbm9uY2UgKyBcIjphdXRoOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNRDUuaGV4ZGlnZXN0KEEyKSkgKyBcIixcIjtcbiAgcmVzcG9uc2VUZXh0ICs9ICdxb3A9YXV0aCc7XG5cbiAgdGhpcy5vbkNoYWxsZW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICB9O1xuICByZXR1cm4gcmVzcG9uc2VUZXh0O1xufTtcblxuXG4vKiogUHJpdmF0ZUNvbnN0cnVjdG9yOiBTQVNMT0F1dGhCZWFyZXJcbiAqICBTQVNMIE9BdXRoIEJlYXJlciBhdXRoZW50aWNhdGlvbi5cbiAqL1xuU3Ryb3BoZS5TQVNMT0F1dGhCZWFyZXIgPSBmdW5jdGlvbigpIHt9O1xuU3Ryb3BoZS5TQVNMT0F1dGhCZWFyZXIucHJvdG90eXBlID0gbmV3IFN0cm9waGUuU0FTTE1lY2hhbmlzbShcIk9BVVRIQkVBUkVSXCIsIHRydWUsIDUwKTtcblxuU3Ryb3BoZS5TQVNMT0F1dGhCZWFyZXIucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb24uYXV0aGNpZCAhPT0gbnVsbDtcbn07XG5cblN0cm9waGUuU0FTTE9BdXRoQmVhcmVyLnByb3RvdHlwZS5vbkNoYWxsZW5nZSA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICB2YXIgYXV0aF9zdHIgPSAnbixhPSc7XG4gICAgYXV0aF9zdHIgPSBhdXRoX3N0ciArIGNvbm5lY3Rpb24uYXV0aHppZDtcbiAgICBhdXRoX3N0ciA9IGF1dGhfc3RyICsgJywnO1xuICAgIGF1dGhfc3RyID0gYXV0aF9zdHIgKyBcIlxcdTAwMDFcIjtcbiAgICBhdXRoX3N0ciA9IGF1dGhfc3RyICsgJ2F1dGg9QmVhcmVyICc7XG4gICAgYXV0aF9zdHIgPSBhdXRoX3N0ciArIGNvbm5lY3Rpb24ucGFzcztcbiAgICBhdXRoX3N0ciA9IGF1dGhfc3RyICsgXCJcXHUwMDAxXCI7XG4gICAgYXV0aF9zdHIgPSBhdXRoX3N0ciArIFwiXFx1MDAwMVwiO1xuICAgIHJldHVybiB1dGlscy51dGYxNnRvOChhdXRoX3N0cik7XG59O1xuXG5cbi8qKiBQcml2YXRlQ29uc3RydWN0b3I6IFNBU0xFeHRlcm5hbFxuICogIFNBU0wgRVhURVJOQUwgYXV0aGVudGljYXRpb24uXG4gKlxuICogIFRoZSBFWFRFUk5BTCBtZWNoYW5pc20gYWxsb3dzIGEgY2xpZW50IHRvIHJlcXVlc3QgdGhlIHNlcnZlciB0byB1c2VcbiAqICBjcmVkZW50aWFscyBlc3RhYmxpc2hlZCBieSBtZWFucyBleHRlcm5hbCB0byB0aGUgbWVjaGFuaXNtIHRvXG4gKiAgYXV0aGVudGljYXRlIHRoZSBjbGllbnQuIFRoZSBleHRlcm5hbCBtZWFucyBtYXkgYmUsIGZvciBpbnN0YW5jZSxcbiAqICBUTFMgc2VydmljZXMuXG4gKi9cblN0cm9waGUuU0FTTEV4dGVybmFsID0gZnVuY3Rpb24oKSB7fTtcblN0cm9waGUuU0FTTEV4dGVybmFsLnByb3RvdHlwZSA9IG5ldyBTdHJvcGhlLlNBU0xNZWNoYW5pc20oXCJFWFRFUk5BTFwiLCB0cnVlLCA2MCk7XG5cblN0cm9waGUuU0FTTEV4dGVybmFsLnByb3RvdHlwZS5vbkNoYWxsZW5nZSA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAvKiogQWNjb3JkaW5nIHRvIFhFUC0xNzgsIGFuIGF1dGh6aWQgU0hPVUxEIE5PVCBiZSBwcmVzZW50ZWQgd2hlbiB0aGVcbiAgICAgKiBhdXRoY2lkIGNvbnRhaW5lZCBvciBpbXBsaWVkIGluIHRoZSBjbGllbnQgY2VydGlmaWNhdGUgaXMgdGhlIEpJRCAoaS5lLlxuICAgICAqIGF1dGh6aWQpIHdpdGggd2hpY2ggdGhlIHVzZXIgd2FudHMgdG8gbG9nIGluIGFzLlxuICAgICAqXG4gICAgICogVG8gTk9UIHNlbmQgdGhlIGF1dGh6aWQsIHRoZSB1c2VyIHNob3VsZCB0aGVyZWZvcmUgc2V0IHRoZSBhdXRoY2lkIGVxdWFsXG4gICAgICogdG8gdGhlIEpJRCB3aGVuIGluc3RhbnRpYXRpbmcgYSBuZXcgU3Ryb3BoZS5Db25uZWN0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICByZXR1cm4gY29ubmVjdGlvbi5hdXRoY2lkID09PSBjb25uZWN0aW9uLmF1dGh6aWQgPyAnJyA6IGNvbm5lY3Rpb24uYXV0aHppZDtcbn07XG5cbnJldHVybiB7XG4gICAgU3Ryb3BoZTogICAgICAgIFN0cm9waGUsXG4gICAgJGJ1aWxkOiAgICAgICAgICRidWlsZCxcbiAgICAkbXNnOiAgICAgICAgICAgJG1zZyxcbiAgICAkaXE6ICAgICAgICAgICAgJGlxLFxuICAgICRwcmVzOiAgICAgICAgICAkcHJlcyxcbiAgICBTSEExOiAgICAgICAgICAgU0hBMSxcbiAgICBCYXNlNjQ6ICAgICAgICAgQmFzZTY0LFxuICAgIE1ENTogICAgICAgICAgICBNRDUsXG59O1xufSkpO1xuXG4vKlxuICAgIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBsaWNlbnNlLlxuICAgIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cblxuICAgIENvcHlyaWdodCAyMDA2LTIwMDgsIE9HRywgTExDXG4qL1xuXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZTosIG5vYXJnOiB0cnVlLCBsYXRlZGVmOiB0cnVlICovXG4vKiBnbG9iYWwgZGVmaW5lLCB3aW5kb3csIHNldFRpbWVvdXQsIGNsZWFyVGltZW91dCwgWE1MSHR0cFJlcXVlc3QsIEFjdGl2ZVhPYmplY3QsIFN0cm9waGUsICRidWlsZCAqL1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3Ryb3BoZS1ib3NoJywgWydzdHJvcGhlLWNvcmUnXSwgZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KFxuICAgICAgICAgICAgICAgIGNvcmUuU3Ryb3BoZSxcbiAgICAgICAgICAgICAgICBjb3JlLiRidWlsZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgICAgIHJldHVybiBmYWN0b3J5KFN0cm9waGUsICRidWlsZCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoU3Ryb3BoZSwgJGJ1aWxkKSB7XG5cbi8qKiBQcml2YXRlQ2xhc3M6IFN0cm9waGUuUmVxdWVzdFxuICogIF9Qcml2YXRlXyBoZWxwZXIgY2xhc3MgdGhhdCBwcm92aWRlcyBhIGNyb3NzIGltcGxlbWVudGF0aW9uIGFic3RyYWN0aW9uXG4gKiAgZm9yIGEgQk9TSCByZWxhdGVkIFhNTEh0dHBSZXF1ZXN0LlxuICpcbiAqICBUaGUgU3Ryb3BoZS5SZXF1ZXN0IGNsYXNzIGlzIHVzZWQgaW50ZXJuYWxseSB0byBlbmNhcHN1bGF0ZSBCT1NIIHJlcXVlc3RcbiAqICBpbmZvcm1hdGlvbi4gIEl0IGlzIG5vdCBtZWFudCB0byBiZSB1c2VkIGZyb20gdXNlcidzIGNvZGUuXG4gKi9cblxuLyoqIFByaXZhdGVDb25zdHJ1Y3RvcjogU3Ryb3BoZS5SZXF1ZXN0XG4gKiAgQ3JlYXRlIGFuZCBpbml0aWFsaXplIGEgbmV3IFN0cm9waGUuUmVxdWVzdCBvYmplY3QuXG4gKlxuICogIFBhcmFtZXRlcnM6XG4gKiAgICAoWE1MRWxlbWVudCkgZWxlbSAtIFRoZSBYTUwgZGF0YSB0byBiZSBzZW50IGluIHRoZSByZXF1ZXN0LlxuICogICAgKEZ1bmN0aW9uKSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGVcbiAqICAgICAgWE1MSHR0cFJlcXVlc3QgcmVhZHlTdGF0ZSBjaGFuZ2VzLlxuICogICAgKEludGVnZXIpIHJpZCAtIFRoZSBCT1NIIHJpZCBhdHRyaWJ1dGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmVxdWVzdC5cbiAqICAgIChJbnRlZ2VyKSBzZW5kcyAtIFRoZSBudW1iZXIgb2YgdGltZXMgdGhpcyBzYW1lIHJlcXVlc3QgaGFzIGJlZW4gc2VudC5cbiAqL1xuU3Ryb3BoZS5SZXF1ZXN0ID0gZnVuY3Rpb24gKGVsZW0sIGZ1bmMsIHJpZCwgc2VuZHMpIHtcbiAgICB0aGlzLmlkID0gKytTdHJvcGhlLl9yZXF1ZXN0SWQ7XG4gICAgdGhpcy54bWxEYXRhID0gZWxlbTtcbiAgICB0aGlzLmRhdGEgPSBTdHJvcGhlLnNlcmlhbGl6ZShlbGVtKTtcbiAgICAvLyBzYXZlIG9yaWdpbmFsIGZ1bmN0aW9uIGluIGNhc2Ugd2UgbmVlZCB0byBtYWtlIGEgbmV3IHJlcXVlc3RcbiAgICAvLyBmcm9tIHRoaXMgb25lLlxuICAgIHRoaXMub3JpZ0Z1bmMgPSBmdW5jO1xuICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgdGhpcy5yaWQgPSByaWQ7XG4gICAgdGhpcy5kYXRlID0gTmFOO1xuICAgIHRoaXMuc2VuZHMgPSBzZW5kcyB8fCAwO1xuICAgIHRoaXMuYWJvcnQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYWQgPSBudWxsO1xuXG4gICAgdGhpcy5hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRlKSB7IHJldHVybiAwOyB9XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gKG5vdyAtIHRoaXMuZGF0ZSkgLyAxMDAwO1xuICAgIH07XG4gICAgdGhpcy50aW1lRGVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlYWQpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHJldHVybiAobm93IC0gdGhpcy5kZWFkKSAvIDEwMDA7XG4gICAgfTtcbiAgICB0aGlzLnhociA9IHRoaXMuX25ld1hIUigpO1xufTtcblxuU3Ryb3BoZS5SZXF1ZXN0LnByb3RvdHlwZSA9IHtcbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBnZXRSZXNwb25zZVxuICAgICAqICBHZXQgYSByZXNwb25zZSBmcm9tIHRoZSB1bmRlcmx5aW5nIFhNTEh0dHBSZXF1ZXN0LlxuICAgICAqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gYXR0ZW1wdHMgdG8gZ2V0IGEgcmVzcG9uc2UgZnJvbSB0aGUgcmVxdWVzdCBhbmQgY2hlY2tzXG4gICAgICogIGZvciBlcnJvcnMuXG4gICAgICpcbiAgICAgKiAgVGhyb3dzOlxuICAgICAqICAgIFwicGFyc2VyZXJyb3JcIiAtIEEgcGFyc2VyIGVycm9yIG9jY3VyZWQuXG4gICAgICogICAgXCJiYWRmb3JtYXRcIiAtIFRoZSBlbnRpdHkgaGFzIHNlbnQgWE1MIHRoYXQgY2Fubm90IGJlIHByb2Nlc3NlZC5cbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIFRoZSBET00gZWxlbWVudCB0cmVlIG9mIHRoZSByZXNwb25zZS5cbiAgICAgKi9cbiAgICBnZXRSZXNwb25zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnhoci5yZXNwb25zZVhNTCAmJiB0aGlzLnhoci5yZXNwb25zZVhNTC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLnhoci5yZXNwb25zZVhNTC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lID09IFwicGFyc2VyZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIFN0cm9waGUuZXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlIHJlY2VpdmVkXCIpO1xuICAgICAgICAgICAgICAgIFN0cm9waGUuZXJyb3IoXCJyZXNwb25zZVRleHQ6IFwiICsgdGhpcy54aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBTdHJvcGhlLmVycm9yKFwicmVzcG9uc2VYTUw6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cm9waGUuc2VyaWFsaXplKHRoaXMueGhyLnJlc3BvbnNlWE1MKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJwYXJzZXJlcnJvclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMueGhyLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgU3Ryb3BoZS5lcnJvcihcImludmFsaWQgcmVzcG9uc2UgcmVjZWl2ZWRcIik7XG4gICAgICAgICAgICBTdHJvcGhlLmVycm9yKFwicmVzcG9uc2VUZXh0OiBcIiArIHRoaXMueGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB0aHJvdyBcImJhZGZvcm1hdFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9uZXdYSFJcbiAgICAgKiAgX1ByaXZhdGVfIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgWE1MSHR0cFJlcXVlc3RzLlxuICAgICAqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBYTUxIdHRwUmVxdWVzdHMgYWNyb3NzIGFsbCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBBIG5ldyBYTUxIdHRwUmVxdWVzdC5cbiAgICAgKi9cbiAgICBfbmV3WEhSOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB4aHIgPSBudWxsO1xuICAgICAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgICAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIGlmICh4aHIub3ZlcnJpZGVNaW1lVHlwZSkge1xuICAgICAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKFwidGV4dC94bWw7IGNoYXJzZXQ9dXRmLThcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgICAgIHhociA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXNlIEZ1bmN0aW9uLmJpbmQoKSB0byBwcmVwZW5kIG91cnNlbHZlcyBhcyBhbiBhcmd1bWVudFxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5mdW5jLmJpbmQobnVsbCwgdGhpcyk7XG4gICAgICAgIHJldHVybiB4aHI7XG4gICAgfVxufTtcblxuLyoqIENsYXNzOiBTdHJvcGhlLkJvc2hcbiAqICBfUHJpdmF0ZV8gaGVscGVyIGNsYXNzIHRoYXQgaGFuZGxlcyBCT1NIIENvbm5lY3Rpb25zXG4gKlxuICogIFRoZSBTdHJvcGhlLkJvc2ggY2xhc3MgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IFN0cm9waGUuQ29ubmVjdGlvblxuICogIHRvIGVuY2Fwc3VsYXRlIEJPU0ggc2Vzc2lvbnMuIEl0IGlzIG5vdCBtZWFudCB0byBiZSB1c2VkIGZyb20gdXNlcidzIGNvZGUuXG4gKi9cblxuLyoqIEZpbGU6IGJvc2guanNcbiAqICBBIEphdmFTY3JpcHQgbGlicmFyeSB0byBlbmFibGUgQk9TSCBpbiBTdHJvcGhlanMuXG4gKlxuICogIHRoaXMgbGlicmFyeSB1c2VzIEJpZGlyZWN0aW9uYWwtc3RyZWFtcyBPdmVyIFN5bmNocm9ub3VzIEhUVFAgKEJPU0gpXG4gKiAgdG8gZW11bGF0ZSBhIHBlcnNpc3RlbnQsIHN0YXRlZnVsLCB0d28td2F5IGNvbm5lY3Rpb24gdG8gYW4gWE1QUCBzZXJ2ZXIuXG4gKiAgTW9yZSBpbmZvcm1hdGlvbiBvbiBCT1NIIGNhbiBiZSBmb3VuZCBpbiBYRVAgMTI0LlxuICovXG5cbi8qKiBQcml2YXRlQ29uc3RydWN0b3I6IFN0cm9waGUuQm9zaFxuICogIENyZWF0ZSBhbmQgaW5pdGlhbGl6ZSBhIFN0cm9waGUuQm9zaCBvYmplY3QuXG4gKlxuICogIFBhcmFtZXRlcnM6XG4gKiAgICAoU3Ryb3BoZS5Db25uZWN0aW9uKSBjb25uZWN0aW9uIC0gVGhlIFN0cm9waGUuQ29ubmVjdGlvbiB0aGF0IHdpbGwgdXNlIEJPU0guXG4gKlxuICogIFJldHVybnM6XG4gKiAgICBBIG5ldyBTdHJvcGhlLkJvc2ggb2JqZWN0LlxuICovXG5TdHJvcGhlLkJvc2ggPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgdGhpcy5fY29ubiA9IGNvbm5lY3Rpb247XG4gICAgLyogcmVxdWVzdCBpZCBmb3IgYm9keSB0YWdzICovXG4gICAgdGhpcy5yaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0Mjk0OTY3Mjk1KTtcbiAgICAvKiBUaGUgY3VycmVudCBzZXNzaW9uIElELiAqL1xuICAgIHRoaXMuc2lkID0gbnVsbDtcblxuICAgIC8vIGRlZmF1bHQgQk9TSCB2YWx1ZXNcbiAgICB0aGlzLmhvbGQgPSAxO1xuICAgIHRoaXMud2FpdCA9IDYwO1xuICAgIHRoaXMud2luZG93ID0gNTtcbiAgICB0aGlzLmVycm9ycyA9IDA7XG4gICAgdGhpcy5pbmFjdGl2aXR5ID0gbnVsbDtcblxuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG59O1xuXG5TdHJvcGhlLkJvc2gucHJvdG90eXBlID0ge1xuICAgIC8qKiBWYXJpYWJsZTogc3RyaXBcbiAgICAgKlxuICAgICAqICBCT1NILUNvbm5lY3Rpb25zIHdpbGwgaGF2ZSBhbGwgc3RhbnphcyB3cmFwcGVkIGluIGEgPGJvZHk+IHRhZyB3aGVuXG4gICAgICogIHBhc3NlZCB0byA8U3Ryb3BoZS5Db25uZWN0aW9uLnhtbElucHV0PiBvciA8U3Ryb3BoZS5Db25uZWN0aW9uLnhtbE91dHB1dD4uXG4gICAgICogIFRvIHN0cmlwIHRoaXMgdGFnLCBVc2VyIGNvZGUgY2FuIHNldCA8U3Ryb3BoZS5Cb3NoLnN0cmlwPiB0byBcImJvZHlcIjpcbiAgICAgKlxuICAgICAqICA+IFN0cm9waGUuQm9zaC5wcm90b3R5cGUuc3RyaXAgPSBcImJvZHlcIjtcbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgZW5hYmxlIHN0cmlwcGluZyBvZiB0aGUgYm9keSB0YWcgaW4gYm90aFxuICAgICAqICA8U3Ryb3BoZS5Db25uZWN0aW9uLnhtbElucHV0PiBhbmQgPFN0cm9waGUuQ29ubmVjdGlvbi54bWxPdXRwdXQ+LlxuICAgICAqL1xuICAgIHN0cmlwOiBudWxsLFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2J1aWxkQm9keVxuICAgICAqICBfUHJpdmF0ZV8gaGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSA8Ym9keS8+IHdyYXBwZXIgZm9yIEJPU0guXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBBIFN0cm9waGUuQnVpbGRlciB3aXRoIGEgPGJvZHkvPiBlbGVtZW50LlxuICAgICAqL1xuICAgIF9idWlsZEJvZHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJvZHlXcmFwID0gJGJ1aWxkKCdib2R5Jywge1xuICAgICAgICAgICAgcmlkOiB0aGlzLnJpZCsrLFxuICAgICAgICAgICAgeG1sbnM6IFN0cm9waGUuTlMuSFRUUEJJTkRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnNpZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYm9keVdyYXAuYXR0cnMoe3NpZDogdGhpcy5zaWR9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29ubi5vcHRpb25zLmtlZXBhbGl2ZSAmJiB0aGlzLl9jb25uLl9zZXNzaW9uQ2FjaGluZ1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVNlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9keVdyYXA7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9yZXNldFxuICAgICAqICBSZXNldCB0aGUgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB0aGUgcmVzZXQgZnVuY3Rpb24gb2YgdGhlIFN0cm9waGUgQ29ubmVjdGlvblxuICAgICAqL1xuICAgIF9yZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQyOTQ5NjcyOTUpO1xuICAgICAgICB0aGlzLnNpZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gMDtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm4uX3Nlc3Npb25DYWNoaW5nU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKCdzdHJvcGhlLWJvc2gtc2Vzc2lvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29ubi5uZXh0VmFsaWRSaWQodGhpcy5yaWQpO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfY29ubmVjdFxuICAgICAqICBfUHJpdmF0ZV8gZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB0aGUgQk9TSCBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogIENyZWF0ZXMgYW5kIHNlbmRzIHRoZSBSZXF1ZXN0IHRoYXQgaW5pdGlhbGl6ZXMgdGhlIEJPU0ggY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBfY29ubmVjdDogZnVuY3Rpb24gKHdhaXQsIGhvbGQsIHJvdXRlKSB7XG4gICAgICAgIHRoaXMud2FpdCA9IHdhaXQgfHwgdGhpcy53YWl0O1xuICAgICAgICB0aGlzLmhvbGQgPSBob2xkIHx8IHRoaXMuaG9sZDtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSAwO1xuXG4gICAgICAgIC8vIGJ1aWxkIHRoZSBib2R5IHRhZ1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMuX2J1aWxkQm9keSgpLmF0dHJzKHtcbiAgICAgICAgICAgIHRvOiB0aGlzLl9jb25uLmRvbWFpbixcbiAgICAgICAgICAgIFwieG1sOmxhbmdcIjogXCJlblwiLFxuICAgICAgICAgICAgd2FpdDogdGhpcy53YWl0LFxuICAgICAgICAgICAgaG9sZDogdGhpcy5ob2xkLFxuICAgICAgICAgICAgY29udGVudDogXCJ0ZXh0L3htbDsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAgICAgdmVyOiBcIjEuNlwiLFxuICAgICAgICAgICAgXCJ4bXBwOnZlcnNpb25cIjogXCIxLjBcIixcbiAgICAgICAgICAgIFwieG1sbnM6eG1wcFwiOiBTdHJvcGhlLk5TLkJPU0hcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYocm91dGUpe1xuICAgICAgICAgICAgYm9keS5hdHRycyh7XG4gICAgICAgICAgICAgICAgcm91dGU6IHJvdXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfY29ubmVjdF9jYiA9IHRoaXMuX2Nvbm4uX2Nvbm5lY3RfY2I7XG5cbiAgICAgICAgdGhpcy5fcmVxdWVzdHMucHVzaChcbiAgICAgICAgICAgIG5ldyBTdHJvcGhlLlJlcXVlc3QoYm9keS50cmVlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uUmVxdWVzdFN0YXRlQ2hhbmdlLmJpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLCBfY29ubmVjdF9jYi5iaW5kKHRoaXMuX2Nvbm4pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS50cmVlKCkuZ2V0QXR0cmlidXRlKFwicmlkXCIpKSk7XG4gICAgICAgIHRoaXMuX3Rocm90dGxlZFJlcXVlc3RIYW5kbGVyKCk7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9hdHRhY2hcbiAgICAgKiAgQXR0YWNoIHRvIGFuIGFscmVhZHkgY3JlYXRlZCBhbmQgYXV0aGVudGljYXRlZCBCT1NIIHNlc3Npb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBhbGxvdyBTdHJvcGhlIHRvIGF0dGFjaCB0byBCT1NIXG4gICAgICogIHNlc3Npb25zIHdoaWNoIGhhdmUgYmVlbiBjcmVhdGVkIGV4dGVybmFsbHksIHBlcmhhcHMgYnkgYSBXZWJcbiAgICAgKiAgYXBwbGljYXRpb24uICBUaGlzIGlzIG9mdGVuIHVzZWQgdG8gc3VwcG9ydCBhdXRvLWxvZ2luIHR5cGUgZmVhdHVyZXNcbiAgICAgKiAgd2l0aG91dCBwdXR0aW5nIHVzZXIgY3JlZGVudGlhbHMgaW50byB0aGUgcGFnZS5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJpbmcpIGppZCAtIFRoZSBmdWxsIEpJRCB0aGF0IGlzIGJvdW5kIGJ5IHRoZSBzZXNzaW9uLlxuICAgICAqICAgIChTdHJpbmcpIHNpZCAtIFRoZSBTSUQgb2YgdGhlIEJPU0ggc2Vzc2lvbi5cbiAgICAgKiAgICAoU3RyaW5nKSByaWQgLSBUaGUgY3VycmVudCBSSUQgb2YgdGhlIEJPU0ggc2Vzc2lvbi4gIFRoaXMgUklEXG4gICAgICogICAgICB3aWxsIGJlIHVzZWQgYnkgdGhlIG5leHQgcmVxdWVzdC5cbiAgICAgKiAgICAoRnVuY3Rpb24pIGNhbGxiYWNrIFRoZSBjb25uZWN0IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqICAgIChJbnRlZ2VyKSB3YWl0IC0gVGhlIG9wdGlvbmFsIEhUVFBCSU5EIHdhaXQgdmFsdWUuICBUaGlzIGlzIHRoZVxuICAgICAqICAgICAgdGltZSB0aGUgc2VydmVyIHdpbGwgd2FpdCBiZWZvcmUgcmV0dXJuaW5nIGFuIGVtcHR5IHJlc3VsdCBmb3JcbiAgICAgKiAgICAgIGEgcmVxdWVzdC4gIFRoZSBkZWZhdWx0IHNldHRpbmcgb2YgNjAgc2Vjb25kcyBpcyByZWNvbW1lbmRlZC5cbiAgICAgKiAgICAgIE90aGVyIHNldHRpbmdzIHdpbGwgcmVxdWlyZSB0d2Vha3MgdG8gdGhlIFN0cm9waGUuVElNRU9VVCB2YWx1ZS5cbiAgICAgKiAgICAoSW50ZWdlcikgaG9sZCAtIFRoZSBvcHRpb25hbCBIVFRQQklORCBob2xkIHZhbHVlLiAgVGhpcyBpcyB0aGVcbiAgICAgKiAgICAgIG51bWJlciBvZiBjb25uZWN0aW9ucyB0aGUgc2VydmVyIHdpbGwgaG9sZCBhdCBvbmUgdGltZS4gIFRoaXNcbiAgICAgKiAgICAgIHNob3VsZCBhbG1vc3QgYWx3YXlzIGJlIHNldCB0byAxICh0aGUgZGVmYXVsdCkuXG4gICAgICogICAgKEludGVnZXIpIHdpbmQgLSBUaGUgb3B0aW9uYWwgSFRUQklORCB3aW5kb3cgdmFsdWUuICBUaGlzIGlzIHRoZVxuICAgICAqICAgICAgYWxsb3dlZCByYW5nZSBvZiByZXF1ZXN0IGlkcyB0aGF0IGFyZSB2YWxpZC4gIFRoZSBkZWZhdWx0IGlzIDUuXG4gICAgICovXG4gICAgX2F0dGFjaDogZnVuY3Rpb24gKGppZCwgc2lkLCByaWQsIGNhbGxiYWNrLCB3YWl0LCBob2xkLCB3aW5kKSB7XG4gICAgICAgIHRoaXMuX2Nvbm4uamlkID0gamlkO1xuICAgICAgICB0aGlzLnNpZCA9IHNpZDtcbiAgICAgICAgdGhpcy5yaWQgPSByaWQ7XG5cbiAgICAgICAgdGhpcy5fY29ubi5jb25uZWN0X2NhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICAgICAgdGhpcy5fY29ubi5kb21haW4gPSBTdHJvcGhlLmdldERvbWFpbkZyb21KaWQodGhpcy5fY29ubi5qaWQpO1xuXG4gICAgICAgIHRoaXMuX2Nvbm4uYXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Nvbm4uY29ubmVjdGVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLndhaXQgPSB3YWl0IHx8IHRoaXMud2FpdDtcbiAgICAgICAgdGhpcy5ob2xkID0gaG9sZCB8fCB0aGlzLmhvbGQ7XG4gICAgICAgIHRoaXMud2luZG93ID0gd2luZCB8fCB0aGlzLndpbmRvdztcblxuICAgICAgICB0aGlzLl9jb25uLl9jaGFuZ2VDb25uZWN0U3RhdHVzKFN0cm9waGUuU3RhdHVzLkFUVEFDSEVELCBudWxsKTtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX3Jlc3RvcmVcbiAgICAgKiAgQXR0ZW1wdCB0byByZXN0b3JlIGEgY2FjaGVkIEJPU0ggc2Vzc2lvblxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cmluZykgamlkIC0gVGhlIGZ1bGwgSklEIHRoYXQgaXMgYm91bmQgYnkgdGhlIHNlc3Npb24uXG4gICAgICogICAgICBUaGlzIHBhcmFtZXRlciBpcyBvcHRpb25hbCBidXQgcmVjb21tZW5kZWQsIHNwZWNpZmljYWxseSBpbiBjYXNlc1xuICAgICAqICAgICAgd2hlcmUgcHJlYmluZGVkIEJPU0ggc2Vzc2lvbnMgYXJlIHVzZWQgd2hlcmUgaXQncyBpbXBvcnRhbnQgdG8ga25vd1xuICAgICAqICAgICAgdGhhdCB0aGUgcmlnaHQgc2Vzc2lvbiBpcyBiZWluZyByZXN0b3JlZC5cbiAgICAgKiAgICAoRnVuY3Rpb24pIGNhbGxiYWNrIFRoZSBjb25uZWN0IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqICAgIChJbnRlZ2VyKSB3YWl0IC0gVGhlIG9wdGlvbmFsIEhUVFBCSU5EIHdhaXQgdmFsdWUuICBUaGlzIGlzIHRoZVxuICAgICAqICAgICAgdGltZSB0aGUgc2VydmVyIHdpbGwgd2FpdCBiZWZvcmUgcmV0dXJuaW5nIGFuIGVtcHR5IHJlc3VsdCBmb3JcbiAgICAgKiAgICAgIGEgcmVxdWVzdC4gIFRoZSBkZWZhdWx0IHNldHRpbmcgb2YgNjAgc2Vjb25kcyBpcyByZWNvbW1lbmRlZC5cbiAgICAgKiAgICAgIE90aGVyIHNldHRpbmdzIHdpbGwgcmVxdWlyZSB0d2Vha3MgdG8gdGhlIFN0cm9waGUuVElNRU9VVCB2YWx1ZS5cbiAgICAgKiAgICAoSW50ZWdlcikgaG9sZCAtIFRoZSBvcHRpb25hbCBIVFRQQklORCBob2xkIHZhbHVlLiAgVGhpcyBpcyB0aGVcbiAgICAgKiAgICAgIG51bWJlciBvZiBjb25uZWN0aW9ucyB0aGUgc2VydmVyIHdpbGwgaG9sZCBhdCBvbmUgdGltZS4gIFRoaXNcbiAgICAgKiAgICAgIHNob3VsZCBhbG1vc3QgYWx3YXlzIGJlIHNldCB0byAxICh0aGUgZGVmYXVsdCkuXG4gICAgICogICAgKEludGVnZXIpIHdpbmQgLSBUaGUgb3B0aW9uYWwgSFRUQklORCB3aW5kb3cgdmFsdWUuICBUaGlzIGlzIHRoZVxuICAgICAqICAgICAgYWxsb3dlZCByYW5nZSBvZiByZXF1ZXN0IGlkcyB0aGF0IGFyZSB2YWxpZC4gIFRoZSBkZWZhdWx0IGlzIDUuXG4gICAgICovXG4gICAgX3Jlc3RvcmU6IGZ1bmN0aW9uIChqaWQsIGNhbGxiYWNrLCB3YWl0LCBob2xkLCB3aW5kKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gSlNPTi5wYXJzZSh3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnc3Ryb3BoZS1ib3NoLXNlc3Npb24nKSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgIHNlc3Npb24gIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJpZCAmJlxuICAgICAgICAgICAgICAgICAgIHNlc3Npb24uc2lkICYmXG4gICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5qaWQgJiZcbiAgICAgICAgICAgICAgICAgICAoICAgIHR5cGVvZiBqaWQgPT09IFwidW5kZWZpbmVkXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGppZCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgU3Ryb3BoZS5nZXRCYXJlSmlkRnJvbUppZChzZXNzaW9uLmppZCkgPT0gU3Ryb3BoZS5nZXRCYXJlSmlkRnJvbUppZChqaWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhdXRoY2lkIGlzIG51bGwsIHRoZW4gaXQncyBhbiBhbm9ueW1vdXMgbG9naW4sIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjb21wYXJlIG9ubHkgdGhlIGRvbWFpbnM6XG4gICAgICAgICAgICAgICAgICAgICAgICAoKFN0cm9waGUuZ2V0Tm9kZUZyb21KaWQoamlkKSA9PT0gbnVsbCkgJiYgKFN0cm9waGUuZ2V0RG9tYWluRnJvbUppZChzZXNzaW9uLmppZCkgPT0gamlkKSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm4ucmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoKHNlc3Npb24uamlkLCBzZXNzaW9uLnNpZCwgc2Vzc2lvbi5yaWQsIGNhbGxiYWNrLCB3YWl0LCBob2xkLCB3aW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHsgbmFtZTogXCJTdHJvcGhlU2Vzc2lvbkVycm9yXCIsIG1lc3NhZ2U6IFwiX3Jlc3RvcmU6IG5vIHJlc3RvcmVhYmxlIHNlc3Npb24uXCIgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfY2FjaGVTZXNzaW9uXG4gICAgICogIF9Qcml2YXRlXyBoYW5kbGVyIGZvciB0aGUgYmVmb3JldW5sb2FkIGV2ZW50LlxuICAgICAqXG4gICAgICogIFRoaXMgaGFuZGxlciBpcyB1c2VkIHRvIHByb2Nlc3MgdGhlIEJvc2gtcGFydCBvZiB0aGUgaW5pdGlhbCByZXF1ZXN0LlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJvcGhlLlJlcXVlc3QpIGJvZHlXcmFwIC0gVGhlIHJlY2VpdmVkIHN0YW56YS5cbiAgICAgKi9cbiAgICBfY2FjaGVTZXNzaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb25uLmF1dGhlbnRpY2F0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb25uLmppZCAmJiB0aGlzLnJpZCAmJiB0aGlzLnNpZCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdzdHJvcGhlLWJvc2gtc2Vzc2lvbicsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgJ2ppZCc6IHRoaXMuX2Nvbm4uamlkLFxuICAgICAgICAgICAgICAgICAgICAncmlkJzogdGhpcy5yaWQsXG4gICAgICAgICAgICAgICAgICAgICdzaWQnOiB0aGlzLnNpZFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKCdzdHJvcGhlLWJvc2gtc2Vzc2lvbicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9jb25uZWN0X2NiXG4gICAgICogIF9Qcml2YXRlXyBoYW5kbGVyIGZvciBpbml0aWFsIGNvbm5lY3Rpb24gcmVxdWVzdC5cbiAgICAgKlxuICAgICAqICBUaGlzIGhhbmRsZXIgaXMgdXNlZCB0byBwcm9jZXNzIHRoZSBCb3NoLXBhcnQgb2YgdGhlIGluaXRpYWwgcmVxdWVzdC5cbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoU3Ryb3BoZS5SZXF1ZXN0KSBib2R5V3JhcCAtIFRoZSByZWNlaXZlZCBzdGFuemEuXG4gICAgICovXG4gICAgX2Nvbm5lY3RfY2I6IGZ1bmN0aW9uIChib2R5V3JhcCkge1xuICAgICAgICB2YXIgdHlwID0gYm9keVdyYXAuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcbiAgICAgICAgdmFyIGNvbmQsIGNvbmZsaWN0O1xuICAgICAgICBpZiAodHlwICE9PSBudWxsICYmIHR5cCA9PSBcInRlcm1pbmF0ZVwiKSB7XG4gICAgICAgICAgICAvLyBhbiBlcnJvciBvY2N1cnJlZFxuICAgICAgICAgICAgY29uZCA9IGJvZHlXcmFwLmdldEF0dHJpYnV0ZShcImNvbmRpdGlvblwiKTtcbiAgICAgICAgICAgIFN0cm9waGUuZXJyb3IoXCJCT1NILUNvbm5lY3Rpb24gZmFpbGVkOiBcIiArIGNvbmQpO1xuICAgICAgICAgICAgY29uZmxpY3QgPSBib2R5V3JhcC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNvbmZsaWN0XCIpO1xuICAgICAgICAgICAgaWYgKGNvbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZCA9PSBcInJlbW90ZS1zdHJlYW0tZXJyb3JcIiAmJiBjb25mbGljdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmQgPSBcImNvbmZsaWN0XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm4uX2NoYW5nZUNvbm5lY3RTdGF0dXMoU3Ryb3BoZS5TdGF0dXMuQ09OTkZBSUwsIGNvbmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uLl9jaGFuZ2VDb25uZWN0U3RhdHVzKFN0cm9waGUuU3RhdHVzLkNPTk5GQUlMLCBcInVua25vd25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jb25uLl9kb0Rpc2Nvbm5lY3QoY29uZCk7XG4gICAgICAgICAgICByZXR1cm4gU3Ryb3BoZS5TdGF0dXMuQ09OTkZBSUw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayB0byBtYWtlIHN1cmUgd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZXNlIGlmIF9jb25uZWN0X2NiIGlzXG4gICAgICAgIC8vIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIHN0cmVhbTpmZWF0dXJlc1xuICAgICAgICBpZiAoIXRoaXMuc2lkKSB7XG4gICAgICAgICAgICB0aGlzLnNpZCA9IGJvZHlXcmFwLmdldEF0dHJpYnV0ZShcInNpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2luZCA9IGJvZHlXcmFwLmdldEF0dHJpYnV0ZSgncmVxdWVzdHMnKTtcbiAgICAgICAgaWYgKHdpbmQpIHsgdGhpcy53aW5kb3cgPSBwYXJzZUludCh3aW5kLCAxMCk7IH1cbiAgICAgICAgdmFyIGhvbGQgPSBib2R5V3JhcC5nZXRBdHRyaWJ1dGUoJ2hvbGQnKTtcbiAgICAgICAgaWYgKGhvbGQpIHsgdGhpcy5ob2xkID0gcGFyc2VJbnQoaG9sZCwgMTApOyB9XG4gICAgICAgIHZhciB3YWl0ID0gYm9keVdyYXAuZ2V0QXR0cmlidXRlKCd3YWl0Jyk7XG4gICAgICAgIGlmICh3YWl0KSB7IHRoaXMud2FpdCA9IHBhcnNlSW50KHdhaXQsIDEwKTsgfVxuICAgICAgICB2YXIgaW5hY3Rpdml0eSA9IGJvZHlXcmFwLmdldEF0dHJpYnV0ZSgnaW5hY3Rpdml0eScpO1xuICAgICAgICBpZiAoaW5hY3Rpdml0eSkgeyB0aGlzLmluYWN0aXZpdHkgPSBwYXJzZUludChpbmFjdGl2aXR5LCAxMCk7IH1cbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2Rpc2Nvbm5lY3RcbiAgICAgKiAgX1ByaXZhdGVfIHBhcnQgb2YgQ29ubmVjdGlvbi5kaXNjb25uZWN0IGZvciBCb3NoXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoUmVxdWVzdCkgcHJlcyAtIFRoaXMgc3RhbnphIHdpbGwgYmUgc2VudCBiZWZvcmUgZGlzY29ubmVjdGluZy5cbiAgICAgKi9cbiAgICBfZGlzY29ubmVjdDogZnVuY3Rpb24gKHByZXMpIHtcbiAgICAgICAgdGhpcy5fc2VuZFRlcm1pbmF0ZShwcmVzKTtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2RvRGlzY29ubmVjdFxuICAgICAqICBfUHJpdmF0ZV8gZnVuY3Rpb24gdG8gZGlzY29ubmVjdC5cbiAgICAgKlxuICAgICAqICBSZXNldHMgdGhlIFNJRCBhbmQgUklELlxuICAgICAqL1xuICAgIF9kb0Rpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zaWQgPSBudWxsO1xuICAgICAgICB0aGlzLnJpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQyOTQ5NjcyOTUpO1xuICAgICAgICBpZiAodGhpcy5fY29ubi5fc2Vzc2lvbkNhY2hpbmdTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ3N0cm9waGUtYm9zaC1zZXNzaW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb25uLm5leHRWYWxpZFJpZCh0aGlzLnJpZCk7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9lbXB0eVF1ZXVlXG4gICAgICogX1ByaXZhdGVfIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBSZXF1ZXN0IHF1ZXVlIGlzIGVtcHR5LlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgVHJ1ZSwgaWYgdGhlcmUgYXJlIG5vIFJlcXVlc3RzIHF1ZXVlZCwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIF9lbXB0eVF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPT09IDA7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9jYWxsUHJvdG9jb2xFcnJvckhhbmRsZXJzXG4gICAgICogIF9Qcml2YXRlXyBmdW5jdGlvbiB0byBjYWxsIGVycm9yIGhhbmRsZXJzIHJlZ2lzdGVyZWQgZm9yIEhUVFAgZXJyb3JzLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cm9waGUuUmVxdWVzdCkgcmVxIC0gVGhlIHJlcXVlc3QgdGhhdCBpcyBjaGFuZ2luZyByZWFkeVN0YXRlLlxuICAgICAqL1xuICAgIF9jYWxsUHJvdG9jb2xFcnJvckhhbmRsZXJzOiBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIHZhciByZXFTdGF0dXMgPSB0aGlzLl9nZXRSZXF1ZXN0U3RhdHVzKHJlcSksXG4gICAgICAgICAgICBlcnJfY2FsbGJhY2s7XG4gICAgICAgIGVycl9jYWxsYmFjayA9IHRoaXMuX2Nvbm4ucHJvdG9jb2xFcnJvckhhbmRsZXJzLkhUVFBbcmVxU3RhdHVzXTtcbiAgICAgICAgaWYgKGVycl9jYWxsYmFjaykge1xuICAgICAgICAgICAgZXJyX2NhbGxiYWNrLmNhbGwodGhpcywgcmVxU3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfaGl0RXJyb3JcbiAgICAgKiAgX1ByaXZhdGVfIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgZXJyb3IgY291bnQuXG4gICAgICpcbiAgICAgKiAgUmVxdWVzdHMgYXJlIHJlc2VudCBhdXRvbWF0aWNhbGx5IHVudGlsIHRoZWlyIGVycm9yIGNvdW50IHJlYWNoZXNcbiAgICAgKiAgNS4gIEVhY2ggdGltZSBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgdG9cbiAgICAgKiAgaW5jcmVtZW50IHRoZSBjb3VudCBhbmQgZGlzY29ubmVjdCBpZiB0aGUgY291bnQgaXMgdG9vIGhpZ2guXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoSW50ZWdlcikgcmVxU3RhdHVzIC0gVGhlIHJlcXVlc3Qgc3RhdHVzLlxuICAgICAqL1xuICAgIF9oaXRFcnJvcjogZnVuY3Rpb24gKHJlcVN0YXR1cykge1xuICAgICAgICB0aGlzLmVycm9ycysrO1xuICAgICAgICBTdHJvcGhlLndhcm4oXCJyZXF1ZXN0IGVycm9yZWQsIHN0YXR1czogXCIgKyByZXFTdGF0dXMgK1xuICAgICAgICAgICAgICAgICAgICAgXCIsIG51bWJlciBvZiBlcnJvcnM6IFwiICsgdGhpcy5lcnJvcnMpO1xuICAgICAgICBpZiAodGhpcy5lcnJvcnMgPiA0KSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uLl9vbkRpc2Nvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX25vX2F1dGhfcmVjZWl2ZWRcbiAgICAgKlxuICAgICAqIENhbGxlZCBvbiBzdHJlYW0gc3RhcnQvcmVzdGFydCB3aGVuIG5vIHN0cmVhbTpmZWF0dXJlc1xuICAgICAqIGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBzZW5kcyBhIGJsYW5rIHBvbGwgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBfbm9fYXV0aF9yZWNlaXZlZDogZnVuY3Rpb24gKF9jYWxsYmFjaykge1xuICAgICAgICBpZiAoX2NhbGxiYWNrKSB7XG4gICAgICAgICAgICBfY2FsbGJhY2sgPSBfY2FsbGJhY2suYmluZCh0aGlzLl9jb25uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9jYWxsYmFjayA9IHRoaXMuX2Nvbm4uX2Nvbm5lY3RfY2IuYmluZCh0aGlzLl9jb25uKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm9keSA9IHRoaXMuX2J1aWxkQm9keSgpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBTdHJvcGhlLlJlcXVlc3QoYm9keS50cmVlKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uUmVxdWVzdFN0YXRlQ2hhbmdlLmJpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLCBfY2FsbGJhY2suYmluZCh0aGlzLl9jb25uKSksXG4gICAgICAgICAgICAgICAgICAgIGJvZHkudHJlZSgpLmdldEF0dHJpYnV0ZShcInJpZFwiKSkpO1xuICAgICAgICB0aGlzLl90aHJvdHRsZWRSZXF1ZXN0SGFuZGxlcigpO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfb25EaXNjb25uZWN0VGltZW91dFxuICAgICAqICBfUHJpdmF0ZV8gdGltZW91dCBoYW5kbGVyIGZvciBoYW5kbGluZyBub24tZ3JhY2VmdWwgZGlzY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqICBDYW5jZWxzIGFsbCByZW1haW5pbmcgUmVxdWVzdHMgYW5kIGNsZWFycyB0aGUgcXVldWUuXG4gICAgICovXG4gICAgX29uRGlzY29ubmVjdFRpbWVvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWJvcnRBbGxSZXF1ZXN0cygpO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfYWJvcnRBbGxSZXF1ZXN0c1xuICAgICAqICBfUHJpdmF0ZV8gaGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFrZXMgc3VyZSBhbGwgcGVuZGluZyByZXF1ZXN0cyBhcmUgYWJvcnRlZC5cbiAgICAgKi9cbiAgICBfYWJvcnRBbGxSZXF1ZXN0czogZnVuY3Rpb24gX2Fib3J0QWxsUmVxdWVzdHMoKSB7XG4gICAgICAgIHZhciByZXE7XG4gICAgICAgIHdoaWxlICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXEgPSB0aGlzLl9yZXF1ZXN0cy5wb3AoKTtcbiAgICAgICAgICAgIHJlcS5hYm9ydCA9IHRydWU7XG4gICAgICAgICAgICByZXEueGhyLmFib3J0KCk7XG4gICAgICAgICAgICAvLyBqc2xpbnQgY29tcGxhaW5zLCBidXQgdGhpcyBpcyBmaW5lLiBzZXR0aW5nIHRvIGVtcHR5IGZ1bmNcbiAgICAgICAgICAgIC8vIGlzIG5lY2Vzc2FyeSBmb3IgSUU2XG4gICAgICAgICAgICByZXEueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHt9OyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfb25JZGxlXG4gICAgICogIF9Qcml2YXRlXyBoYW5kbGVyIGNhbGxlZCBieSBTdHJvcGhlLkNvbm5lY3Rpb24uX29uSWRsZVxuICAgICAqXG4gICAgICogIFNlbmRzIGFsbCBxdWV1ZWQgUmVxdWVzdHMgb3IgcG9sbHMgd2l0aCBlbXB0eSBSZXF1ZXN0IGlmIHRoZXJlIGFyZSBub25lLlxuICAgICAqL1xuICAgIF9vbklkbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9jb25uLl9kYXRhO1xuICAgICAgICAvLyBpZiBubyByZXF1ZXN0cyBhcmUgaW4gcHJvZ3Jlc3MsIHBvbGxcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm4uYXV0aGVudGljYXRlZCAmJiB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgIGRhdGEubGVuZ3RoID09PSAwICYmICF0aGlzLl9jb25uLmRpc2Nvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIFN0cm9waGUuaW5mbyhcIm5vIHJlcXVlc3RzIGR1cmluZyBpZGxlIGN5Y2xlLCBzZW5kaW5nIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBcImJsYW5rIHJlcXVlc3RcIik7XG4gICAgICAgICAgICBkYXRhLnB1c2gobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY29ubi5wYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPCAyICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLl9idWlsZEJvZHkoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09PSBcInJlc3RhcnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5hdHRycyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMuX2Nvbm4uZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieG1sOmxhbmdcIjogXCJlblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieG1wcDpyZXN0YXJ0XCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieG1sbnM6eG1wcFwiOiBTdHJvcGhlLk5TLkJPU0hcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5jbm9kZShkYXRhW2ldKS51cCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Nvbm4uX2RhdGE7XG4gICAgICAgICAgICB0aGlzLl9jb25uLl9kYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBTdHJvcGhlLlJlcXVlc3QoYm9keS50cmVlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblJlcXVlc3RTdGF0ZUNoYW5nZS5iaW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsIHRoaXMuX2Nvbm4uX2RhdGFSZWN2LmJpbmQodGhpcy5fY29ubikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS50cmVlKCkuZ2V0QXR0cmlidXRlKFwicmlkXCIpKSk7XG4gICAgICAgICAgICB0aGlzLl90aHJvdHRsZWRSZXF1ZXN0SGFuZGxlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciB0aW1lX2VsYXBzZWQgPSB0aGlzLl9yZXF1ZXN0c1swXS5hZ2UoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0c1swXS5kZWFkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RzWzBdLnRpbWVEZWFkKCkgPlxuICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKFN0cm9waGUuU0VDT05EQVJZX1RJTUVPVVQgKiB0aGlzLndhaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rocm90dGxlZFJlcXVlc3RIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGltZV9lbGFwc2VkID4gTWF0aC5mbG9vcihTdHJvcGhlLlRJTUVPVVQgKiB0aGlzLndhaXQpKSB7XG4gICAgICAgICAgICAgICAgU3Ryb3BoZS53YXJuKFwiUmVxdWVzdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzWzBdLmlkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgdGltZWQgb3V0LCBvdmVyIFwiICsgTWF0aC5mbG9vcihTdHJvcGhlLlRJTUVPVVQgKiB0aGlzLndhaXQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgc2Vjb25kcyBzaW5jZSBsYXN0IGFjdGl2aXR5XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm90dGxlZFJlcXVlc3RIYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2dldFJlcXVlc3RTdGF0dXNcbiAgICAgKlxuICAgICAqICBSZXR1cm5zIHRoZSBIVFRQIHN0YXR1cyBjb2RlIGZyb20gYSBTdHJvcGhlLlJlcXVlc3RcbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJvcGhlLlJlcXVlc3QpIHJlcSAtIFRoZSBTdHJvcGhlLlJlcXVlc3QgaW5zdGFuY2UuXG4gICAgICogICAgKEludGVnZXIpIGRlZiAtIFRoZSBkZWZhdWx0IHZhbHVlIHRoYXQgc2hvdWxkIGJlIHJldHVybmVkIGlmIG5vXG4gICAgICogICAgICAgICAgc3RhdHVzIHZhbHVlIHdhcyBmb3VuZC5cbiAgICAgKi9cbiAgICBfZ2V0UmVxdWVzdFN0YXR1czogZnVuY3Rpb24gKHJlcSwgZGVmKSB7XG4gICAgICAgIHZhciByZXFTdGF0dXM7XG4gICAgICAgIGlmIChyZXEueGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXFTdGF0dXMgPSByZXEueGhyLnN0YXR1cztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGZyb20gdW5kZWZpbmVkIHN0YXR1cyBhdHRyaWJ1dGUuIFdvcmtzXG4gICAgICAgICAgICAgICAgLy8gYXJvdW5kIGEgYnJvd3NlciBidWdcbiAgICAgICAgICAgICAgICBTdHJvcGhlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkNhdWdodCBhbiBlcnJvciB3aGlsZSByZXRyaWV2aW5nIGEgcmVxdWVzdCdzIHN0YXR1cywgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInJlcVN0YXR1czogXCIgKyByZXFTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YocmVxU3RhdHVzKSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXFTdGF0dXMgPSB0eXBlb2YgZGVmID09PSAnbnVtYmVyJyA/IGRlZiA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcVN0YXR1cztcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX29uUmVxdWVzdFN0YXRlQ2hhbmdlXG4gICAgICogIF9Qcml2YXRlXyBoYW5kbGVyIGZvciBTdHJvcGhlLlJlcXVlc3Qgc3RhdGUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHRoZSBYTUxIdHRwUmVxdWVzdCByZWFkeVN0YXRlIGNoYW5nZXMuXG4gICAgICogIEl0IGNvbnRhaW5zIGEgbG90IG9mIGVycm9yIGhhbmRsaW5nIGxvZ2ljIGZvciB0aGUgbWFueSB3YXlzIHRoYXRcbiAgICAgKiAgcmVxdWVzdHMgY2FuIGZhaWwsIGFuZCBjYWxscyB0aGUgcmVxdWVzdCBjYWxsYmFjayB3aGVuIHJlcXVlc3RzXG4gICAgICogIHN1Y2NlZWQuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoRnVuY3Rpb24pIGZ1bmMgLSBUaGUgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogICAgKFN0cm9waGUuUmVxdWVzdCkgcmVxIC0gVGhlIHJlcXVlc3QgdGhhdCBpcyBjaGFuZ2luZyByZWFkeVN0YXRlLlxuICAgICAqL1xuICAgIF9vblJlcXVlc3RTdGF0ZUNoYW5nZTogZnVuY3Rpb24gKGZ1bmMsIHJlcSkge1xuICAgICAgICBTdHJvcGhlLmRlYnVnKFwicmVxdWVzdCBpZCBcIityZXEuaWQrXCIuXCIrcmVxLnNlbmRzK1xuICAgICAgICAgICAgICAgICAgICAgIFwiIHN0YXRlIGNoYW5nZWQgdG8gXCIrcmVxLnhoci5yZWFkeVN0YXRlKTtcbiAgICAgICAgaWYgKHJlcS5hYm9ydCkge1xuICAgICAgICAgICAgcmVxLmFib3J0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcS54aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgaXMgbm90IHlldCBjb21wbGV0ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXFTdGF0dXMgPSB0aGlzLl9nZXRSZXF1ZXN0U3RhdHVzKHJlcSk7XG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RpbmcgJiYgcmVxU3RhdHVzID49IDQwMCkge1xuICAgICAgICAgICAgdGhpcy5faGl0RXJyb3IocmVxU3RhdHVzKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxQcm90b2NvbEVycm9ySGFuZGxlcnMocmVxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgocmVxU3RhdHVzID4gMCAmJiByZXFTdGF0dXMgPCA1MDApIHx8IHJlcS5zZW5kcyA+IDUpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIGludGVybmFsIHF1ZXVlXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVSZXF1ZXN0KHJlcSk7XG4gICAgICAgICAgICBTdHJvcGhlLmRlYnVnKFwicmVxdWVzdCBpZCBcIityZXEuaWQrXCIgc2hvdWxkIG5vdyBiZSByZW1vdmVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcVN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgIC8vIHJlcXVlc3Qgc3VjY2VlZGVkXG4gICAgICAgICAgICB2YXIgcmVxSXMwID0gKHRoaXMuX3JlcXVlc3RzWzBdID09IHJlcSk7XG4gICAgICAgICAgICB2YXIgcmVxSXMxID0gKHRoaXMuX3JlcXVlc3RzWzFdID09IHJlcSk7XG4gICAgICAgICAgICAvLyBpZiByZXF1ZXN0IDEgZmluaXNoZWQsIG9yIHJlcXVlc3QgMCBmaW5pc2hlZCBhbmQgcmVxdWVzdFxuICAgICAgICAgICAgLy8gMSBpcyBvdmVyIFN0cm9waGUuU0VDT05EQVJZX1RJTUVPVVQgc2Vjb25kcyBvbGQsIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHJlc3RhcnQgdGhlIG90aGVyIC0gYm90aCB3aWxsIGJlIGluIHRoZSBmaXJzdCBzcG90LCBhcyB0aGVcbiAgICAgICAgICAgIC8vIGNvbXBsZXRlZCByZXF1ZXN0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcXVldWUgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKHJlcUlzMSB8fFxuICAgICAgICAgICAgICAgIChyZXFJczAgJiYgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0c1swXS5hZ2UoKSA+IE1hdGguZmxvb3IoU3Ryb3BoZS5TRUNPTkRBUllfVElNRU9VVCAqIHRoaXMud2FpdCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzdGFydFJlcXVlc3QoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jb25uLm5leHRWYWxpZFJpZChOdW1iZXIocmVxLnJpZCkgKyAxKTtcbiAgICAgICAgICAgIFN0cm9waGUuZGVidWcoXCJyZXF1ZXN0IGlkIFwiK3JlcS5pZCtcIi5cIityZXEuc2VuZHMrXCIgZ290IDIwMFwiKTtcbiAgICAgICAgICAgIGZ1bmMocmVxKTsgLy8gY2FsbCBoYW5kbGVyXG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocmVxU3RhdHVzID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgKHJlcVN0YXR1cyA+PSA0MDAgJiYgcmVxU3RhdHVzIDwgNjAwKSB8fFxuICAgICAgICAgICAgICAgICAgIHJlcVN0YXR1cyA+PSAxMjAwMCkge1xuICAgICAgICAgICAgLy8gcmVxdWVzdCBmYWlsZWRcbiAgICAgICAgICAgIFN0cm9waGUuZXJyb3IoXCJyZXF1ZXN0IGlkIFwiK3JlcS5pZCtcIi5cIityZXEuc2VuZHMrXCIgZXJyb3IgXCIrcmVxU3RhdHVzK1wiIGhhcHBlbmVkXCIpO1xuICAgICAgICAgICAgdGhpcy5faGl0RXJyb3IocmVxU3RhdHVzKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxQcm90b2NvbEVycm9ySGFuZGxlcnMocmVxKTtcbiAgICAgICAgICAgIGlmIChyZXFTdGF0dXMgPj0gNDAwICYmIHJlcVN0YXR1cyA8IDUwMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm4uX2NoYW5nZUNvbm5lY3RTdGF0dXMoU3Ryb3BoZS5TdGF0dXMuRElTQ09OTkVDVElORywgbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubi5fZG9EaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBTdHJvcGhlLmVycm9yKFwicmVxdWVzdCBpZCBcIityZXEuaWQrXCIuXCIrcmVxLnNlbmRzK1wiIGVycm9yIFwiK3JlcVN0YXR1cytcIiBoYXBwZW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShyZXFTdGF0dXMgPiAwICYmIHJlcVN0YXR1cyA8IDUwMCkgfHwgcmVxLnNlbmRzID4gNSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3R0bGVkUmVxdWVzdEhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfcHJvY2Vzc1JlcXVlc3RcbiAgICAgKiAgX1ByaXZhdGVfIGZ1bmN0aW9uIHRvIHByb2Nlc3MgYSByZXF1ZXN0IGluIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIHRha2VzIHJlcXVlc3RzIG9mZiB0aGUgcXVldWUgYW5kIHNlbmRzIHRoZW0gYW5kXG4gICAgICogIHJlc3RhcnRzIGRlYWQgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoSW50ZWdlcikgaSAtIFRoZSBpbmRleCBvZiB0aGUgcmVxdWVzdCBpbiB0aGUgcXVldWUuXG4gICAgICovXG4gICAgX3Byb2Nlc3NSZXF1ZXN0OiBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciByZXEgPSB0aGlzLl9yZXF1ZXN0c1tpXTtcbiAgICAgICAgdmFyIHJlcVN0YXR1cyA9IHRoaXMuX2dldFJlcXVlc3RTdGF0dXMocmVxLCAtMSk7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGxpbWl0IHRoZSBudW1iZXIgb2YgcmV0cmllc1xuICAgICAgICBpZiAocmVxLnNlbmRzID4gdGhpcy5fY29ubi5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uLl9vbkRpc2Nvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGltZV9lbGFwc2VkID0gcmVxLmFnZSgpO1xuICAgICAgICB2YXIgcHJpbWFyeVRpbWVvdXQgPSAoIWlzTmFOKHRpbWVfZWxhcHNlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVfZWxhcHNlZCA+IE1hdGguZmxvb3IoU3Ryb3BoZS5USU1FT1VUICogdGhpcy53YWl0KSk7XG4gICAgICAgIHZhciBzZWNvbmRhcnlUaW1lb3V0ID0gKHJlcS5kZWFkICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS50aW1lRGVhZCgpID4gTWF0aC5mbG9vcihTdHJvcGhlLlNFQ09OREFSWV9USU1FT1VUICogdGhpcy53YWl0KSk7XG4gICAgICAgIHZhciByZXF1ZXN0Q29tcGxldGVkV2l0aFNlcnZlckVycm9yID0gKHJlcS54aHIucmVhZHlTdGF0ZSA9PSA0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXFTdGF0dXMgPCAxIHx8IHJlcVN0YXR1cyA+PSA1MDApKTtcbiAgICAgICAgaWYgKHByaW1hcnlUaW1lb3V0IHx8IHNlY29uZGFyeVRpbWVvdXQgfHxcbiAgICAgICAgICAgIHJlcXVlc3RDb21wbGV0ZWRXaXRoU2VydmVyRXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChzZWNvbmRhcnlUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgU3Ryb3BoZS5lcnJvcihcIlJlcXVlc3QgXCIgKyB0aGlzLl9yZXF1ZXN0c1tpXS5pZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiB0aW1lZCBvdXQgKHNlY29uZGFyeSksIHJlc3RhcnRpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEuYWJvcnQgPSB0cnVlO1xuICAgICAgICAgICAgcmVxLnhoci5hYm9ydCgpO1xuICAgICAgICAgICAgLy8gc2V0dGluZyB0byBudWxsIGZhaWxzIG9uIElFNiwgc28gc2V0IHRvIGVtcHR5IGZ1bmN0aW9uXG4gICAgICAgICAgICByZXEueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHNbaV0gPSBuZXcgU3Ryb3BoZS5SZXF1ZXN0KHJlcS54bWxEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vcmlnRnVuYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEucmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5zZW5kcyk7XG4gICAgICAgICAgICByZXEgPSB0aGlzLl9yZXF1ZXN0c1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXEueGhyLnJlYWR5U3RhdGUgPT09IDApIHtcbiAgICAgICAgICAgIFN0cm9waGUuZGVidWcoXCJyZXF1ZXN0IGlkIFwiK3JlcS5pZCtcIi5cIityZXEuc2VuZHMrXCIgcG9zdGluZ1wiKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSB0aGlzLl9jb25uLm9wdGlvbnMuY29udGVudFR5cGUgfHwgXCJ0ZXh0L3htbDsgY2hhcnNldD11dGYtOFwiO1xuICAgICAgICAgICAgICAgIHJlcS54aHIub3BlbihcIlBPU1RcIiwgdGhpcy5fY29ubi5zZXJ2aWNlLCB0aGlzLl9jb25uLm9wdGlvbnMuc3luYyA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXEueGhyLnNldFJlcXVlc3RIZWFkZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElFOSBkb2Vzbid0IGhhdmUgc2V0UmVxdWVzdEhlYWRlclxuICAgICAgICAgICAgICAgICAgICByZXEueGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgY29udGVudFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29ubi5vcHRpb25zLndpdGhDcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgICAgICByZXEueGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgICBTdHJvcGhlLmVycm9yKFwiWEhSIG9wZW4gZmFpbGVkLlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2Nvbm4uY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm4uX2NoYW5nZUNvbm5lY3RTdGF0dXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3Ryb3BoZS5TdGF0dXMuQ09OTkZBSUwsIFwiYmFkLXNlcnZpY2VcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm4uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlyZXMgdGhlIFhIUiByZXF1ZXN0IC0tIG1heSBiZSBpbnZva2VkIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAvLyBvciBvbiBhIGdyYWR1YWxseSBleHBhbmRpbmcgcmV0cnkgd2luZG93IGZvciByZWNvbm5lY3RzXG4gICAgICAgICAgICB2YXIgc2VuZEZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVxLmRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9jb25uLm9wdGlvbnMuY3VzdG9tSGVhZGVycyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0gc2VsZi5fY29ubi5vcHRpb25zLmN1c3RvbUhlYWRlcnM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXEueGhyLnNlbmQocmVxLmRhdGEpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gSW1wbGVtZW50IHByb2dyZXNzaXZlIGJhY2tvZmYgZm9yIHJlY29ubmVjdHMgLS1cbiAgICAgICAgICAgIC8vIEZpcnN0IHJldHJ5IChzZW5kID09IDEpIHNob3VsZCBhbHNvIGJlIGluc3RhbnRhbmVvdXNcbiAgICAgICAgICAgIGlmIChyZXEuc2VuZHMgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNpbmcgYSBjdWJlIG9mIHRoZSByZXRyeSBudW1iZXIgY3JlYXRlcyBhIG5pY2VseVxuICAgICAgICAgICAgICAgIC8vIGV4cGFuZGluZyByZXRyeSB3aW5kb3dcbiAgICAgICAgICAgICAgICB2YXIgYmFja29mZiA9IE1hdGgubWluKE1hdGguZmxvb3IoU3Ryb3BoZS5USU1FT1VUICogdGhpcy53YWl0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93KHJlcS5zZW5kcywgMykpICogMTAwMDtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBYWFg6IHNldFRpbWVvdXQgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IHdpdGggZnVuY3Rpb24gZXhwcmVzc2lvbnMgKDIzOTc0YmMxKVxuICAgICAgICAgICAgICAgICAgICBzZW5kRnVuYygpO1xuICAgICAgICAgICAgICAgIH0sIGJhY2tvZmYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZW5kRnVuYygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXEuc2VuZHMrKztcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2Nvbm4ueG1sT3V0cHV0ICE9PSBTdHJvcGhlLkNvbm5lY3Rpb24ucHJvdG90eXBlLnhtbE91dHB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXEueG1sRGF0YS5ub2RlTmFtZSA9PT0gdGhpcy5zdHJpcCAmJiByZXEueG1sRGF0YS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uLnhtbE91dHB1dChyZXEueG1sRGF0YS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uLnhtbE91dHB1dChyZXEueG1sRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2Nvbm4ucmF3T3V0cHV0ICE9PSBTdHJvcGhlLkNvbm5lY3Rpb24ucHJvdG90eXBlLnJhd091dHB1dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm4ucmF3T3V0cHV0KHJlcS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFN0cm9waGUuZGVidWcoXCJfcHJvY2Vzc1JlcXVlc3Q6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGkgPT09IDAgPyBcImZpcnN0XCIgOiBcInNlY29uZFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHJlcXVlc3QgaGFzIHJlYWR5U3RhdGUgb2YgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXEueGhyLnJlYWR5U3RhdGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9yZW1vdmVSZXF1ZXN0XG4gICAgICogIF9Qcml2YXRlXyBmdW5jdGlvbiB0byByZW1vdmUgYSByZXF1ZXN0IGZyb20gdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKFN0cm9waGUuUmVxdWVzdCkgcmVxIC0gVGhlIHJlcXVlc3QgdG8gcmVtb3ZlLlxuICAgICAqL1xuICAgIF9yZW1vdmVSZXF1ZXN0OiBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIFN0cm9waGUuZGVidWcoXCJyZW1vdmluZyByZXF1ZXN0XCIpO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gdGhpcy5fcmVxdWVzdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChyZXEgPT0gdGhpcy5fcmVxdWVzdHNbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSUU2IGZhaWxzIG9uIHNldHRpbmcgdG8gbnVsbCwgc28gc2V0IHRvIGVtcHR5IGZ1bmN0aW9uXG4gICAgICAgIHJlcS54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIHRoaXMuX3Rocm90dGxlZFJlcXVlc3RIYW5kbGVyKCk7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9yZXN0YXJ0UmVxdWVzdFxuICAgICAqICBfUHJpdmF0ZV8gZnVuY3Rpb24gdG8gcmVzdGFydCBhIHJlcXVlc3QgdGhhdCBpcyBwcmVzdW1lZCBkZWFkLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKEludGVnZXIpIGkgLSBUaGUgaW5kZXggb2YgdGhlIHJlcXVlc3QgaW4gdGhlIHF1ZXVlLlxuICAgICAqL1xuICAgIF9yZXN0YXJ0UmVxdWVzdDogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIHJlcSA9IHRoaXMuX3JlcXVlc3RzW2ldO1xuICAgICAgICBpZiAocmVxLmRlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlcS5kZWFkID0gbmV3IERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NSZXF1ZXN0KGkpO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfcmVxVG9EYXRhXG4gICAgICogX1ByaXZhdGVfIGZ1bmN0aW9uIHRvIGdldCBhIHN0YW56YSBvdXQgb2YgYSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogVHJpZXMgdG8gZXh0cmFjdCBhIHN0YW56YSBvdXQgb2YgYSBSZXF1ZXN0IE9iamVjdC5cbiAgICAgKiBXaGVuIHRoaXMgZmFpbHMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiB3aWxsIGJlIGRpc2Nvbm5lY3RlZC5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChPYmplY3QpIHJlcSAtIFRoZSBSZXF1ZXN0LlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgVGhlIHN0YW56YSB0aGF0IHdhcyBwYXNzZWQuXG4gICAgICovXG4gICAgX3JlcVRvRGF0YTogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcS5nZXRSZXNwb25zZSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSAhPSBcInBhcnNlcmVycm9yXCIpIHsgdGhyb3cgZTsgfVxuICAgICAgICAgICAgdGhpcy5fY29ubi5kaXNjb25uZWN0KFwic3Ryb3BoZS1wYXJzZXJlcnJvclwiKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfc2VuZFRlcm1pbmF0ZVxuICAgICAqICBfUHJpdmF0ZV8gZnVuY3Rpb24gdG8gc2VuZCBpbml0aWFsIGRpc2Nvbm5lY3Qgc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB0aGUgZmlyc3Qgc3RlcCBpbiBhIGdyYWNlZnVsIGRpc2Nvbm5lY3QuICBJdCBzZW5kc1xuICAgICAqICB0aGUgQk9TSCBzZXJ2ZXIgYSB0ZXJtaW5hdGUgYm9keSBhbmQgaW5jbHVkZXMgYW4gdW5hdmFpbGFibGVcbiAgICAgKiAgcHJlc2VuY2UgaWYgYXV0aGVudGljYXRpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBfc2VuZFRlcm1pbmF0ZTogZnVuY3Rpb24gKHByZXMpIHtcbiAgICAgICAgU3Ryb3BoZS5pbmZvKFwiX3NlbmRUZXJtaW5hdGUgd2FzIGNhbGxlZFwiKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLl9idWlsZEJvZHkoKS5hdHRycyh7dHlwZTogXCJ0ZXJtaW5hdGVcIn0pO1xuICAgICAgICBpZiAocHJlcykge1xuICAgICAgICAgICAgYm9keS5jbm9kZShwcmVzLnRyZWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcSA9IG5ldyBTdHJvcGhlLlJlcXVlc3QoXG4gICAgICAgICAgICBib2R5LnRyZWUoKSxcbiAgICAgICAgICAgIHRoaXMuX29uUmVxdWVzdFN0YXRlQ2hhbmdlLmJpbmQoXG4gICAgICAgICAgICB0aGlzLCB0aGlzLl9jb25uLl9kYXRhUmVjdi5iaW5kKHRoaXMuX2Nvbm4pKSxcbiAgICAgICAgICAgIGJvZHkudHJlZSgpLmdldEF0dHJpYnV0ZShcInJpZFwiKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcSk7XG4gICAgICAgIHRoaXMuX3Rocm90dGxlZFJlcXVlc3RIYW5kbGVyKCk7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9zZW5kXG4gICAgICogIF9Qcml2YXRlXyBwYXJ0IG9mIHRoZSBDb25uZWN0aW9uLnNlbmQgZnVuY3Rpb24gZm9yIEJPU0hcbiAgICAgKlxuICAgICAqIEp1c3QgdHJpZ2dlcnMgdGhlIFJlcXVlc3RIYW5kbGVyIHRvIHNlbmQgdGhlIG1lc3NhZ2VzIHRoYXQgYXJlIGluIHRoZSBxdWV1ZVxuICAgICAqL1xuICAgIF9zZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jb25uLl9pZGxlVGltZW91dCk7XG4gICAgICAgIHRoaXMuX3Rocm90dGxlZFJlcXVlc3RIYW5kbGVyKCk7XG5cbiAgICAgICAgLy8gWFhYOiBzZXRUaW1lb3V0IHNob3VsZCBiZSBjYWxsZWQgb25seSB3aXRoIGZ1bmN0aW9uIGV4cHJlc3Npb25zICgyMzk3NGJjMSlcbiAgICAgICAgdGhpcy5fY29ubi5faWRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fb25JZGxlKCk7XG4gICAgICAgIH0uYmluZCh0aGlzLl9jb25uKSwgMTAwKTtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX3NlbmRSZXN0YXJ0XG4gICAgICpcbiAgICAgKiAgU2VuZCBhbiB4bXBwOnJlc3RhcnQgc3RhbnphLlxuICAgICAqL1xuICAgIF9zZW5kUmVzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90aHJvdHRsZWRSZXF1ZXN0SGFuZGxlcigpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fY29ubi5faWRsZVRpbWVvdXQpO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfdGhyb3R0bGVkUmVxdWVzdEhhbmRsZXJcbiAgICAgKiAgX1ByaXZhdGVfIGZ1bmN0aW9uIHRvIHRocm90dGxlIHJlcXVlc3RzIHRvIHRoZSBjb25uZWN0aW9uIHdpbmRvdy5cbiAgICAgKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgd2UgZG9uJ3Qgc2VuZCByZXF1ZXN0cyBzbyBmYXN0IHRoYXQgdGhlXG4gICAgICogIHJlcXVlc3QgaWRzIG92ZXJmbG93IHRoZSBjb25uZWN0aW9uIHdpbmRvdyBpbiB0aGUgY2FzZSB0aGF0IG9uZVxuICAgICAqICByZXF1ZXN0IGRpZWQuXG4gICAgICovXG4gICAgX3Rocm90dGxlZFJlcXVlc3RIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgICAgICAgIFN0cm9waGUuZGVidWcoXCJfdGhyb3R0bGVkUmVxdWVzdEhhbmRsZXIgY2FsbGVkIHdpdGggXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcInVuZGVmaW5lZCByZXF1ZXN0c1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFN0cm9waGUuZGVidWcoXCJfdGhyb3R0bGVkUmVxdWVzdEhhbmRsZXIgY2FsbGVkIHdpdGggXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggKyBcIiByZXF1ZXN0c1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdHMgfHwgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1JlcXVlc3QoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5fcmVxdWVzdHNbMF0ucmlkIC1cbiAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzWzFdLnJpZCkgPCB0aGlzLndpbmRvdykge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1JlcXVlc3QoMSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xucmV0dXJuIFN0cm9waGU7XG59KSk7XG5cbi8qXG4gICAgVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIGxpY2Vuc2UuXG4gICAgUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuXG4gICAgQ29weXJpZ2h0IDIwMDYtMjAwOCwgT0dHLCBMTENcbiovXG5cbi8qIGpzaGludCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlOiwgbm9hcmc6IHRydWUsIGxhdGVkZWY6IHRydWUgKi9cbi8qIGdsb2JhbCBkZWZpbmUsIHdpbmRvdywgY2xlYXJUaW1lb3V0LCBXZWJTb2NrZXQsIERPTVBhcnNlciwgU3Ryb3BoZSwgJGJ1aWxkICovXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdzdHJvcGhlLXdlYnNvY2tldCcsIFsnc3Ryb3BoZS1jb3JlJ10sIGZ1bmN0aW9uIChjb3JlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeShcbiAgICAgICAgICAgICAgICBjb3JlLlN0cm9waGUsXG4gICAgICAgICAgICAgICAgY29yZS4kYnVpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgICAgICByZXR1cm4gZmFjdG9yeShTdHJvcGhlLCAkYnVpbGQpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKFN0cm9waGUsICRidWlsZCkge1xuXG4vKiogQ2xhc3M6IFN0cm9waGUuV2ViU29ja2V0XG4gKiAgX1ByaXZhdGVfIGhlbHBlciBjbGFzcyB0aGF0IGhhbmRsZXMgV2ViU29ja2V0IENvbm5lY3Rpb25zXG4gKlxuICogIFRoZSBTdHJvcGhlLldlYlNvY2tldCBjbGFzcyBpcyB1c2VkIGludGVybmFsbHkgYnkgU3Ryb3BoZS5Db25uZWN0aW9uXG4gKiAgdG8gZW5jYXBzdWxhdGUgV2ViU29ja2V0IHNlc3Npb25zLiBJdCBpcyBub3QgbWVhbnQgdG8gYmUgdXNlZCBmcm9tIHVzZXIncyBjb2RlLlxuICovXG5cbi8qKiBGaWxlOiB3ZWJzb2NrZXQuanNcbiAqICBBIEphdmFTY3JpcHQgbGlicmFyeSB0byBlbmFibGUgWE1QUCBvdmVyIFdlYnNvY2tldCBpbiBTdHJvcGhlanMuXG4gKlxuICogIFRoaXMgZmlsZSBpbXBsZW1lbnRzIFhNUFAgb3ZlciBXZWJTb2NrZXRzIGZvciBTdHJvcGhlanMuXG4gKiAgSWYgYSBDb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIHdpdGggYSBXZWJzb2NrZXQgdXJsICh3czovLy4uLilcbiAqICBTdHJvcGhlIHdpbGwgdXNlIFdlYlNvY2tldHMuXG4gKiAgRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gWE1QUC1vdmVyLVdlYlNvY2tldCBzZWUgUkZDIDczOTU6XG4gKiAgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzM5NVxuICpcbiAqICBXZWJTb2NrZXQgc3VwcG9ydCBpbXBsZW1lbnRlZCBieSBBbmRyZWFzIEd1dGggKGFuZHJlYXMuZ3V0aEByd3RoLWFhY2hlbi5kZSlcbiAqL1xuXG4vKiogUHJpdmF0ZUNvbnN0cnVjdG9yOiBTdHJvcGhlLldlYnNvY2tldFxuICogIENyZWF0ZSBhbmQgaW5pdGlhbGl6ZSBhIFN0cm9waGUuV2ViU29ja2V0IG9iamVjdC5cbiAqICBDdXJyZW50bHkgb25seSBzZXRzIHRoZSBjb25uZWN0aW9uIE9iamVjdC5cbiAqXG4gKiAgUGFyYW1ldGVyczpcbiAqICAgIChTdHJvcGhlLkNvbm5lY3Rpb24pIGNvbm5lY3Rpb24gLSBUaGUgU3Ryb3BoZS5Db25uZWN0aW9uIHRoYXQgd2lsbCB1c2UgV2ViU29ja2V0cy5cbiAqXG4gKiAgUmV0dXJuczpcbiAqICAgIEEgbmV3IFN0cm9waGUuV2ViU29ja2V0IG9iamVjdC5cbiAqL1xuU3Ryb3BoZS5XZWJzb2NrZXQgPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgdGhpcy5fY29ubiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5zdHJpcCA9IFwid3JhcHBlclwiO1xuXG4gICAgdmFyIHNlcnZpY2UgPSBjb25uZWN0aW9uLnNlcnZpY2U7XG4gICAgaWYgKHNlcnZpY2UuaW5kZXhPZihcIndzOlwiKSAhPT0gMCAmJiBzZXJ2aWNlLmluZGV4T2YoXCJ3c3M6XCIpICE9PSAwKSB7XG4gICAgICAgIC8vIElmIHRoZSBzZXJ2aWNlIGlzIG5vdCBhbiBhYnNvbHV0ZSBVUkwsIGFzc3VtZSBpdCBpcyBhIHBhdGggYW5kIHB1dCB0aGUgYWJzb2x1dGVcbiAgICAgICAgLy8gVVJMIHRvZ2V0aGVyIGZyb20gb3B0aW9ucywgY3VycmVudCBVUkwgYW5kIHRoZSBwYXRoLlxuICAgICAgICB2YXIgbmV3X3NlcnZpY2UgPSBcIlwiO1xuXG4gICAgICAgIGlmIChjb25uZWN0aW9uLm9wdGlvbnMucHJvdG9jb2wgPT09IFwid3NcIiAmJiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIpIHtcbiAgICAgICAgICAgIG5ld19zZXJ2aWNlICs9IFwid3NcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld19zZXJ2aWNlICs9IFwid3NzXCI7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdfc2VydmljZSArPSBcIjovL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3Q7XG5cbiAgICAgICAgaWYgKHNlcnZpY2UuaW5kZXhPZihcIi9cIikgIT09IDApIHtcbiAgICAgICAgICAgIG5ld19zZXJ2aWNlICs9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHNlcnZpY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdfc2VydmljZSArPSBzZXJ2aWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29ubmVjdGlvbi5zZXJ2aWNlID0gbmV3X3NlcnZpY2U7XG4gICAgfVxufTtcblxuU3Ryb3BoZS5XZWJzb2NrZXQucHJvdG90eXBlID0ge1xuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9idWlsZFN0cmVhbVxuICAgICAqICBfUHJpdmF0ZV8gaGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSA8c3RyZWFtPiBzdGFydCB0YWcgZm9yIFdlYlNvY2tldHNcbiAgICAgKlxuICAgICAqICBSZXR1cm5zOlxuICAgICAqICAgIEEgU3Ryb3BoZS5CdWlsZGVyIHdpdGggYSA8c3RyZWFtPiBlbGVtZW50LlxuICAgICAqL1xuICAgIF9idWlsZFN0cmVhbTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJGJ1aWxkKFwib3BlblwiLCB7XG4gICAgICAgICAgICBcInhtbG5zXCI6IFN0cm9waGUuTlMuRlJBTUlORyxcbiAgICAgICAgICAgIFwidG9cIjogdGhpcy5fY29ubi5kb21haW4sXG4gICAgICAgICAgICBcInZlcnNpb25cIjogJzEuMCdcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9jaGVja19zdHJlYW1lcnJvclxuICAgICAqIF9Qcml2YXRlXyBjaGVja3MgYSBtZXNzYWdlIGZvciBzdHJlYW06ZXJyb3JcbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJvcGhlLlJlcXVlc3QpIGJvZHlXcmFwIC0gVGhlIHJlY2VpdmVkIHN0YW56YS5cbiAgICAgKiAgICBjb25uZWN0c3RhdHVzIC0gVGhlIENvbm5lY3RTdGF0dXMgdGhhdCB3aWxsIGJlIHNldCBvbiBlcnJvci5cbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICAgdHJ1ZSBpZiB0aGVyZSB3YXMgYSBzdHJlYW1lcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIF9jaGVja19zdHJlYW1lcnJvcjogZnVuY3Rpb24gKGJvZHlXcmFwLCBjb25uZWN0c3RhdHVzKSB7XG4gICAgICAgIHZhciBlcnJvcnM7XG4gICAgICAgIGlmIChib2R5V3JhcC5nZXRFbGVtZW50c0J5VGFnTmFtZU5TKSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBib2R5V3JhcC5nZXRFbGVtZW50c0J5VGFnTmFtZU5TKFN0cm9waGUuTlMuU1RSRUFNLCBcImVycm9yXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JzID0gYm9keVdyYXAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdHJlYW06ZXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBlcnJvcnNbMF07XG5cbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IFwiXCI7XG4gICAgICAgIHZhciB0ZXh0ID0gXCJcIjtcblxuICAgICAgICB2YXIgbnMgPSBcInVybjppZXRmOnBhcmFtczp4bWw6bnM6eG1wcC1zdHJlYW1zXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXJyb3IuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGUgPSBlcnJvci5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKGUuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgIT09IG5zKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGlmIChlLm5vZGVOYW1lID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgIHRleHQgPSBlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb24gPSBlLm5vZGVOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gXCJXZWJTb2NrZXQgc3RyZWFtIGVycm9yOiBcIjtcblxuICAgICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICBlcnJvclN0cmluZyArPSBjb25kaXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvclN0cmluZyArPSBcInVua25vd25cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBlcnJvclN0cmluZyArPSBcIiAtIFwiICsgY29uZGl0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgU3Ryb3BoZS5lcnJvcihlcnJvclN0cmluZyk7XG5cbiAgICAgICAgLy8gY2xvc2UgdGhlIGNvbm5lY3Rpb24gb24gc3RyZWFtX2Vycm9yXG4gICAgICAgIHRoaXMuX2Nvbm4uX2NoYW5nZUNvbm5lY3RTdGF0dXMoY29ubmVjdHN0YXR1cywgY29uZGl0aW9uKTtcbiAgICAgICAgdGhpcy5fY29ubi5fZG9EaXNjb25uZWN0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfcmVzZXRcbiAgICAgKiAgUmVzZXQgdGhlIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgdGhlIHJlc2V0IGZ1bmN0aW9uIG9mIHRoZSBTdHJvcGhlIENvbm5lY3Rpb24uXG4gICAgICogIElzIG5vdCBuZWVkZWQgYnkgV2ViU29ja2V0cy5cbiAgICAgKi9cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfY29ubmVjdFxuICAgICAqICBfUHJpdmF0ZV8gZnVuY3Rpb24gY2FsbGVkIGJ5IFN0cm9waGUuQ29ubmVjdGlvbi5jb25uZWN0XG4gICAgICpcbiAgICAgKiAgQ3JlYXRlcyBhIFdlYlNvY2tldCBmb3IgYSBjb25uZWN0aW9uIGFuZCBhc3NpZ25zIENhbGxiYWNrcyB0byBpdC5cbiAgICAgKiAgRG9lcyBub3RoaW5nIGlmIHRoZXJlIGFscmVhZHkgaXMgYSBXZWJTb2NrZXQuXG4gICAgICovXG4gICAgX2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgbm8gb3BlbiBXZWJTb2NrZXQgZnJvbSBhIHByZXZpb3VzIENvbm5lY3Rpb24uXG4gICAgICAgIHRoaXMuX2Nsb3NlU29ja2V0KCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgV29iU29ja2V0XG4gICAgICAgIHRoaXMuc29ja2V0ID0gbmV3IFdlYlNvY2tldCh0aGlzLl9jb25uLnNlcnZpY2UsIFwieG1wcFwiKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gdGhpcy5fb25PcGVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uZXJyb3IgPSB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSB0aGlzLl9vbkNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IHRoaXMuX2Nvbm5lY3RfY2Jfd3JhcHBlci5iaW5kKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfY29ubmVjdF9jYlxuICAgICAqICBfUHJpdmF0ZV8gZnVuY3Rpb24gY2FsbGVkIGJ5IFN0cm9waGUuQ29ubmVjdGlvbi5fY29ubmVjdF9jYlxuICAgICAqXG4gICAgICogY2hlY2tzIGZvciBzdHJlYW06ZXJyb3JcbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChTdHJvcGhlLlJlcXVlc3QpIGJvZHlXcmFwIC0gVGhlIHJlY2VpdmVkIHN0YW56YS5cbiAgICAgKi9cbiAgICBfY29ubmVjdF9jYjogZnVuY3Rpb24oYm9keVdyYXApIHtcbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy5fY2hlY2tfc3RyZWFtZXJyb3IoYm9keVdyYXAsIFN0cm9waGUuU3RhdHVzLkNPTk5GQUlMKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gU3Ryb3BoZS5TdGF0dXMuQ09OTkZBSUw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2hhbmRsZVN0cmVhbVN0YXJ0XG4gICAgICogX1ByaXZhdGVfIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIHRoZSBvcGVuaW5nIDxvcGVuIC8+IHRhZyBmb3IgZXJyb3JzLlxuICAgICAqXG4gICAgICogRGlzY29ubmVjdHMgaWYgdGhlcmUgaXMgYW4gZXJyb3IgYW5kIHJldHVybnMgZmFsc2UsIHRydWUgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogIFBhcmFtZXRlcnM6XG4gICAgICogICAgKE5vZGUpIG1lc3NhZ2UgLSBTdGFuemEgY29udGFpbmluZyB0aGUgPG9wZW4gLz4gdGFnLlxuICAgICAqL1xuICAgIF9oYW5kbGVTdHJlYW1TdGFydDogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBmYWxzZTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgZXJyb3JzIGluIHRoZSA8b3BlbiAvPiB0YWdcbiAgICAgICAgdmFyIG5zID0gbWVzc2FnZS5nZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBucyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZXJyb3IgPSBcIk1pc3NpbmcgeG1sbnMgaW4gPG9wZW4gLz5cIjtcbiAgICAgICAgfSBlbHNlIGlmIChucyAhPT0gU3Ryb3BoZS5OUy5GUkFNSU5HKSB7XG4gICAgICAgICAgICBlcnJvciA9IFwiV3JvbmcgeG1sbnMgaW4gPG9wZW4gLz46IFwiICsgbnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVyID0gbWVzc2FnZS5nZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHZlciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZXJyb3IgPSBcIk1pc3NpbmcgdmVyc2lvbiBpbiA8b3BlbiAvPlwiO1xuICAgICAgICB9IGVsc2UgaWYgKHZlciAhPT0gXCIxLjBcIikge1xuICAgICAgICAgICAgZXJyb3IgPSBcIldyb25nIHZlcnNpb24gaW4gPG9wZW4gLz46IFwiICsgdmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uLl9jaGFuZ2VDb25uZWN0U3RhdHVzKFN0cm9waGUuU3RhdHVzLkNPTk5GQUlMLCBlcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9jb25uLl9kb0Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfY29ubmVjdF9jYl93cmFwcGVyXG4gICAgICogX1ByaXZhdGVfIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyB0aGUgZmlyc3QgY29ubmVjdGlvbiBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIE9uIHJlY2VpdmluZyBhbiBvcGVuaW5nIHN0cmVhbSB0YWcgdGhpcyBjYWxsYmFjayByZXBsYWNlcyBpdHNlbGYgd2l0aCB0aGUgcmVhbFxuICAgICAqIG1lc3NhZ2UgaGFuZGxlci4gT24gcmVjZWl2aW5nIGEgc3RyZWFtIGVycm9yIHRoZSBjb25uZWN0aW9uIGlzIHRlcm1pbmF0ZWQuXG4gICAgICovXG4gICAgX2Nvbm5lY3RfY2Jfd3JhcHBlcjogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZS5kYXRhLmluZGV4T2YoXCI8b3BlbiBcIikgPT09IDAgfHwgbWVzc2FnZS5kYXRhLmluZGV4T2YoXCI8P3htbFwiKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gU3RyaXAgdGhlIFhNTCBEZWNsYXJhdGlvbiwgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgICAgICB2YXIgZGF0YSA9IG1lc3NhZ2UuZGF0YS5yZXBsYWNlKC9eKDxcXD8uKj9cXD8+XFxzKikqLywgXCJcIik7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gJycpIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIHN0cmVhbVN0YXJ0ID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhkYXRhLCBcInRleHQveG1sXCIpLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm4ueG1sSW5wdXQoc3RyZWFtU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5fY29ubi5yYXdJbnB1dChtZXNzYWdlLmRhdGEpO1xuXG4gICAgICAgICAgICAvL19oYW5kbGVTdHJlYW1TdGVhcnQgd2lsbCBjaGVjayBmb3IgWE1MIGVycm9ycyBhbmQgZGlzY29ubmVjdCBvbiBlcnJvclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZVN0cmVhbVN0YXJ0KHN0cmVhbVN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIC8vX2Nvbm5lY3RfY2Igd2lsbCBjaGVjayBmb3Igc3RyZWFtOmVycm9yIGFuZCBkaXNjb25uZWN0IG9uIGVycm9yXG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdF9jYihzdHJlYW1TdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5kYXRhLmluZGV4T2YoXCI8Y2xvc2UgXCIpID09PSAwKSB7IC8vJzxjbG9zZSB4bWxucz1cInVybjppZXRmOnBhcmFtczp4bWw6bnM6eG1wcC1mcmFtaW5nIC8+Jykge1xuICAgICAgICAgICAgdGhpcy5fY29ubi5yYXdJbnB1dChtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5fY29ubi54bWxJbnB1dChtZXNzYWdlKTtcbiAgICAgICAgICAgIHZhciBzZWVfdXJpID0gbWVzc2FnZS5nZXRBdHRyaWJ1dGUoXCJzZWUtb3RoZXItdXJpXCIpO1xuICAgICAgICAgICAgaWYgKHNlZV91cmkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uLl9jaGFuZ2VDb25uZWN0U3RhdHVzKFN0cm9waGUuU3RhdHVzLlJFRElSRUNULCBcIlJlY2VpdmVkIHNlZS1vdGhlci11cmksIHJlc2V0dGluZyBjb25uZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm4ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uLnNlcnZpY2UgPSBzZWVfdXJpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubi5fY2hhbmdlQ29ubmVjdFN0YXR1cyhTdHJvcGhlLlN0YXR1cy5DT05ORkFJTCwgXCJSZWNlaXZlZCBjbG9zaW5nIHN0cmVhbVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uLl9kb0Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzLl9zdHJlYW1XcmFwKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc3RyaW5nLCBcInRleHQveG1sXCIpLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IHRoaXMuX29uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fY29ubi5fY29ubmVjdF9jYihlbGVtLCBudWxsLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9kaXNjb25uZWN0XG4gICAgICogIF9Qcml2YXRlXyBmdW5jdGlvbiBjYWxsZWQgYnkgU3Ryb3BoZS5Db25uZWN0aW9uLmRpc2Nvbm5lY3RcbiAgICAgKlxuICAgICAqICBEaXNjb25uZWN0cyBhbmQgc2VuZHMgYSBsYXN0IHN0YW56YSBpZiBvbmUgaXMgZ2l2ZW5cbiAgICAgKlxuICAgICAqICBQYXJhbWV0ZXJzOlxuICAgICAqICAgIChSZXF1ZXN0KSBwcmVzIC0gVGhpcyBzdGFuemEgd2lsbCBiZSBzZW50IGJlZm9yZSBkaXNjb25uZWN0aW5nLlxuICAgICAqL1xuICAgIF9kaXNjb25uZWN0OiBmdW5jdGlvbiAocHJlcykge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQgJiYgdGhpcy5zb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgICAgICAgaWYgKHByZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uLnNlbmQocHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSAkYnVpbGQoXCJjbG9zZVwiLCB7IFwieG1sbnNcIjogU3Ryb3BoZS5OUy5GUkFNSU5HIH0pO1xuICAgICAgICAgICAgdGhpcy5fY29ubi54bWxPdXRwdXQoY2xvc2UpO1xuICAgICAgICAgICAgdmFyIGNsb3NlU3RyaW5nID0gU3Ryb3BoZS5zZXJpYWxpemUoY2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5fY29ubi5yYXdPdXRwdXQoY2xvc2VTdHJpbmcpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGNsb3NlU3RyaW5nKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBTdHJvcGhlLmluZm8oXCJDb3VsZG4ndCBzZW5kIDxjbG9zZSAvPiB0YWcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nvbm4uX2RvRGlzY29ubmVjdCgpO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfZG9EaXNjb25uZWN0XG4gICAgICogIF9Qcml2YXRlXyBmdW5jdGlvbiB0byBkaXNjb25uZWN0LlxuICAgICAqXG4gICAgICogIEp1c3QgY2xvc2VzIHRoZSBTb2NrZXQgZm9yIFdlYlNvY2tldHNcbiAgICAgKi9cbiAgICBfZG9EaXNjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFN0cm9waGUuaW5mbyhcIldlYlNvY2tldHMgX2RvRGlzY29ubmVjdCB3YXMgY2FsbGVkXCIpO1xuICAgICAgICB0aGlzLl9jbG9zZVNvY2tldCgpO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uIF9zdHJlYW1XcmFwXG4gICAgICogIF9Qcml2YXRlXyBoZWxwZXIgZnVuY3Rpb24gdG8gd3JhcCBhIHN0YW56YSBpbiBhIDxzdHJlYW0+IHRhZy5cbiAgICAgKiAgVGhpcyBpcyB1c2VkIHNvIFN0cm9waGUgY2FuIHByb2Nlc3Mgc3RhbnphcyBmcm9tIFdlYlNvY2tldHMgbGlrZSBCT1NIXG4gICAgICovXG4gICAgX3N0cmVhbVdyYXA6IGZ1bmN0aW9uIChzdGFuemEpIHtcbiAgICAgICAgcmV0dXJuIFwiPHdyYXBwZXI+XCIgKyBzdGFuemEgKyAnPC93cmFwcGVyPic7XG4gICAgfSxcblxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2Nsb3NlU29ja2V0XG4gICAgICogIF9Qcml2YXRlXyBmdW5jdGlvbiB0byBjbG9zZSB0aGUgV2ViU29ja2V0LlxuICAgICAqXG4gICAgICogIENsb3NlcyB0aGUgc29ja2V0IGlmIGl0IGlzIHN0aWxsIG9wZW4gYW5kIGRlbGV0ZXMgaXRcbiAgICAgKi9cbiAgICBfY2xvc2VTb2NrZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7IHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fSB9XG4gICAgICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX2VtcHR5UXVldWVcbiAgICAgKiBfUHJpdmF0ZV8gZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIG1lc3NhZ2UgcXVldWUgaXMgZW1wdHkuXG4gICAgICpcbiAgICAgKiAgUmV0dXJuczpcbiAgICAgKiAgICBUcnVlLCBiZWNhdXNlIFdlYlNvY2tldCBtZXNzYWdlcyBhcmUgc2VuZCBpbW1lZGlhdGVseSBhZnRlciBxdWV1ZWluZy5cbiAgICAgKi9cbiAgICBfZW1wdHlRdWV1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX29uQ2xvc2VcbiAgICAgKiBfUHJpdmF0ZV8gZnVuY3Rpb24gdG8gaGFuZGxlIHdlYnNvY2tldHMgY2xvc2luZy5cbiAgICAgKlxuICAgICAqIE5vdGhpbmcgdG8gZG8gaGVyZSBmb3IgV2ViU29ja2V0c1xuICAgICAqL1xuICAgIF9vbkNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5fY29ubi5jb25uZWN0ZWQgJiYgIXRoaXMuX2Nvbm4uZGlzY29ubmVjdGluZykge1xuICAgICAgICAgICAgU3Ryb3BoZS5lcnJvcihcIldlYnNvY2tldCBjbG9zZWQgdW5leHBlY3RlZGx5XCIpO1xuICAgICAgICAgICAgdGhpcy5fY29ubi5fZG9EaXNjb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBTdHJvcGhlLmluZm8oXCJXZWJzb2NrZXQgY2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9ub19hdXRoX3JlY2VpdmVkXG4gICAgICpcbiAgICAgKiBDYWxsZWQgb24gc3RyZWFtIHN0YXJ0L3Jlc3RhcnQgd2hlbiBubyBzdHJlYW06ZmVhdHVyZXNcbiAgICAgKiBoYXMgYmVlbiByZWNlaXZlZC5cbiAgICAgKi9cbiAgICBfbm9fYXV0aF9yZWNlaXZlZDogZnVuY3Rpb24gKF9jYWxsYmFjaykge1xuICAgICAgICBTdHJvcGhlLmVycm9yKFwiU2VydmVyIGRpZCBub3Qgc2VuZCBhbnkgYXV0aCBtZXRob2RzXCIpO1xuICAgICAgICB0aGlzLl9jb25uLl9jaGFuZ2VDb25uZWN0U3RhdHVzKFN0cm9waGUuU3RhdHVzLkNPTk5GQUlMLCBcIlNlcnZlciBkaWQgbm90IHNlbmQgYW55IGF1dGggbWV0aG9kc1wiKTtcbiAgICAgICAgaWYgKF9jYWxsYmFjaykge1xuICAgICAgICAgICAgX2NhbGxiYWNrID0gX2NhbGxiYWNrLmJpbmQodGhpcy5fY29ubik7XG4gICAgICAgICAgICBfY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25uLl9kb0Rpc2Nvbm5lY3QoKTtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX29uRGlzY29ubmVjdFRpbWVvdXRcbiAgICAgKiAgX1ByaXZhdGVfIHRpbWVvdXQgaGFuZGxlciBmb3IgaGFuZGxpbmcgbm9uLWdyYWNlZnVsIGRpc2Nvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBkb2VzIG5vdGhpbmcgZm9yIFdlYlNvY2tldHNcbiAgICAgKi9cbiAgICBfb25EaXNjb25uZWN0VGltZW91dDogZnVuY3Rpb24gKCkge30sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfYWJvcnRBbGxSZXF1ZXN0c1xuICAgICAqICBfUHJpdmF0ZV8gaGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFrZXMgc3VyZSBhbGwgcGVuZGluZyByZXF1ZXN0cyBhcmUgYWJvcnRlZC5cbiAgICAgKi9cbiAgICBfYWJvcnRBbGxSZXF1ZXN0czogZnVuY3Rpb24gKCkge30sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfb25FcnJvclxuICAgICAqIF9Qcml2YXRlXyBmdW5jdGlvbiB0byBoYW5kbGUgd2Vic29ja2V0cyBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqIChPYmplY3QpIGVycm9yIC0gVGhlIHdlYnNvY2tldCBlcnJvci5cbiAgICAgKi9cbiAgICBfb25FcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgU3Ryb3BoZS5lcnJvcihcIldlYnNvY2tldCBlcnJvciBcIiArIGVycm9yKTtcbiAgICAgICAgdGhpcy5fY29ubi5fY2hhbmdlQ29ubmVjdFN0YXR1cyhTdHJvcGhlLlN0YXR1cy5DT05ORkFJTCwgXCJUaGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY291bGQgbm90IGJlIGVzdGFibGlzaGVkIG9yIHdhcyBkaXNjb25uZWN0ZWQuXCIpO1xuICAgICAgICB0aGlzLl9kaXNjb25uZWN0KCk7XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9vbklkbGVcbiAgICAgKiAgX1ByaXZhdGVfIGZ1bmN0aW9uIGNhbGxlZCBieSBTdHJvcGhlLkNvbm5lY3Rpb24uX29uSWRsZVxuICAgICAqXG4gICAgICogIHNlbmRzIGFsbCBxdWV1ZWQgc3Rhbnphc1xuICAgICAqL1xuICAgIF9vbklkbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9jb25uLl9kYXRhO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAwICYmICF0aGlzLl9jb25uLnBhdXNlZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YW56YSwgcmF3U3RhbnphO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PT0gXCJyZXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YW56YSA9IHRoaXMuX2J1aWxkU3RyZWFtKCkudHJlZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhbnphID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByYXdTdGFuemEgPSBTdHJvcGhlLnNlcmlhbGl6ZShzdGFuemEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uLnhtbE91dHB1dChzdGFuemEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uLnJhd091dHB1dChyYXdTdGFuemEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKHJhd1N0YW56YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY29ubi5fZGF0YSA9IFtdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBQcml2YXRlRnVuY3Rpb246IF9vbk1lc3NhZ2VcbiAgICAgKiBfUHJpdmF0ZV8gZnVuY3Rpb24gdG8gaGFuZGxlIHdlYnNvY2tldHMgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHBhcnNlcyBlYWNoIG9mIHRoZSBtZXNzYWdlcyBhcyBpZiB0aGV5IGFyZSBmdWxsIGRvY3VtZW50cy5cbiAgICAgKiBbVE9ETyA6IFdlIG1heSBhY3R1YWxseSB3YW50IHRvIHVzZSBhIFNBWCBQdXNoIHBhcnNlcl0uXG4gICAgICpcbiAgICAgKiBTaW5jZSBhbGwgWE1QUCB0cmFmZmljIHN0YXJ0cyB3aXRoXG4gICAgICogIDxzdHJlYW06c3RyZWFtIHZlcnNpb249JzEuMCdcbiAgICAgKiAgICAgICAgICAgICAgICAgeG1sOmxhbmc9J2VuJ1xuICAgICAqICAgICAgICAgICAgICAgICB4bWxucz0namFiYmVyOmNsaWVudCdcbiAgICAgKiAgICAgICAgICAgICAgICAgeG1sbnM6c3RyZWFtPSdodHRwOi8vZXRoZXJ4LmphYmJlci5vcmcvc3RyZWFtcydcbiAgICAgKiAgICAgICAgICAgICAgICAgaWQ9JzM2OTczOTU0NjMnXG4gICAgICogICAgICAgICAgICAgICAgIGZyb209J1NFUlZFUic+XG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3Qgc3RhbnphIHdpbGwgYWx3YXlzIGZhaWwgdG8gYmUgcGFyc2VkLlxuICAgICAqXG4gICAgICogQWRkaXRpb25hbGx5LCB0aGUgc2Vjb25kcyBzdGFuemEgd2lsbCBhbHdheXMgYmUgPHN0cmVhbTpmZWF0dXJlcz4gd2l0aFxuICAgICAqIHRoZSBzdHJlYW0gTlMgZGVmaW5lZCBpbiB0aGUgcHJldmlvdXMgc3RhbnphLCBzbyB3ZSBuZWVkIHRvICdmb3JjZSdcbiAgICAgKiB0aGUgaW5jbHVzaW9uIG9mIHRoZSBOUyBpbiB0aGlzIHN0YW56YS5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogKHN0cmluZykgbWVzc2FnZSAtIFRoZSB3ZWJzb2NrZXQgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBfb25NZXNzYWdlOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIHZhciBlbGVtLCBkYXRhO1xuICAgICAgICAvLyBjaGVjayBmb3IgY2xvc2luZyBzdHJlYW1cbiAgICAgICAgdmFyIGNsb3NlID0gJzxjbG9zZSB4bWxucz1cInVybjppZXRmOnBhcmFtczp4bWw6bnM6eG1wcC1mcmFtaW5nXCIgLz4nO1xuICAgICAgICBpZiAobWVzc2FnZS5kYXRhID09PSBjbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5fY29ubi5yYXdJbnB1dChjbG9zZSk7XG4gICAgICAgICAgICB0aGlzLl9jb25uLnhtbElucHV0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb25uLmRpc2Nvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uLl9kb0Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLmRhdGEuc2VhcmNoKFwiPG9wZW4gXCIpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGhhbmRsZXMgc3RyZWFtIHJlc3RhcnRzXG4gICAgICAgICAgICBlbGVtID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhtZXNzYWdlLmRhdGEsIFwidGV4dC94bWxcIikuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVTdHJlYW1TdGFydChlbGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9zdHJlYW1XcmFwKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgICBlbGVtID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhkYXRhLCBcInRleHQveG1sXCIpLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jaGVja19zdHJlYW1lcnJvcihlbGVtLCBTdHJvcGhlLlN0YXR1cy5FUlJPUikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaGFuZGxlIHVuYXZhaWxhYmxlIHByZXNlbmNlIHN0YW56YSBiZWZvcmUgZGlzY29ubmVjdGluZ1xuICAgICAgICBpZiAodGhpcy5fY29ubi5kaXNjb25uZWN0aW5nICYmXG4gICAgICAgICAgICAgICAgZWxlbS5maXJzdENoaWxkLm5vZGVOYW1lID09PSBcInByZXNlbmNlXCIgJiZcbiAgICAgICAgICAgICAgICBlbGVtLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PT0gXCJ1bmF2YWlsYWJsZVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uLnhtbElucHV0KGVsZW0pO1xuICAgICAgICAgICAgdGhpcy5fY29ubi5yYXdJbnB1dChTdHJvcGhlLnNlcmlhbGl6ZShlbGVtKSk7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgYWxyZWFkeSBkaXNjb25uZWN0aW5nIHdlIHdpbGwgaWdub3JlIHRoZSB1bmF2YWlsYWJsZSBzdGFuemEgYW5kXG4gICAgICAgICAgICAvLyB3YWl0IGZvciB0aGUgPC9zdHJlYW06c3RyZWFtPiB0YWcgYmVmb3JlIHdlIGNsb3NlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29ubi5fZGF0YVJlY3YoZWxlbSwgbWVzc2FnZS5kYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX29uT3BlblxuICAgICAqIF9Qcml2YXRlXyBmdW5jdGlvbiB0byBoYW5kbGUgd2Vic29ja2V0cyBjb25uZWN0aW9uIHNldHVwLlxuICAgICAqXG4gICAgICogVGhlIG9wZW5pbmcgc3RyZWFtIHRhZyBpcyBzZW50IGhlcmUuXG4gICAgICovXG4gICAgX29uT3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIFN0cm9waGUuaW5mbyhcIldlYnNvY2tldCBvcGVuXCIpO1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9idWlsZFN0cmVhbSgpO1xuICAgICAgICB0aGlzLl9jb25uLnhtbE91dHB1dChzdGFydC50cmVlKCkpO1xuXG4gICAgICAgIHZhciBzdGFydFN0cmluZyA9IFN0cm9waGUuc2VyaWFsaXplKHN0YXJ0KTtcbiAgICAgICAgdGhpcy5fY29ubi5yYXdPdXRwdXQoc3RhcnRTdHJpbmcpO1xuICAgICAgICB0aGlzLnNvY2tldC5zZW5kKHN0YXJ0U3RyaW5nKTtcbiAgICB9LFxuXG4gICAgLyoqIFByaXZhdGVGdW5jdGlvbjogX3JlcVRvRGF0YVxuICAgICAqIF9Qcml2YXRlXyBmdW5jdGlvbiB0byBnZXQgYSBzdGFuemEgb3V0IG9mIGEgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIFdlYlNvY2tldHMgZG9uJ3QgdXNlIHJlcXVlc3RzLCBzbyB0aGUgcGFzc2VkIGFyZ3VtZW50IGlzIGp1c3QgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiAgUGFyYW1ldGVyczpcbiAgICAgKiAgICAoT2JqZWN0KSBzdGFuemEgLSBUaGUgc3RhbnphLlxuICAgICAqXG4gICAgICogIFJldHVybnM6XG4gICAgICogICAgVGhlIHN0YW56YSB0aGF0IHdhcyBwYXNzZWQuXG4gICAgICovXG4gICAgX3JlcVRvRGF0YTogZnVuY3Rpb24gKHN0YW56YSkge1xuICAgICAgICByZXR1cm4gc3RhbnphO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfc2VuZFxuICAgICAqICBfUHJpdmF0ZV8gcGFydCBvZiB0aGUgQ29ubmVjdGlvbi5zZW5kIGZ1bmN0aW9uIGZvciBXZWJTb2NrZXRcbiAgICAgKlxuICAgICAqIEp1c3QgZmx1c2hlcyB0aGUgbWVzc2FnZXMgdGhhdCBhcmUgaW4gdGhlIHF1ZXVlXG4gICAgICovXG4gICAgX3NlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29ubi5mbHVzaCgpO1xuICAgIH0sXG5cbiAgICAvKiogUHJpdmF0ZUZ1bmN0aW9uOiBfc2VuZFJlc3RhcnRcbiAgICAgKlxuICAgICAqICBTZW5kIGFuIHhtcHA6cmVzdGFydCBzdGFuemEuXG4gICAgICovXG4gICAgX3NlbmRSZXN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jb25uLl9pZGxlVGltZW91dCk7XG4gICAgICAgIHRoaXMuX2Nvbm4uX29uSWRsZS5iaW5kKHRoaXMuX2Nvbm4pKCk7XG4gICAgfVxufTtcbnJldHVybiBTdHJvcGhlO1xufSkpO1xuXG4oZnVuY3Rpb24ocm9vdCl7XG4gICAgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKXtcbiAgICAgICAgZGVmaW5lKFwic3Ryb3BoZVwiLCBbXG4gICAgICAgICAgICBcInN0cm9waGUtY29yZVwiLFxuICAgICAgICAgICAgXCJzdHJvcGhlLWJvc2hcIixcbiAgICAgICAgICAgIFwic3Ryb3BoZS13ZWJzb2NrZXRcIlxuICAgICAgICBdLCBmdW5jdGlvbiAod3JhcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pKHRoaXMpO1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5pZiAoY2FsbGJhY2spIHtcbiAgICBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpe1xuICAgICAgICAvL0ZvciBiYWNrd2FyZHMgY29tcGF0YWJpbGl0eVxuICAgICAgICB2YXIgbl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVqcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVxdWlyZWpzKFtcInN0cm9waGVcIl0sIGZ1bmN0aW9uKG8pe1xuICAgICAgICAgICAgICAgIG5fY2FsbGJhY2soby5TdHJvcGhlLG8uJGJ1aWxkLG8uJG1zZyxvLiRpcSxvLiRwcmVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX19icm93c2VyaWZ5X3NoaW1fcmVxdWlyZV9fKFtcInN0cm9waGVcIl0sIGZ1bmN0aW9uKG8pe1xuICAgICAgICAgICAgICAgIG5fY2FsbGJhY2soby5TdHJvcGhlLG8uJGJ1aWxkLG8uJG1zZyxvLiRpcSxvLiRwcmVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfWVsc2V7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhTdHJvcGhlLCAkYnVpbGQsICRtc2csICRpcSwgJHByZXMpO1xuICAgIH1cbn1cblxuXG59KShmdW5jdGlvbiAoU3Ryb3BoZSwgYnVpbGQsIG1zZywgaXEsIHByZXMpIHtcbiAgICB3aW5kb3cuU3Ryb3BoZSA9IFN0cm9waGU7XG4gICAgd2luZG93LiRidWlsZCA9IGJ1aWxkO1xuICAgIHdpbmRvdy4kbXNnID0gbXNnO1xuICAgIHdpbmRvdy4kaXEgPSBpcTtcbiAgICB3aW5kb3cuJHByZXMgPSBwcmVzO1xufSk7XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG47IGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKHR5cGVvZiBTdHJvcGhlICE9IFwidW5kZWZpbmVkXCIgPyBTdHJvcGhlIDogd2luZG93LlN0cm9waGUpO1xuXG59KS5jYWxsKGdsb2JhbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiBkZWZpbmVFeHBvcnQoZXgpIHsgbW9kdWxlLmV4cG9ydHMgPSBleDsgfSk7XG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbkNvbm5lY3Rpb24gPSByZXF1aXJlICdjb25uZWN0aW9uJ1xuVXRpbHMgPSByZXF1aXJlICd1dGlsL3V0aWxzJ1xuXG4jIEV4cG9ydCB0aGlzIG9iamVjdCBhbmQgYWxzbyBhc3NpZ24gaXQgdG8gYSBcIk5pdHJvXCIgZ2xvYmFsIG9uIHRoZSB3aW5kb3cuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5OaXRybyA9XG5cbiAgIyBAcHJvcGVydHkgW1N0cmluZ10gcHVibGljIGlkIGZvciB0aGUgUm9zdGVyIHN1Yi1jb21wb25lbnRcbiAgUk9TVEVSOiByZXF1aXJlKCdjb21wb25lbnRzL3Jvc3RlcicpLk5BTUVcblxuICAjIEBwcm9wZXJ0eSBbU3RyaW5nXSBwdWJsaWMgaWQgZm9yIHRoZSBNZXNzYWdpbmcgc3ViLWNvbXBvbmVudFxuICBNRVNTQUdJTkc6IHJlcXVpcmUoJ2NvbXBvbmVudHMvbWVzc2FnaW5nJykuTkFNRVxuXG4gICMgQHByb3BlcnR5IFtTdHJpbmddIHB1YmxpYyBpZCBmb3IgdGhlIFN0b3JhZ2Ugc3ViLWNvbXBvbmVudFxuICBTVE9SQUdFOiByZXF1aXJlKCdjb21wb25lbnRzL3N0b3JhZ2UnKS5OQU1FXG5cbiAgIyBAcHJvcGVydHkgW1N0cmluZ10gcHVibGljIGlkIGZvciB0aGUgQmxvY2tsaXN0IHN1Yi1jb21wb25lbnRcbiAgQkxPQ0tMSVNUOiByZXF1aXJlKCdjb21wb25lbnRzL2Jsb2NrbGlzdCcpLk5BTUVcblxuICAjIEBwcm9wZXJ0eSBbU3RyaW5nXSBwdWJsaWMgaWQgZm9yIHRoZSBCbG9ja2xpc3Qgc3ViLWNvbXBvbmVudFxuICBNVUM6IHJlcXVpcmUoJ2NvbXBvbmVudHMvbXVjJykuTkFNRVxuXG4gICMgQHByb3BlcnR5IFtTdHJpbmddIHB1YmxpYyBpZCBmb3IgdGhlIEJsb2NrbGlzdCBzdWItY29tcG9uZW50XG4gIFlBSE9POiByZXF1aXJlKCdlbnVtL2dhdGV3YXlzJykuWUFIT09cblxuICBTdGF0dXM6IHJlcXVpcmUgJ2VudW0vc3RhdHVzJ1xuICBQcmVzZW5jZVNob3c6IHJlcXVpcmUgJ2VudW0vcHJlc2VuY2Vfc2hvdydcbiAgWE1QUFByZXNlbmNlOiByZXF1aXJlICdlbnVtL3htcHBfcHJlc2VuY2UnXG4gIFByZXNlbmNlVHlwZTogcmVxdWlyZSAnZW51bS9wcmVzZW5jZV90eXBlJ1xuICBNZXNzYWdlVHlwZTogcmVxdWlyZSAnZW51bS9tZXNzYWdlX3R5cGUnXG4gIE1VQ05vZGU6IHJlcXVpcmUgJ2VudW0vbXVjX25vZGUnXG4gIE1VQ1JvbGU6IHJlcXVpcmUgJ2VudW0vbXVjX3JvbGUnXG4gIE1VQ0Vycm9yOiByZXF1aXJlICdlbnVtL211Y19lcnJvcidcbiAgTVVDRXJyb3JUeXBlOiByZXF1aXJlICdlbnVtL211Y19lcnJvcl90eXBlJ1xuICBTdWJzY3JpcHRpb25TdGF0dXM6IHJlcXVpcmUgJ2VudW0vc3Vic2NyaXB0aW9uX3N0YXR1cydcbiAgQ29tcGxpYW5jZUVycm9yOiByZXF1aXJlICdlbnVtL2NvbXBsaWFuY2VfZXJyb3InXG4gIFlhaG9vRXJyb3I6IHJlcXVpcmUgJ2VudW0veWFob29fZXJyb3InXG5cbiAgIyBFdmVudCBjbGFzcyBmb3IgcmVnaXN0ZXJpbmcgZm9yIE5pdHJvIGxpYnJhcnkgZXZlbnRzXG4gIEV2ZW50czogcmVxdWlyZSAnZXZlbnRzL2V2ZW50cydcbiAgSU9FdmVudDogcmVxdWlyZSAnZXZlbnRzL2lvX2V2ZW50J1xuXG4gICMgUmV0cmlldmUgdGhlIE5pdHJvIGNvbm5lY3Rpb24gc2luZ2xldG9uIGluc3RhbmNlXG4gICMgSXQgaXMgbmVjZXNzYXJ5IHRvIHBhc3MgaW4gYXBwIG5hbWUgYW5kIHZlcnNpb25cbiAgI1xuICAjIEBzZWUgQ29ubmVjdGlvbi5nZXRcbiAgZ2V0Q29ubmVjdGlvbjogQ29ubmVjdGlvbi5nZXRcblxuICAjIFJldHJpZXZlIGEgc3BlY2lmaWVkIGNvbXBvbmVudCBieSBuYW1lLCBlLmcuICdyb3N0ZXInLCAnc3RvcmFnZScsXG4gICMgJ21lc3NhZ2luZycsIGV0Yy5cbiAgI1xuICAjIEByZXR1cm4gW09iamVjdF0gYSBjb21wb25lbnQgaW5zdGFuY2VcbiAgZ2V0Q29tcG9uZW50OiAtPlxuICAgIHRyeVxuICAgICAgY29ubmVjdGlvbiA9IENvbm5lY3Rpb24uZ2V0KClcbiAgICAgIGNvbm5lY3Rpb24uZ2V0Q29tcG9uZW50LmFwcGx5IGNvbm5lY3Rpb24sIGFyZ3VtZW50c1xuICAgIGNhdGNoIGVycm9yXG4gICAgICBudWxsXG5cbiMgRXhwb3NlIHRoZSB0aGUgQ29ubmVjdGlvbiBzaW5nbGV0b24gaW5zdGFuY2Vcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSBOaXRybywgJ2Nvbm5lY3Rpb24nLFxuICBnZXQ6IC0+XG4gICAgVXRpbHMudHJ5Q2F0Y2goLT4gQ29ubmVjdGlvbi5nZXQoKSkoKVxuXG4jIEV4cG9zZSB0aGUgRXZlbnRNYW5hZ2VyIGluc3RhbmNlIGZvciByZWdpc3RlcmluZyBmb3IgTml0cm8gZXZlbnRzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkgTml0cm8sICdldmVudE1hbmFnZXInLFxuICBnZXQ6IC0+XG4gICAgVXRpbHMudHJ5Q2F0Y2goLT4gQ29ubmVjdGlvbi5nZXQoKT8uZXZlbnRNYW5hZ2VyKSgpXG5cbiMgRXhwb3NlIHRoZSB1dGlsaXR5IGZ1bmN0aW9uc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5IE5pdHJvLCAndXRpbHMnLFxuICBnZXQ6IF8ub25jZSAtPlxuICAgIFhNUFBVdGlscyA9IHJlcXVpcmUgJ3V0aWwveG1wcF91dGlscydcbiAgICBNYXRjaGVycyA9IHJlcXVpcmUgJ3V0aWwvbWF0Y2hlcnMnXG4gICAgcmV0cnllciA9IHJlcXVpcmUgJ3V0aWwvcmV0cnllcidcblxuICAgIHN0cm9waGVBUEkgPSBnZXRTdHJvcGhlQVBJIFN0cm9waGVcbiAgICBfLmV4dGVuZCB7fSwgVXRpbHMsIFhNUFBVdGlscywgTWF0Y2hlcnMsIHJldHJ5ZXIsIHN0cm9waGVBUElcblxuIyBNYXAgc2VsZWN0IFN0cm9waGUgbWV0b2RzIHRvIHByb3BzIG9uIGFuIG9iamVjdC5cbiNcbiMgQHBhcmFtIFtPYmplY3RdIFRoZSBTdHJvcGhlIGxpYnJhcnkuXG4jXG4jIEByZXR1cm4gW09iamVjdF0gQW4gb2JqZWN0IHdpdGggc2VsZWN0IG1ldGhvZHMuXG5nZXRTdHJvcGhlQVBJID0gKHN0cm9waGUpIC0+XG4gIGdldEJhcmVKSUQ6IHN0cm9waGUuZ2V0QmFyZUppZEZyb21KaWRcbiAgZ2V0UmVzb3VyY2U6IHN0cm9waGUuZ2V0UmVzb3VyY2VGcm9tSmlkXG4gIHNlcmlhbGl6ZTogc3Ryb3BoZS5zZXJpYWxpemVcbiIsIntzaW5vbiwgZXhwZWN0LCBhc3NlcnR9ID0gcmVxdWlyZSAnc3BlYy9zcGVjX2hlbHBlcidcbmFkYXB0ZXJzID0gcmVxdWlyZSAnYWRhcHRlcnMvYWRhcHRlcnMnXG5cbmRlc2NyaWJlICdBZGFwdGVycycsIC0+XG5cbiAgZGVzY3JpYmUgJ3htbFRvSlNPTicsIC0+XG5cbiAgICBpdCAnc2hvdWxkIGNvbnZlcnQgWE1MIHRvIEpTT04nLCAtPlxuICAgICAgYXNzZXJ0IHRydWVcblxuICBkZXNjcmliZSAnanNvbkF0dHJzJywgLT5cblxuICAgIG9iamVjdCA9IG51bGxcbiAgICBleHBlY3RlZCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgb2JqZWN0ID0gbnVsbFxuICAgICAgZXhwZWN0ZWQgPSBudWxsXG5cbiAgICBpdCAnc2hvdWxkIGdyb3VwIGF0dHJpYnV0ZXMgdW5kZXIgYGF0dHJpYnV0ZXNgIG9iamVjdCcsIC0+XG4gICAgICBvYmplY3QgPVxuICAgICAgICBfYXR0cjE6ICdhdHRyMVZhbCdcbiAgICAgICAgX2F0dHIyOiAnYXR0cjJWYWwnXG4gICAgICBcbiAgICAgIG5ld09iaiA9IGFkYXB0ZXJzLmpzb25BdHRycyBvYmplY3RcbiAgICAgIG5ld09iai5zaG91bGQuaGF2ZS5hLnByb3BlcnR5KCdhdHRyaWJ1dGVzJykudGhhdC5lcWxzXG4gICAgICAgIGF0dHIxOiAnYXR0cjFWYWwnXG4gICAgICAgIGF0dHIyOiAnYXR0cjJWYWwnXG4gICAgICBuZXdPYmouc2hvdWxkLm5vdC5oYXZlLmEucHJvcGVydHkgJ19hdHRyMSdcbiAgICAgIG5ld09iai5zaG91bGQubm90LmhhdmUuYS5wcm9wZXJ0eSAnX2F0dHIyJ1xuICAgIFxuICAgIGl0ICdzaG91bGQgcHJvY2VzcyBhbiBvYmplY3QgdGhhdCBpcyBhbiBhcnJheScsIC0+XG4gICAgICBvYmplY3QgPSBbXCJlbGVtZW50MVwiLCBcImVsZW1lbnQyXCJdXG4gICAgICBuZXdPYmogPSBhZGFwdGVycy5qc29uQXR0cnMgb2JqZWN0XG4gICAgICBuZXdPYmouc2hvdWxkLmVxbCBbXCJlbGVtZW50MVwiLCBcImVsZW1lbnQyXCJdXG5cbiAgICBpdCAnc2hvdWxkIHByb2Nlc3MgYW4gb2JqZWN0IHdpdGggYW4gYXJyYXknLCAtPlxuICAgICAgb2JqZWN0ID1cbiAgICAgICAgcHJvcDE6IFtcIm9uZVwiLCBcInR3b1wiXVxuICAgICAgICBcbiAgICAgIG5ld09iaiA9IGFkYXB0ZXJzLmpzb25BdHRycyBvYmplY3RcbiAgICAgXG4gICAgICBuZXdPYmouc2hvdWxkLmVxbFxuICAgICAgICBwcm9wMTogW1wib25lXCIsIFwidHdvXCJdXG5cbiAgICBpdCAnc2hvdWxkIHByb2Nlc3MgYW4gb2JqZWN0IHdpdGggYW4gYXJyYXkgb2Ygb2JqZWN0cycsIC0+XG4gICAgICBvYmplY3QgPVxuICAgICAgICBwcm9wMTogW1xuICAgICAgICAgIGVsMVByb3AxOiBcImVsMVByb3AxXCJcbiAgICAgICAgICBlbDFQcm9wMjogXCJlbDFQcm9wMlwiXG4gICAgICAgICxcbiAgICAgICAgICBlbDJQcm9wMTogXCJlbDJQcm9wMVwiXG4gICAgICAgICAgZWwyUHJvcDI6IFwiZWwyUHJvcDJcIlxuICAgICAgICBdXG4gICAgICAgIFxuICAgICAgbmV3T2JqID0gYWRhcHRlcnMuanNvbkF0dHJzIG9iamVjdFxuXG4gICAgICBleHBlY3RlZCA9XG4gICAgICAgIHByb3AxOiBbXG4gICAgICAgICAgZWwxUHJvcDE6IFwiZWwxUHJvcDFcIlxuICAgICAgICAgIGVsMVByb3AyOiBcImVsMVByb3AyXCJcbiAgICAgICAgLFxuICAgICAgICAgIGVsMlByb3AxOiBcImVsMlByb3AxXCJcbiAgICAgICAgICBlbDJQcm9wMjogXCJlbDJQcm9wMlwiXG4gICAgICAgIF1cbiAgICAgXG4gICAgICBuZXdPYmouc2hvdWxkLmVxbCBleHBlY3RlZFxuXG4gICAgaXQgJ3Nob3VsZCByZWN1cnNlIHRvIGdyb3VwIGF0dHJpYnV0ZXMgZm9yIGVhY2ggb2JqZWN0IHByb3BlcnR5JywgLT5cbiAgICAgIG9iamVjdCA9XG4gICAgICAgIHByb3AxOiAncHJvcDFWYWwnXG4gICAgICAgIHByb3AyOlxuICAgICAgICAgIHByb3AyX3Byb3AxOiAncHJvcDJfcHJvcDFWYWwnXG4gICAgICAgICAgcHJvcDJfcHJvcDI6ICdwcm9wMl9wcm9wMlZhbCdcbiAgICAgICAgICBfcHJvcDJfYXR0cjE6ICdwcm9wMl9hdHRyMVZhbCdcbiAgICAgICAgICBfcHJvcDJfYXR0cjI6ICdwcm9wMl9hdHRyMlZhbCdcbiAgICAgICAgX2F0dHIxOiAnYXR0cjFWYWwnXG4gICAgICAgIF9hdHRyMjogJ2F0dHIyVmFsJ1xuXG4gICAgICBuZXdPYmogPSBhZGFwdGVycy5qc29uQXR0cnMgb2JqZWN0XG4gICAgIFxuICAgICAgZXhwZWN0ZWQgPVxuICAgICAgICBhdHRyaWJ1dGVzOlxuICAgICAgICAgIGF0dHIxOiAnYXR0cjFWYWwnXG4gICAgICAgICAgYXR0cjI6ICdhdHRyMlZhbCdcbiAgICAgICAgcHJvcDE6ICdwcm9wMVZhbCdcbiAgICAgICAgcHJvcDI6XG4gICAgICAgICAgYXR0cmlidXRlczpcbiAgICAgICAgICAgIHByb3AyX2F0dHIxOiAncHJvcDJfYXR0cjFWYWwnXG4gICAgICAgICAgICBwcm9wMl9hdHRyMjogJ3Byb3AyX2F0dHIyVmFsJ1xuICAgICAgICAgIHByb3AyX3Byb3AxOiAncHJvcDJfcHJvcDFWYWwnXG4gICAgICAgICAgcHJvcDJfcHJvcDI6ICdwcm9wMl9wcm9wMlZhbCdcblxuICAgICAgbmV3T2JqLnNob3VsZC5lcWwgZXhwZWN0ZWRcbiAgIFxuICAgIGl0ICdzaG91bGQgaGFuZGxlIGFuIG9iamVjdCB3aXRoIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBhdHRyaWJ1dGVzJywgLT5cbiAgICAgIG9iamVjdCA9XG4gICAgICAgIHByb3AxOiBbXG4gICAgICAgICAgZWxlbWVudDE6ICdlbGVtZW50MVZhbCdcbiAgICAgICAgICBlbGVtZW50MjpcbiAgICAgICAgICAgIF9lbDFBdHRyMTogJ2VsMUF0dHIxJ1xuICAgICAgICAgICAgX2VsMUF0dHIyOiAnZWwxQXR0cjInXG4gICAgICAgIF1cblxuICAgICAgbmV3T2JqID0gYWRhcHRlcnMuanNvbkF0dHJzIG9iamVjdFxuICAgICAgXG4gICAgICBleHBlY3RlZCA9XG4gICAgICAgIHByb3AxOiBbXG4gICAgICAgICAgZWxlbWVudDE6ICdlbGVtZW50MVZhbCdcbiAgICAgICAgICBlbGVtZW50MjpcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgIGVsMUF0dHIxOiAnZWwxQXR0cjEnXG4gICAgICAgICAgICAgIGVsMUF0dHIyOiAnZWwxQXR0cjInXG4gICAgICAgIF1cbiAgICAgIG5ld09iai5zaG91bGQuZXFsIGV4cGVjdGVkXG5cbiAgICBpdCAnc2hvdWxkIGhhbmRsZSBhcnJheXMgb2Ygb2JqZWN0cycsIC0+XG4gICAgICBvYmplY3QgPSBbXG4gICAgICAgIGVsZW1lbnQxOlxuICAgICAgICAgIGUxUHJvcDE6ICdlMVByb3AxVmFsJ1xuICAgICAgICAgIGUxUHJvcDI6ICdlMVByb3AyVmFsJ1xuICAgICAgICAgIF9lMUF0dHIxOiAnZTFBdHRyMVZhbCdcbiAgICAgICAgICBfZTFBdHRyMjogJ2UxQXR0cjJWYWwnXG4gICAgICBdXG5cbiAgICAgIG5ld09iaiA9IGFkYXB0ZXJzLmpzb25BdHRycyBvYmplY3RcblxuICAgICAgZXhwZWN0ZWQgPSBbXG4gICAgICAgIGVsZW1lbnQxOlxuICAgICAgICAgIGUxUHJvcDE6ICdlMVByb3AxVmFsJ1xuICAgICAgICAgIGUxUHJvcDI6ICdlMVByb3AyVmFsJ1xuICAgICAgICAgIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICBlMUF0dHIxOiAnZTFBdHRyMVZhbCdcbiAgICAgICAgICAgIGUxQXR0cjI6ICdlMUF0dHIyVmFsJ1xuICAgICAgXVxuXG4gICAgICBuZXdPYmouc2hvdWxkLmVxbCBleHBlY3RlZFxuICAgICAgXG4gICAgaXQgJ3Nob3VsZCBoYW5kbGUgYXJyYXlzIG9mIG9iamVjdHMgd2l0aCBhdHRyaWJ1dGVzJywgLT5cbiAgICAgIG9iamVjdCA9IFtcbiAgICAgICAgZWxlbWVudDE6XG4gICAgICAgICAgZTFQcm9wMTogJ2UxUHJvcDFWYWwnXG4gICAgICAgICAgZTFQcm9wMjogJ2UxUHJvcDJWYWwnXG4gICAgICAgICAgX2UxQXR0cjE6ICdlMUF0dHIxVmFsJ1xuICAgICAgICAgIF9lMUF0dHIyOiAnZTFBdHRyMlZhbCdcbiAgICAgICAgZWxlbWVudDI6XG4gICAgICAgICAgZTJQcm9wMTogJ2UyUHJvcDFWYWwnXG4gICAgICAgICAgZTJQcm9wMjogJ2UyUHJvcDJWYWwnXG4gICAgICAgICAgX2UyQXR0cjE6ICdlMkF0dHIxVmFsJ1xuICAgICAgICAgIF9lMkF0dHIyOiAnZTJBdHRyMlZhbCdcbiAgICAgIF1cblxuICAgICAgbmV3T2JqID0gYWRhcHRlcnMuanNvbkF0dHJzIG9iamVjdFxuICAgICAgXG4gICAgICBleHBlY3RlZCA9IFtcbiAgICAgICAgZWxlbWVudDE6XG4gICAgICAgICAgZTFQcm9wMTogJ2UxUHJvcDFWYWwnXG4gICAgICAgICAgZTFQcm9wMjogJ2UxUHJvcDJWYWwnXG4gICAgICAgICAgYXR0cmlidXRlczpcbiAgICAgICAgICAgIGUxQXR0cjE6ICdlMUF0dHIxVmFsJ1xuICAgICAgICAgICAgZTFBdHRyMjogJ2UxQXR0cjJWYWwnXG4gICAgICAgIGVsZW1lbnQyOlxuICAgICAgICAgIGUyUHJvcDE6ICdlMlByb3AxVmFsJ1xuICAgICAgICAgIGUyUHJvcDI6ICdlMlByb3AyVmFsJ1xuICAgICAgICAgIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICBlMkF0dHIxOiAnZTJBdHRyMVZhbCdcbiAgICAgICAgICAgIGUyQXR0cjI6ICdlMkF0dHIyVmFsJ1xuICAgICAgXVxuXG4gICAgICBuZXdPYmouc2hvdWxkLmVxbCBleHBlY3RlZFxuICAgICAgXG4gICAgaXQgJ3Nob3VsZCBoYW5kbGUgYSBtaXggb2Ygb2JqZWN0IHdpdGggYXJyYXlzIGFuZCB3aXRob3V0JywgLT5cbiAgICAgIG9iamVjdCA9XG4gICAgICAgIHByb3AxOiAncHJvcDFWYWwnXG4gICAgICAgIHByb3AyOiAncHJvcDJWYWwnXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgXCJlbGVtZW50MVwiXG4gICAgICAgICAgXCJlbGVtZW50MlwiXG4gICAgICAgICAgZWxlbWVudE9iajE6XG4gICAgICAgICAgICBlbE9ialByb3AxOiAnZWxPYmpQcm9wMVZhbCdcbiAgICAgICAgICAgIGVsT2JqUHJvcDI6ICdlbE9ialByb3AyVmFsJ1xuICAgICAgICAgICAgX2VsT2JqQXR0cjE6ICdlbE9iakF0dHIxVmFsJ1xuICAgICAgICAgICAgX2VsT2JqQXR0cjI6ICdlbE9iakF0dHIyVmFsJ1xuICAgICAgICBdXG4gICAgICAgIF9hdHRyMTogJ2F0dHIxVmFsJ1xuICAgICAgICBfYXR0cjI6ICdhdHRyMlZhbCdcblxuICAgICAgbmV3T2JqID0gYWRhcHRlcnMuanNvbkF0dHJzIG9iamVjdFxuICAgICBcbiAgICAgIGV4cGVjdGVkID1cbiAgICAgICAgcHJvcDE6ICdwcm9wMVZhbCdcbiAgICAgICAgcHJvcDI6ICdwcm9wMlZhbCdcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICBcImVsZW1lbnQxXCJcbiAgICAgICAgICBcImVsZW1lbnQyXCJcbiAgICAgICAgICBlbGVtZW50T2JqMTpcbiAgICAgICAgICAgIGVsT2JqUHJvcDE6ICdlbE9ialByb3AxVmFsJ1xuICAgICAgICAgICAgZWxPYmpQcm9wMjogJ2VsT2JqUHJvcDJWYWwnXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICBlbE9iakF0dHIxOiAnZWxPYmpBdHRyMVZhbCdcbiAgICAgICAgICAgICAgZWxPYmpBdHRyMjogJ2VsT2JqQXR0cjJWYWwnXG4gICAgICAgIF1cbiAgICAgICAgYXR0cmlidXRlczpcbiAgICAgICAgICBhdHRyMTogJ2F0dHIxVmFsJ1xuICAgICAgICAgIGF0dHIyOiAnYXR0cjJWYWwnXG5cbiAgICAgIG5ld09iai5zaG91bGQuZXFsIGV4cGVjdGVkXG5cbiAgICBpdCAnc2hvdWxkIGFsbG93IGEgY3VzdG9tIGBhdHRyaWJ1dGVgIG9iamVjdCBuYW1lJywgLT5cbiAgICAgIG9iamVjdCA9XG4gICAgICAgIF9hdHRyMTogJ2F0dHIxVmFsJ1xuICAgICAgICBfYXR0cjI6ICdhdHRyMlZhbCdcblxuICAgICAgbmV3T2JqID0gYWRhcHRlcnMuanNvbkF0dHJzIG9iamVjdCwgYXR0ck9iamVjdE5hbWU6IFwibXlBdHRyaWJ1dGVzXCJcblxuICAgICAgZXhwZWN0ZWQgPVxuICAgICAgICBteUF0dHJpYnV0ZXM6XG4gICAgICAgICAgYXR0cjE6ICdhdHRyMVZhbCdcbiAgICAgICAgICBhdHRyMjogJ2F0dHIyVmFsJ1xuXG4gICAgICBuZXdPYmouc2hvdWxkLmVxbCBleHBlY3RlZFxuXG4gICAgaXQgJ3Nob3VsZCBhbGxvdyBhIGN1c3RvbSByZWdleHAgdG8gaWRlbnRpZnkgcG90ZW50aWFsIGF0dHJpYnV0ZXMnLCAtPlxuICAgICAgb2JqZWN0ID1cbiAgICAgICAgX2F0dHJpYnV0ZV9hdHRyMTogJ2F0dHIxVmFsJ1xuICAgICAgICBfYXR0cmlidXRlX2F0dHIyOiAnYXR0cjJWYWwnXG5cbiAgICAgIG5ld09iaiA9IGFkYXB0ZXJzLmpzb25BdHRycyBvYmplY3QsIHJlZ2V4cDogL15fYXR0cmlidXRlXy9cblxuICAgICAgZXhwZWN0ZWQgPVxuICAgICAgICBhdHRyaWJ1dGVzOlxuICAgICAgICAgIGF0dHJpYnV0ZV9hdHRyMTogJ2F0dHIxVmFsJ1xuICAgICAgICAgIGF0dHJpYnV0ZV9hdHRyMjogJ2F0dHIyVmFsJ1xuXG4gICAgICBuZXdPYmouc2hvdWxkLmVxbCBleHBlY3RlZFxuICAgIFxuICAgIGl0ICdzaG91bGQgYWxsb3cgYSBjdXN0b20gZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGF0dHJpYnV0ZSBwcm9wZXJ0eSBuYW1lcycsIC0+XG4gICAgICBvYmplY3QgPVxuICAgICAgICBfYXR0cjE6ICdhdHRyMVZhbCdcbiAgICAgICAgX2F0dHIyOiAnYXR0cjJWYWwnXG5cbiAgICAgIG5ld09iaiA9IGFkYXB0ZXJzLmpzb25BdHRycyBvYmplY3QsIG5hbWVUcmFuc2Zvcm06IChuYW1lKSAtPiBcImF0dHIje25hbWV9XCJcblxuICAgICAgZXhwZWN0ZWQgPVxuICAgICAgICBhdHRyaWJ1dGVzOlxuICAgICAgICAgIGF0dHJfYXR0cjE6ICdhdHRyMVZhbCdcbiAgICAgICAgICBhdHRyX2F0dHIyOiAnYXR0cjJWYWwnXG5cbiAgICAgIG5ld09iai5zaG91bGQuZXFsIGV4cGVjdGVkXG5cbiAgICBpdCAnc2hvdWxkIGNvbnZlcnQgYSBcXCdfX3RleHRcXCcgcHJvcGVydHkgdG8gYSB0ZXh0IHByb3BlcnR5JywgLT5cblxuICAgICAgb2JqZWN0ID1cbiAgICAgICAgX2F0dHIxOiAnYXR0cjFWYWwnXG4gICAgICAgIF9hdHRyMjogJ2F0dHIyVmFsJ1xuICAgICAgICBfX3RleHQ6ICdzb21lIHRleHQgdmFsdWUnXG5cbiAgICAgIG5ld09iaiA9IGFkYXB0ZXJzLmpzb25BdHRycyBvYmplY3RcblxuICAgICAgZXhwZWN0ZWQgPVxuICAgICAgICBhdHRyaWJ1dGVzOlxuICAgICAgICAgIGF0dHIxOiAnYXR0cjFWYWwnXG4gICAgICAgICAgYXR0cjI6ICdhdHRyMlZhbCdcbiAgICAgICAgdGV4dDogJ3NvbWUgdGV4dCB2YWx1ZSdcblxuICAgICAgbmV3T2JqLnNob3VsZC5lcWwgZXhwZWN0ZWRcblxuICAgIGl0ICdzaG91bGQgY29udmVydCBuZXN0ZWQgXFwnX190ZXh0XFwnIHByb3BlcnRpZXMgdG8gdGV4dCBwcm9wZXJ0aWVzJywgLT5cblxuICAgICAgb2JqZWN0ID1cbiAgICAgICAgX2F0dHIxOiAnYXR0cjFWYWwnXG4gICAgICAgIF9hdHRyMjogJ2F0dHIyVmFsJ1xuICAgICAgICBfX3RleHQ6ICdzb21lIHRleHQgdmFsdWUnXG4gICAgICAgIGNoaWxkOlxuICAgICAgICAgIF9jaGlsZF9hdHRyMTogJ2NoaWxkQXR0cjFWYWwnXG4gICAgICAgICAgX2NoaWxkX2F0dHIyOiAnY2hpbGRBdHRyMlZhbCdcbiAgICAgICAgICBfX3RleHQ6ICdzb21lIGNoaWxkIHRleHQgdmFsdWUnXG5cbiAgICAgIG5ld09iaiA9IGFkYXB0ZXJzLmpzb25BdHRycyBvYmplY3RcblxuICAgICAgZXhwZWN0ZWQgPVxuICAgICAgICBhdHRyaWJ1dGVzOlxuICAgICAgICAgIGF0dHIxOiAnYXR0cjFWYWwnXG4gICAgICAgICAgYXR0cjI6ICdhdHRyMlZhbCdcbiAgICAgICAgdGV4dDogJ3NvbWUgdGV4dCB2YWx1ZSdcbiAgICAgICAgY2hpbGQ6XG4gICAgICAgICAgYXR0cmlidXRlczpcbiAgICAgICAgICAgIGNoaWxkX2F0dHIxOiAnY2hpbGRBdHRyMVZhbCdcbiAgICAgICAgICAgIGNoaWxkX2F0dHIyOiAnY2hpbGRBdHRyMlZhbCdcbiAgICAgICAgICB0ZXh0OiAnc29tZSBjaGlsZCB0ZXh0IHZhbHVlJ1xuXG4gICAgICBuZXdPYmouc2hvdWxkLmVxbCBleHBlY3RlZFxuIiwie3Npbm9uLCBhc3NlcnR9ID0gcmVxdWlyZSAnc3BlYy9zcGVjX2hlbHBlcidcblxuZGVzY3JpYmUgJ2Nsb3N1cmVzJywgLT5cblxuICBkZXNjcmliZSAncHJpdmF0ZSB2YXJpYWJsZXMnLCAtPlxuXG4gICAgZGVzY3JpYmUgJ2RlY2xhcmVkIGluIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiBhIGNsb3N1cmUnLCAtPlxuICAgIFxuICAgICAgZnVuYyA9IG51bGxcblxuICAgICAgYmVmb3JlRWFjaCAtPlxuXG4gICAgICAgIGZ1bmMgPSAtPlxuICAgICAgICAgIHZhcmlhYmxlID0gMFxuICAgICAgICAgIC0+XG4gICAgICAgICAgICB2YXJpYWJsZSArPSAxXG5cbiAgICAgIGFmdGVyRWFjaCAtPlxuICAgICAgICBmdW5jID0gbnVsbFxuXG4gICAgICBpdCAnc2hvdWxkIHJldHVybiAxIHdoZW4gY3JlYXRlZCBvbmNlJywgLT5cbiAgICAgICAgZiA9IGZ1bmMoKVxuICAgICAgICBmKCkuc2hvdWxkLmVxdWFsIDFcblxuICAgICAgaXQgJ3Nob3VsZCBtYWludGFpbiBzZXBhcmF0ZSBmdW5jdGlvbiBlbnZpcm9ubWVudHMgd2hlbiBjcmVhdGVkIHR3aWNlJywgLT5cbiAgICAgICAgZjEgPSBmdW5jKClcbiAgICAgICAgZjEoKS5zaG91bGQuZXF1YWwgMVxuICAgICAgICBmMSgpLnNob3VsZC5lcXVhbCAyXG4gICAgICAgIGYxKCkuc2hvdWxkLmVxdWFsIDNcblxuICAgICAgICBmMiA9IGZ1bmMoKVxuICAgICAgICBmMigpLnNob3VsZC5lcXVhbCAxXG5cbiAgICBkZXNjcmliZSAnZGVmaW5lZCBieSBhcmdzIHBhc3NlZCBpbnRvIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiBhIGNsb3N1cmUnLCAtPlxuICAgIFxuICAgICAgZnVuYyA9IG51bGxcblxuICAgICAgYmVmb3JlRWFjaCAtPlxuICAgICAgICBmdW5jID0gKGFyZykgLT5cbiAgICAgICAgICAtPlxuICAgICAgICAgICAgYXJnICs9IDFcblxuICAgICAgYWZ0ZXJFYWNoIC0+XG4gICAgICAgIGZ1bmMgPSBudWxsXG5cbiAgICAgIGl0ICdzaG91bGQgcmV0dXJuIDEgd2hlbiBjcmVhdGVkIG9uY2UnLCAtPlxuICAgICAgICBmID0gZnVuYyAxXG4gICAgICAgIGYoKS5zaG91bGQuZXF1YWwgMlxuXG4gICAgICBpdCAnc2hvdWxkIG1haW50YWluIHNlcGFyYXRlIGZ1bmN0aW9uIGVudmlyb25tZW50cyB3aGVuIGNyZWF0ZWQgdHdpY2UnLCAtPlxuICAgICAgICBmMSA9IGZ1bmMgMVxuICAgICAgICBmMSgpLnNob3VsZC5lcXVhbCAyXG4gICAgICAgIGYxKCkuc2hvdWxkLmVxdWFsIDNcbiAgICAgICAgZjEoKS5zaG91bGQuZXF1YWwgNFxuXG4gICAgICAgIGYyID0gZnVuYyAxXG4gICAgICAgIGYyKCkuc2hvdWxkLmVxdWFsIDJcbiIsIntzaW5vbiwgYXNzZXJ0LCBYMkpTLCBmaXh0dXJlcywgdHJpbUZpeHR1cmV9ID0gcmVxdWlyZSAnc3BlYy9zcGVjX2hlbHBlcidcblN0cm9waGUgPSByZXF1aXJlICdzdHJvcGhlJ1xuQmxvY2tsaXN0ID0gcmVxdWlyZSAnY29tcG9uZW50cy9ibG9ja2xpc3QnXG5cbmRlc2NyaWJlICdCbG9ja2xpc3QnLCAtPlxuXG4gIGJsb2NrbGlzdCA9IG51bGxcbiAgc2VuZElRID0gbnVsbFxuICBzdHJvcGhlSGVscGVyID1cbiAgICBnZXRCbG9ja2xpc3RTdGFuemE6IHNpbm9uLnN0dWIoKS5yZXR1cm5zIG5ldyBTdHJvcGhlLkJ1aWxkZXIoKVxuICAgIGdldEJsb2NrU3RhbnphOiBzaW5vbi5zdHViKCkucmV0dXJucyBuZXcgU3Ryb3BoZS5CdWlsZGVyKClcbiAgICBnZXRVbmJsb2NrU3RhbnphOiBzaW5vbi5zdHViKCkucmV0dXJucyBuZXcgU3Ryb3BoZS5CdWlsZGVyKClcbiAgXG4gIGFmdGVyRWFjaCAtPlxuICAgIHN0cm9waGVIZWxwZXIuZ2V0QmxvY2tsaXN0U3RhbnphLnJlc2V0KClcbiAgICBzdHJvcGhlSGVscGVyLmdldEJsb2NrU3RhbnphLnJlc2V0KClcbiAgICBzdHJvcGhlSGVscGVyLmdldFVuYmxvY2tTdGFuemEucmVzZXQoKVxuICAgIEJsb2NrbGlzdC5kZXN0cm95KClcbiAgICBibG9ja2xpc3QgPSBudWxsXG4gICAgc2VuZElRID0gbnVsbFxuICAgIGhlbHBlciA9IG51bGxcblxuICBkZXNjcmliZSAnI2dldEJsb2NrbGlzdCgpJywgLT5cblxuICAgIHJlc29sdmUgPSBudWxsXG4gICAgcmVqZWN0ID0gbnVsbFxuICAgIFxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIHNlbmRJUSA9IHNpbm9uLnNweSAob3B0aW9ucyA9IHt9KSAtPlxuICAgICAgICB7cmVzb2x2ZSwgcmVqZWN0fSA9IG9wdGlvbnNcblxuICAgIFxuICAgICAgYmxvY2tsaXN0ID0gQmxvY2tsaXN0LmdldCBzZW5kSVE6IHNlbmRJUSwgaGVscGVyOiBzdHJvcGhlSGVscGVyXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIHNlbmRJUS5yZXNldCgpXG4gICAgICByZXNvbHZlID0gbnVsbFxuICAgICAgcmVqZWN0ID0gbnVsbFxuICAgIFxuICAgIGl0ICdzaG91bGQgcmV0cmlldmUgYSBibG9ja2xpc3QgYnkgY2FsbGluZyAjc2VuZElRKCkgd2l0aCBhIHN0YW56YScsIC0+XG4gICAgICBibG9ja2xpc3QuZ2V0QmxvY2tsaXN0KClcblxuICAgICAgc3Ryb3BoZUhlbHBlci5nZXRCbG9ja2xpc3RTdGFuemEuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRPbmNlXG4gICAgICBzZW5kSVEuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aCBzaW5vbi5tYXRjaFxuICAgICAgICAgIGVsZW1lbnQ6IHNpbm9uLm1hdGNoLmluc3RhbmNlT2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICAgICAgcmVzb2x2ZTogc2lub24ubWF0Y2guZnVuY1xuICAgICAgICAgIHJlamVjdDogc2lub24ubWF0Y2guZnVuY1xuXG4gICAgZGVzY3JpYmUgJ3doZW4gZmFpbHVyZScsIC0+XG5cbiAgICAgIGVycm9yTXNnID0gbnVsbFxuICAgIFxuICAgICAgYmVmb3JlRWFjaCAtPlxuICAgICAgICBzaW5vbi5zdHViIGNvbnNvbGUsICdlcnJvcidcbiAgICAgICAgZXJyb3JNc2cgPSBcIllvdSBhcmUgbm90IGNvbm5lY3RlZCB0byBOaXRybyFcIlxuXG4gICAgICBhZnRlckVhY2ggLT5cbiAgICAgICAgZXJyb3JNc2cgPSBudWxsXG4gICAgICAgIGNvbnNvbGUuZXJyb3IucmVzdG9yZSgpXG4gICAgXG4gICAgICBpdCAnc2hvdWxkIGxvZyBhbiBlcnJvciB0byB0aGUgY29uc29sZScsIChkb25lKSAtPlxuICAgICAgICBwcm9taXNlID0gYmxvY2tsaXN0LmdldEJsb2NrbGlzdCgpXG4gICAgICAgIHByb21pc2Uuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWQubm90aWZ5IGRvbmVcbiAgICAgICAgcHJvbWlzZS5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGggZXJyb3JNc2dcbiAgICAgICAgXG4gICAgICAgICMgU2ltdWxhdGUgZmFpbHVyZSBieSBjYWxsaW5nIHJlamVjdCB3aXRoIGFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIHJlamVjdCBlcnJvck1zZ1xuXG4gICAgICBpdCAnc2hvdWxkIG5vdCBhZmZlY3QgdGhlIHByZXZpb3VzbHkgc3RvcmVkIGxpc3Qgb2YgYmxvY2tlZCBjb250YWN0IEpJRHMnLCAoZG9uZSkgLT5cbiAgICAgICAgYmxvY2tsaXN0Ll9ibG9ja2VkSklEcyA9IFsncHJldmlvdXNKSUQxJywgJ3ByZXZpb3VzSklEMiddXG4gICAgICAgIGJsb2NrbGlzdC5nZXRCbG9ja2xpc3QoKS5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZC50aGVuIC0+XG4gICAgICAgICAgIyBKSURzIHNob3VsZCBtYXRjaCB0aGUgcHJldmlvdXMgYmxvY2tlZCBqaWRzLlxuICAgICAgICAgIGJsb2NrbGlzdC5fYmxvY2tlZEpJRHMuc2hvdWxkLmVxbCBbJ3ByZXZpb3VzSklEMScsICdwcmV2aW91c0pJRDInXVxuICAgICAgICAgIGRvbmUoKVxuICAgICAgIFxuICAgICAgICAjIFNpbXVsYXRlIGZhaWx1cmUgYnkgY2FsbGluZyByZWplY3Qgd2l0aCBhbiBlcnJvciBtZXNzYWdlLlxuICAgICAgICByZWplY3QgZXJyb3JNc2dcbiAgICAgICAgXG4gIGRlc2NyaWJlICcjYmxvY2soKScsIC0+XG4gICAgXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgc2VuZElRID0gc2lub24uc3R1YigpXG4gICAgICBibG9ja2xpc3QgPSBCbG9ja2xpc3QuZ2V0IHNlbmRJUTogc2VuZElRLCBoZWxwZXI6IHN0cm9waGVIZWxwZXJcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgc2VuZElRLnJlc2V0KClcblxuICAgIGl0ICdzaG91bGQgYWNjZXB0IGEgc2luZ2xlIHBsYWluIGppZCcsIC0+XG4gICAgICBqaWQgPSAnamlkMSdcbiAgICAgIGJsb2NrbGlzdC5ibG9jayBqaWRcbiAgICAgIHN0cm9waGVIZWxwZXIuZ2V0QmxvY2tTdGFuemEuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRPbmNlXG4gICAgICBzZW5kSVEuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aCBzaW5vbi5tYXRjaFxuICAgICAgICAgIGVsZW1lbnQ6IHNpbm9uLm1hdGNoLmluc3RhbmNlT2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICAgICAgcmVzb2x2ZTogc2lub24ubWF0Y2guZnVuY1xuICAgICAgICAgIHJlamVjdDogc2lub24ubWF0Y2guZnVuY1xuICAgIFxuICAgIGl0ICdzaG91bGQgYmxvY2sgdXNlcnMgYnkgY2FsbGluZyAjc2VuZElRKCkgd2l0aCBhIHN0YW56YScsIC0+XG4gICAgICBqaWRzID0gWydqaWQxJywgJ2ppZDInXVxuICAgICAgYmxvY2tsaXN0LmJsb2NrIGppZHNcbiAgICAgIHN0cm9waGVIZWxwZXIuZ2V0QmxvY2tTdGFuemEuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRPbmNlXG4gICAgICBzZW5kSVEuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aCBzaW5vbi5tYXRjaFxuICAgICAgICAgIGVsZW1lbnQ6IHNpbm9uLm1hdGNoLmluc3RhbmNlT2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICAgICAgcmVzb2x2ZTogc2lub24ubWF0Y2guZnVuY1xuICAgICAgICAgIHJlamVjdDogc2lub24ubWF0Y2guZnVuY1xuXG4gIGRlc2NyaWJlICcjdW5ibG9jaygpJywgLT5cbiAgICBcbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBzZW5kSVEgPSBzaW5vbi5zdHViKClcbiAgICAgIGJsb2NrbGlzdCA9IEJsb2NrbGlzdC5nZXQgc2VuZElROiBzZW5kSVEsIGhlbHBlcjogc3Ryb3BoZUhlbHBlclxuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICBzZW5kSVEucmVzZXQoKVxuXG4gICAgaXQgJ3Nob3VsZCBhY2NlcHQgYSBzaW5nbGUgcGxhaW4gamlkJywgLT5cbiAgICAgIGppZCA9ICdqaWQxJ1xuICAgICAgYmxvY2tsaXN0LnVuYmxvY2sgamlkXG4gICAgICBzdHJvcGhlSGVscGVyLmdldFVuYmxvY2tTdGFuemEuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRPbmNlXG4gICAgICBzZW5kSVEuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aCBzaW5vbi5tYXRjaFxuICAgICAgICAgIGVsZW1lbnQ6IHNpbm9uLm1hdGNoLmluc3RhbmNlT2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICAgICAgcmVzb2x2ZTogc2lub24ubWF0Y2guZnVuY1xuICAgICAgICAgIHJlamVjdDogc2lub24ubWF0Y2guZnVuY1xuICAgIFxuICAgIGl0ICdzaG91bGQgdW5ibG9jayB1c2VycyBieSBjYWxsaW5nICNzZW5kSVEoKSB3aXRoIGEgc3RhbnphJywgLT5cbiAgICAgIGppZHMgPSBbJ2ppZDEnLCAnamlkMiddXG4gICAgICBibG9ja2xpc3QudW5ibG9jayBqaWRzXG4gICAgICBzdHJvcGhlSGVscGVyLmdldFVuYmxvY2tTdGFuemEuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRPbmNlXG4gICAgICBzZW5kSVEuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aCBzaW5vbi5tYXRjaFxuICAgICAgICAgIGVsZW1lbnQ6IHNpbm9uLm1hdGNoLmluc3RhbmNlT2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICAgICAgcmVzb2x2ZTogc2lub24ubWF0Y2guZnVuY1xuICAgICAgICAgIHJlamVjdDogc2lub24ubWF0Y2guZnVuY1xuIiwie18sIHNpbm9uLCBhc3NlcnQsIGV4cGVjdH0gPSByZXF1aXJlICdzcGVjL3NwZWNfaGVscGVyJ1xuU3Ryb3BoZSA9IHJlcXVpcmUgJ3N0cm9waGUnXG5HYXRld2F5ID0gcmVxdWlyZSAnY29tcG9uZW50cy9nYXRld2F5J1xuXG5kZXNjcmliZSAnR2F0ZXdheScsIC0+XG5cbiAgZ2F0ZXdheSA9IG51bGxcbiAgc2VuZCA9IG51bGxcbiAgc2VuZElRID0gbnVsbFxuICBzdHJvcGhlSGVscGVyID0gbnVsbFxuXG4gIGdldFVzZXJuYW1lID0gKG5hbWUgPSAnYScpIC0+XG4gICAgXCJ1c2VyLiN7bmFtZX0udGhvbXNvbnJldXRlcnMuY29tQHJldXRlcnMubmV0XCJcblxuICBnZXRQYXNzd29yZCA9IC0+XG4gICAgKG5ldyBEYXRlKCkuZ2V0VGltZSgpKS50b1N0cmluZygpXG5cbiAgYmVmb3JlIC0+XG4gICAgc3Ryb3BoZUhlbHBlciA9XG4gICAgICBnZXRSZWdpc3RlclN0YW56YTogc2lub24uc3R1YigpLnJldHVybnMgJGlxKClcbiAgICAgIGdldFVucmVnaXN0ZXJTdGFuemE6IHNpbm9uLnN0dWIoKS5yZXR1cm5zICRpcSgpXG4gICAgICBnZXRTdWJzY3JpcHRpb25TdGFuemE6IHNpbm9uLnN0dWIoKS5yZXR1cm5zICRwcmVzKClcbiAgICAgIGdldFByZXNlbmNlU3RhbnphOiBzaW5vbi5zdHViKCkucmV0dXJucyAkcHJlcygpXG4gICAgICBnZXRSb3N0ZXJTdGFuemE6IHNpbm9uLnN0dWIoKS5yZXR1cm5zICRpcSgpXG5cbiAgYWZ0ZXJFYWNoIC0+XG4gICAgc3Ryb3BoZUhlbHBlci5nZXRSZWdpc3RlclN0YW56YS5yZXNldCgpXG4gICAgc3Ryb3BoZUhlbHBlci5nZXRVbnJlZ2lzdGVyU3RhbnphLnJlc2V0KClcbiAgICBzdHJvcGhlSGVscGVyLmdldFN1YnNjcmlwdGlvblN0YW56YS5yZXNldCgpXG4gICAgc3Ryb3BoZUhlbHBlci5nZXRQcmVzZW5jZVN0YW56YS5yZXNldCgpXG4gICAgc3Ryb3BoZUhlbHBlci5nZXRSb3N0ZXJTdGFuemEucmVzZXQoKVxuXG4gIGRlc2NyaWJlICcjcmVnaXN0ZXIoKScsIC0+XG5cbiAgICByZWdpc3Rlck9wdGlvbnMgPSBudWxsXG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBzZW5kSVEgPSBzaW5vbi5zdHViKClcbiAgICAgIGdhdGV3YXkgPSBuZXcgR2F0ZXdheSBzZW5kOiBzZW5kLCBzZW5kSVE6IHNlbmRJUSwgaGVscGVyOiBzdHJvcGhlSGVscGVyXG4gICAgICBnYXRld2F5Lm5pdHJvQ29ubmVjdGVkID0gdHJ1ZVxuICAgICAgZ2F0ZXdheS5qaWQgPSBnZXRVc2VybmFtZSAnc2VsZidcblxuICAgICAgcmVnaXN0ZXJPcHRpb25zID1cbiAgICAgICAgdXNlcm5hbWU6IGdldFVzZXJuYW1lICdzZWxmLXlhaG9vJ1xuICAgICAgICBwYXNzd29yZDogZ2V0UGFzc3dvcmQoKVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBRIHByb21pc2UnLCAtPlxuICAgICAgZ2F0ZXdheS5yZWdpc3RlcihyZWdpc3Rlck9wdGlvbnMpLl9fcHJvdG9fXy50b1N0cmluZygpXG4gICAgICAgIC5zaG91bGQuZXF1YWwgXCJbb2JqZWN0IFByb21pc2VdXCJcblxuICAgIGl0ICdzaG91bGQgY2FsbCBzZW5kSVEgd2l0aCBwcm9wZXIgYXJncycsIC0+XG4gICAgICBnYXRld2F5LnJlZ2lzdGVyKHJlZ2lzdGVyT3B0aW9ucylcbiAgICAgIHNlbmRJUS5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoIHNpbm9uLm1hdGNoXG4gICAgICAgICAgZWxlbWVudDogU3Ryb3BoZS5CdWlsZGVyLnByb3RvdHlwZVxuICAgICAgICAgIHJlc29sdmU6IHNpbm9uLm1hdGNoLmZ1bmNcbiAgICAgICAgICByZWplY3Q6IHNpbm9uLm1hdGNoLmZ1bmNcblxuICAgIGl0ICdzaG91bGQgc2hvdWxkIHJldHVybiBudWxsIHdoZW4gdXNlcm5hbWUgaXMgdW5zcGVjaWZpZWQnLCAtPlxuICAgICAgcHJvbWlzZSA9IGdhdGV3YXkucmVnaXN0ZXIgcGFzc3dvcmQ6IGdldFBhc3N3b3JkKClcbiAgICAgIHByb21pc2UgaXMgbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCBzaG91bGQgcmV0dXJuIG51bGwgd2hlbiBwYXNzd29yZCBpcyB1bnNwZWNpZmllZCcsIC0+XG4gICAgICBwcm9taXNlID0gZ2F0ZXdheS5yZWdpc3RlciB1c2VybmFtZTogZ2V0VXNlcm5hbWUoKVxuICAgICAgcHJvbWlzZSBpcyBudWxsXG5cbiAgZGVzY3JpYmUgJyN1bnJlZ2lzdGVyKCknLCAtPlxuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgc2VuZElRID0gc2lub24uc3R1YigpXG4gICAgICBnYXRld2F5ID0gbmV3IEdhdGV3YXkgc2VuZDogc2VuZCwgc2VuZElROiBzZW5kSVEsIGhlbHBlcjogc3Ryb3BoZUhlbHBlclxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBRIHByb21pc2UnLCAtPlxuICAgICAgZ2F0ZXdheS51bnJlZ2lzdGVyKCkuX19wcm90b19fLnRvU3RyaW5nKClcbiAgICAgICAgLnNob3VsZC5lcXVhbCBcIltvYmplY3QgUHJvbWlzZV1cIlxuXG4gICAgaXQgJ3Nob3VsZCBjYWxsIHNlbmRJUSB3aXRoIHByb3BlciBhcmdzJywgLT5cbiAgICAgIGdhdGV3YXkudW5yZWdpc3RlcigpXG4gICAgICBzZW5kSVEuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aCBzaW5vbi5tYXRjaFxuICAgICAgICAgIGVsZW1lbnQ6IFN0cm9waGUuQnVpbGRlci5wcm90b3R5cGVcbiAgICAgICAgICByZXNvbHZlOiBzaW5vbi5tYXRjaC5mdW5jXG4gICAgICAgICAgcmVqZWN0OiBzaW5vbi5tYXRjaC5mdW5jXG5cbiAgZGVzY3JpYmUgJyNzZXRQcmVzZW5jZSgpJywgLT5cbiIsIntzaW5vbiwgYXNzZXJ0fSA9IHJlcXVpcmUgJ3NwZWMvc3BlY19oZWxwZXInXG5TdHJvcGhlID0gcmVxdWlyZSAnc3Ryb3BoZSdcbk1lc3NhZ2luZyA9IHJlcXVpcmUgJ2NvbXBvbmVudHMvbWVzc2FnaW5nJ1xuXG5kZXNjcmliZSAnTWVzc2FnaW5nJywgLT5cblxuICBtZXNzYWdlcyA9IG51bGxcblxuICBhZnRlckVhY2ggLT5cbiAgICBtZXNzYWdlcyA9IG51bGxcblxuICBpdCAndHJ1ZScsIC0+XG4gICAgYXNzZXJ0IHRydWVcbiIsIntzaW5vbiwgYXNzZXJ0fSA9IHJlcXVpcmUgJ3NwZWMvc3BlY19oZWxwZXInXG5TdHJvcGhlID0gcmVxdWlyZSAnc3Ryb3BoZSdcbk1VQyA9IHJlcXVpcmUgJ2NvbXBvbmVudHMvbXVjJ1xuUSA9IHJlcXVpcmUgJ1EnXG5cbmRlc2NyaWJlICdNVUMnLCAtPlxuXG4gIG11YyA9IG51bGxcbiAgc3Ryb3BoZUhlbHBlciA9IG51bGxcblxuICBiZWZvcmUgLT5cbiAgICBzdHJvcGhlSGVscGVyID1cbiAgICAgIGdldEpvaW5TdGFuemE6IHNpbm9uLnN0dWIoKS5yZXR1cm5zICRwcmVzKClcbiAgICAgIGdldExlYXZlU3RhbnphOiBzaW5vbi5zdHViKCkucmV0dXJucyAkcHJlcygpXG4gICAgICBnZXREZXN0cm95R3JvdXBjaGF0U3RhbnphOiBzaW5vbi5zdHViKCkucmV0dXJucyAkaXEoKVxuICAgICAgZ2V0R3JvdXBjaGF0Q29uZmlnRm9ybTogc2lub24uc3R1YigpXG4gICAgICBhZGRHcm91cGNoYXRDb25maWdGaWVsZDogc2lub24uc3R1YigpXG4gICAgICBnZXRSb29tRGlzY29TdGFuemE6IHNpbm9uLnN0dWIoKS5yZXR1cm5zICRpcSgpXG4gICAgICBnZXRNZW1iZXJMaXN0U3RhbnphOiBzaW5vbi5zdHViKCkucmV0dXJucyAkaXEoKVxuICAgICAgZ2V0TWVkaWF0ZWRJbnZpdGVTdGFuemE6IHNpbm9uLnN0dWIoKS5yZXR1cm5zICRtc2coKVxuXG4gIGFmdGVyRWFjaCAtPlxuICAgIHN0cm9waGVIZWxwZXIuZ2V0Sm9pblN0YW56YS5yZXNldCgpXG4gICAgc3Ryb3BoZUhlbHBlci5nZXRMZWF2ZVN0YW56YS5yZXNldCgpXG4gICAgc3Ryb3BoZUhlbHBlci5nZXREZXN0cm95R3JvdXBjaGF0U3RhbnphLnJlc2V0KClcbiAgICBzdHJvcGhlSGVscGVyLmdldEdyb3VwY2hhdENvbmZpZ0Zvcm0ucmVzZXQoKVxuICAgIHN0cm9waGVIZWxwZXIuYWRkR3JvdXBjaGF0Q29uZmlnRmllbGQucmVzZXQoKVxuICAgIHN0cm9waGVIZWxwZXIuZ2V0Um9vbURpc2NvU3RhbnphLnJlc2V0KClcbiAgICBzdHJvcGhlSGVscGVyLmdldE1lbWJlckxpc3RTdGFuemEucmVzZXQoKVxuICAgIHN0cm9waGVIZWxwZXIuZ2V0TWVkaWF0ZWRJbnZpdGVTdGFuemEucmVzZXQoKVxuICAgIE1VQy5kZXN0cm95KClcbiAgICBtdWMgPSBudWxsXG4gIFxuICBnZXRKSUQgPSBzaW5vbi5zcHkgLT5cbiAgICAnbXkuamlkLnRob21zb25yZXV0ZXJzLmNvbUByZXV0ZXJzLm5ldCdcbiAgc2VuZCA9IHNpbm9uLnN0dWIoKVxuICAjIGF1dG8gcmVzb2x2ZSBzZW5kSVFcbiAgc2VuZElRID0gc2lub24uc3B5IChvcHRpb25zKSAtPlxuICAgIGNvbnNvbGUubG9nICdyZXNvbHZpbmcnLCBvcHRpb25zXG4gICAgb3B0aW9ucy5yZXNvbHZlIHRydWVcblxuICBldmVudE1hbmFnZXIgPVxuICAgIGxpc3Rlbjogc2lub24uc3B5IChwYXRoKSAtPiBwYXRoXG4gICAgc3RvcExpc3RlbmluZzogc2lub24uc3R1YigpXG5cbiAgZGVzY3JpYmUgJyNjcmVhdGUoKScsIC0+XG5cbiAgICB2YWxpZEpJRCAgPSAnZm9vLmJhckBjb25mZXJlbmNlLnJldXRlcnMubmV0J1xuICAgIGludmFsaWRKSUQgPSAnaW52YWxpZCdcbiAgICBuYW1lID0gJ0Zvb0JhciBDaGF0cm9vbSdcblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIG11YyA9IE1VQy5nZXRcbiAgICAgICAgZ2V0SklEOiBnZXRKSURcbiAgICAgICAgZXZlbnRNYW5hZ2VyOiBldmVudE1hbmFnZXJcbiAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICBzZW5kSVE6IHNlbmRJUVxuICAgICAgICBoZWxwZXI6IHN0cm9waGVIZWxwZXJcblxuICAgICAgcHJvbWlzZSA9IFEoKVxuXG4gICAgICBzaW5vbi5zdHViKG11YywgJ2pvaW4nKS5yZXR1cm5zIHByb21pc2VcbiAgICAgIHNpbm9uLnN0dWIobXVjLCAnYWNjZXB0RGVmYXVsdENvbmZpZ3VyYXRpb24nKS5yZXR1cm5zIHByb21pc2VcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgc2VuZElRLnJlc2V0KClcbiAgICAgIHNlbmQucmVzZXQoKVxuICAgICAgZXZlbnRNYW5hZ2VyLmxpc3Rlbi5yZXNldCgpXG4gICAgICBldmVudE1hbmFnZXIuc3RvcExpc3RlbmluZy5yZXNldCgpXG5cbiAgICAgIG11Yy5qb2luLnJlc3RvcmUoKVxuICAgICAgbXVjLmFjY2VwdERlZmF1bHRDb25maWd1cmF0aW9uLnJlc3RvcmUoKVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBRIHByb21pc2UnLCAtPlxuICAgICAgbXVjLmNyZWF0ZSgpLl9fcHJvdG9fXy50b1N0cmluZygpXG4gICAgICAgIC5zaG91bGQuZXF1YWwgXCJbb2JqZWN0IFByb21pc2VdXCJcblxuICAgIGl0ICdzaG91bGQgcmVqZWN0IHJldHVybmVkIHByb21pc2Ugd2hlbiBnaXZlbiBhbiBpbnZhbGlkIEpJRCcsIChkb25lKSAtPlxuICAgICAgIyBubyBAZG9tYWluIHBhcnQsIHNvIGludmFsaWRcbiAgICAgIHByb21pc2UgPSBtdWMuY3JlYXRlIGppZDogaW52YWxpZEpJRFxuICAgICAgIyBub3RpZnkgYXN5bmMgbGlzdGVuZXIgd2hlbiB0aGlzIHByb21pc2UgaXMgKGhvcGVmdWxseSkgcmVqZWN0ZWQuXG4gICAgICBwcm9taXNlLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkLm5vdGlmeSBkb25lXG4gICAgICAjIGNvbmZpcm0gZXJyb3IgbWVzc2FnZVxuICAgICAgcHJvbWlzZS5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGggXCJpbnZhbGlkIGdyb3VwY2hhdCBqaWQgI3tpbnZhbGlkSklEfVwiXG5cbiAgICBpdCAnc2hvdWxkIGNhbGwgI2pvaW4oKSB3aXRoIGppZCB0byBjcmVhdGUnLCAoZG9uZSkgLT5cblxuICAgICAgbXVjLmNyZWF0ZSBqaWQ6IHZhbGlkSklELCBuYW1lOiBuYW1lXG4gICAgICAgIC5zaG91bGQuZXZlbnR1YWxseS5iZS5mdWxmaWxsZWRcbiAgICAgICAgLnRoZW4gLT5cbiAgICAgICAgICBtdWMuam9pbi5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAgICAgLmNhbGxlZFdpdGggdmFsaWRKSURcbiAgICAgICAgLnNob3VsZC5ub3RpZnkgZG9uZVxuXG4gICAgaXQgJ3Nob3VsZCBjYWxsICNhY2NlcHREZWZhdWx0Q29uZmlndXJhdGlvbigpIHdpdGggcHJvcGVyIGFyZ3MnLCAoZG9uZSkgLT5cblxuICAgICAgIyBpbnZva2UgYXBpXG4gICAgICBtdWMuY3JlYXRlIGppZDogdmFsaWRKSUQsIG5hbWU6IG5hbWVcbiAgICAgICAgLnNob3VsZC5ldmVudHVhbGx5LmJlLmZ1bGZpbGxlZFxuICAgICAgICAudGhlbiAtPlxuICAgICAgICAgIG11Yy5hY2NlcHREZWZhdWx0Q29uZmlndXJhdGlvbi5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuc2hvdWxkLm5vdGlmeSBkb25lXG4gICAgICAgIFxuICAgICAgIyBtYWtlIHN1cmUgd2UgY2FsbCBhY2NlcHREZWZhdWx0Q29uZmlndXJhdGlvbiB3aXRoIGppZCBhbmQgbmFtZVxuICAgICAgIyBwcm9taXNlLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlc29sdmVkLm5vdGlmeSBkb25lXG5cbiAgZGVzY3JpYmUgJyNqb2luKCknLCAtPlxuXG4gICAgdmFsaWRKSUQgID0gJ2Zvby5iYXJAY29uZmVyZW5jZS5yZXV0ZXJzLm5ldCdcbiAgICBpbnZhbGlkSklEID0gJ2ludmFsaWQnXG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBtdWMgPSBNVUMuZ2V0XG4gICAgICAgIGdldEpJRDogZ2V0SklEXG4gICAgICAgIGV2ZW50TWFuYWdlcjogZXZlbnRNYW5hZ2VyXG4gICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgc2VuZElROiBzZW5kSVFcbiAgICAgICAgaGVscGVyOiBzdHJvcGhlSGVscGVyXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIHNlbmRJUS5yZXNldCgpXG4gICAgICBzZW5kLnJlc2V0KClcbiAgICAgIGV2ZW50TWFuYWdlci5saXN0ZW4ucmVzZXQoKVxuICAgICAgZXZlbnRNYW5hZ2VyLnN0b3BMaXN0ZW5pbmcucmVzZXQoKVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBRIHByb21pc2UnLCAtPlxuICAgICAgbXVjLmpvaW4oKS5fX3Byb3RvX18udG9TdHJpbmcoKVxuICAgICAgICAuc2hvdWxkLmVxdWFsIFwiW29iamVjdCBQcm9taXNlXVwiXG5cbiAgICBpdCAnc2hvdWxkIHJlamVjdCByZXR1cm5lZCBwcm9taXNlIHdoZW4gZ2l2ZW4gYW4gaW52YWxpZCBKSUQnLCAoZG9uZSkgLT5cbiAgICAgICMgbm8gQGRvbWFpbiBwYXJ0LCBzbyBpbnZhbGlkXG4gICAgICBwcm9taXNlID0gbXVjLmpvaW4gaW52YWxpZEpJRFxuICAgICAgIyBub3RpZnkgYXN5bmMgbGlzdGVuZXIgd2hlbiB0aGlzIHByb21pc2UgaXMgKGhvcGVmdWxseSkgcmVqZWN0ZWQuXG4gICAgICBwcm9taXNlLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkLm5vdGlmeSBkb25lXG4gICAgICAjIGNvbmZpcm0gZXJyb3IgbWVzc2FnZVxuICAgICAgcHJvbWlzZS5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGggXCJpbnZhbGlkIGdyb3VwY2hhdCBqaWQgI3tpbnZhbGlkSklEfVwiXG5cbiAgZGVzY3JpYmUgJyNsZWF2ZSgpJywgLT5cblxuICAgIHZhbGlkSklEICA9ICdmb28uYmFyQGNvbmZlcmVuY2UucmV1dGVycy5uZXQnXG4gICAgaW52YWxpZEpJRCA9ICdpbnZhbGlkJ1xuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgbXVjID0gTVVDLmdldFxuICAgICAgICBnZXRKSUQ6IGdldEpJRFxuICAgICAgICBldmVudE1hbmFnZXI6IGV2ZW50TWFuYWdlclxuICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgIHNlbmRJUTogc2VuZElRXG4gICAgICAgIGhlbHBlcjogc3Ryb3BoZUhlbHBlclxuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICBzZW5kSVEucmVzZXQoKVxuICAgICAgc2VuZC5yZXNldCgpXG4gICAgICBldmVudE1hbmFnZXIubGlzdGVuLnJlc2V0KClcbiAgICAgIGV2ZW50TWFuYWdlci5zdG9wTGlzdGVuaW5nLnJlc2V0KClcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgUSBwcm9taXNlJywgLT5cbiAgICAgIG11Yy5sZWF2ZSgpLl9fcHJvdG9fXy50b1N0cmluZygpXG4gICAgICAgIC5zaG91bGQuZXF1YWwgXCJbb2JqZWN0IFByb21pc2VdXCJcblxuICAgIGl0ICdzaG91bGQgcmVqZWN0IHJldHVybmVkIHByb21pc2Ugd2hlbiBnaXZlbiBhbiBpbnZhbGlkIEpJRCcsIChkb25lKSAtPlxuICAgICAgIyBubyBAZG9tYWluIHBhcnQsIHNvIGludmFsaWRcbiAgICAgIHByb21pc2UgPSBtdWMubGVhdmUgaW52YWxpZEpJRFxuICAgICAgIyBub3RpZnkgYXN5bmMgbGlzdGVuZXIgd2hlbiB0aGlzIHByb21pc2UgaXMgKGhvcGVmdWxseSkgcmVqZWN0ZWQuXG4gICAgICBwcm9taXNlLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkLm5vdGlmeSBkb25lXG4gICAgICAjIGNvbmZpcm0gZXJyb3IgbWVzc2FnZVxuICAgICAgcHJvbWlzZS5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGggXCJpbnZhbGlkIGdyb3VwY2hhdCBqaWQgI3tpbnZhbGlkSklEfVwiXG5cbiAgZGVzY3JpYmUgJyNkZXN0cm95KCknLCAtPlxuXG4gICAgdmFsaWRKSUQgID0gJ2Zvby5iYXJAY29uZmVyZW5jZS5yZXV0ZXJzLm5ldCdcbiAgICBpbnZhbGlkSklEID0gJ2ludmFsaWQnXG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBtdWMgPSBNVUMuZ2V0XG4gICAgICAgIGdldEpJRDogZ2V0SklEXG4gICAgICAgIGV2ZW50TWFuYWdlcjogZXZlbnRNYW5hZ2VyXG4gICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgc2VuZElROiBzZW5kSVFcbiAgICAgICAgaGVscGVyOiBzdHJvcGhlSGVscGVyXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIHNlbmRJUS5yZXNldCgpXG4gICAgICBzZW5kLnJlc2V0KClcbiAgICAgIGV2ZW50TWFuYWdlci5saXN0ZW4ucmVzZXQoKVxuICAgICAgZXZlbnRNYW5hZ2VyLnN0b3BMaXN0ZW5pbmcucmVzZXQoKVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBRIHByb21pc2UnLCAtPlxuICAgICAgbXVjLmRlc3Ryb3koKS5fX3Byb3RvX18udG9TdHJpbmcoKVxuICAgICAgICAuc2hvdWxkLmVxdWFsIFwiW29iamVjdCBQcm9taXNlXVwiXG5cbiAgICBpdCAnc2hvdWxkIHJlamVjdCByZXR1cm5lZCBwcm9taXNlIHdoZW4gZ2l2ZW4gYW4gaW52YWxpZCBKSUQnLCAoZG9uZSkgLT5cbiAgICAgICMgbm8gQGRvbWFpbiBwYXJ0LCBzbyBpbnZhbGlkXG4gICAgICBwcm9taXNlID0gbXVjLmRlc3Ryb3kgaW52YWxpZEpJRFxuICAgICAgIyBub3RpZnkgYXN5bmMgbGlzdGVuZXIgd2hlbiB0aGlzIHByb21pc2UgaXMgKGhvcGVmdWxseSkgcmVqZWN0ZWQuXG4gICAgICBwcm9taXNlLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkLm5vdGlmeSBkb25lXG4gICAgICAjIGNvbmZpcm0gZXJyb3IgbWVzc2FnZVxuICAgICAgcHJvbWlzZS5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGggXCJpbnZhbGlkIGdyb3VwY2hhdCBqaWQgI3tpbnZhbGlkSklEfVwiXG5cbiAgZGVzY3JpYmUgJyNhY2NlcHREZWZhdWx0Q29uZmlndXJhdGlvbigpJywgLT5cblxuICAgIHZhbGlkSklEICA9ICdmb28uYmFyQGNvbmZlcmVuY2UucmV1dGVycy5uZXQnXG4gICAgaW52YWxpZEpJRCA9ICdpbnZhbGlkJ1xuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgbXVjID0gTVVDLmdldFxuICAgICAgICBnZXRKSUQ6IGdldEpJRFxuICAgICAgICBldmVudE1hbmFnZXI6IGV2ZW50TWFuYWdlclxuICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgIHNlbmRJUTogc2VuZElRXG4gICAgICAgIGhlbHBlcjogc3Ryb3BoZUhlbHBlclxuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICBzZW5kSVEucmVzZXQoKVxuICAgICAgc2VuZC5yZXNldCgpXG4gICAgICBldmVudE1hbmFnZXIubGlzdGVuLnJlc2V0KClcbiAgICAgIGV2ZW50TWFuYWdlci5zdG9wTGlzdGVuaW5nLnJlc2V0KClcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgUSBwcm9taXNlJywgLT5cbiAgICAgIG11Yy5hY2NlcHREZWZhdWx0Q29uZmlndXJhdGlvbihqaWQ6IHZhbGlkSklELCBuYW1lOiBuYW1lKS5fX3Byb3RvX18udG9TdHJpbmcoKVxuICAgICAgICAuc2hvdWxkLmVxdWFsIFwiW29iamVjdCBQcm9taXNlXVwiXG5cbiAgICBpdCAnc2hvdWxkIHJlamVjdCByZXR1cm5lZCBwcm9taXNlIHdoZW4gZ2l2ZW4gYW4gaW52YWxpZCBKSUQnLCAoZG9uZSkgLT5cbiAgICAgICMgbm8gQGRvbWFpbiBwYXJ0LCBzbyBpbnZhbGlkXG4gICAgICBwcm9taXNlID0gbXVjLmFjY2VwdERlZmF1bHRDb25maWd1cmF0aW9uIGppZDogaW52YWxpZEpJRCwgbmFtZTogbmFtZVxuICAgICAgIyBub3RpZnkgYXN5bmMgbGlzdGVuZXIgd2hlbiB0aGlzIHByb21pc2UgaXMgKGhvcGVmdWxseSkgcmVqZWN0ZWQuXG4gICAgICBwcm9taXNlLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkLm5vdGlmeSBkb25lXG4gICAgICAjIGNvbmZpcm0gZXJyb3IgbWVzc2FnZVxuICAgICAgcHJvbWlzZS5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGggXCJpbnZhbGlkIGdyb3VwY2hhdCBqaWQgI3tpbnZhbGlkSklEfVwiXG4iLCJ7Xywgc2lub24sIGFzc2VydCwgZXhwZWN0LCBRfSA9IHJlcXVpcmUgJ3NwZWMvc3BlY19oZWxwZXInXG5TdHJvcGhlID0gcmVxdWlyZSAnc3Ryb3BoZSdcblJvc3RlciA9IHJlcXVpcmUgJ2NvbXBvbmVudHMvcm9zdGVyJ1xuUHJlc2VuY2VUeXBlID0gcmVxdWlyZSAnZW51bS9wcmVzZW5jZV90eXBlJ1xuXG5kZXNjcmliZSAnUm9zdGVyJywgLT5cblxuICByb3N0ZXIgPSBudWxsXG4gIHNlbmQgPSBudWxsXG4gIHNlbmRJUSA9IG51bGxcblxuICBnZXRVc2VyID0gKG5hbWUpIC0+XG4gICAgamlkOiBcInVzZXIuI3tuYW1lfS50aG9tc29ucmV1dGVycy5jb21AcmV1dGVycy5uZXRcIlxuICAgIG5hbWU6IG5hbWVcblxuICBzdHJvcGhlSGVscGVyID0gbnVsbFxuXG4gIGJlZm9yZSAtPlxuICAgIHN0cm9waGVIZWxwZXIgPVxuICAgICAgZ2V0Um9zdGVyU3RhbnphOiBzaW5vbi5zdHViKCkucmV0dXJucyAkaXEoKVxuICAgICAgZ2V0QWRkU3RhbnphOiBzaW5vbi5zdHViKCkucmV0dXJucyAkaXEoKVxuICAgICAgZ2V0UmVtb3ZlU3RhbnphOiBzaW5vbi5zdHViKCkucmV0dXJucyAkaXEoKVxuICAgICAgZ2V0UHJlc2VuY2VTdWJzY3JpcHRpb25TdGFuemE6IHNpbm9uLnN0dWIoKS5yZXR1cm5zICRwcmVzKClcblxuICBhZnRlckVhY2ggLT5cbiAgICBzdHJvcGhlSGVscGVyLmdldFJvc3RlclN0YW56YS5yZXNldCgpXG4gICAgc3Ryb3BoZUhlbHBlci5nZXRBZGRTdGFuemEucmVzZXQoKVxuICAgIHN0cm9waGVIZWxwZXIuZ2V0UmVtb3ZlU3RhbnphLnJlc2V0KClcbiAgICBzdHJvcGhlSGVscGVyLmdldFByZXNlbmNlU3Vic2NyaXB0aW9uU3RhbnphLnJlc2V0KClcbiAgICBSb3N0ZXIuZGVzdHJveSgpXG4gICAgcm9zdGVyID0gbnVsbFxuICBcbiAgZGVzY3JpYmUgJyNnZXRSb3N0ZXIoKScsIC0+XG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBzZW5kSVEgPSBzaW5vbi5zdHViKClcbiAgICAgIHJvc3RlciA9IFJvc3Rlci5nZXQgc2VuZDogc2VuZCwgc2VuZElROiBzZW5kSVEsIGhlbHBlcjogc3Ryb3BoZUhlbHBlclxuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICBzZW5kSVEucmVzZXQoKVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBRIHByb21pc2UnLCAtPlxuICAgICAgcm9zdGVyLmdldFJvc3RlcigpLl9fcHJvdG9fXy50b1N0cmluZygpXG4gICAgICAgIC5zaG91bGQuZXF1YWwgXCJbb2JqZWN0IFByb21pc2VdXCJcblxuICAgIGl0ICdzaG91bGQgY2FsbCBzZW5kSVEgd2l0aCBwcm9wZXIgYXJncycsIC0+XG4gICAgICByb3N0ZXIuZ2V0Um9zdGVyKClcbiAgICAgIHNlbmRJUS5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoIHNpbm9uLm1hdGNoXG4gICAgICAgICAgZWxlbWVudDogU3Ryb3BoZS5CdWlsZGVyLnByb3RvdHlwZVxuICAgICAgICAgIHJlc29sdmU6IHNpbm9uLm1hdGNoLmZ1bmNcbiAgICAgICAgICByZWplY3Q6IHNpbm9uLm1hdGNoLmZ1bmNcblxuICBkZXNjcmliZSAnI2FkZENvbnRhY3QoKScsIC0+XG5cbiAgICB1c2VyMSA9IG51bGxcbiAgICB1c2VyMiA9IG51bGxcbiAgICByZXNvbHZlID0gbnVsbFxuICAgIHJlamVjdCA9IG51bGxcblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIHVzZXIxID0gZ2V0VXNlciAxXG4gICAgICB1c2VyMiA9IGdldFVzZXIgMlxuICAgICAgc2lub24uc3R1YiBjb25zb2xlLCAnd2FybidcbiAgICAgIHNlbmRJUSA9IHNpbm9uLnNweSAob3B0aW9ucyA9IHt9KSAtPlxuICAgICAgICB7cmVzb2x2ZSwgcmVqZWN0fSA9IG9wdGlvbnNcbiAgICAgIHJvc3RlciA9IFJvc3Rlci5nZXQgc2VuZDogc2VuZCwgc2VuZElROiBzZW5kSVEsIGhlbHBlcjogc3Ryb3BoZUhlbHBlclxuICAgXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICBzZW5kSVEucmVzZXQoKVxuICAgICAgY29uc29sZS53YXJuLnJlc3RvcmUoKVxuICAgICAgdXNlcjEgPSBudWxsXG4gICAgICB1c2VyMiA9IG51bGxcbiAgICAgIHJlc29sdmUgPSBudWxsXG4gICAgICByZWplY3QgPSBudWxsXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIFEgcHJvbWlzZScsIC0+XG4gICAgICByb3N0ZXIuYWRkQ29udGFjdCh1c2VyMS5qaWQpLl9fcHJvdG9fXy50b1N0cmluZygpXG4gICAgICAgIC5zaG91bGQuZXF1YWwgXCJbb2JqZWN0IFByb21pc2VdXCJcblxuICAgIGRlc2NyaWJlICdhZGRpbmcgYSBzaW5nbGUgY29udGFjdCcsIC0+XG5cbiAgICAgIGl0ICdzaG91bGQgcmVxdWlyZSBhIHZhbGlkIGNvbnRhY3QnLCAoZG9uZSkgLT5cbiAgICAgICAgcm9zdGVyLmFkZENvbnRhY3QgbnVsbFxuICAgICAgICAgIC5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZFxuICAgICAgICAgIC5ub3RpZnkgZG9uZVxuICAgICAgICBcbiAgICAgIGl0ICdzaG91bGQgcmVxdWlyZSBhIHZhbGlkIGNvbnRhY3Qgd2l0aCBhdCBsZWFzdCBhIGppZCBwcm9wZXJ0eScsIChkb25lKSAtPlxuICAgICAgICByb3N0ZXIuYWRkQ29udGFjdCB7fVxuICAgICAgICAgIC5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZFxuICAgICAgICAgIC5ub3RpZnkgZG9uZVxuXG4gICAgICBpdCAnc2hvdWxkIGNhbGwgI2dldEFkZFN0YW56YSgpIG9uIHRoZSBzdHJvcGhlSGVscGVyJywgLT5cbiAgICAgICAgcm9zdGVyLmFkZENvbnRhY3QgdXNlcjFcbiAgICAgICAgc3Ryb3BoZUhlbHBlci5nZXRBZGRTdGFuemEuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRPbmNlXG5cbiAgICAgIGl0ICdzaG91bGQgYWNjZXB0IHNpbmdsZSBzdHJpbmctYmFzZWQgaXRlbScsIC0+XG4gICAgICAgIHJvc3Rlci5hZGRDb250YWN0IHVzZXIxLmppZFxuICAgICAgICBzZW5kSVEuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgICAgLmNhbGxlZFdpdGggc2lub24ubWF0Y2hcbiAgICAgICAgICAgIGVsZW1lbnQ6IHNpbm9uLm1hdGNoLmluc3RhbmNlT2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICAgICAgICByZXNvbHZlOiBzaW5vbi5tYXRjaC5mdW5jXG4gICAgICAgICAgICByZWplY3Q6IHNpbm9uLm1hdGNoLmZ1bmNcblxuICAgICAgaXQgJ3Nob3VsZCBhY2NlcHQgYSBzaW5nbGUgaGFzaC1iYXNlZCBpdGVtJywgLT5cbiAgICAgICAgcm9zdGVyLmFkZENvbnRhY3QgdXNlcjFcbiAgICAgICAgc2VuZElRLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAgIC5jYWxsZWRXaXRoIHNpbm9uLm1hdGNoXG4gICAgICAgICAgICBlbGVtZW50OiBzaW5vbi5tYXRjaC5pbnN0YW5jZU9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgICAgICAgcmVzb2x2ZTogc2lub24ubWF0Y2guZnVuY1xuICAgICAgICAgICAgcmVqZWN0OiBzaW5vbi5tYXRjaC5mdW5jXG5cbiAgICBkZXNjcmliZSAnZm9yIGNvbnRhY3RzIHdpdGggZ3JvdXBzJywgLT5cblxuICAgICAgaXQgJ3Nob3VsZCBjYWxsICNnZXRBZGRTdGFuemEoKSBvbiBzdHJvcGhlUm9zdGVyJywgLT5cbiAgICAgICAgdXNlcjEuZ3JvdXBzID0gW1wiR3JvdXBBXCIsIFwiR3JvdXBCXCJdXG4gICAgICAgIHJvc3Rlci5hZGRDb250YWN0IHVzZXIxXG4gICAgICAgIHN0cm9waGVIZWxwZXIuZ2V0QWRkU3RhbnphLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAgIC5jYWxsZWRXaXRoIHVzZXIxLmppZCwgdXNlcjEubmFtZSwgdXNlcjEuZ3JvdXBzXG5cbiAgZGVzY3JpYmUgJyNyZW1vdmVDb250YWN0KCknLCAtPlxuXG4gICAgdXNlcjEgPSBudWxsXG4gICAgdXNlcjIgPSBudWxsXG4gICAgcmVzb2x2ZSA9IG51bGxcbiAgICByZWplY3QgPSBudWxsXG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICB1c2VyMSA9IGdldFVzZXIgMVxuICAgICAgdXNlcjIgPSBnZXRVc2VyIDJcbiAgICAgIHNlbmRJUSA9IHNpbm9uLnNweSAob3B0aW9ucyA9IHt9KSAtPlxuICAgICAgICB7cmVzb2x2ZSwgcmVqZWN0fSA9IG9wdGlvbnNcbiAgICAgIHJvc3RlciA9IFJvc3Rlci5nZXQgc2VuZDogc2VuZCwgc2VuZElROiBzZW5kSVEsIGhlbHBlcjogc3Ryb3BoZUhlbHBlclxuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICB1c2VyMSA9IG51bGxcbiAgICAgIHVzZXIyID0gbnVsbFxuICAgICAgcmVzb2x2ZSA9IG51bGxcbiAgICAgIHJlamVjdCA9IG51bGxcbiAgICAgIHNlbmRJUS5yZXNldCgpXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIFEgcHJvbWlzZScsIC0+XG4gICAgICByb3N0ZXIucmVtb3ZlQ29udGFjdCh1c2VyMS5qaWQpLl9fcHJvdG9fXy50b1N0cmluZygpXG4gICAgICAgIC5zaG91bGQuZXF1YWwgXCJbb2JqZWN0IFByb21pc2VdXCJcblxuICAgIGRlc2NyaWJlICdyZW1vdmluZyBhIHNpbmdsZSBjb250YWN0JywgLT5cblxuICAgICAgaXQgJ3Nob3VsZCByZXF1aXJlIGEgdmFsaWQgY29udGFjdCcsIChkb25lKSAtPlxuICAgICAgICByb3N0ZXIucmVtb3ZlQ29udGFjdCBudWxsXG4gICAgICAgICAgLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkXG4gICAgICAgICAgLm5vdGlmeSBkb25lXG4gICAgICAgIFxuICAgICAgaXQgJ3Nob3VsZCByZXF1aXJlIGEgdmFsaWQgY29udGFjdCB3aXRoIGF0IGxlYXN0IGEgamlkbCBwcm9wZXJ0eScsIChkb25lKSAtPlxuICAgICAgICByb3N0ZXIucmVtb3ZlQ29udGFjdCB7fVxuICAgICAgICAgIC5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZFxuICAgICAgICAgIC5ub3RpZnkgZG9uZVxuXG4gICAgICBpdCAnc2hvdWxkIGNhbGwgI2dldFJlbW92ZVN0YW56YSgpIG9uIHRoZSBzdHJvcGhlSGVscGVyJywgLT5cbiAgICAgICAgcm9zdGVyLnJlbW92ZUNvbnRhY3QgdXNlcjFcbiAgICAgICAgc3Ryb3BoZUhlbHBlci5nZXRSZW1vdmVTdGFuemEuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRPbmNlXG5cbiAgICAgIGl0ICdzaG91bGQgYWNjZXB0IHNpbmdsZSBzdHJpbmctYmFzZWQgaXRlbScsIC0+XG4gICAgICAgIHJvc3Rlci5yZW1vdmVDb250YWN0IHVzZXIxLmppZFxuICAgICAgICBzZW5kSVEuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgICAgLmNhbGxlZFdpdGggc2lub24ubWF0Y2hcbiAgICAgICAgICAgIGVsZW1lbnQ6IHNpbm9uLm1hdGNoLmluc3RhbmNlT2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICAgICAgICByZXNvbHZlOiBzaW5vbi5tYXRjaC5mdW5jXG4gICAgICAgICAgICByZWplY3Q6IHNpbm9uLm1hdGNoLmZ1bmNcblxuICAgICAgaXQgJ3Nob3VsZCBhY2NlcHQgYSBzaW5nbGUgaGFzaC1iYXNlZCBpdGVtJywgLT5cbiAgICAgICAgcm9zdGVyLnJlbW92ZUNvbnRhY3QgdXNlcjFcbiAgICAgICAgc2VuZElRLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAgIC5jYWxsZWRXaXRoIHNpbm9uLm1hdGNoXG4gICAgICAgICAgICBlbGVtZW50OiBzaW5vbi5tYXRjaC5pbnN0YW5jZU9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgICAgICAgcmVzb2x2ZTogc2lub24ubWF0Y2guZnVuY1xuICAgICAgICAgICAgcmVqZWN0OiBzaW5vbi5tYXRjaC5mdW5jXG5cbiAgZGVzY3JpYmUgJyNpbnZpdGUoKScsIC0+XG5cbiAgICB1c2VyMSA9IG51bGxcblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIHVzZXIxID0gZ2V0VXNlciAxXG4gICAgICByb3N0ZXIgPSBSb3N0ZXIuZ2V0IHNlbmQ6IHNlbmQsIHNlbmRJUTogc2VuZElRLCBoZWxwZXI6IHN0cm9waGVIZWxwZXJcbiAgICAgIHNpbm9uLnN0dWIocm9zdGVyLCAnc3Vic2NyaWJlJykucmV0dXJucyBRKClcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgdXNlcjEgPSBudWxsXG4gICAgICByb3N0ZXIuc3Vic2NyaWJlLnJlc3RvcmUoKVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBRLlByb21pc2UnLCAtPlxuICAgICAgc3ViamVjdCA9IHJvc3Rlci5pbnZpdGUoKVxuXG4gICAgICBzdWJqZWN0Ll9fcHJvdG9fXy50b1N0cmluZygpLnNob3VsZC5lcXVhbCBcIltvYmplY3QgUHJvbWlzZV1cIlxuXG4gICAgaXQgJ3Nob3VsZCBpbnZva2UgI3N1YnNjcmliZSgpJywgLT5cbiAgICAgIHJvc3Rlci5pbnZpdGUgdXNlcjFcbiAgICAgIHJvc3Rlci5zdWJzY3JpYmUuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aEV4YWN0bHkgdXNlcjFcblxuICBkZXNjcmliZSAnI3N1YnNjcmliZSgpJywgLT5cblxuICAgIHVzZXIxID0gbnVsbFxuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgdXNlcjEgPSBnZXRVc2VyIDFcbiAgICAgIHNlbmQgPSBzaW5vbi5zdHViKClcbiAgICAgIHJvc3RlciA9IFJvc3Rlci5nZXQgc2VuZDogc2VuZCwgc2VuZElROiBzZW5kSVEsIGhlbHBlcjogc3Ryb3BoZUhlbHBlclxuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICB1c2VyMSA9IG51bGxcbiAgICAgIHNlbmQucmVzZXQoKVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBRIHByb21pc2UnLCAtPlxuICAgICAgcm9zdGVyLnN1YnNjcmliZSh1c2VyMSkuX19wcm90b19fLnRvU3RyaW5nKClcbiAgICAgICAgLnNob3VsZC5lcXVhbCBcIltvYmplY3QgUHJvbWlzZV1cIlxuXG4gICAgaXQgJ3Nob3VsZCByZXF1aXJlIGEgdmFsaWQgY29udGFjdCcsIChkb25lKSAtPlxuICAgICAgcm9zdGVyLnN1YnNjcmliZShudWxsKVxuICAgICAgICAuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWRcbiAgICAgICAgLm5vdGlmeSBkb25lXG5cbiAgICBpdCAnc2hvdWxkIGNhbGwgI2dldFByZXNlbmNlU3Vic2NyaXB0aW9uU3RhbnphKCkgb24gdGhlIHJvc3RlckhlbHBlcicsIC0+XG4gICAgICByb3N0ZXIuc3Vic2NyaWJlIHVzZXIxLmppZFxuICAgICAgc3Ryb3BoZUhlbHBlci5nZXRQcmVzZW5jZVN1YnNjcmlwdGlvblN0YW56YS5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoRXhhY3RseSB1c2VyMS5qaWQsIFByZXNlbmNlVHlwZS5TVUJTQ1JJQkVcblxuICAgIGl0ICdzaG91bGQgY2FsbCBzZW5kIHdpdGggcHJvcGVyIGFyZ3MnLCAtPlxuICAgICAgcm9zdGVyLnN1YnNjcmliZSB1c2VyMS5qaWRcbiAgICAgIHNlbmQuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aCBzaW5vbi5tYXRjaFxuICAgICAgICAgIGVsZW1lbnQ6IHNpbm9uLm1hdGNoLmluc3RhbmNlT2YgU3Ryb3BoZS5CdWlsZGVyXG5cbiAgZGVzY3JpYmUgJyNzdWJzY3JpYmVkKCknLCAtPlxuXG4gICAgdXNlcjEgPSBudWxsXG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICB1c2VyMSA9IGdldFVzZXIgMVxuICAgICAgc2VuZCA9IHNpbm9uLnN0dWIoKVxuICAgICAgcm9zdGVyID0gUm9zdGVyLmdldCBzZW5kOiBzZW5kLCBzZW5kSVE6IHNlbmRJUSwgaGVscGVyOiBzdHJvcGhlSGVscGVyXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIHVzZXIxID0gbnVsbFxuICAgICAgc2VuZC5yZXNldCgpXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIFEgcHJvbWlzZScsIC0+XG4gICAgICByb3N0ZXIuc3Vic2NyaWJlZCh1c2VyMSkuX19wcm90b19fLnRvU3RyaW5nKClcbiAgICAgICAgLnNob3VsZC5lcXVhbCBcIltvYmplY3QgUHJvbWlzZV1cIlxuXG4gICAgaXQgJ3Nob3VsZCByZXF1aXJlIGEgdmFsaWQgY29udGFjdCcsIChkb25lKSAtPlxuICAgICAgcm9zdGVyLnN1YnNjcmliZWQobnVsbClcbiAgICAgICAgLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkXG4gICAgICAgIC5ub3RpZnkgZG9uZVxuXG4gICAgaXQgJ3Nob3VsZCBjYWxsICNnZXRQcmVzZW5jZVN1YnNjcmlwdGlvblN0YW56YSgpIG9uIHRoZSByb3N0ZXJIZWxwZXInLCAtPlxuICAgICAgcm9zdGVyLnN1YnNjcmliZWQgdXNlcjEuamlkXG4gICAgICBzdHJvcGhlSGVscGVyLmdldFByZXNlbmNlU3Vic2NyaXB0aW9uU3RhbnphLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGhFeGFjdGx5IHVzZXIxLmppZCwgUHJlc2VuY2VUeXBlLlNVQlNDUklCRURcblxuICAgIGl0ICdzaG91bGQgY2FsbCBzZW5kIHdpdGggcHJvcGVyIGFyZ3MnLCAtPlxuICAgICAgcm9zdGVyLnN1YnNjcmliZWQgdXNlcjEuamlkXG4gICAgICBzZW5kLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGggc2lub24ubWF0Y2hcbiAgICAgICAgICBlbGVtZW50OiBzaW5vbi5tYXRjaC5pbnN0YW5jZU9mIFN0cm9waGUuQnVpbGRlclxuXG4gIGRlc2NyaWJlICcjdW5zdWJzY3JpYmUoKScsIC0+XG5cbiAgICB1c2VyMSA9IG51bGxcblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIHVzZXIxID0gZ2V0VXNlciAxXG4gICAgICBzZW5kID0gc2lub24uc3R1YigpXG4gICAgICByb3N0ZXIgPSBSb3N0ZXIuZ2V0IHNlbmQ6IHNlbmQsIHNlbmRJUTogc2VuZElRLCBoZWxwZXI6IHN0cm9waGVIZWxwZXJcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgdXNlcjEgPSBudWxsXG4gICAgICBzZW5kLnJlc2V0KClcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgUSBwcm9taXNlJywgLT5cbiAgICAgIHJvc3Rlci51bnN1YnNjcmliZSgpLl9fcHJvdG9fXy50b1N0cmluZygpXG4gICAgICAgIC5zaG91bGQuZXF1YWwgXCJbb2JqZWN0IFByb21pc2VdXCJcblxuICAgIGl0ICdzaG91bGQgcmVxdWlyZSBhIHZhbGlkIGNvbnRhY3QnLCAoZG9uZSkgLT5cbiAgICAgIHJvc3Rlci51bnN1YnNjcmliZShudWxsKVxuICAgICAgICAuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWRcbiAgICAgICAgLm5vdGlmeSBkb25lXG5cbiAgICBpdCAnc2hvdWxkIGNhbGwgI2dldFByZXNlbmNlU3Vic2NyaXB0aW9uU3RhbnphKCkgb24gdGhlIHJvc3RlckhlbHBlcicsIC0+XG4gICAgICByb3N0ZXIudW5zdWJzY3JpYmUgdXNlcjEuamlkXG4gICAgICBzdHJvcGhlSGVscGVyLmdldFByZXNlbmNlU3Vic2NyaXB0aW9uU3RhbnphLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGhFeGFjdGx5IHVzZXIxLmppZCwgUHJlc2VuY2VUeXBlLlVOU1VCU0NSSUJFXG5cbiAgICBpdCAnc2hvdWxkIGNhbGwgc2VuZCB3aXRoIHByb3BlciBhcmdzJywgLT5cbiAgICAgIHJvc3Rlci51bnN1YnNjcmliZSB1c2VyMS5qaWRcbiAgICAgIHNlbmQuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aCBzaW5vbi5tYXRjaFxuICAgICAgICAgIGVsZW1lbnQ6IHNpbm9uLm1hdGNoLmluc3RhbmNlT2YgU3Ryb3BoZS5CdWlsZGVyXG5cbiAgZGVzY3JpYmUgJyN1cGRhdGUoKSAtIGFsaWFzIGZvciAjYWRkQ29udGFjdCgpJywgLT5cblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIHJvc3RlciA9IFJvc3Rlci5nZXQgc2VuZDogc2VuZCwgc2VuZElROiBzZW5kSVEsIGhlbHBlcjogc3Ryb3BoZUhlbHBlclxuICAgICAgc2lub24uc3R1YiByb3N0ZXIsICdhZGRDb250YWN0J1xuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICByb3N0ZXIuYWRkQ29udGFjdC5yZXN0b3JlKClcblxuICAgIGl0ICdzaG91bGQgY2FsbCAjYWRkQ29udGFjdCgpIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIHBhc3NlZCB0byBpdCcsIC0+XG4gICAgICB1c2VyID0gZ2V0VXNlciAxXG4gICAgICByb3N0ZXIudXBkYXRlQ29udGFjdCB1c2VyXG4gICAgICByb3N0ZXIuYWRkQ29udGFjdC5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoRXhhY3RseSB1c2VyXG4iLCJ7c2lub24sIGFzc2VydH0gPSByZXF1aXJlICdzcGVjL3NwZWNfaGVscGVyJ1xuU3Ryb3BoZSA9IHJlcXVpcmUgJ3N0cm9waGUnXG5TdG9yYWdlID0gcmVxdWlyZSAnY29tcG9uZW50cy9zdG9yYWdlJ1xuXG5kZXNjcmliZSAnU3RvcmFnZScsIC0+XG5cbiAgc3RvcmFnZSA9IG51bGxcbiAgc2VuZElRID0gbnVsbFxuICBzdGFuemEgPSBudWxsXG4gIHN0cm9waGVIZWxwZXIgPSBudWxsXG4gIFxuICBzdHJvcGhlSGVscGVyID1cbiAgICBnZXRQcmVmZXJlbmNlc1N0YW56YTogc2lub24uc3R1YigpLnJldHVybnMgbmV3IFN0cm9waGUuQnVpbGRlcigpXG4gICAgc2V0UHJlZmVyZW5jZXNTdGFuemE6IHNpbm9uLnN0dWIoKS5yZXR1cm5zIG5ldyBTdHJvcGhlLkJ1aWxkZXIoKVxuICAgIGdldEJvb2ttYXJrc1N0YW56YTogc2lub24uc3R1YigpLnJldHVybnMgbmV3IFN0cm9waGUuQnVpbGRlcigpXG4gICAgc2V0Qm9va21hcmtzU3RhbnphOiBzaW5vbi5zdHViKCkucmV0dXJucyBuZXcgU3Ryb3BoZS5CdWlsZGVyKClcblxuICBiZWZvcmVFYWNoIC0+XG4gICAgc2VuZElRID0gc2lub24uc3R1YigpXG4gICAgc3RhbnphID0gbmV3IFN0cm9waGUuQnVpbGRlcigpXG4gICAgc3Ryb3BoZUhlbHBlciA9XG4gICAgICBnZXRQcmVmZXJlbmNlc1N0YW56YTogc2lub24uc3R1YigpXG4gICAgICBzZXRQcmVmZXJlbmNlc1N0YW56YTogc2lub24uc3R1YigpXG4gICAgICBnZXRCb29rbWFya3NTdGFuemE6IHNpbm9uLnN0dWIoKVxuICAgICAgc2V0Qm9va21hcmtzU3RhbnphOiBzaW5vbi5zdHViKClcbiAgXG4gIGFmdGVyRWFjaCAtPlxuICAgIFN0b3JhZ2UuZGVzdHJveSgpXG4gICAgc2VuZElRLnJlc2V0KClcbiAgICBzdHJvcGhlSGVscGVyLmdldFByZWZlcmVuY2VzU3RhbnphLnJlc2V0KClcbiAgICBzdHJvcGhlSGVscGVyLnNldFByZWZlcmVuY2VzU3RhbnphLnJlc2V0KClcbiAgICBzdHJvcGhlSGVscGVyLmdldEJvb2ttYXJrc1N0YW56YS5yZXNldCgpXG4gICAgc3Ryb3BoZUhlbHBlci5zZXRCb29rbWFya3NTdGFuemEucmVzZXQoKVxuICAgIHN0cm9waGVIZWxwZXIgPSBudWxsXG4gICAgc3RvcmFnZSA9IG51bGxcbiAgXG4gIGRlc2NyaWJlICcjZ2V0UHJlZmVyZW5jZXMoKScsIC0+XG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBzdG9yYWdlID0gU3RvcmFnZS5nZXQgc2VuZElROiBzZW5kSVEsIGhlbHBlcjogc3Ryb3BoZUhlbHBlclxuICAgICAgc3Ryb3BoZUhlbHBlci5nZXRQcmVmZXJlbmNlc1N0YW56YS5yZXR1cm5zIHN0YW56YVxuICAgIGl0ICdzaG91bGQgY2FsbCBzZW5kSVEoKScsIC0+XG4gICAgICBzdG9yYWdlLmdldFByZWZlcmVuY2VzKClcblxuICAgICAgc3Ryb3BoZUhlbHBlci5nZXRQcmVmZXJlbmNlc1N0YW56YS5zaG91bGQuaGF2ZS5iZWVuLmNhbGxlZE9uY2VcbiAgICAgIHNlbmRJUS5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoIHNpbm9uLm1hdGNoXG4gICAgICAgICAgZWxlbWVudDogc2lub24ubWF0Y2guaW5zdGFuY2VPZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgICAgICByZXNvbHZlOiBzaW5vbi5tYXRjaC5mdW5jXG4gICAgICAgICAgcmVqZWN0OiBzaW5vbi5tYXRjaC5mdW5jXG4gICAgICBcbiAgZGVzY3JpYmUgJyNzZXRQcmVmZXJlbmNlcygpJywgLT5cblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIHN0b3JhZ2UgPSBTdG9yYWdlLmdldCBzZW5kSVE6IHNlbmRJUSwgaGVscGVyOiBzdHJvcGhlSGVscGVyXG4gICAgICBzdHJvcGhlSGVscGVyLnNldFByZWZlcmVuY2VzU3RhbnphLnJldHVybnMgc3RhbnphXG5cbiAgICBpdCAnc2hvdWxkIGNhbGwgc2VuZElRKCknLCAtPlxuICAgICAgcHJlZmVyZW5jZXMgPSB7fVxuICAgICAgc3RvcmFnZS5zZXRQcmVmZXJlbmNlcyBwcmVmZXJlbmNlc1xuXG4gICAgICBzdHJvcGhlSGVscGVyLnNldFByZWZlcmVuY2VzU3RhbnphLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGggcHJlZmVyZW5jZXNcbiAgICAgIHNlbmRJUS5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoIHNpbm9uLm1hdGNoXG4gICAgICAgICAgZWxlbWVudDogc2lub24ubWF0Y2guaW5zdGFuY2VPZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgICAgICByZXNvbHZlOiBzaW5vbi5tYXRjaC5mdW5jXG4gICAgICAgICAgcmVqZWN0OiBzaW5vbi5tYXRjaC5mdW5jXG4gICAgICBcbiAgZGVzY3JpYmUgJyNnZXRCb29rbWFya3MoKScsIC0+XG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBzdG9yYWdlID0gU3RvcmFnZS5nZXQgc2VuZElROiBzZW5kSVEsIGhlbHBlcjogc3Ryb3BoZUhlbHBlclxuICAgICAgc3Ryb3BoZUhlbHBlci5nZXRCb29rbWFya3NTdGFuemEucmV0dXJucyBzdGFuemFcblxuICAgIGl0ICdzaG91bGQgY2FsbCBzZW5kSVEoKScsIC0+XG4gICAgICBzdG9yYWdlLmdldEJvb2ttYXJrcygpXG5cbiAgICAgIHN0cm9waGVIZWxwZXIuZ2V0Qm9va21hcmtzU3RhbnphLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgIHNlbmRJUS5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoIHNpbm9uLm1hdGNoXG4gICAgICAgICAgZWxlbWVudDogc2lub24ubWF0Y2guaW5zdGFuY2VPZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgICAgICByZXNvbHZlOiBzaW5vbi5tYXRjaC5mdW5jXG4gICAgICAgICAgcmVqZWN0OiBzaW5vbi5tYXRjaC5mdW5jXG5cbiAgZGVzY3JpYmUgJyNzZXRCb29rbWFya3MoKScsIC0+XG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBzdG9yYWdlID0gU3RvcmFnZS5nZXQgc2VuZElROiBzZW5kSVEsIGhlbHBlcjogc3Ryb3BoZUhlbHBlclxuICAgICAgc3Ryb3BoZUhlbHBlci5zZXRCb29rbWFya3NTdGFuemEucmV0dXJucyBzdGFuemFcblxuICAgIGl0ICdzaG91bGQgY2FsbCBzZW5kSVEoKScsIC0+XG4gICAgICBib29rbWFya3MgPSB7fVxuICAgICAgc3RvcmFnZS5zZXRCb29rbWFya3MgYm9va21hcmtzXG5cbiAgICAgIHN0cm9waGVIZWxwZXIuc2V0Qm9va21hcmtzU3RhbnphLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGggYm9va21hcmtzXG4gICAgICBzZW5kSVEuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aCBzaW5vbi5tYXRjaFxuICAgICAgICAgIGVsZW1lbnQ6IHNpbm9uLm1hdGNoLmluc3RhbmNlT2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICAgICAgcmVzb2x2ZTogc2lub24ubWF0Y2guZnVuY1xuICAgICAgICAgIHJlamVjdDogc2lub24ubWF0Y2guZnVuY1xuIiwie18sIHNpbm9uLCBhc3NlcnQsIGV4cGVjdH0gPSByZXF1aXJlICdzcGVjL3NwZWNfaGVscGVyJ1xuU3Ryb3BoZSA9IHJlcXVpcmUgJ3N0cm9waGUnXG5Db25uZWN0aW9uID0gcmVxdWlyZSAnY29ubmVjdGlvbidcblhNUFBQcmVzZW5jZSA9IHJlcXVpcmUgJ2VudW0veG1wcF9wcmVzZW5jZSdcblJvc3RlciA9IHJlcXVpcmUgJ2NvbXBvbmVudHMvcm9zdGVyJ1xuU3RvcmFnZSA9IHJlcXVpcmUgJ2NvbXBvbmVudHMvc3RvcmFnZSdcbkJsb2NrbGlzdCA9IHJlcXVpcmUgJ2NvbXBvbmVudHMvYmxvY2tsaXN0J1xuUmF0ZUxpbWl0ZXIgPSByZXF1aXJlICd1dGlsL3JhdGVfbGltaXRlcidcbkV2ZW50TWFuYWdlciA9IHJlcXVpcmUgJ2V2ZW50cy9ldmVudF9tYW5hZ2VyJ1xuU3RhdHVzID0gcmVxdWlyZSAnZW51bS9zdGF0dXMnXG5TdHJvcGhlSU8gPSByZXF1aXJlICdzdHJvcGhlL3N0cm9waGVfaW8nXG5JT0V2ZW50ID0gcmVxdWlyZSAnZXZlbnRzL2lvX2V2ZW50J1xuXG5kZXNjcmliZSAnQ29ubmVjdGlvbicsIC0+XG5cbiAgY29ubmVjdGlvbiA9IG51bGxcbiAgc3BlY09wdGlvbnMgPSBudWxsXG5cbiAgIyBAbm9kb2NcbiAgY2xhc3MgUm9zdGVyU3R1YlxuXG4gICMgQG5vZG9jXG4gIGNsYXNzIFN0b3JhZ2VTdHViXG5cbiAgIyBAbm9kb2NcbiAgY2xhc3MgQmxvY2tsaXN0U3R1YlxuXG4gICMgQG5vZG9jXG4gIGNsYXNzIEV2ZW50TWFuYWdlclN0dWJcbiAgICB0b2dnbGVDb25uZWN0aW9uOiBzaW5vbi5zdHViKClcblxuICAjIEBub2RvY1xuICBjbGFzcyBTdHJvcGhlQ29ubmVjdGlvblN0dWJcbiAgICBjb25uZWN0OiBzaW5vbi5zdHViKClcbiAgICBzZW5kOiBzaW5vbi5zdHViKClcbiAgICBzZW5kSVE6IHNpbm9uLnN0dWIoKVxuICAgIHJlc2V0OiBzaW5vbi5zdHViKClcbiAgICBhZGRIYW5kbGVyOiBzaW5vbi5zdHViKClcbiAgICBkZWxldGVIYW5kbGVyOiBzaW5vbi5zdHViKClcblxuICBiZWZvcmUgLT5cbiAgICBTdHJvcGhlLkNvbm5lY3Rpb24gPSBTdHJvcGhlQ29ubmVjdGlvblN0dWJcbiAgICBzaW5vbi5zdHViKEV2ZW50TWFuYWdlciwgJ2dldCcpLnJldHVybnMgbmV3IEV2ZW50TWFuYWdlclN0dWIoKVxuICAgIHNpbm9uLnN0dWIoUm9zdGVyLCAnZ2V0JykucmV0dXJucyBuZXcgUm9zdGVyU3R1YigpXG4gICAgc2lub24uc3R1YihTdG9yYWdlLCAnZ2V0JykucmV0dXJucyBuZXcgU3RvcmFnZVN0dWIoKVxuICAgIHNpbm9uLnN0dWIoQmxvY2tsaXN0LCAnZ2V0JykucmV0dXJucyBuZXcgQmxvY2tsaXN0U3R1YigpXG5cbiAgYWZ0ZXIgLT5cbiAgICBTdHJvcGhlLkNvbm5lY3Rpb24gPSBudWxsXG4gICAgUm9zdGVyLmdldC5yZXN0b3JlKClcbiAgICBFdmVudE1hbmFnZXIuZ2V0LnJlc3RvcmUoKVxuICAgIFN0b3JhZ2UuZ2V0LnJlc3RvcmUoKVxuICAgIEJsb2NrbGlzdC5nZXQucmVzdG9yZSgpXG5cbiAgYmVmb3JlRWFjaCAtPlxuICAgICMgVXNlIENvbm5lY3Rpb24uVEVTVF9LRVkgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBkZXN0cm95IHNpbmdsZXRvblxuICAgICMgaW5zdGFuY2VzIGluIHRoZXNlIHRlc3RzLlxuICAgIHNwZWNPcHRpb25zID0gYXBwTmFtZTogQ29ubmVjdGlvbi5URVNUX0tFWSwgYXBwVmVyc2lvbjogXCIxLjBcIlxuICAgIHNpbm9uLnNweSBfLCAnYmluZCdcblxuICBhZnRlckVhY2ggLT5cbiAgICBfLmJpbmQucmVzdG9yZSgpXG4gICAgY29ubmVjdGlvbj8uX2Nvbm5lY3Rpb24uc2VuZC5yZXNldCgpXG4gICAgY29ubmVjdGlvbj8uX2Nvbm5lY3Rpb24uc2VuZElRLnJlc2V0KClcbiAgICBDb25uZWN0aW9uLmRlc3Ryb3koKVxuICAgIGNvbm5lY3Rpb24gPSBudWxsXG4gICAgc3BlY09wdGlvbnMgPSBudWxsXG4gICAgUm9zdGVyLmdldC5yZXNldCgpXG5cbiAgaXQgJ0Nvbm5lY3Rpb24gY2xhc3Mgc2hvdWxkIGJlIGF2YWlsYWJsZSBvbiB0aGUgd2luZG93IG9iamVjdCcsIC0+XG4gICAgd2luZG93LkNvbm5lY3Rpb24uc2hvdWxkLmV4aXN0XG5cbiAgaXQgJ3Nob3VsZCByZXR1cm4gYW4gZW1wdHkgb2JqZWN0IHdoZW4gZGlyZWN0bHkgaW5zdGFudGlhdGVkJywgLT5cbiAgICBuZXcgQ29ubmVjdGlvbigpLnNob3VsZC5iZS5lbXB0eVxuXG4gIGRlc2NyaWJlICdpbnN0YW50aWF0aW5nIGRlcGVuZGVuY2llcycsIC0+XG5cbiAgICBpdCAnc2hvdWxkIHJldHJpZXZlIHRoZSBSb3N0ZXIgc2luZ2xldG9uIGFuZCBpbmplY3QgZGVwZW5kZW5jaWVzJywgLT5cbiAgICAgIGNvbm5lY3Rpb24gPSBDb25uZWN0aW9uLmdldCBzcGVjT3B0aW9uc1xuXG4gICAgICBSb3N0ZXIuZ2V0LnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGggc2lub24ubWF0Y2hcbiAgICAgICAgICBzZW5kOiBzaW5vbi5tYXRjaC5mdW5jXG4gICAgICAgICAgc2VuZElROiBzaW5vbi5tYXRjaC5mdW5jXG5cbiAgICBpdCAnc2hvdWxkIHJldHJpZXZlIHRoZSBTdG9yYWdlIHNpbmdsZXRvbiBhbmQgaW5qZWN0IGRlcGVuZGVuY2llcycsIC0+XG4gICAgICBjb25uZWN0aW9uID0gQ29ubmVjdGlvbi5nZXQgc3BlY09wdGlvbnNcblxuICAgICAgUm9zdGVyLmdldC5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoIHNpbm9uLm1hdGNoXG4gICAgICAgICAgc2VuZElROiBzaW5vbi5tYXRjaC5mdW5jXG5cbiAgICBpdCAnc2hvdWxkIGJpbmQgc2VuZCBhbmQgc2VuZElRIGFuZCBhZGRIYW5kbGVyIGFuZCBkZWxldGVIYW5kbGVyIG9uIFN0cm9waGUuQ29ubmVjdGlvbicsIC0+XG4gICAgICBjb25uZWN0aW9uID0gQ29ubmVjdGlvbi5nZXQgc3BlY09wdGlvbnNcblxuICAgICAgXy5iaW5kLmNhbGxDb3VudC5zaG91bGQuZXF1YWwgNFxuICAgICAgXy5iaW5kLmZpcnN0Q2FsbC5zaG91bGQuaGF2ZS5iZWVuLmNhbGxlZFdpdGggc2lub24ubWF0Y2guZnVuYywgY29ubmVjdGlvblxuICAgICAgXy5iaW5kLnNlY29uZENhbGwuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRXaXRoIHNpbm9uLm1hdGNoLmZ1bmMsIGNvbm5lY3Rpb25cbiAgICAgIF8uYmluZC50aGlyZENhbGwuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRXaXRoIHNpbm9uLm1hdGNoLmZ1bmMsIGNvbm5lY3Rpb24uX2Nvbm5lY3Rpb25cblxuICAgIGl0ICdzaG91bGQgY29ubmVjdCBTdHJvcGhlIHdpdGggcG90ZW50aWFsIGV2ZW50IGxpc3RlbmVycycsIC0+XG4gICAgICBzaW5vbi5zdHViIFN0cm9waGVJTywgJ2Nvbm5lY3RJT0xpc3RlbmVycydcbiAgICAgIGNvbm5lY3Rpb24gPSBDb25uZWN0aW9uLmdldCBzcGVjT3B0aW9uc1xuXG4gICAgICBTdHJvcGhlSU8uY29ubmVjdElPTGlzdGVuZXJzLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGhcbiAgICAgICAgICBjb25uZWN0aW9uOiBjb25uZWN0aW9uLl9jb25uZWN0aW9uXG4gICAgICAgICAgZ2V0UmF3SW5wdXRMaXN0ZW5lcnM6IHNpbm9uLm1hdGNoLmZ1bmNcbiAgICAgICAgICBnZXRSYXdPdXRwdXRMaXN0ZW5lcnM6IHNpbm9uLm1hdGNoLmZ1bmNcbiAgICAgICAgICBnZXRYTUxJbnB1dExpc3RlbmVyczogc2lub24ubWF0Y2guZnVuY1xuICAgICAgICAgIGdldFhNTE91dHB1dExpc3RlbmVyczogc2lub24ubWF0Y2guZnVuY1xuXG4gICAgICBTdHJvcGhlSU8uY29ubmVjdElPTGlzdGVuZXJzLnJlc3RvcmUoKVxuXG4gIGRlc2NyaWJlICcjYWRkU3Ryb3BoZUxpc3RlbmVyKCknLCAtPlxuXG4gICAgZGVzY3JpYmUgJ2FkZGluZyBhIHNpbmdsZSBsaXN0ZW5lcicsIC0+XG5cbiAgICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgICAgY29ubmVjdGlvbiA9IENvbm5lY3Rpb24uZ2V0IHNwZWNPcHRpb25zXG4gICAgICAgIHNpbm9uLnN0dWIgU3Ryb3BoZUlPLCAnYWRkSU9MaXN0ZW5lcidcblxuICAgICAgYWZ0ZXJFYWNoIC0+XG4gICAgICAgIFN0cm9waGVJTy5hZGRJT0xpc3RlbmVyLnJlc3RvcmUoKVxuXG4gICAgICBpdCAnc2hvdWxkIHJlZ2lzdGVyIGEgc2luZ2xlIGxpc3RlbmVyIHdpdGggU3Ryb3BoZUlPIGZvciByYXcgaW5wdXQvb3V0cHV0IGJ5IGRlZmF1bHQnLCAtPlxuICAgICAgICBsaXN0ZW5lciA9IHNpbm9uLnN0dWIoKVxuICAgICAgICBvcHRpb25zID1cbiAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXJcblxuICAgICAgICBjb25uZWN0aW9uLmFkZFN0cm9waGVMaXN0ZW5lciBvcHRpb25zXG5cbiAgICAgICAgU3Ryb3BoZUlPLmFkZElPTGlzdGVuZXIuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAgIC5jYWxsZWRUd2ljZVxuICAgICAgICAgIC5jYWxsZWRXaXRoIGxpc3RlbmVyLCBTdHJvcGhlSU8ucmF3SW5wdXRMaXN0ZW5lcnNcbiAgICAgICAgICAuY2FsbGVkV2l0aCBsaXN0ZW5lciwgU3Ryb3BoZUlPLnJhd091dHB1dExpc3RlbmVyc1xuXG4gICAgICBpdCAnc2hvdWxkIHJlZ2lzdGVyIGEgc2luZ2xlIGxpc3RlbmVyIHdpdGggU3Ryb3BoZUlPIGZvciByYXcgaW5wdXQnLCAtPlxuICAgICAgICBsaXN0ZW5lciA9IHNpbm9uLnN0dWIoKVxuICAgICAgICBvcHRpb25zID1cbiAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgICAgICAgICB0eXBlOiBJT0V2ZW50LlJBV1xuICAgICAgICAgIGlvVHlwZTogSU9FdmVudC5JTlBVVFxuXG4gICAgICAgIGNvbm5lY3Rpb24uYWRkU3Ryb3BoZUxpc3RlbmVyIG9wdGlvbnNcblxuICAgICAgICBTdHJvcGhlSU8uYWRkSU9MaXN0ZW5lci5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgICAuY2FsbGVkV2l0aEV4YWN0bHkgbGlzdGVuZXIsIFN0cm9waGVJTy5yYXdJbnB1dExpc3RlbmVyc1xuXG4gICAgICBpdCAnc2hvdWxkIHJlZ2lzdGVyIGEgc2luZ2xlIGxpc3RlbmVyIHdpdGggU3Ryb3BoZUlPIGZvciByYXcgb3V0cHV0JywgLT5cbiAgICAgICAgbGlzdGVuZXIgPSBzaW5vbi5zdHViKClcbiAgICAgICAgb3B0aW9ucyA9XG4gICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gICAgICAgICAgdHlwZTogSU9FdmVudC5SQVdcbiAgICAgICAgICBpb1R5cGU6IElPRXZlbnQuT1VUUFVUXG5cbiAgICAgICAgY29ubmVjdGlvbi5hZGRTdHJvcGhlTGlzdGVuZXIgb3B0aW9uc1xuXG4gICAgICAgIFN0cm9waGVJTy5hZGRJT0xpc3RlbmVyLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAgIC5jYWxsZWRXaXRoRXhhY3RseSBsaXN0ZW5lciwgU3Ryb3BoZUlPLnJhd091dHB1dExpc3RlbmVyc1xuXG4gICAgICBpdCAnc2hvdWxkIHJlZ2lzdGVyIGEgc2luZ2xlIGxpc3RlbmVyIHdpdGggU3Ryb3BoZUlPIGZvciBYTUwgaW5wdXQnLCAtPlxuICAgICAgICBsaXN0ZW5lciA9IHNpbm9uLnN0dWIoKVxuICAgICAgICBvcHRpb25zID1cbiAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgICAgICAgICB0eXBlOiBJT0V2ZW50LlhNTFxuICAgICAgICAgIGlvVHlwZTogSU9FdmVudC5JTlBVVFxuXG4gICAgICAgIGNvbm5lY3Rpb24uYWRkU3Ryb3BoZUxpc3RlbmVyIG9wdGlvbnNcblxuICAgICAgICBTdHJvcGhlSU8uYWRkSU9MaXN0ZW5lci5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgICAuY2FsbGVkV2l0aEV4YWN0bHkgbGlzdGVuZXIsIFN0cm9waGVJTy54bWxJbnB1dExpc3RlbmVyc1xuXG4gICAgICBpdCAnc2hvdWxkIHJlZ2lzdGVyIGEgc2luZ2xlIGxpc3RlbmVyIHdpdGggU3Ryb3BoZUlPIGZvciBYTUwgb3V0cHV0JywgLT5cbiAgICAgICAgbGlzdGVuZXIgPSBzaW5vbi5zdHViKClcbiAgICAgICAgb3B0aW9ucyA9XG4gICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gICAgICAgICAgdHlwZTogSU9FdmVudC5YTUxcbiAgICAgICAgICBpb1R5cGU6IElPRXZlbnQuT1VUUFVUXG5cbiAgICAgICAgY29ubmVjdGlvbi5hZGRTdHJvcGhlTGlzdGVuZXIgb3B0aW9uc1xuXG4gICAgICAgIFN0cm9waGVJTy5hZGRJT0xpc3RlbmVyLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAgIC5jYWxsZWRXaXRoRXhhY3RseSBsaXN0ZW5lciwgU3Ryb3BoZUlPLnhtbE91dHB1dExpc3RlbmVyc1xuXG4gICAgZGVzY3JpYmUgJ2FkZGluZyBtdWx0aXBsZSBsaXN0ZW5lcnMnLCAtPlxuXG4gICAgICBiZWZvcmVFYWNoIC0+XG4gICAgICAgIGNvbm5lY3Rpb24gPSBDb25uZWN0aW9uLmdldCBzcGVjT3B0aW9uc1xuICAgICAgICBzaW5vbi5zdHViIFN0cm9waGVJTywgJ2FkZElPTGlzdGVuZXInXG5cbiAgICAgIGFmdGVyRWFjaCAtPlxuICAgICAgICBTdHJvcGhlSU8uYWRkSU9MaXN0ZW5lci5yZXN0b3JlKClcblxuICAgICAgaXQgJ3Nob3VsZCByZWdpc3RlciBhIG11bHRpcGxlIGxpc3RlbmVycyB3aXRoIFN0cm9waGVJTyBmb3IgcmF3IGlucHV0L291dHB1dCBieSBkZWZhdWx0JywgLT5cbiAgICAgICAgbGlzdGVuZXIxID0gc2lub24uc3R1YigpXG4gICAgICAgIGxpc3RlbmVyMiA9IHNpbm9uLnN0dWIoKVxuICAgICAgICBsaXN0ZW5lcnMgPSBbbGlzdGVuZXIxLCBsaXN0ZW5lcjJdXG4gICAgICAgIG9wdGlvbnMgPVxuICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcnNcblxuICAgICAgICBjb25uZWN0aW9uLmFkZFN0cm9waGVMaXN0ZW5lciBvcHRpb25zXG5cbiAgICAgICAgU3Ryb3BoZUlPLmFkZElPTGlzdGVuZXIuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAgIC5jYWxsZWRUd2ljZVxuICAgICAgICAgIC5jYWxsZWRXaXRoIGxpc3RlbmVycywgU3Ryb3BoZUlPLnJhd0lucHV0TGlzdGVuZXJzXG4gICAgICAgICAgLmNhbGxlZFdpdGggbGlzdGVuZXJzLCBTdHJvcGhlSU8ucmF3T3V0cHV0TGlzdGVuZXJzXG5cbiAgICAgIGl0ICdzaG91bGQgcmVnaXN0ZXIgYSBzaW5nbGUgbGlzdGVuZXIgd2l0aCBTdHJvcGhlSU8gZm9yIHJhdyBpbnB1dCcsIC0+XG4gICAgICAgIGxpc3RlbmVyMSA9IHNpbm9uLnN0dWIoKVxuICAgICAgICBsaXN0ZW5lcjIgPSBzaW5vbi5zdHViKClcbiAgICAgICAgbGlzdGVuZXJzID0gW2xpc3RlbmVyMSwgbGlzdGVuZXIyXVxuICAgICAgICBvcHRpb25zID1cbiAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXJzXG4gICAgICAgICAgdHlwZTogSU9FdmVudC5SQVdcbiAgICAgICAgICBpb1R5cGU6IElPRXZlbnQuSU5QVVRcblxuICAgICAgICBjb25uZWN0aW9uLmFkZFN0cm9waGVMaXN0ZW5lciBvcHRpb25zXG5cbiAgICAgICAgU3Ryb3BoZUlPLmFkZElPTGlzdGVuZXIuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgICAgLmNhbGxlZFdpdGhFeGFjdGx5IGxpc3RlbmVycywgU3Ryb3BoZUlPLnJhd0lucHV0TGlzdGVuZXJzXG5cbiAgICAgIGl0ICdzaG91bGQgcmVnaXN0ZXIgYSBzaW5nbGUgbGlzdGVuZXIgd2l0aCBTdHJvcGhlSU8gZm9yIHJhdyBvdXRwdXQnLCAtPlxuICAgICAgICBsaXN0ZW5lcjEgPSBzaW5vbi5zdHViKClcbiAgICAgICAgbGlzdGVuZXIyID0gc2lub24uc3R1YigpXG4gICAgICAgIGxpc3RlbmVycyA9IFtsaXN0ZW5lcjEsIGxpc3RlbmVyMl1cbiAgICAgICAgb3B0aW9ucyA9XG4gICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyc1xuICAgICAgICAgIHR5cGU6IElPRXZlbnQuUkFXXG4gICAgICAgICAgaW9UeXBlOiBJT0V2ZW50Lk9VVFBVVFxuXG4gICAgICAgIGNvbm5lY3Rpb24uYWRkU3Ryb3BoZUxpc3RlbmVyIG9wdGlvbnNcblxuICAgICAgICBTdHJvcGhlSU8uYWRkSU9MaXN0ZW5lci5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgICAuY2FsbGVkV2l0aEV4YWN0bHkgbGlzdGVuZXJzLCBTdHJvcGhlSU8ucmF3T3V0cHV0TGlzdGVuZXJzXG5cbiAgICAgIGl0ICdzaG91bGQgcmVnaXN0ZXIgYSBzaW5nbGUgbGlzdGVuZXIgd2l0aCBTdHJvcGhlSU8gZm9yIFhNTCBpbnB1dCcsIC0+XG4gICAgICAgIGxpc3RlbmVyMSA9IHNpbm9uLnN0dWIoKVxuICAgICAgICBsaXN0ZW5lcjIgPSBzaW5vbi5zdHViKClcbiAgICAgICAgbGlzdGVuZXJzID0gW2xpc3RlbmVyMSwgbGlzdGVuZXIyXVxuICAgICAgICBvcHRpb25zID1cbiAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXJzXG4gICAgICAgICAgdHlwZTogSU9FdmVudC5YTUxcbiAgICAgICAgICBpb1R5cGU6IElPRXZlbnQuSU5QVVRcblxuICAgICAgICBjb25uZWN0aW9uLmFkZFN0cm9waGVMaXN0ZW5lciBvcHRpb25zXG5cbiAgICAgICAgU3Ryb3BoZUlPLmFkZElPTGlzdGVuZXIuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgICAgLmNhbGxlZFdpdGhFeGFjdGx5IGxpc3RlbmVycywgU3Ryb3BoZUlPLnhtbElucHV0TGlzdGVuZXJzXG5cbiAgICAgIGl0ICdzaG91bGQgcmVnaXN0ZXIgYSBzaW5nbGUgbGlzdGVuZXIgd2l0aCBTdHJvcGhlSU8gZm9yIFhNTCBvdXRwdXQnLCAtPlxuICAgICAgICBsaXN0ZW5lcjEgPSBzaW5vbi5zdHViKClcbiAgICAgICAgbGlzdGVuZXIyID0gc2lub24uc3R1YigpXG4gICAgICAgIGxpc3RlbmVycyA9IFtsaXN0ZW5lcjEsIGxpc3RlbmVyMl1cbiAgICAgICAgb3B0aW9ucyA9XG4gICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyc1xuICAgICAgICAgIHR5cGU6IElPRXZlbnQuWE1MXG4gICAgICAgICAgaW9UeXBlOiBJT0V2ZW50Lk9VVFBVVFxuXG4gICAgICAgIGNvbm5lY3Rpb24uYWRkU3Ryb3BoZUxpc3RlbmVyIG9wdGlvbnNcblxuICAgICAgICBTdHJvcGhlSU8uYWRkSU9MaXN0ZW5lci5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgICAuY2FsbGVkV2l0aEV4YWN0bHkgbGlzdGVuZXJzLCBTdHJvcGhlSU8ueG1sT3V0cHV0TGlzdGVuZXJzXG5cblxuICBkZXNjcmliZSAnI3N0YXR1cygpJywgLT5cblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIGNvbm5lY3Rpb24gPSBDb25uZWN0aW9uLmdldCBzcGVjT3B0aW9uc1xuXG4gICAgaXQgJ3Nob3VsZCBoYXZlIGEgZGVmYXVsdCBzdGF0dXMgb2YgYGRpc2Nvbm5lY3RlZGAnLCAtPlxuICAgICAgY29ubmVjdGlvbi5zdGF0dXMoKS5zaG91bGQuZXF1YWwgU3RhdHVzLkRJU0NPTk5FQ1RFRFxuXG4gICAgaXQgJ3Nob3VsZCByZXRyaWV2ZSB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIGNvbm5lY3Rpb24nLCAtPlxuICAgICAgY29ubmVjdGlvbi5fY29ubmVjdGlvblN0YXR1cyA9IFN0YXR1cy5DT05ORUNURURcbiAgICAgIGNvbm5lY3Rpb24uc3RhdHVzKCkuc2hvdWxkLmVxdWFsIFN0YXR1cy5DT05ORUNURURcblxuICBkZXNjcmliZSAnI2lzQ29ubmVjdGVkKCknLCAtPlxuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgY29ubmVjdGlvbiA9IENvbm5lY3Rpb24uZ2V0IHNwZWNPcHRpb25zXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0cnVlIGlmIHRoZSBjb25uZWN0aW9uIHN0YXR1cyBpcyBgQ09OTkVDVEVEYCcsIC0+XG4gICAgICBjb25uZWN0aW9uLl9jb25uZWN0aW9uU3RhdHVzID0gU3RhdHVzLkNPTk5FQ1RFRFxuICAgICAgY29ubmVjdGlvbi5pc0Nvbm5lY3RlZCgpLnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0cnVlIGlmIHRoZSBjb25uZWN0aW9uIHN0YXR1cyBpcyBgQ09OTkVDVEVEYCcsIC0+XG4gICAgICBjb25uZWN0aW9uLl9jb25uZWN0aW9uU3RhdHVzID0gU3RhdHVzLkRJU0NPTk5FQ1RFRFxuICAgICAgY29ubmVjdGlvbi5pc0Nvbm5lY3RlZCgpLnNob3VsZC5iZS5mYWxzZVxuXG4gIGRlc2NyaWJlICdnZXRBcHBOYW1lJywgLT5cblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIGNvbm5lY3Rpb24gPSBDb25uZWN0aW9uLmdldCBzcGVjT3B0aW9uc1xuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYW4gYGFwcE5hbWVgIFN0cmluZycsIC0+XG4gICAgICBjb25uZWN0aW9uLmdldEFwcE5hbWUoKS5zaG91bGQuZXF1YWwgQ29ubmVjdGlvbi5URVNUX0tFWVxuXG4gIGRlc2NyaWJlICdnZXRBcHBWZXJzaW9uJywgLT5cblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIGNvbm5lY3Rpb24gPSBDb25uZWN0aW9uLmdldCBzcGVjT3B0aW9uc1xuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYW4gYGFwcFZlcnNpb25gIFN0cmluZycsIC0+XG4gICAgICBjb25uZWN0aW9uLmdldEFwcFZlcnNpb24oKS5zaG91bGQuZXF1YWwgXCIxLjBcIlxuXG4gIGRlc2NyaWJlICdnZXRBcHBTZXJ2aWNlJywgLT5cblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIHNwZWNPcHRpb25zID0gXy5leHRlbmQge30sIHNwZWNPcHRpb25zLCBzZXJ2aWNlOiBcInRlc3Qtc2VydmljZVwiXG4gICAgICBjb25uZWN0aW9uID0gQ29ubmVjdGlvbi5nZXQgc3BlY09wdGlvbnNcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGFuIGBhcHBWZXJzaW9uYCBTdHJpbmcnLCAtPlxuICAgICAgY29ubmVjdGlvbi5nZXRTZXJ2aWNlKCkuc2hvdWxkLmVxdWFsIFwiL3Rlc3Qtc2VydmljZS9cIlxuXG4gIGRlc2NyaWJlICcjZ2V0KCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGV0b24gb2YgQ29ubmVjdGlvbicsIC0+XG4gICAgICBjb25uZWN0aW9uID0gQ29ubmVjdGlvbi5nZXQgc3BlY09wdGlvbnNcbiAgICAgIGNvbm5lY3Rpb24yID0gQ29ubmVjdGlvbi5nZXQgc3BlY09wdGlvbnNcbiAgICAgIGNvbm5lY3Rpb24uc2hvdWxkLmVxdWFsIGNvbm5lY3Rpb24yXG5cbiAgICBpdCAnc2hvdWxkIGhhdmUgYSBgY29ubmVjdGlvbmAgcHJvcGVydHkgdGhhdCBpcyBhIGBTdHJvcGhlLkNvbm5lY3Rpb25gJywgLT5cbiAgICAgICMgY29ubmVjdGlvbi5fY29ubmVjdGlvbiBpcyBwcml2YXRlIGJ1dCB3ZSBjYW4gY2hlYXQgYW5kIHRlc3QgaXQgaGVyZS5cbiAgICAgIENvbm5lY3Rpb24uZ2V0KHNwZWNPcHRpb25zKS5zaG91bGQuaGF2ZS5hLnByb3BlcnR5KCdfY29ubmVjdGlvbicpXG4gICAgICAgIC50aGF0LmlzLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5Db25uZWN0aW9uXG5cbiAgICBpdCAnc2hvdWxkIHJhdGUgbGltaXQgdGhlIGAjY29ubmVjdCgpYCBtZXRob2Qgb2YgaXRzIFN0cm9waGUgQ29ubmVjdGlvbiB3aXRoIGFsaWFzZXMnLCAtPlxuICAgICAgY29ubmVjdGlvbiA9IENvbm5lY3Rpb24uZ2V0IHNwZWNPcHRpb25zXG4gICAgICBjb25uZWN0aW9uLnNob3VsZC5oYXZlLmEucHJvcGVydHkoJ19jb25uZWN0VG9TZXJ2ZXInKVxuICAgICAgICAudGhhdC5pcy5hbi5pbnN0YW5jZW9mIFJhdGVMaW1pdGVyXG4gICAgICBjb25uZWN0aW9uLl9jb25uZWN0VG9TZXJ2ZXIuc2hvdWxkLmhhdmUuYS5wcm9wZXJ0eSgnYWZ0ZXJTZXJ2ZXJGYWlsdXJlJylcbiAgICAgICAgLnRoYXQuaXMuYSAnZnVuY3Rpb24nXG4gICAgICBjb25uZWN0aW9uLl9jb25uZWN0VG9TZXJ2ZXIuc2hvdWxkLmhhdmUuYS5wcm9wZXJ0eSgnYWZ0ZXJMb25nUG9sbEZhaWx1cmUnKVxuICAgICAgICAudGhhdC5pcy5hICdmdW5jdGlvbidcblxuICAgIGl0ICdzaG91bGQgcmVxdWlyZSBhbiBgYXBwTmFtZWAgYmUgcGFzc2VkIGluJywgLT5cbiAgICAgIGV4cGVjdCgtPiBDb25uZWN0aW9uLmdldCBhcHBOYW1lOiBudWxsKS50by50aHJvdyBFcnJvclxuXG4gICAgaXQgJ3Nob3VsZCByZXF1aXJlIGFuIGBhcHBWZXJzaW9uYCBiZSBwYXNzZWQgaW4nLCAtPlxuICAgICAgb3B0aW9ucyA9IGFwcE5hbWU6IENvbm5lY3Rpb24uVEVTVF9LRVksIGFwcFZlcnNpb246IG51bGxcbiAgICAgIGV4cGVjdCgtPiBDb25uZWN0aW9uLmdldCBvcHRpb25zKS50by50aHJvdyBFcnJvclxuXG4gIGRlc2NyaWJlICcjZ2V0Q29tcG9uZW50KCknLCAtPlxuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgY29ubmVjdGlvbiA9IENvbm5lY3Rpb24uZ2V0IHNwZWNPcHRpb25zXG5cbiAgICBpdCAnc2hvdWxkIHRocm93IGFuIGV4Y2VwdGlvbiB3aGVuIHBhc3NlZCBhIG5vbi1leGlzdGVudCBjb21wb25lbnQnLCAtPlxuICAgICAgaW52YWxpZCA9IFwiaW52YWxpZENvbXBvbmVudFwiXG4gICAgICBleHBlY3QoLT4gY29ubmVjdGlvbi5nZXRDb21wb25lbnQgaW52YWxpZCkudG8udGhyb3cgRXJyb3JcbiAgICAgIGV4cGVjdCgtPiBjb25uZWN0aW9uLmdldENvbXBvbmVudCBpbnZhbGlkKS50by50aHJvdyBcIkNvbXBvbmVudCAnI3tpbnZhbGlkfScgZG9lcyBub3QgZXhpc3QuXCJcblxuICAgIGl0ICdzaG91bGQgdGhvdyBhbiBleGNlcHRpb24gaWYgcGFzc2VkIGFuIGludmFsaWQgdmFsdWUnLCAtPlxuICAgICAgZXhwZWN0KC0+IGNvbm5lY3Rpb24uZ2V0Q29tcG9uZW50KCkpLnRvLnRocm93IEVycm9yXG4gICAgICBleHBlY3QoLT4gY29ubmVjdGlvbi5nZXRDb21wb25lbnQgbnVsbCkudG8udGhyb3cgRXJyb3JcbiAgICAgIGV4cGVjdCgtPiBjb25uZWN0aW9uLmdldENvbXBvbmVudCB1bmRlZmluZWQpLnRvLnRocm93IEVycm9yXG4gICAgICBleHBlY3QoLT4gY29ubmVjdGlvbi5nZXRDb21wb25lbnQge30pLnRvLnRocm93IEVycm9yXG4gICAgICBleHBlY3QoLT4gY29ubmVjdGlvbi5nZXRDb21wb25lbnQgZmFsc2UpLnRvLnRocm93IEVycm9yXG4gICAgICBleHBlY3QoLT4gY29ubmVjdGlvbi5nZXRDb21wb25lbnQgMSkudG8udGhyb3cgRXJyb3JcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGFuIGluc3RhbmNlIG9mIHRoZSByb3N0ZXIgY29tcG9uZW50IHdoZW4gYXZhaWxhYmxlJywgLT5cbiAgICAgIGNvbm5lY3Rpb24uZ2V0Q29tcG9uZW50KFJvc3Rlci5OQU1FKVxuICAgICAgICAuc2hvdWxkLmVxdWFsIGNvbm5lY3Rpb24uX3Jvc3RlclxuXG4gIGRlc2NyaWJlICcjY29ubmVjdCgpJywgLT5cblxuICAgIG9wdGlvbnMgPSBudWxsXG4gICAgc3Ryb3BoZUNvbm5lY3RTdHViID0gbnVsbFxuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgc3Ryb3BoZUNvbm5lY3RTdHViID0gc2lub24uc3R1YigpXG4gICAgICBzaW5vbi5zdHViKF8sICdsaW1pdCcpLnJldHVybnMgc3Ryb3BoZUNvbm5lY3RTdHViXG5cbiAgICAgIGNvbm5lY3Rpb24gPSBDb25uZWN0aW9uLmdldCBzcGVjT3B0aW9uc1xuICAgICAgb3B0aW9ucyA9XG4gICAgICAgIGppZDogXCJ0ZXN0QHRlc3QuY29tXCJcbiAgICAgICAgcGFzc3dvcmQ6IFwicGFzc3dvcmRcIlxuICAgICAgXy5iaW5kLnJlc2V0KClcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgc3Ryb3BoZUNvbm5lY3RTdHViLnJlc2V0KClcbiAgICAgIGNvbm5lY3Rpb24uX2Nvbm5lY3Rpb24ucmVzZXQucmVzZXQoKVxuICAgICAgXy5saW1pdC5yZXN0b3JlKClcbiAgICAgIG9wdGlvbnMgPSBudWxsXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHByb21pc2UnLCAtPlxuICAgICAgY29ubmVjdGlvbi5jb25uZWN0KG9wdGlvbnMpLl9fcHJvdG9fXy50b1N0cmluZygpXG4gICAgICAgIC5zaG91bGQuZXF1YWwgXCJbb2JqZWN0IFByb21pc2VdXCJcblxuICAgIGRlc2NyaWJlICd3aGVuIGEgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzJywgLT5cblxuICAgICAgcHJvbWlzZSA9IG51bGxcblxuICAgICAgYmVmb3JlRWFjaCAoZG9uZSkgLT5cbiAgICAgICAgcHJvbWlzZSA9IGNvbm5lY3Rpb24uY29ubmVjdCBvcHRpb25zXG4gICAgICAgIGRvbmUoKVxuXG4gICAgICBhZnRlckVhY2ggLT5cbiAgICAgICAgcHJvbWlzZSA9IG51bGxcblxuICAgICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBwcmV2aW91cyBwcm9taXNlIGZvciBhIGBwZW5kaW5nYCBkZWZlcnJlZCcsIC0+XG4gICAgICAgIHByb21pc2UyID0gY29ubmVjdGlvbi5jb25uZWN0IG9wdGlvbnNcbiAgICAgICAgcHJvbWlzZTIuc2hvdWxkLmVxdWFsIHByb21pc2VcbiAgICAgICAgcHJvbWlzZTIuaXNQZW5kaW5nKCkuc2hvdWxkLmJlLnRydWVcbiAgICAgICAgc3Ryb3BoZUNvbm5lY3RTdHViLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZVxuXG4gICAgICBpdCAnc2hvdWxkIHJldHVybiBhIHByZXZpb3VzIHByb21pc2Ugd2hlbiB0aGUgc3RhdHVzIGlzIENPTk5FQ1RJTkcnLCAtPlxuICAgICAgICBzaW5vbi5zcHkgY29ubmVjdGlvbi5fY29ubmVjdGlvbkRmZCwgJ25vdGlmeSdcbiAgICAgICAgY29ubmVjdGlvbi5fY29ubmVjdGlvblN0YXR1cyA9IFN0YXR1cy5DT05ORUNUSU5HXG4gICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdCBvcHRpb25zXG4gICAgICAgIGNvbm5lY3Rpb24uX2Nvbm5lY3Rpb25EZmQubm90aWZ5LnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgICAuY2FsbGVkV2l0aCBTdGF0dXMuQ09OTkVDVElORywgXCJBbGVhZHkgY29ubmVjdGluZyB0byB0aGUgTml0cm8gc2VydmVyXCJcblxuICAgICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBwcmV2aW91cyBwcm9taXNlIHdoZW4gdGhlIHN0YXR1cyBpcyBBVVRIRU5USUNBVElORycsIC0+XG4gICAgICAgIHNpbm9uLnNweSBjb25uZWN0aW9uLl9jb25uZWN0aW9uRGZkLCAnbm90aWZ5J1xuICAgICAgICBjb25uZWN0aW9uLl9jb25uZWN0aW9uU3RhdHVzID0gU3RhdHVzLkFVVEhFTlRJQ0FUSU5HXG4gICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdCBvcHRpb25zXG4gICAgICAgIGNvbm5lY3Rpb24uX2Nvbm5lY3Rpb25EZmQubm90aWZ5LnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgICAuY2FsbGVkV2l0aCBTdGF0dXMuQVVUSEVOVElDQVRJTkcsIFwiQWxyZWFkeSBhdXRoZW50aWNhdGluZyB3aXRoIHRoZSBOaXRybyBzZXJ2ZXJcIlxuXG4gICAgICBpdCAnc2hvdWxkIHJldHVybiBhIHByZXZpb3VzIHByb21pc2Ugd2hlbiB0aGUgc3RhdHVzIGlzIERJU0NPTk5FQ1RJTkcnLCAtPlxuICAgICAgICBzaW5vbi5zcHkgY29ubmVjdGlvbi5fY29ubmVjdGlvbkRmZCwgJ25vdGlmeSdcbiAgICAgICAgY29ubmVjdGlvbi5fY29ubmVjdGlvblN0YXR1cyA9IFN0YXR1cy5ESVNDT05ORUNURURcbiAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0IG9wdGlvbnNcbiAgICAgICAgY29ubmVjdGlvbi5fY29ubmVjdGlvbkRmZC5ub3RpZnkuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAgIC5jYWxsZWRXaXRoIFN0YXR1cy5ESVNDT05ORUNURUQsIFwiQWxyZWFkeSBkaXNjb25uZWN0aW5nIGZyb20gdGhlIE5pdHJvIHNlcnZlclwiXG5cbiAgICBpdCAnc2hvdWxkIGltbWVkaWF0ZWx5IHJldHVybiBhIHJlc29sdmVkIHByb21pc2UgaWYgc3RhdHVzIGlzIGFscmVhZHkgQ09OTkVDVEVEJywgLT5cbiAgICAgIGNvbm5lY3Rpb24uX2Nvbm5lY3Rpb25TdGF0dXMgPSBTdGF0dXMuQ09OTkVDVEVEXG4gICAgICBjb25uZWN0aW9uLmNvbm5lY3Qob3B0aW9ucykuc2hvdWxkLmJlLmZ1bGZpbGxlZFxuICAgICAgc3Ryb3BoZUNvbm5lY3RTdHViLnNob3VsZC5ub3QuaGF2ZS5iZWVuLmNhbGxlZFxuXG4gICAgaXQgJ3Nob3VsZCBjYWxsIGBjb25uZWN0KClgIG9uIHRoZSBTdHJvcGhlIGNvbm5lY3Rpb24gb2JqZWN0JywgLT5cbiAgICAgIGNvbm5lY3Rpb24uY29ubmVjdCBvcHRpb25zXG5cbiAgICAgIHN0cm9waGVDb25uZWN0U3R1Yi5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoIG9wdGlvbnMuamlkLCBvcHRpb25zLnBhc3N3b3JkXG5cbiAgICAgIF8uYmluZC5zaG91bGQuaGF2ZS5iZWVuLmNhbGxlZE9uY2VcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgZmFpbGVkIHByb21pc2UgaWYgY3JlZGVudGlhbHMgYXJlIGludmFsaWQnLCAoZG9uZSkgLT5cbiAgICAgIG9wdGlvbnMgPSBqaWQ6IG51bGwsIHBhc3N3b3JkOiBudWxsXG4gICAgICBjb25uZWN0aW9uLmNvbm5lY3Qob3B0aW9ucykuc2hvdWxkLmV2ZW50dWFsbHkuYmVcbiAgICAgICAgLnJlamVjdGVkV2l0aCBcIkNhbiBub3QgY29ubmVjdCBkdWUgdG8gbWlzc2luZyBjcmVkZW50aWFsc1wiXG4gICAgICBjb25uZWN0aW9uLmNvbm5lY3Qob3B0aW9ucykuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWQubm90aWZ5IGRvbmVcblxuICAgIGRlc2NyaWJlICdoYW5kbGluZyBzdGF0dXMgdXBkYXRlcyB3aXRoIGBvbkNvbm5lY3Rpb25TdGF0dXMoKWAnLCAtPlxuXG4gICAgICBiZWZvcmVFYWNoIC0+XG4gICAgICAgIHNpbm9uLnN0dWIgY29ubmVjdGlvbiwgJ2dldEpJRCdcblxuICAgICAgYWZ0ZXJFYWNoIC0+XG4gICAgICAgIGNvbm5lY3Rpb24uZ2V0SklELnJlc3RvcmUoKVxuICAgICAgICBjb25uZWN0aW9uLmV2ZW50TWFuYWdlci50b2dnbGVDb25uZWN0aW9uLnJlc2V0KClcbiAgICAgICAgY29ubmVjdGlvbi5fY29ubmVjdGlvbi5yZXNldC5yZXNldCgpXG5cbiAgICAgIGl0ICdzaG91bGQgaGFuZGxlIHRoZSBDT05ORUNURUQgc3RhdHVzJywgKGRvbmUpIC0+XG4gICAgICAgIGNvbm5lY3Rpb24uZ2V0SklELnJldHVybnMgamlkID0gXCJzZWxmSklEXCJcblxuICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3Qob3B0aW9ucykuc2hvdWxkLmV2ZW50dWFsbHkuYmUuZnVsZmlsbGVkLm5vdGlmeSBkb25lXG4gICAgICAgIGhhbmRsZXJGdW5jdGlvbiA9IF8uYmluZC5maXJzdENhbGwuYXJnc1swXVxuICAgICAgICBoYW5kbGVyRnVuY3Rpb24uY2FsbCBjb25uZWN0aW9uLCBjb25uZWN0aW9uLl9jb25uZWN0aW9uRGZkLCBudWxsLCBTdGF0dXMuQ09OTkVDVEVEXG5cbiAgICAgICAgY29ubmVjdGlvbi5zdGF0dXMoKS5zaG91bGQuZXF1YWwgU3RhdHVzLkNPTk5FQ1RFRFxuICAgICAgICBjb25uZWN0aW9uLmV2ZW50TWFuYWdlci50b2dnbGVDb25uZWN0aW9uLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZS5jYWxsZWRXaXRoIHRydWVcblxuICAgICAgaXQgJ3Nob3VsZCBoYW5kbGUgdGhlIENPTk5FQ1RJTkcgc3RhdHVzJywgKGRvbmUpIC0+XG4gICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdChvcHRpb25zKS5wcm9ncmVzcyAtPiBkb25lKClcblxuICAgICAgICBoYW5kbGVyRnVuY3Rpb24gPSBfLmJpbmQuZmlyc3RDYWxsLmFyZ3NbMF1cbiAgICAgICAgaGFuZGxlckZ1bmN0aW9uLmNhbGwgY29ubmVjdGlvbiwgY29ubmVjdGlvbi5fY29ubmVjdGlvbkRmZCwgbnVsbCwgU3RhdHVzLkNPTk5FQ1RJTkdcblxuICAgICAgICBjb25uZWN0aW9uLnN0YXR1cygpLnNob3VsZC5lcXVhbCBTdGF0dXMuQ09OTkVDVElOR1xuICAgICAgICBjb25uZWN0aW9uLmV2ZW50TWFuYWdlci50b2dnbGVDb25uZWN0aW9uLnNob3VsZC5ub3QuaGF2ZS5iZWVuLmNhbGxlZFxuXG4gICAgICBpdCAnc2hvdWxkIGhhbmRsZSB0aGUgQVVUSEVOVElDQVRJTkcgc3RhdHVzJywgKGRvbmUpIC0+XG4gICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdChvcHRpb25zKS5wcm9ncmVzcyAtPiBkb25lKClcblxuICAgICAgICBoYW5kbGVyRnVuY3Rpb24gPSBfLmJpbmQuZmlyc3RDYWxsLmFyZ3NbMF1cbiAgICAgICAgaGFuZGxlckZ1bmN0aW9uLmNhbGwgY29ubmVjdGlvbiwgY29ubmVjdGlvbi5fY29ubmVjdGlvbkRmZCwgbnVsbCwgU3RhdHVzLkFVVEhFTlRJQ0FUSU5HXG5cbiAgICAgICAgY29ubmVjdGlvbi5zdGF0dXMoKS5zaG91bGQuZXF1YWwgU3RhdHVzLkFVVEhFTlRJQ0FUSU5HXG4gICAgICAgIGNvbm5lY3Rpb24uZXZlbnRNYW5hZ2VyLnRvZ2dsZUNvbm5lY3Rpb24uc2hvdWxkLm5vdC5oYXZlLmJlZW4uY2FsbGVkXG5cbiAgICAgIGl0ICdzaG91bGQgaGFuZGxlIHRoZSBDT05ORkFJTCBzdGF0dXMnLCAoZG9uZSkgLT5cbiAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0KG9wdGlvbnMpLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkLm5vdGlmeSBkb25lXG5cbiAgICAgICAgaGFuZGxlckZ1bmN0aW9uID0gXy5iaW5kLmZpcnN0Q2FsbC5hcmdzWzBdXG4gICAgICAgIGhhbmRsZXJGdW5jdGlvbi5jYWxsIGNvbm5lY3Rpb24sIGNvbm5lY3Rpb24uX2Nvbm5lY3Rpb25EZmQsIG51bGwsIFN0YXR1cy5DT05ORkFJTFxuXG4gICAgICAgIGNvbm5lY3Rpb24uc3RhdHVzKCkuc2hvdWxkLmVxdWFsIFN0YXR1cy5DT05ORkFJTFxuICAgICAgICBjb25uZWN0aW9uLmV2ZW50TWFuYWdlci50b2dnbGVDb25uZWN0aW9uLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZS5jYWxsZWRXaXRoIGZhbHNlXG5cbiAgICAgIGl0ICdzaG91bGQgaGFuZGxlIHRoZSBBVVRIRkFJTCBzdGF0dXMnLCAoZG9uZSkgLT5cbiAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0KG9wdGlvbnMpLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkLm5vdGlmeSBkb25lXG5cbiAgICAgICAgaGFuZGxlckZ1bmN0aW9uID0gXy5iaW5kLmZpcnN0Q2FsbC5hcmdzWzBdXG4gICAgICAgIGhhbmRsZXJGdW5jdGlvbi5jYWxsIGNvbm5lY3Rpb24sIGNvbm5lY3Rpb24uX2Nvbm5lY3Rpb25EZmQsIG51bGwsIFN0YXR1cy5BVVRIRkFJTFxuXG4gICAgICAgIGNvbm5lY3Rpb24uc3RhdHVzKCkuc2hvdWxkLmVxdWFsIFN0YXR1cy5BVVRIRkFJTFxuICAgICAgICBjb25uZWN0aW9uLmV2ZW50TWFuYWdlci50b2dnbGVDb25uZWN0aW9uLnNob3VsZC5ub3QuaGF2ZS5iZWVuLmNhbGxlZFxuXG4gICAgICBpdCAnc2hvdWxkIGhhbmRsZSB0aGUgRElTQ09OTkVDVElORyBzdGF0dXMnLCAtPlxuICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3Qgb3B0aW9uc1xuXG4gICAgICAgIGhhbmRsZXJGdW5jdGlvbiA9IF8uYmluZC5maXJzdENhbGwuYXJnc1swXVxuICAgICAgICBoYW5kbGVyRnVuY3Rpb24uY2FsbCBjb25uZWN0aW9uLCBjb25uZWN0aW9uLl9jb25uZWN0aW9uRGZkLCBudWxsLCBTdGF0dXMuRElTQ09OTkVDVElOR1xuXG4gICAgICAgIGNvbm5lY3Rpb24uc3RhdHVzKCkuc2hvdWxkLmVxdWFsIFN0YXR1cy5ESVNDT05ORUNUSU5HXG4gICAgICAgIGNvbm5lY3Rpb24uZXZlbnRNYW5hZ2VyLnRvZ2dsZUNvbm5lY3Rpb24uc2hvdWxkLm5vdC5oYXZlLmJlZW4uY2FsbGVkXG5cbiAgICAgIGl0ICdzaG91bGQgaGFuZGxlIHRoZSBESVNDT05ORUNURUQgc3RhdHVzJywgLT5cbiAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0IG9wdGlvbnNcblxuICAgICAgICBoYW5kbGVyRnVuY3Rpb24gPSBfLmJpbmQuZmlyc3RDYWxsLmFyZ3NbMF1cbiAgICAgICAgaGFuZGxlckZ1bmN0aW9uLmNhbGwgY29ubmVjdGlvbiwgY29ubmVjdGlvbi5fY29ubmVjdGlvbkRmZCwgbnVsbCwgU3RhdHVzLkRJU0NPTk5FQ1RFRFxuXG4gICAgICAgIGNvbm5lY3Rpb24uc3RhdHVzKCkuc2hvdWxkLmVxdWFsIFN0YXR1cy5ESVNDT05ORUNURURcbiAgICAgICAgY29ubmVjdGlvbi5ldmVudE1hbmFnZXIudG9nZ2xlQ29ubmVjdGlvbi5zaG91bGQuaGF2ZS5iZWVuLmNhbGxlZE9uY2UuY2FsbGVkV2l0aCBmYWxzZVxuXG4gICAgICBpdCAnc2hvdWxkIHJlc2V0IHRoZSBTdHJvcGhlIGNvbm5lY3Rpb24gb24gRElTQ09OTkVDVEVEIHN0YXR1cycsIC0+XG4gICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdCBvcHRpb25zXG5cbiAgICAgICAgaGFuZGxlckZ1bmN0aW9uID0gXy5iaW5kLmZpcnN0Q2FsbC5hcmdzWzBdXG4gICAgICAgIGhhbmRsZXJGdW5jdGlvbi5jYWxsIGNvbm5lY3Rpb24sIGNvbm5lY3Rpb24uX2Nvbm5lY3Rpb25EZmQsIG51bGwsIFN0YXR1cy5ESVNDT05ORUNURURcblxuICAgICAgICBjb25uZWN0aW9uLl9jb25uZWN0aW9uLnJlc2V0LnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZVxuXG4gICAgICBpdCAnc2hvdWxkIGhhbmRsZSB0aGUgRkFUQUxfRkFJTFVSRSBzdGF0dXMnLCAtPlxuICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3Qgb3B0aW9uc1xuXG4gICAgICAgIGhhbmRsZXJGdW5jdGlvbiA9IF8uYmluZC5maXJzdENhbGwuYXJnc1swXVxuICAgICAgICBoYW5kbGVyRnVuY3Rpb24uY2FsbCBjb25uZWN0aW9uLCBjb25uZWN0aW9uLl9jb25uZWN0aW9uRGZkLCBudWxsLCBTdGF0dXMuRkFUQUxfRkFJTFVSRVxuXG4gICAgICAgIGNvbm5lY3Rpb24uc3RhdHVzKCkuc2hvdWxkLmVxdWFsIFN0YXR1cy5GQVRBTF9GQUlMVVJFXG4gICAgICAgIGNvbm5lY3Rpb24uZXZlbnRNYW5hZ2VyLnRvZ2dsZUNvbm5lY3Rpb24uc2hvdWxkLm5vdC5oYXZlLmJlZW4uY2FsbGVkXG5cbiAgICAgIGl0ICdzaG91bGQgcmVqZWN0IGFueSB1bmtub3duIHN0YXR1cycsIC0+XG4gICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdCBvcHRpb25zXG5cbiAgICAgICAgaGFuZGxlckZ1bmN0aW9uID0gXy5iaW5kLmZpcnN0Q2FsbC5hcmdzWzBdXG4gICAgICAgIGhhbmRsZXJGdW5jdGlvbi5jYWxsIGNvbm5lY3Rpb24sIGNvbm5lY3Rpb24uX2Nvbm5lY3Rpb25EZmQsIFwiSW52YWxpZFN0YXR1c1wiXG5cbiAgICAgICAgY29ubmVjdGlvbi5zdGF0dXMoKS5zaG91bGQuZXF1YWwgU3RhdHVzLkRJU0NPTk5FQ1RFRFxuICAgICAgICBjb25uZWN0aW9uLmV2ZW50TWFuYWdlci50b2dnbGVDb25uZWN0aW9uLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZS5jYWxsZWRXaXRoIGZhbHNlXG5cbiAgICBkZXNjcmliZSAnI3NldFByZXNlbmNlKCknLCAtPlxuXG4gICAgICBzdGF0dXMgPSBudWxsXG5cbiAgICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgICAgc2lub24uc3R1Yihjb25uZWN0aW9uLCAnaXNDb25uZWN0ZWQnKS5yZXR1cm5zIHRydWVcblxuICAgICAgYWZ0ZXJFYWNoIC0+XG4gICAgICAgIGNvbm5lY3Rpb24uaXNDb25uZWN0ZWQucmVzdG9yZSgpXG5cbiAgICAgIGl0ICdzaG91bGQgc2VuZCBBVkFJTEFCTEUgcHJlc2VuY2UgYW5kIHJldHVybiBhIGZ1bGZpbGxlZCBwcm9taXNlJywgLT5cbiAgICAgICAgc3RhdHVzID0gWE1QUFByZXNlbmNlLkFWQUlMQUJMRVxuICAgICAgICBjb25uZWN0aW9uLnNldFByZXNlbmNlKHN0YXR1cykuc2hvdWxkLmJlLmZ1bGZpbGxlZFxuXG4gICAgICAgIGNvbm5lY3Rpb24uX2Nvbm5lY3Rpb24uc2VuZElRLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZVxuICAgICAgICBjb25uZWN0aW9uLl9jb25uZWN0aW9uLnNlbmRJUS5maXJzdENhbGwuYXJnc1swXVxuICAgICAgICAgIC5zaG91bGQuYmUgaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiIsIntzaW5vbiwgZXhwZWN0LCBjb252ZXJ0WE1MVG9TdGFuemF9ID0gcmVxdWlyZSAnc3BlYy9zcGVjX2hlbHBlcidcbkNoYXRTdGF0ZXNOUyA9IHJlcXVpcmUgJ2VudW0vY2hhdF9zdGF0ZXNfbnMnXG5FdmVudEZpbHRlcnMgPSByZXF1aXJlICdldmVudHMvZXZlbnRfZmlsdGVycydcblxuZGVzY3JpYmUgJ0V2ZW50RmlsdGVycycsIC0+XG5cbiAgZGVzY3JpYmUgJyNpc01VQygpJywgLT5cblxuICAgIHhtbCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgeG1sID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZSBzdGFuemEgY29udGFpbnMgYSBNVUMgbmFtZXNwYWNlJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nPjx4IHhtbG5zPVwiaHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvbXVjI3VzZXJcIj48L3g+PC9zb21ldGhpbmc+J1xuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmlzTVVDKHN0YW56YSkuc2hvdWxkLmJlLnRydWVcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gdGhlIHN0YW56YSBjb250YWlucyBhIG5vbiBNVUMgbmFtZXNwYWNlJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nPjx4IHhtbG5zPVwiaHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvXCI+PC94Pjwvc29tZXRoaW5nPidcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc01VQyhzdGFuemEpLnNob3VsZC5iZS5mYWxzZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2Ugd2hlbiB0aGUgc3RhbnphIGNvbnRhaW5zIG5vIE1VQyBuYW1lc3BhY2UnLCAtPlxuICAgICAgeG1sID0gJzxzb21ldGhpbmc+PC9zb21ldGhpbmc+J1xuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmlzTVVDKHN0YW56YSkuc2hvdWxkLmJlLmZhbHNlXG5cbiAgZGVzY3JpYmUgJyNpc250TVVDKCknLCAtPlxuXG4gICAgeG1sID0gbnVsbFxuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICB4bWwgPSBudWxsXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSB3aGVuIHRoZSBzdGFuemEgY29udGFpbnMgYSBNVUMgbmFtZXNwYWNlJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nPjx4IHhtbG5zPVwiaHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvbXVjI3VzZXJcIj48L3g+PC9zb21ldGhpbmc+J1xuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmlzbnRNVUMoc3RhbnphKS5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRydWUgd2hlbiB0aGUgc3RhbnphIGNvbnRhaW5zIGEgbm9uIE1VQyBuYW1lc3BhY2UnLCAtPlxuICAgICAgeG1sID0gJzxzb21ldGhpbmc+PHggeG1sbnM9XCJodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9cIj48L3g+PC9zb21ldGhpbmc+J1xuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmlzbnRNVUMoc3RhbnphKS5zaG91bGQuYmUudHJ1ZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZSBzdGFuemEgY29udGFpbnMgbm8gTVVDIG5hbWVzcGFjZScsIC0+XG4gICAgICB4bWwgPSAnPHNvbWV0aGluZz48L3NvbWV0aGluZz4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNudE1VQyhzdGFuemEpLnNob3VsZC5iZS50cnVlXG5cbiAgZGVzY3JpYmUgJyNpc01VQ0ludml0ZSgpJywgLT5cblxuICAgIHhtbCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgeG1sID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZSBzdGFuemEgY29udGFpbnMgYSBNVUMgbmFtZXNwYWNlIGFuZCBhbHNvIGFuIGludml0ZSBlbGVtZW50JywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nPlxuICAgICAgICAgIDx4IHhtbG5zPVwiaHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvbXVjI3VzZXJcIj5cbiAgICAgICAgICAgIDxpbnZpdGUgZnJvbT1cInJtLXFhXzgudGhvbXNvbnJldXRlcnMuY29tQHJldWFzbWIubmV0XCJcbiAgICAgICAgICAgICAgbmFtZT1cIlJNIFFBOCAtIFBpb25lZXIgSW52ZXN0bWVudCBNYW5hZ2VtZW50IFNHUnBBXCJcbiAgICAgICAgICAgICAgZW1haWw9XCJybS1xYV84QHRob21zb25yZXV0ZXJzLmNvbVwiPlxuICAgICAgICAgICAgICAgIDxyZWFzb24+JTdCJTIyaWQlMjIlM0ElMjJncm91cGNoYXQtNmFlODE0MGNvbmZlcmVuY2UucmV1YXNtYi5uZXQlMjIlMkMlPC9yZWFzb24+XG4gICAgICAgICAgICA8L2ludml0ZT5cbiAgICAgICAgICA8L3g+XG4gICAgICAgIDwvc29tZXRoaW5nPidcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc01VQ0ludml0ZShzdGFuemEpLnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSB3aGVuIHRoZSBzdGFuemEgY29udGFpbnMgYSBNVUMgbmFtZXNwYWNlIGJ1dCBubyBpbnZpdGUgZWxlbWVudCcsIC0+XG4gICAgICB4bWwgPSAnPHNvbWV0aGluZz5cbiAgICAgICAgICA8eCB4bWxucz1cImh0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL211YyN1c2VyXCI+PC94PlxuICAgICAgICA8L3NvbWV0aGluZz4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNNVUNJbnZpdGUoc3RhbnphKS5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gdGhlIHN0YW56YSBjb250YWlucyBhIG5vbiBNVUMgbmFtZXNwYWNlJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nPlxuICAgICAgICAgIDx4IHhtbG5zPVwiaHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2xcIj5cbiAgICAgICAgICAgIDxpbnZpdGUgZnJvbT1cInJtLXFhXzgudGhvbXNvbnJldXRlcnMuY29tQHJldWFzbWIubmV0XCJcbiAgICAgICAgICAgICAgbmFtZT1cIlJNIFFBOCAtIFBpb25lZXIgSW52ZXN0bWVudCBNYW5hZ2VtZW50IFNHUnBBXCJcbiAgICAgICAgICAgICAgZW1haWw9XCJybS1xYV84QHRob21zb25yZXV0ZXJzLmNvbVwiPlxuICAgICAgICAgICAgICA8cmVhc29uPiU3QiUyMmlkJTIyJTNBJTIyZ3JvdXBjaGF0LTZhZTgxNDBjb25mZXJlbmNlLnJldWFzbWIubmV0JTIyJTJDJTwvcmVhc29uPlxuICAgICAgICAgICAgPC9pbnZpdGU+XG4gICAgICAgICAgPC94PlxuICAgICAgICA8L3NvbWV0aGluZz4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNNVUNJbnZpdGUoc3RhbnphKS5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gdGhlIHN0YW56YSBjb250YWlucyBubyBNVUMgbmFtZXNwYWNlJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nPlxuICAgICAgICAgIDxpbnZpdGUgZnJvbT1cInJtLXFhXzgudGhvbXNvbnJldXRlcnMuY29tQHJldWFzbWIubmV0XCJcbiAgICAgICAgICAgIG5hbWU9XCJSTSBRQTggLSBQaW9uZWVyIEludmVzdG1lbnQgTWFuYWdlbWVudCBTR1JwQVwiXG4gICAgICAgICAgICBlbWFpbD1cInJtLXFhXzhAdGhvbXNvbnJldXRlcnMuY29tXCI+XG4gICAgICAgICAgICAgIDxyZWFzb24+JTdCJTIyaWQlMjIlM0ElMjJncm91cGNoYXQtNmFlODE0MGNvbmZlcmVuY2UucmV1YXNtYi5uZXQlMjIlMkMlPC9yZWFzb24+XG4gICAgICAgICAgPC9pbnZpdGU+XG4gICAgICAgIDwvc29tZXRoaW5nPidcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc01VQ0ludml0ZShzdGFuemEpLnNob3VsZC5iZS5mYWxzZVxuXG4gIGRlc2NyaWJlICcjaGFzVHlwZSgpJywgLT5cblxuICAgIHhtbCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgeG1sID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZSBzdGFuemEgY29udGFpbnMgYSBgdHlwZWAgYXR0cmlidXRlJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nIHR5cGU9XCJzb21ldHlwZVwiPjwvc29tZXRoaW5nPidcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5oYXNUeXBlKHN0YW56YSkuc2hvdWxkLmJlLnRydWVcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gdGhlIHN0YW56YSBjb250YWlucyBubyBgdHlwZWAgYXR0cmlidXRlJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nPjwvc29tZXRoaW5nPidcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5oYXNUeXBlKHN0YW56YSkuc2hvdWxkLmJlLmZhbHNlXG5cbiAgZGVzY3JpYmUgJyNpc1NlbGYoKScsIC0+XG5cbiAgICB4bWwgPSBudWxsXG4gICAgc2VsZklEID0gbnVsbFxuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgc2VsZklEID0gXCJzZWxmaWRcIlxuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICB4bWwgPSBudWxsXG4gICAgICBzZWxmSUQgPSBudWxsXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gdGhlIHN0YW56YSBjb250YWlucyBhIGBmcm9tYCBhdHRyaWJ1dGUgdGhhdCBpcyB0aGUgc2VsZklEJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nIGZyb209XCJzZWxmaWRcIj48L3NvbWV0aGluZz4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNTZWxmKHN0YW56YSwgc2VsZklEKS5zaG91bGQuYmUudHJ1ZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2Ugd2hlbiB0aGUgc3RhbnphIGNvbnRhaW5zIGEgYGZyb21gIGF0cnJpYnV0ZSB0aGF0IGlzIG5vdCB0aGUgc2VsZklEJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nIGZyb209XCJhbm90aGVyaWRcIj48L3NvbWV0aGluZz4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNTZWxmKHN0YW56YSwgc2VsZklEKS5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gdGhlIHN0YW56YSBjb250YWlucyBubyBgZnJvbWAgYXRycmlidXRlJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nPjwvc29tZXRoaW5nPidcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc1NlbGYoc3RhbnphLCBzZWxmSUQpLnNob3VsZC5iZS5mYWxzZVxuXG4gIGRlc2NyaWJlICcjaXNudFNlbGYoKScsIC0+XG5cbiAgICB4bWwgPSBudWxsXG4gICAgc2VsZklEID0gbnVsbFxuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgc2VsZklEID0gXCJzZWxmaWRcIlxuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICB4bWwgPSBudWxsXG4gICAgICBzZWxmSUQgPSBudWxsXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSB3aGVuIHRoZSBzdGFuemEgY29udGFpbnMgYSBgZnJvbWAgYXR0cmlidXRlIHRoYXQgaXMgdGhlIHNlbGZJRCcsIC0+XG4gICAgICB4bWwgPSAnPHNvbWV0aGluZyBmcm9tPVwic2VsZmlkXCI+PC9zb21ldGhpbmc+J1xuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmlzbnRTZWxmKHN0YW56YSwgc2VsZklEKS5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRydWUgd2hlbiB0aGUgc3RhbnphIGNvbnRhaW5zIGEgYGZyb21gIGF0cnJpYnV0ZSB0aGF0IGlzIG5vdCB0aGUgc2VsZklEJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nIGZyb209XCJhbm90aGVyaWRcIj48L3NvbWV0aGluZz4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNudFNlbGYoc3RhbnphLCBzZWxmSUQpLnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gdGhlIHN0YW56YSBjb250YWlucyBubyBgZnJvbWAgYXRycmlidXRlJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nPjwvc29tZXRoaW5nPidcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc250U2VsZihzdGFuemEsIHNlbGZJRCkuc2hvdWxkLmJlLnRydWVcblxuICBkZXNjcmliZSAnI2lzUmVjaXBpZW50VW5hdmFpbGFibGUoKScsIC0+XG5cbiAgICB4bWwgPSBudWxsXG5cbiAgICBiZWZvcmVFYWNoIC0+XG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIHhtbCA9IG51bGxcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRydWUgd2hlbiB0aGUgc3RhbnphIGNvbnRhaW5zIGEgYHJlY2lwaWVudC11bmF2YWlsYWJsZWAgc3RhbnphLicsIC0+XG4gICAgICB4bWwgPSAnPG1lc3NhZ2UgZnJvbT1cImFub3RoZXJpZFwiPjxlcnJvcj48cmVjaXBpZW50LXVuYXZhaWxhYmxlLz48L2Vycm9yPjwvbWVzc2FnZT4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNSZWNpcGllbnRVbmF2YWlsYWJsZShzdGFuemEpLnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSB3aGVuIHRoZSBzdGFuemEgZG9lcyBub3QgY29udGFpbiBhIGByZWNpcGllbnQtdW5hdmFpbGFibGVgIHN0YW56YS4nLCAtPlxuICAgICAgeG1sID0gJzxzb21ldGhpbmc+PC9zb21ldGhpbmc+J1xuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmlzUmVjaXBpZW50VW5hdmFpbGFibGUoc3RhbnphKS5zaG91bGQuYmUuZmFsc2VcblxuICBkZXNjcmliZSAnI2lzUHJlZmVyZW5jZXMoKScsIC0+XG5cbiAgICB4bWwgPSBudWxsXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIHhtbCA9IG51bGxcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRydWUgZm9yIGEgcHJlZmVyZW5jZXMgc3RhbnphJywgLT5cbiAgICAgIHhtbCA9IFwiPGlxIHR5cGU9J3NldCcgeG1sbnM9J2phYmJlcjpjbGllbnQnPlxuICAgICAgICA8cXVlcnkgeG1sbnM9J2phYmJlcjppcTpwcml2YXRlJz5cbiAgICAgICAgICA8c3RvcmFnZSB4bWxucz0nc3RvcmFnZTpwcmVmZXJlbmNlcycgLz5cbiAgICAgICAgPC9xdWVyeT5cbiAgICAgIDwvaXE+XCJcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc1ByZWZlcmVuY2VzKHN0YW56YSkuc2hvdWxkLmJlLnRydWVcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBhIGJvb2ttYXJrcyBzdGFuemEnLCAtPlxuICAgICAgeG1sID0gXCI8aXEgdHlwZT0nc2V0JyB4bWxucz0namFiYmVyOmNsaWVudCc+XG4gICAgICAgIDxxdWVyeSB4bWxucz0namFiYmVyOmlxOnByaXZhdGUnPlxuICAgICAgICAgIDxzdG9yYWdlIHhtbG5zPSdzdG9yYWdlOmJvb2ttYXJrcycgLz5cbiAgICAgICAgPC9xdWVyeT5cbiAgICAgIDwvaXE+XCJcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc1ByZWZlcmVuY2VzKHN0YW56YSkuc2hvdWxkLmJlLmZhbHNlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSBmb3IgYSBzdGFuemEgbWlzc2luZyB0aGUgcHJlZmVyZW5jZXMgeG1sbnMnLCAtPlxuICAgICAgeG1sID0gXCI8aXEgdHlwZT0nc2V0JyB4bWxucz0namFiYmVyOmNsaWVudCc+XG4gICAgICAgIDxxdWVyeSB4bWxucz0namFiYmVyOmlxOnByaXZhdGUnPlxuICAgICAgICAgIDxzdG9yYWdlIC8+XG4gICAgICAgIDwvcXVlcnk+XG4gICAgICA8L2lxPlwiXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNQcmVmZXJlbmNlcyhzdGFuemEpLnNob3VsZC5iZS5mYWxzZVxuXG4gIGRlc2NyaWJlICcjaXNCb29rbWFya3MoKScsIC0+XG5cbiAgICB4bWwgPSBudWxsXG5cblxuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICB4bWwgPSBudWxsXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0cnVlIGZvciBhIGJvb2ttYXJrcyBzdGFuemEnLCAtPlxuICAgICAgeG1sID0gXCI8aXEgdHlwZT0nc2V0JyB4bWxucz0namFiYmVyOmNsaWVudCc+XG4gICAgICAgIDxxdWVyeSB4bWxucz0namFiYmVyOmlxOnByaXZhdGUnPlxuICAgICAgICAgIDxzdG9yYWdlIHhtbG5zPSdzdG9yYWdlOmJvb2ttYXJrcycgLz5cbiAgICAgICAgPC9xdWVyeT5cbiAgICAgIDwvaXE+XCJcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc0Jvb2ttYXJrcyhzdGFuemEpLnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0cnVlIGZvciBhIHByZWZlcmVuY2VzIHN0YW56YScsIC0+XG4gICAgICB4bWwgPSBcIjxpcSB0eXBlPSdzZXQnIHhtbG5zPSdqYWJiZXI6Y2xpZW50Jz5cbiAgICAgICAgPHF1ZXJ5IHhtbG5zPSdqYWJiZXI6aXE6cHJpdmF0ZSc+XG4gICAgICAgICAgPHN0b3JhZ2UgeG1sbnM9J3N0b3JhZ2U6cHJlZmVyZW5jZXMnIC8+XG4gICAgICAgIDwvcXVlcnk+XG4gICAgICA8L2lxPlwiXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNCb29rbWFya3Moc3RhbnphKS5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBhIHN0YW56YSBtaXNzaW5nIHRoZSBib29rbWFya3MgeG1sbnMnLCAtPlxuICAgICAgeG1sID0gXCI8aXEgdHlwZT0nc2V0JyB4bWxucz0namFiYmVyOmNsaWVudCc+XG4gICAgICAgIDxxdWVyeSB4bWxucz0namFiYmVyOmlxOnByaXZhdGUnPlxuICAgICAgICAgIDxzdG9yYWdlIC8+XG4gICAgICAgIDwvcXVlcnk+XG4gICAgICA8L2lxPlwiXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNCb29rbWFya3Moc3RhbnphKS5zaG91bGQuYmUuZmFsc2VcblxuICBkZXNjcmliZSAnI2lzUm9zdGVyQWRkZWQoKScsIC0+XG5cbiAgICB4bWwgPSBudWxsXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIHhtbCA9IG51bGxcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRydWUgZm9yIGEgc3Vic2NyaXB0aW9uIG9mIGBub25lYCBzdGFuemEnLCAtPlxuICAgICAgeG1sID0gXCI8aXEgZnJvbT0ncm0tcWFfNi50aG9tc29ucmV1dGVycy5jb21AcmV1YXNtYi5uZXQnXG4gICAgICAgIHRvPSdybS1xYV82LnRob21zb25yZXV0ZXJzLmNvbUByZXVhc21iLm5ldC9uaXRybzdiMjAzZWJlZTVmZDgzODcnIGlkPSc1ODExMDc5JyB0eXBlPSdzZXQnPlxuICAgICAgICA8cXVlcnkgeG1sbnM9J2phYmJlcjppcTpyb3N0ZXInPlxuICAgICAgICAgICAgPGl0ZW0gamlkPSd0ZXN0LnVzZXIudGhvbXNvbnJldXRlcnMuY29tQHJldWFzbWIubmV0JyBzdWJzY3JpcHRpb249J25vbmUnIC8+XG4gICAgICAgIDwvcXVlcnk+XCJcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc1Jvc3RlckFkZGVkKHN0YW56YSkuc2hvdWxkLmJlLnRydWVcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRydWUgZm9yIGEgc3Vic2NyaXB0aW9uIG9mIGBmcm9tYCBzdGFuemEnLCAtPlxuICAgICAgeG1sID0gXCI8aXEgZnJvbT0ncm0tcWFfNi50aG9tc29ucmV1dGVycy5jb21AcmV1YXNtYi5uZXQnXG4gICAgICAgIHRvPSdybS1xYV82LnRob21zb25yZXV0ZXJzLmNvbUByZXVhc21iLm5ldC9uaXRybzdiMjAzZWJlZTVmZDgzODcnIGlkPSc1ODExMDc5JyB0eXBlPSdzZXQnPlxuICAgICAgICA8cXVlcnkgeG1sbnM9J2phYmJlcjppcTpyb3N0ZXInPlxuICAgICAgICAgICAgPGl0ZW0gamlkPSd0ZXN0LnVzZXIudGhvbXNvbnJldXRlcnMuY29tQHJldWFzbWIubmV0JyBzdWJzY3JpcHRpb249J2Zyb20nIC8+XG4gICAgICAgIDwvcXVlcnk+XCJcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc1Jvc3RlckFkZGVkKHN0YW56YSkuc2hvdWxkLmJlLnRydWVcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBhIHN1YnNjcmlwdGlvbiBvZiBgcmVtb3ZlYCBzdGFuemEnLCAtPlxuICAgICAgeG1sID0gXCI8aXEgZnJvbT0ncm0tcWFfNi50aG9tc29ucmV1dGVycy5jb21AcmV1YXNtYi5uZXQnXG4gICAgICAgIHRvPSdybS1xYV82LnRob21zb25yZXV0ZXJzLmNvbUByZXVhc21iLm5ldC9uaXRybzdiMjAzZWJlZTVmZDgzODcnIGlkPSc1ODExMDc5JyB0eXBlPSdzZXQnPlxuICAgICAgICA8cXVlcnkgeG1sbnM9J2phYmJlcjppcTpyb3N0ZXInPlxuICAgICAgICAgICAgPGl0ZW0gamlkPSd0ZXN0LnVzZXIudGhvbXNvbnJldXRlcnMuY29tQHJldWFzbWIubmV0JyBzdWJzY3JpcHRpb249J3JlbW92ZScgLz5cbiAgICAgICAgPC9xdWVyeT5cIlxuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmlzUm9zdGVyQWRkZWQoc3RhbnphKS5zaG91bGQuYmUuZmFsc2VcblxuICBkZXNjcmliZSAnI2lzUm9zdGVyUmVtb3ZlZCgpJywgLT5cblxuICAgIHhtbCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgeG1sID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSBmb3IgYSBzdWJzY3JpcHRpb24gb2YgYHJlbW92ZWAgc3RhbnphJywgLT5cbiAgICAgIHhtbCA9IFwiPGlxIGZyb209J3JtLXFhXzYudGhvbXNvbnJldXRlcnMuY29tQHJldWFzbWIubmV0J1xuICAgICAgICB0bz0ncm0tcWFfNi50aG9tc29ucmV1dGVycy5jb21AcmV1YXNtYi5uZXQvbml0cm83YjIwM2ViZWU1ZmQ4Mzg3JyBpZD0nNTgxMTA3OScgdHlwZT0nc2V0Jz5cbiAgICAgICAgPHF1ZXJ5IHhtbG5zPSdqYWJiZXI6aXE6cm9zdGVyJz5cbiAgICAgICAgICAgIDxpdGVtIGppZD0ndGVzdC51c2VyLnRob21zb25yZXV0ZXJzLmNvbUByZXVhc21iLm5ldCcgc3Vic2NyaXB0aW9uPSdyZW1vdmUnIC8+XG4gICAgICAgIDwvcXVlcnk+XCJcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc1Jvc3RlclJlbW92ZWQoc3RhbnphKS5zaG91bGQuYmUudHJ1ZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgZm9yIGEgc3Vic2NyaXB0aW9uIG9mIGBub25lYCBzdGFuemEnLCAtPlxuICAgICAgeG1sID0gXCI8aXEgZnJvbT0ncm0tcWFfNi50aG9tc29ucmV1dGVycy5jb21AcmV1YXNtYi5uZXQnXG4gICAgICAgIHRvPSdybS1xYV82LnRob21zb25yZXV0ZXJzLmNvbUByZXVhc21iLm5ldC9uaXRybzdiMjAzZWJlZTVmZDgzODcnIGlkPSc1ODExMDc5JyB0eXBlPSdzZXQnPlxuICAgICAgICA8cXVlcnkgeG1sbnM9J2phYmJlcjppcTpyb3N0ZXInPlxuICAgICAgICAgICAgPGl0ZW0gamlkPSd0ZXN0LnVzZXIudGhvbXNvbnJldXRlcnMuY29tQHJldWFzbWIubmV0JyBzdWJzY3JpcHRpb249J25vbmUnIC8+XG4gICAgICAgIDwvcXVlcnk+XCJcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc1Jvc3RlclJlbW92ZWQoc3RhbnphKS5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBhIHN1YnNjcmlwdGlvbiBvZiBgZnJvbWAgc3RhbnphJywgLT5cbiAgICAgIHhtbCA9IFwiPGlxIGZyb209J3JtLXFhXzYudGhvbXNvbnJldXRlcnMuY29tQHJldWFzbWIubmV0J1xuICAgICAgICB0bz0ncm0tcWFfNi50aG9tc29ucmV1dGVycy5jb21AcmV1YXNtYi5uZXQvbml0cm83YjIwM2ViZWU1ZmQ4Mzg3JyBpZD0nNTgxMTA3OScgdHlwZT0nc2V0Jz5cbiAgICAgICAgPHF1ZXJ5IHhtbG5zPSdqYWJiZXI6aXE6cm9zdGVyJz5cbiAgICAgICAgICAgIDxpdGVtIGppZD0ndGVzdC51c2VyLnRob21zb25yZXV0ZXJzLmNvbUByZXVhc21iLm5ldCcgc3Vic2NyaXB0aW9uPSdmcm9tJyAvPlxuICAgICAgICA8L3F1ZXJ5PlwiXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNSb3N0ZXJSZW1vdmVkKHN0YW56YSkuc2hvdWxkLmJlLmZhbHNlXG5cbiAgZGVzY3JpYmUgJyNpc0Jsb2NrbGlzdEJsb2NrZWQoKScsIC0+XG5cbiAgICB4bWwgPSBudWxsXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIHhtbCA9IG51bGxcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRydWUgaWYgdGhlIHN0YW56YSBpbmNsdWRlcyBhIGBibG9ja2AgZWxlbWVudCcsIC0+XG4gICAgICB4bWwgPSBcIjxpcSBmcm9tPSdybS1xYV82LnRob21zb25yZXV0ZXJzLmNvbUByZXVhc21iLm5ldCdcbiAgICAgICAgdG89J3JtLXFhXzYudGhvbXNvbnJldXRlcnMuY29tQHJldWFzbWIubmV0L25pdHJvNjhmNDZkYjA1ZjAwZGQ3OCcgaWQ9JzEwOnNlbmRJUScgdHlwZT0nc2V0Jz5cbiAgICAgICAgICA8YmxvY2sgeG1sbnM9J3Vybjp4bXBwOmJsb2NraW5nJz5cbiAgICAgICAgICAgIDxpdGVtIGppZD0na2V2aW4ubWFlczEucWEtdGVzdC5jb21AcmV1YXNtYi5uZXQnIC8+XG4gICAgICAgICAgPC9ibG9jaz5cbiAgICAgICAgPC9pcT5cIlxuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmlzQmxvY2tsaXN0QmxvY2tlZChzdGFuemEpLnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSBpZiB0aGUgc3RhbnphIGluY2x1ZGVzIGFuIGB1bmJsb2NrYCBlbGVtZW50JywgLT5cbiAgICAgIHhtbCA9IFwiPGlxIGZyb209J3JtLXFhXzYudGhvbXNvbnJldXRlcnMuY29tQHJldWFzbWIubmV0J1xuICAgICAgICB0bz0ncm0tcWFfNi50aG9tc29ucmV1dGVycy5jb21AcmV1YXNtYi5uZXQvbml0cm82OGY0NmRiMDVmMDBkZDc4JyBpZD0nMTA6c2VuZElRJyB0eXBlPSdzZXQnPlxuICAgICAgICAgIDx1bmJsb2NrIHhtbG5zPSd1cm46eG1wcDpibG9ja2luZyc+XG4gICAgICAgICAgICA8aXRlbSBqaWQ9J2tldmluLm1hZXMxLnFhLXRlc3QuY29tQHJldWFzbWIubmV0JyAvPlxuICAgICAgICAgIDwvdW5ibG9jaz5cbiAgICAgICAgPC9pcT5cIlxuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmlzQmxvY2tsaXN0QmxvY2tlZChzdGFuemEpLnNob3VsZC5iZS5mYWxzZVxuXG4gIGRlc2NyaWJlICcjaXNCbG9ja2xpc3RVbmJsb2NrZWQoKScsIC0+XG5cbiAgICB4bWwgPSBudWxsXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIHhtbCA9IG51bGxcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRydWUgaWYgdGhlIHN0YW56YSBpbmNsdWRlcyBhIGBibG9ja2AgZWxlbWVudCcsIC0+XG4gICAgICB4bWwgPSBcIjxpcSBmcm9tPSdybS1xYV82LnRob21zb25yZXV0ZXJzLmNvbUByZXVhc21iLm5ldCdcbiAgICAgICAgdG89J3JtLXFhXzYudGhvbXNvbnJldXRlcnMuY29tQHJldWFzbWIubmV0L25pdHJvNjhmNDZkYjA1ZjAwZGQ3OCcgaWQ9JzEwOnNlbmRJUScgdHlwZT0nc2V0Jz5cbiAgICAgICAgICA8dW5ibG9jayB4bWxucz0ndXJuOnhtcHA6YmxvY2tpbmcnPlxuICAgICAgICAgICAgPGl0ZW0gamlkPSdrZXZpbi5tYWVzMS5xYS10ZXN0LmNvbUByZXVhc21iLm5ldCcgLz5cbiAgICAgICAgICA8L3VuYmxvY2s+XG4gICAgICAgIDwvaXE+XCJcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc0Jsb2NrbGlzdFVuYmxvY2tlZChzdGFuemEpLnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSBpZiB0aGUgc3RhbnphIGluY2x1ZGVzIGFuIGB1bmJsb2NrYCBlbGVtZW50JywgLT5cbiAgICAgIHhtbCA9IFwiPGlxIGZyb209J3JtLXFhXzYudGhvbXNvbnJldXRlcnMuY29tQHJldWFzbWIubmV0J1xuICAgICAgICB0bz0ncm0tcWFfNi50aG9tc29ucmV1dGVycy5jb21AcmV1YXNtYi5uZXQvbml0cm82OGY0NmRiMDVmMDBkZDc4JyBpZD0nMTA6c2VuZElRJyB0eXBlPSdzZXQnPlxuICAgICAgICAgIDxibG9jayB4bWxucz0ndXJuOnhtcHA6YmxvY2tpbmcnPlxuICAgICAgICAgICAgPGl0ZW0gamlkPSdrZXZpbi5tYWVzMS5xYS10ZXN0LmNvbUByZXVhc21iLm5ldCcgLz5cbiAgICAgICAgICA8L2Jsb2NrPlxuICAgICAgICA8L2lxPlwiXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNCbG9ja2xpc3RVbmJsb2NrZWQoc3RhbnphKS5zaG91bGQuYmUuZmFsc2VcblxuICBkZXNjcmliZSAnLmlzQ29uZmxpY3QoKScsIC0+XG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0cnVlIGlmIGEgYGNvbmZsaWN0YCBzdGFuemEgaXMgaW5jbHVkZWQnLCAtPlxuICAgICAgeG1sID0gXCI8Ym9keSB4bWxucz0naHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvaHR0cGJpbmQnXG4gICAgICAgIHhtbG5zOnN0cmVhbT0naHR0cDovL2V0aGVyeC5qYWJiZXIub3JnL3N0cmVhbXMnIGFjaz0nMTQyOTcwNjU2NSc+XG4gICAgICAgICAgPHN0cmVhbTplcnJvcj5cbiAgICAgICAgICAgIDxjb25mbGljdCB4bWxucz0ndXJuOmlldGY6cGFyYW1zOnhtbDpuczp4bXBwLXN0cmVhbXMnLz5cbiAgICAgICAgICA8L3N0cmVhbTplcnJvcj5cbiAgICAgICAgPC9ib2R5PlwiXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG5cbiAgICAgIHJlc3VsdCA9IEV2ZW50RmlsdGVycy5pc0NvbmZsaWN0IHN0YW56YVxuXG4gICAgICByZXN1bHQuc2hvdWxkLmJlLnRydWVcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIGlmIGEgYGNvbmZsaWN0YCBzdGFuemEgaXMgbm90IGluY2x1ZGVkJywgLT5cbiAgICAgIHhtbCA9IFwiPGJvZHkgeG1sbnM9J2h0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL2h0dHBiaW5kJ1xuICAgICAgICB4bWxuczpzdHJlYW09J2h0dHA6Ly9ldGhlcnguamFiYmVyLm9yZy9zdHJlYW1zJyBhY2s9JzE0Mjk3MDY1NjUnPlxuICAgICAgICAgIDxzdHJlYW06ZXJyb3IgLz5cbiAgICAgICAgPC9ib2R5PlwiXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG5cbiAgICAgIHJlc3VsdCA9IEV2ZW50RmlsdGVycy5pc0NvbmZsaWN0IHN0YW56YVxuXG4gICAgICByZXN1bHQuc2hvdWxkLmJlLmZhbHNlXG5cbiAgZGVzY3JpYmUgJyNydW4oKScsIC0+XG5cbiAgICBzdGFuemEgPSBudWxsXG4gICAgZmlsdGVycyA9IG51bGxcbiAgICBzZWxmSUQgPSBudWxsXG4gICAgZmlsdGVyMSA9IG51bGxcbiAgICBmaWx0ZXIyID0gbnVsbFxuXG4gICAgYmVmb3JlIC0+XG4gICAgICBmaWx0ZXIxID0gc2lub24uc3R1YigpXG4gICAgICBmaWx0ZXIyID0gc2lub24uc3R1YigpXG5cbiAgICBhZnRlciAtPlxuICAgICAgZmlsdGVyMSA9IG51bGxcbiAgICAgIGZpbHRlcjIgPSBudWxsXG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBzdGFuemEgPSBcIjx4bWwvPlwiXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIGZpbHRlcjEucmVzZXQoKVxuICAgICAgZmlsdGVyMi5yZXNldCgpXG4gICAgICBmaWx0ZXJzID0gbnVsbFxuICAgICAgc3RhbnphID0gbnVsbFxuICAgICAgc2VsZklEID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCBydW4gYWxsIGZpbHRlcnMgYW5kIHJldHVybiB0cnVlIGlmIHRoZXkgYWxsIHBhc3MnLCAtPlxuICAgICAgZmlsdGVyMS5yZXR1cm5zIHRydWVcbiAgICAgIGZpbHRlcjIucmV0dXJucyB0cnVlXG4gICAgICBmaWx0ZXJzID0gW2ZpbHRlcjEsIGZpbHRlcjJdXG4gICAgICBFdmVudEZpbHRlcnMucnVuKHN0YW56YSwgZmlsdGVycywgc2VsZklEKS5zaG91bGQuYmUudHJ1ZVxuXG4gICAgICBmaWx0ZXIxLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGhFeGFjdGx5IHN0YW56YSwgc2VsZklEXG5cbiAgICAgIGZpbHRlcjIuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aEV4YWN0bHkgc3RhbnphLCBzZWxmSURcblxuICAgIGl0ICdzaG91bGQgcnVuIGFsbCBmaWx0ZXJzIGFuZCByZXR1cm4gZmFsc2UgaWYgYW55IG9uZSBmYWlscycsIC0+XG4gICAgICBmaWx0ZXIxLnJldHVybnMgdHJ1ZVxuICAgICAgZmlsdGVyMi5yZXR1cm5zIGZhbHNlXG4gICAgICBmaWx0ZXJzID0gW2ZpbHRlcjEsIGZpbHRlcjJdXG4gICAgICBFdmVudEZpbHRlcnMucnVuKHN0YW56YSwgZmlsdGVycywgc2VsZklEKS5zaG91bGQuYmUuZmFsc2VcblxuICAgICAgZmlsdGVyMS5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoRXhhY3RseSBzdGFuemEsIHNlbGZJRFxuXG4gICAgICBmaWx0ZXIyLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGhFeGFjdGx5IHN0YW56YSwgc2VsZklEXG5cbiAgICBpdCAnc2hvdWxkIHJ1biBhbGwgZmlsdGVycyBhbmQgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGZpbHRlciBub3QgZm91bmQnLCAtPlxuICAgICAgZXhwZWN0KC0+IEV2ZW50RmlsdGVycy5ydW4gc3RhbnphLCBbbnVsbF0sIHNlbGZJRCkudG8udGhyb3cuRXJyb3JcbiAgICAgIGV4cGVjdCgtPiBFdmVudEZpbHRlcnMucnVuIHN0YW56YSwgW3VuZGVmaW5lZF0sIHNlbGZJRCkudG8udGhyb3cuRXJyb3JcbiAgICAgIGV4cGVjdCgtPiBFdmVudEZpbHRlcnMucnVuIHN0YW56YSwgWydub3RBRnVuY3Rpb24nXSwgc2VsZklEKS50by50aHJvdy5FcnJvclxuXG4gIGRlc2NyaWJlICcuZmlsdGVyQnlSZWNpcGllbnQoKScsIC0+XG5cbiAgICBzdGFuemEgPSBudWxsXG4gICAgY2FsbGJhY2sgPSBudWxsXG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBzdGFuemEgPVxuICAgICAgICBnZXRBdHRyaWJ1dGU6IHNpbm9uLnN0dWIoKVxuICAgICAgY2FsbGJhY2sgPSBzaW5vbi5zdHViKClcbiAgICAgIHNpbm9uLnN0dWIgRXZlbnRGaWx0ZXJzLCAnbWF0Y2hCYXJlSklEJ1xuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICBFdmVudEZpbHRlcnMubWF0Y2hCYXJlSklELnJlc3RvcmUoKVxuICAgICAgc3RhbnphID0gbnVsbFxuICAgICAgY2FsbGJhY2sgPSBudWxsXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIGZ1bmN0aW9uJywgLT5cbiAgICAgIEV2ZW50RmlsdGVycy5maWx0ZXJCeVJlY2lwaWVudChjYWxsYmFjaywgXCJzdGFuemFKSURcIikuc2hvdWxkLmJlLmEgJ2Z1bmN0aW9uJ1xuXG4gICAgaXQgJ3Nob3VsZCBpbnZva2UgdGhlIGNhbGxiYWNrIGlmIGF0dHJpYnV0ZSBtYXRjaGVzIGV4YWN0IGppZCcsIC0+XG4gICAgICBmaWx0ZXJlZENhbGxiYWNrID0gRXZlbnRGaWx0ZXJzLmZpbHRlckJ5UmVjaXBpZW50IGNhbGxiYWNrLCBcInN0YW56YUpJRFwiXG4gICAgICBzdGFuemEuZ2V0QXR0cmlidXRlLndpdGhBcmdzKCd0bycpLnJldHVybnMgXCJzdGFuemFKSURcIlxuICAgICAgZmlsdGVyZWRDYWxsYmFjayBzdGFuemFcbiAgICAgIGNhbGxiYWNrLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZS5jYWxsZWRXaXRoIHN0YW56YVxuXG4gICAgaXQgJ3Nob3VsZCBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBpZiBhdHRyaWJ1dGUgZG9lcyBub3QgbWF0Y2ggdGhlIGV4YWN0IGppZCcsIC0+XG4gICAgICBmaWx0ZXJlZENhbGxiYWNrID0gRXZlbnRGaWx0ZXJzLmZpbHRlckJ5UmVjaXBpZW50IGNhbGxiYWNrLCBcInNvbWVqaWRcIlxuICAgICAgc3RhbnphLmdldEF0dHJpYnV0ZS53aXRoQXJncygndG8nKS5yZXR1cm5zIFwic3RhbnphSklEXCJcbiAgICAgIGZpbHRlcmVkQ2FsbGJhY2sgc3RhbnphXG4gICAgICBjYWxsYmFjay5zaG91bGQubm90LmhhdmUuYmVlbi5jYWxsZWRcblxuICAgIGl0ICdzaG91bGQgaW52b2tlIHRoZSBjYWxsYmFjayBpZiBhdHRyaWJ1dGUgYXQgbGVhc3QgbWF0Y2hlcyB0aGUgYmFyZSBqaWQnLCAtPlxuICAgICAgZmlsdGVyZWRDYWxsYmFjayA9IEV2ZW50RmlsdGVycy5maWx0ZXJCeVJlY2lwaWVudCBjYWxsYmFjaywgXCJleHBlY3RlZEpJRFwiLCB0cnVlXG4gICAgICBzdGFuemEuZ2V0QXR0cmlidXRlLndpdGhBcmdzKCd0bycpLnJldHVybnMgXCJzdGFuemFKSURcIlxuICAgICAgRXZlbnRGaWx0ZXJzLm1hdGNoQmFyZUpJRC53aXRoQXJncyhcImV4cGVjdGVkSklEXCIsIFwic3RhbnphSklEXCIpLnJldHVybnMgdHJ1ZVxuICAgICAgZmlsdGVyZWRDYWxsYmFjayBzdGFuemFcbiAgICAgIGNhbGxiYWNrLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZS5jYWxsZWRXaXRoIHN0YW56YVxuXG4gICAgaXQgJ3Nob3VsZCBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBpZiBhdHRyaWJ1dGUgZG9lcyBub3QgZXZlbiBtYXRjaCB0aGUgYmFyZSBqaWQnLCAtPlxuICAgICAgZmlsdGVyZWRDYWxsYmFjayA9IEV2ZW50RmlsdGVycy5maWx0ZXJCeVJlY2lwaWVudCBjYWxsYmFjaywgXCJleHBlY3RlZEpJRFwiLCB0cnVlXG4gICAgICBzdGFuemEuZ2V0QXR0cmlidXRlLndpdGhBcmdzKCd0bycpLnJldHVybnMgXCJzdGFuemFKSURcIlxuICAgICAgRXZlbnRGaWx0ZXJzLm1hdGNoQmFyZUpJRC53aXRoQXJncyhcImV4cGVjdGVkSklEXCIsIFwic3RhbnphSklEXCIpLnJldHVybnMgZmFsc2VcbiAgICAgIGZpbHRlcmVkQ2FsbGJhY2sgc3RhbnphXG4gICAgICBjYWxsYmFjay5zaG91bGQubm90LmhhdmUuYmVlbi5jYWxsZWRcblxuICBkZXNjcmliZSAnLmZpbHRlckJ5U2VuZGVyKCknLCAtPlxuXG4gICAgc3RhbnphID0gbnVsbFxuICAgIGNhbGxiYWNrID0gbnVsbFxuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgc3RhbnphID1cbiAgICAgICAgZ2V0QXR0cmlidXRlOiBzaW5vbi5zdHViKClcbiAgICAgIGNhbGxiYWNrID0gc2lub24uc3R1YigpXG4gICAgICBzaW5vbi5zdHViIEV2ZW50RmlsdGVycywgJ21hdGNoQmFyZUpJRCdcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgRXZlbnRGaWx0ZXJzLm1hdGNoQmFyZUpJRC5yZXN0b3JlKClcbiAgICAgIHN0YW56YSA9IG51bGxcbiAgICAgIGNhbGxiYWNrID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBmdW5jdGlvbicsIC0+XG4gICAgICBFdmVudEZpbHRlcnMuZmlsdGVyQnlTZW5kZXIoY2FsbGJhY2ssIFwic3RhbnphSklEXCIpLnNob3VsZC5iZS5hICdmdW5jdGlvbidcblxuICAgIGl0ICdzaG91bGQgaW52b2tlIHRoZSBjYWxsYmFjayBpZiBhdHRyaWJ1dGUgbWF0Y2hlcyBleGFjdCBqaWQnLCAtPlxuICAgICAgZmlsdGVyZWRDYWxsYmFjayA9IEV2ZW50RmlsdGVycy5maWx0ZXJCeVNlbmRlciBjYWxsYmFjaywgXCJzdGFuemFKSURcIlxuICAgICAgc3RhbnphLmdldEF0dHJpYnV0ZS53aXRoQXJncygnZnJvbScpLnJldHVybnMgXCJzdGFuemFKSURcIlxuICAgICAgZmlsdGVyZWRDYWxsYmFjayBzdGFuemFcbiAgICAgIGNhbGxiYWNrLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZS5jYWxsZWRXaXRoIHN0YW56YVxuXG4gICAgaXQgJ3Nob3VsZCBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBpZiBhdHRyaWJ1dGUgZG9lcyBub3QgbWF0Y2ggdGhlIGV4YWN0IGppZCcsIC0+XG4gICAgICBmaWx0ZXJlZENhbGxiYWNrID0gRXZlbnRGaWx0ZXJzLmZpbHRlckJ5U2VuZGVyIGNhbGxiYWNrLCBcInNvbWVqaWRcIlxuICAgICAgc3RhbnphLmdldEF0dHJpYnV0ZS53aXRoQXJncygnZnJvbScpLnJldHVybnMgXCJzdGFuemFKSURcIlxuICAgICAgZmlsdGVyZWRDYWxsYmFjayBzdGFuemFcbiAgICAgIGNhbGxiYWNrLnNob3VsZC5ub3QuaGF2ZS5iZWVuLmNhbGxlZFxuXG4gICAgaXQgJ3Nob3VsZCBpbnZva2UgdGhlIGNhbGxiYWNrIGlmIGF0dHJpYnV0ZSBhdCBsZWFzdCBtYXRjaGVzIHRoZSBiYXJlIGppZCcsIC0+XG4gICAgICBmaWx0ZXJlZENhbGxiYWNrID0gRXZlbnRGaWx0ZXJzLmZpbHRlckJ5U2VuZGVyIGNhbGxiYWNrLCBcImV4cGVjdGVkSklEXCIsIHRydWVcbiAgICAgIHN0YW56YS5nZXRBdHRyaWJ1dGUud2l0aEFyZ3MoJ2Zyb20nKS5yZXR1cm5zIFwic3RhbnphSklEXCJcbiAgICAgIEV2ZW50RmlsdGVycy5tYXRjaEJhcmVKSUQud2l0aEFyZ3MoXCJleHBlY3RlZEpJRFwiLCBcInN0YW56YUpJRFwiKS5yZXR1cm5zIHRydWVcbiAgICAgIGZpbHRlcmVkQ2FsbGJhY2sgc3RhbnphXG4gICAgICBjYWxsYmFjay5zaG91bGQuaGF2ZS5iZWVuLmNhbGxlZE9uY2UuY2FsbGVkV2l0aCBzdGFuemFcblxuICAgIGl0ICdzaG91bGQgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgaWYgYXR0cmlidXRlIGRvZXMgbm90IGV2ZW4gbWF0Y2ggdGhlIGJhcmUgamlkJywgLT5cbiAgICAgIGZpbHRlcmVkQ2FsbGJhY2sgPSBFdmVudEZpbHRlcnMuZmlsdGVyQnlTZW5kZXIgY2FsbGJhY2ssIFwiZXhwZWN0ZWRKSURcIiwgdHJ1ZVxuICAgICAgc3RhbnphLmdldEF0dHJpYnV0ZS53aXRoQXJncygnZnJvbScpLnJldHVybnMgXCJzdGFuemFKSURcIlxuICAgICAgRXZlbnRGaWx0ZXJzLm1hdGNoQmFyZUpJRC53aXRoQXJncyhcImV4cGVjdGVkSklEXCIsIFwic3RhbnphSklEXCIpLnJldHVybnMgZmFsc2VcbiAgICAgIGZpbHRlcmVkQ2FsbGJhY2sgc3RhbnphXG4gICAgICBjYWxsYmFjay5zaG91bGQubm90LmhhdmUuYmVlbi5jYWxsZWRcblxuICBkZXNjcmliZSAnI2lzSGlzdG9yeUZpbigpJywgLT5cblxuICAgIHhtbCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgeG1sID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZSBzdGFuemEgY29udGFpbnMgYSBmaW4gc3RhbnphJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nPjxmaW4geG1sbnM9XCJ1cm46eG1wcDptYW06dG1wXCI+PC9maW4+PC9zb21ldGhpbmc+J1xuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmlzSGlzdG9yeUZpbihzdGFuemEpLnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSB3aGVuIHRoZSBzdGFuemEgZG9lcyBub3QgY29udGFpbiBhIGZpbiBzdGFuemEnLCAtPlxuICAgICAgeG1sID0gJzxzb21ldGhpbmc+PHggeG1sbnM9XCJodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9cIj48L3g+PC9zb21ldGhpbmc+J1xuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmlzSGlzdG9yeUZpbihzdGFuemEpLnNob3VsZC5iZS5mYWxzZVxuXG5cbiAgZGVzY3JpYmUgJyNpc250SGlzdG9yeUZpbigpJywgLT5cblxuICAgIHhtbCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgeG1sID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZSBzdGFuemEgZG9lcyBub3QgY29udGFpbiBhIGZpbiBzdGFuemEnLCAtPlxuICAgICAgeG1sID0gJzxzb21ldGhpbmc+PHggeG1sbnM9XCJodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9cIj48L3g+PC9zb21ldGhpbmc+J1xuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmlzbnRIaXN0b3J5RmluKHN0YW56YSkuc2hvdWxkLmJlLnRydWVcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gdGhlIHN0YW56YSBjb250YWlucyBhIGZpbiBzdGFuemEnLCAtPlxuICAgICAgeG1sID0gJzxzb21ldGhpbmc+PGZpbiB4bWxucz1cInVybjp4bXBwOm1hbTp0bXBcIj48L2Zpbj48L3NvbWV0aGluZz4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNudEhpc3RvcnlGaW4oc3RhbnphKS5zaG91bGQuYmUuZmFsc2VcblxuICBkZXNjcmliZSAnI2lzTVVDU3ViamVjdCgpJywgLT5cblxuICAgIHhtbCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgeG1sID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZSBzdGFuemEgY29udGFpbnMgYSBzdWJqZWN0IHN0YW56YScsIC0+XG4gICAgICB4bWwgPSAnPG1lc3NhZ2UgdHlwZT1cImdyb3VwY2hhdFwiPjxzdWJqZWN0PnRoZSBzdWJqZWN0PC9zdWJqZWN0PjwvbWVzc2FnZT4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNNVUNTdWJqZWN0KHN0YW56YSkuc2hvdWxkLmJlLnRydWVcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gdGhlIHN0YW56YSBkb2VzIG5vdCBjb250YWluIGEgc3ViamVjdCBzdGFuemEnLCAtPlxuICAgICAgeG1sID0gJzxzb21ldGhpbmc+PHggeG1sbnM9XCJodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9cIj48L3g+PC9zb21ldGhpbmc+J1xuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmlzTVVDU3ViamVjdChzdGFuemEpLnNob3VsZC5iZS5mYWxzZVxuXG5cbiAgZGVzY3JpYmUgJyNpc250TVVDU3ViamVjdCgpJywgLT5cblxuICAgIHhtbCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgeG1sID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZSBzdGFuemEgZG9lcyBub3QgY29udGFpbiBhIHN1YmplY3Qgc3RhbnphJywgLT5cbiAgICAgIHhtbCA9ICc8c29tZXRoaW5nPjx4IHhtbG5zPVwiaHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvXCI+PC94Pjwvc29tZXRoaW5nPidcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc250TVVDU3ViamVjdChzdGFuemEpLnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSB3aGVuIHRoZSBzdGFuemEgY29udGFpbnMgYSBmaW4gc3RhbnphJywgLT5cbiAgICAgIHhtbCA9ICc8bWVzc2FnZSB0eXBlPVwiZ3JvdXBjaGF0XCI+PHN1YmplY3Q+dGhlIHN1YmplY3Q8L3N1YmplY3Q+PC9tZXNzYWdlPidcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc250TVVDU3ViamVjdChzdGFuemEpLnNob3VsZC5iZS5mYWxzZVxuXG5cbiAgZGVzY3JpYmUgJyNpc1R5cGluZ05vdGljZSgpJywgLT5cblxuICAgIHhtbCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgeG1sID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZSBzdGFuemEgY29udGFpbnMgYSBjb21wb3Npbmcgc3RhbnphJywgLT5cbiAgICAgIHhtbCA9ICc8bWVzc2FnZT48Y29tcG9zaW5nIHhtbG5zPVwiJyArIENoYXRTdGF0ZXNOUy5DSEFUX1NUQVRFUyArICdcIi8+PC9tZXNzYWdlPidcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc1R5cGluZ05vdGljZShzdGFuemEpLnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSB3aGVuIHRoZSBzdGFuemEgZG9lcyBub3QgY29udGFpbiBhIGNvbXBvc2luZyBzdGFuemEnLCAtPlxuICAgICAgeG1sID0gJzxtZXNzYWdlIHR5cGU9XCJncm91cGNoYXRcIj48Ym9keT5mb288L2JvZHk+PC9tZXNzYWdlPidcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc1R5cGluZ05vdGljZShzdGFuemEpLnNob3VsZC5iZS5mYWxzZVxuXG4gIGRlc2NyaWJlICcjaXNudFR5cGluZ05vdGljZSgpJywgLT5cblxuICAgIHhtbCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgeG1sID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2Ugd2hlbiB0aGUgc3RhbnphIGNvbnRhaW5zIGEgY29tcG9zaW5nIHN0YW56YScsIC0+XG4gICAgICB4bWwgPSAnPG1lc3NhZ2U+PGNvbXBvc2luZyB4bWxucz1cIicgKyBDaGF0U3RhdGVzTlMuQ0hBVF9TVEFURVMgKyAnXCIvPjwvbWVzc2FnZT4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaXNudFR5cGluZ05vdGljZShzdGFuemEpLnNob3VsZC5iZS5mYWxzZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZSBzdGFuemEgZG9lcyBub3QgY29udGFpbiBhIGNvbXBvc2luZyBzdGFuemEnLCAtPlxuICAgICAgeG1sID0gJzxtZXNzYWdlIHR5cGU9XCJncm91cGNoYXRcIj48Ym9keT5mb288L2JvZHk+PC9tZXNzYWdlPidcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5pc250VHlwaW5nTm90aWNlKHN0YW56YSkuc2hvdWxkLmJlLnRydWVcblxuICBkZXNjcmliZSAnI2hhc0JvZHlUYWcnLCAtPlxuICAgIHhtbCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgeG1sID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSBpZiB0aGUgc3RhbnphIGhhcyBhIGJvZHkgdGFnJywgLT5cbiAgICAgIHhtbCA9ICc8bWVzc2FnZSB0eXBlPVwiZ3JvdXBjaGF0XCI+PGJvZHk+Zm9vPC9ib2R5PjwvbWVzc2FnZT4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaGFzQm9keVRhZyhzdGFuemEpLnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSBpZiB0aGUgc3RhbnphIGRvZXMgbm90IGhhdmUgYSBib2R5IHRhZycsIC0+XG4gICAgICB4bWwgPSAnPG1lc3NhZ2UgdHlwZT1cImdyb3VwY2hhdFwiPjwvbWVzc2FnZT4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaGFzQm9keVRhZyhzdGFuemEpLnNob3VsZC5iZS5mYWxzZVxuXG4gIGRlc2NyaWJlICcjaGFzbnRCb2R5VGFnJywgLT5cbiAgICB4bWwgPSBudWxsXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIHhtbCA9IG51bGxcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRydWUgaWYgdGhlIHN0YW56YSBkb2VzIG5vdCBoYXZlIGEgYm9keSB0YWcnLCAtPlxuICAgICAgeG1sID0gJzxtZXNzYWdlIHR5cGU9XCJncm91cGNoYXRcIj48L21lc3NhZ2U+J1xuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmhhc250Qm9keVRhZyhzdGFuemEpLnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSBpZiB0aGUgc3RhbnphIGhhcyBhIGJvZHkgdGFnJywgLT5cbiAgICAgIHhtbCA9ICc8bWVzc2FnZSB0eXBlPVwiZ3JvdXBjaGF0XCI+PGJvZHk+Zm9vPC9ib2R5PjwvbWVzc2FnZT4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaGFzbnRCb2R5VGFnKHN0YW56YSkuc2hvdWxkLmJlLmZhbHNlXG5cbiAgZGVzY3JpYmUgJyNoYXNTdGF0dXNUYWcnLCAtPlxuICAgIHhtbCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgeG1sID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSBpZiB0aGUgc3RhbnphIGhhcyBhIHN0YXR1cyB0YWcnLCAtPlxuICAgICAgeG1sID0gJzxtZXNzYWdlIHR5cGU9XCJncm91cGNoYXRcIj48c3RhdHVzIGNvZGU9XCIxMDRcIi8+PC9tZXNzYWdlPidcbiAgICAgIHN0YW56YSA9IGNvbnZlcnRYTUxUb1N0YW56YSB4bWxcbiAgICAgIEV2ZW50RmlsdGVycy5oYXNTdGF0dXNUYWcoc3RhbnphKS5zaG91bGQuYmUudHJ1ZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgaWYgdGhlIHN0YW56YSBkb2VzIG5vdCBoYXZlIGEgc3RhdHVzIHRhZycsIC0+XG4gICAgICB4bWwgPSAnPG1lc3NhZ2UgdHlwZT1cImdyb3VwY2hhdFwiPjxib2R5PmZvbzwvYm9keT48L21lc3NhZ2U+J1xuICAgICAgc3RhbnphID0gY29udmVydFhNTFRvU3RhbnphIHhtbFxuICAgICAgRXZlbnRGaWx0ZXJzLmhhc1N0YXR1c1RhZyhzdGFuemEpLnNob3VsZC5iZS5mYWxzZVxuXG4gIGRlc2NyaWJlICcjaGFzbnRTdGF0dXNUYWcnLCAtPlxuICAgIHhtbCA9IG51bGxcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgeG1sID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSBpZiB0aGUgc3RhbnphIGRvZXMgbm90IGhhdmUgYSBzdGF0dXMgdGFnJywgLT5cbiAgICAgIHhtbCA9ICc8bWVzc2FnZSB0eXBlPVwiZ3JvdXBjaGF0XCI+PGJvZHk+Zm9vPC9ib2R5PjwvbWVzc2FnZT4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaGFzbnRTdGF0dXNUYWcoc3RhbnphKS5zaG91bGQuYmUudHJ1ZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgaWYgdGhlIHN0YW56YSBoYXMgYSBzdGF0dXMgdGFnJywgLT5cbiAgICAgIHhtbCA9ICc8bWVzc2FnZSB0eXBlPVwiZ3JvdXBjaGF0XCI+PHN0YXR1cyBjb2RlPVwiMTA0XCIvPjwvbWVzc2FnZT4nXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgeG1sXG4gICAgICBFdmVudEZpbHRlcnMuaGFzbnRTdGF0dXNUYWcoc3RhbnphKS5zaG91bGQuYmUuZmFsc2VcbiIsIntzaW5vbiwgZXhwZWN0LCBfLCBjb252ZXJ0WE1MVG9TdGFuemF9ID0gcmVxdWlyZSAnc3BlYy9zcGVjX2hlbHBlcidcbkV2ZW50SGFuZGxlciA9IHJlcXVpcmUgJ2V2ZW50cy9ldmVudF9oYW5kbGVyJ1xuRXZlbnRGaWx0ZXJzID0gcmVxdWlyZSAnZXZlbnRzL2V2ZW50X2ZpbHRlcnMnXG5TdHJvcGhlID0gcmVxdWlyZSAnc3Ryb3BoZSdcblxuZGVzY3JpYmUgJ0V2ZW50SGFuZGxlcicsIC0+XG5cbiAgZXZlbnRIYW5kbGVyID0gbnVsbFxuICBwYXRoID0gbnVsbFxuXG4gIGJlZm9yZUVhY2ggLT5cbiAgICBwYXRoID0gJ3BhdGgudG8uZXZlbnQnXG5cbiAgYWZ0ZXJFYWNoIC0+XG4gICAgZXZlbnRIYW5kbGVyID0gbnVsbFxuICAgIHBhdGggPSBudWxsXG5cbiAgZGVzY3JpYmUgJyNjb25zdHJ1Y3RvcigpJywgLT5cblxuICAgIGNvbmZpZyA9IG51bGxcblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIGNvbmZpZyA9XG4gICAgICAgIG5zOiAnbnMnXG4gICAgICAgIG5hbWU6ICduYW1lJ1xuICAgICAgICB0eXBlOiAndHlwZSdcbiAgICAgICAgaWQ6ICdpZCdcbiAgICAgICAgZnJvbTogJ2Zyb20nXG4gICAgICAgIGZpbHRlcnM6IFtcImFcIiwgXCJiXCJdXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIGNvbmZpZyA9IG51bGxcblxuICAgIGl0ICdzaG91bGQgYWNjZXB0IGEgY29uZmlnIG9iamVjdCcsIC0+XG4gICAgICBldmVudEhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyIGNvbmZpZ1xuICAgICAgZXZlbnRIYW5kbGVyLmNvbmZpZy5ucy5zaG91bGQuZXF1YWwgY29uZmlnLm5zXG4gICAgICBldmVudEhhbmRsZXIuY29uZmlnLm5hbWUuc2hvdWxkLmVxdWFsIGNvbmZpZy5uYW1lXG4gICAgICBldmVudEhhbmRsZXIuY29uZmlnLnR5cGUuc2hvdWxkLmVxdWFsIGNvbmZpZy50eXBlXG4gICAgICBldmVudEhhbmRsZXIuY29uZmlnLmlkLnNob3VsZC5lcXVhbCBjb25maWcuaWRcbiAgICAgIGV2ZW50SGFuZGxlci5jb25maWcuZnJvbS5zaG91bGQuZXF1YWwgY29uZmlnLmZyb21cbiAgICAgIGV2ZW50SGFuZGxlci5jb25maWcuZmlsdGVycy5zaG91bGQuZXF1YWwgY29uZmlnLmZpbHRlcnNcblxuICAgIGl0ICdzaG91bGQgYWNjZXB0IGEgYG1hdGNoQmFyZWAgcHJvcGVydHknLCAtPlxuICAgICAgY29uZmlnID0gXy5leHRlbmQgY29uZmlnLCBtYXRjaEJhcmU6IHRydWVcbiAgICAgIGV2ZW50SGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXIgY29uZmlnXG4gICAgICBldmVudEhhbmRsZXIuY29uZmlnLm1hdGNoQmFyZS5zaG91bGQuYmUudHJ1ZVxuICAgICAgZXZlbnRIYW5kbGVyLmNvbmZpZy5vcHRpb25zLm1hdGNoQmFyZS5zaG91bGQuYmUudHJ1ZVxuXG4gICAgaXQgJ3Nob3VsZCBhY2NlcHQgYSBgbWF0Y2hCYXJlYCBwcm9wZXJ0eScsIC0+XG4gICAgICBldmVudEhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyIGNvbmZpZ1xuICAgICAgZXhwZWN0KGV2ZW50SGFuZGxlci5jb25maWcubWF0Y2hCYXJlKS50by5ub3QuZXhpc3RcbiAgICAgIGV2ZW50SGFuZGxlci5jb25maWcub3B0aW9ucy5tYXRjaEJhcmUuc2hvdWxkLmJlLmZhbHNlXG5cbiAgICBpdCAnc2hvdWxkIGhhdmUgYW4gZW1wdHkgY2FsbGJhY2tzIG9iamVjdCcsIC0+XG4gICAgICBuZXcgRXZlbnRIYW5kbGVyKGNvbmZpZykuc2hvdWxkLmhhdmUuYS5wcm9wZXJ0eSgnX2NhbGxiYWNrcycpXG4gICAgICAgIC50aGF0LmVxbHMge31cbiAgICAgIFxuICBkZXNjcmliZSAnI2FkZENhbGxiYWNrKCknLCAtPlxuXG4gICAgY2FsbGJhY2sgPSBudWxsXG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBldmVudEhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyKClcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgY2FsbGJhY2sgPSBudWxsXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhbiBpZCcsIC0+XG4gICAgICBjYWxsYmFjayA9IHNpbm9uLnN0dWIoKVxuICAgICAgXG4gICAgICBpZCA9IGV2ZW50SGFuZGxlci5hZGRDYWxsYmFjayBjYWxsYmFja1xuICAgICAgXG4gICAgICBpZC5zaG91bGQuYmUuYSAnc3RyaW5nJ1xuXG4gICAgaXQgJ3Nob3VsZCBhZGQgYSBjYWxsYmFjaycsIC0+XG4gICAgICBjYWxsYmFjayA9IHNpbm9uLnN0dWIoKVxuICAgICAgXG4gICAgICBpZCA9IGV2ZW50SGFuZGxlci5hZGRDYWxsYmFjayBjYWxsYmFja1xuICAgICAgXG4gICAgICBldmVudEhhbmRsZXIuX2NhbGxiYWNrc1tpZF0uc2hvdWxkLmVxdWFsIGNhbGxiYWNrXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBudWxsIGlmIG5vdCBwYXNzZWQgYSBjYWxsYmFjayBmdW5jdGlvbicsIC0+XG4gICAgICBleHBlY3QoZXZlbnRIYW5kbGVyLmFkZENhbGxiYWNrKCkpLnRvLmJlLm51bGxcbiAgICAgIGV4cGVjdChldmVudEhhbmRsZXIuYWRkQ2FsbGJhY2sobnVsbCkpLnRvLmJlLm51bGxcbiAgICAgIGV4cGVjdChldmVudEhhbmRsZXIuYWRkQ2FsbGJhY2soMSkpLnRvLmJlLm51bGxcbiAgICAgIGV4cGVjdChldmVudEhhbmRsZXIuYWRkQ2FsbGJhY2soXCJmdW5jdGlvblwiKSkudG8uYmUubnVsbFxuICAgICAgZXhwZWN0KGV2ZW50SGFuZGxlci5hZGRDYWxsYmFjayh0cnVlKSkudG8uYmUubnVsbFxuICAgICAgZXhwZWN0KGV2ZW50SGFuZGxlci5hZGRDYWxsYmFjayhbXSkpLnRvLmJlLm51bGxcblxuICBkZXNjcmliZSAnI2hhc0NhbGxiYWNrcygpJywgLT5cbiAgICBcbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBldmVudEhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyKClcbiAgICBcbiAgICBpdCAnc2hvdWxkIHJldHVybiB0cnVlIGlmIHRoZXJlIGFyZSBjYWxsYmFja3MnLCAtPlxuICAgICAgZXZlbnRIYW5kbGVyLl9jYWxsYmFja3MgPVxuICAgICAgICAnYWJjZCc6IHNpbm9uLnN0dWIoKVxuICAgICAgICAnZWZnaCc6IHNpbm9uLnN0dWIoKVxuICAgICAgZXZlbnRIYW5kbGVyLmhhc0NhbGxiYWNrcygpLnNob3VsZC5iZS50cnVlXG4gICAgICBcbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSBpZiB0aGVyZSBhcmUgbm8gY2FsbGJhY2tzJywgLT5cbiAgICAgIGV2ZW50SGFuZGxlci5oYXNDYWxsYmFja3MoKS5zaG91bGQuYmUuZmFsc2VcblxuICBkZXNjcmliZSAnI2dldFN0cm9waGVIYW5kbGVyKCknLCAtPlxuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgZXZlbnRIYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlcigpXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0aGUgU3Ryb3BoZS5IYW5kbGVyIGluc3RhbmNlIGlmIHRoZXJlIGlzIG9uZScsIC0+XG4gICAgICBzdHJvcGhlSGFuZGxlciA9IG5ldyBTdHJvcGhlLkhhbmRsZXIoKVxuICAgICAgZXZlbnRIYW5kbGVyLl9zdHJvcGhlSGFuZGxlciA9IHN0cm9waGVIYW5kbGVyXG4gICAgICBldmVudEhhbmRsZXIuZ2V0U3Ryb3BoZUhhbmRsZXIoKS5zaG91bGQuZXF1YWwgc3Ryb3BoZUhhbmRsZXJcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIG51bGwgaWYgdGhlcmUgaXMgbm8gU3Ryb3BoZS5IYW5kbGVyIGluc3RhbmNlJywgLT5cbiAgICAgIGV4cGVjdChldmVudEhhbmRsZXIuZ2V0U3Ryb3BoZUhhbmRsZXIoKSkudG8uYmUubnVsbFxuXG4gIGRlc2NyaWJlICcjc2V0U3Ryb3BoZUhhbmRsZXIoKScsIC0+XG4gICAgXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgZXZlbnRIYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlcigpXG5cbiAgICBpdCAnc2hvdWxkIHNldCBhIFN0cm9waGUuSGFuZGxlciBpbnN0YW5jZScsIC0+XG4gICAgICBzdHJvcGhlSGFuZGxlciA9IG5ldyBTdHJvcGhlLkhhbmRsZXIoKVxuICAgICAgZXZlbnRIYW5kbGVyLnNldFN0cm9waGVIYW5kbGVyIHN0cm9waGVIYW5kbGVyXG4gICAgICBldmVudEhhbmRsZXIuX3N0cm9waGVIYW5kbGVyLnNob3VsZC5lcXVhbCBzdHJvcGhlSGFuZGxlclxuXG4gICAgaXQgJ3Nob3VsZCBub3Qgc2V0IGFueXRoaW5nIHRoYXQgaXMgbm90IGEgU3Ryb3BoZS5IYW5kbGVyIGluc3RhbmNlJywgLT5cbiAgICAgIG5vblN0cm9waGVIYW5kbGVyID0ge31cbiAgICAgIGV2ZW50SGFuZGxlci5zZXRTdHJvcGhlSGFuZGxlcihub25TdHJvcGhlSGFuZGxlcikuc2hvdWxkLmVxdWFsIGV2ZW50SGFuZGxlclxuICAgICAgZXhwZWN0KGV2ZW50SGFuZGxlci5fc3Ryb3BoZUhhbmRsZXIpLnRvLmJlLm51bGxcblxuICAgIGl0ICdzaG91bGQgc2V0IHRoZSBTdHJvcGhlIGhhbmRsZXIgdG8gbnVsbCB3aGVuIHRoZSBgcmVzZXRgIGZsYWcgaXMgdHJ1ZScsIC0+XG4gICAgICAjIFNldHVwIGEgcmVhbCBzdHJvcGhlIGhhbmRsZXIgYmVmb3JlIHJlc2V0dGluZ1xuICAgICAgc3Ryb3BoZUhhbmRsZXIgPSBuZXcgU3Ryb3BoZS5IYW5kbGVyKClcbiAgICAgIGV2ZW50SGFuZGxlci5fc3Ryb3BoZUhhbmRsZXIgPSBzdHJvcGhlSGFuZGxlclxuICAgICAgIyBSZXNldCB3aXRoIG51bGwgYW5kIHJlc2V0PXRydWVcbiAgICAgIGV2ZW50SGFuZGxlci5zZXRTdHJvcGhlSGFuZGxlciBudWxsLCB0cnVlXG4gICAgICBleHBlY3QoZXZlbnRIYW5kbGVyLl9zdHJvcGhlSGFuZGxlcikudG8uYmUubnVsbFxuXG4gICAgaXQgJ3Nob3VsZCBiZSBhIGZsdWVudCBtZXRob2QgcmV0dXJuaW5nIHRoaXMnLCAtPlxuICAgICAgc3Ryb3BoZUhhbmRsZXIgPSBuZXcgU3Ryb3BoZS5IYW5kbGVyKClcbiAgICAgIGV2ZW50SGFuZGxlci5zZXRTdHJvcGhlSGFuZGxlcihzdHJvcGhlSGFuZGxlcikuc2hvdWxkLmVxdWFsIGV2ZW50SGFuZGxlclxuICAgICAgXG4gIGRlc2NyaWJlICcjcmVzZXQoKScsIC0+XG4gICAgXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgZXZlbnRIYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlcigpXG4gICAgICBzaW5vbi5zdHViIGV2ZW50SGFuZGxlciwgJ3NldFN0cm9waGVIYW5kbGVyJ1xuICAgICAgc2lub24uc3R1YiBldmVudEhhbmRsZXIsICdyZXNldENhbGxiYWNrcydcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgZXZlbnRIYW5kbGVyLnNldFN0cm9waGVIYW5kbGVyLnJlc3RvcmUoKVxuICAgICAgZXZlbnRIYW5kbGVyLnJlc2V0Q2FsbGJhY2tzLnJlc3RvcmUoKVxuXG4gICAgaXQgJ3Nob3VsZCByZXNldCB0aGUgU3Ryb3BoZS5IYW5kbGVyIGJ5IGNhbGxpbmcgI3NldFN0cm9waGVIYW5kbGVyKCknLCAtPlxuICAgICAgZXZlbnRIYW5kbGVyLnJlc2V0KClcbiAgICAgIGV2ZW50SGFuZGxlci5zZXRTdHJvcGhlSGFuZGxlci5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoRXhhY3RseSBudWxsLCB0cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJlc2V0IHRoZSBjYWxsYmFja3MgY2FsbGluZyAjcmVzZXRDYWxsYmFja3MoKScsIC0+XG4gICAgICBldmVudEhhbmRsZXIucmVzZXQoKVxuICAgICAgZXZlbnRIYW5kbGVyLnJlc2V0Q2FsbGJhY2tzLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZVxuXG4gIGRlc2NyaWJlICcjcmVzZXRDYWxsYmFja3MoKScsIC0+XG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBldmVudEhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyKClcblxuICAgIGl0ICdzaG91bGQgZGVsZXRlIGFsbCBjYWxsYmFja3MnLCAtPlxuICAgICAgY2FsbGJhY2tzID1cbiAgICAgICAgYWJjZDogc2lub24uc3R1YigpXG4gICAgICAgIGVmZ2g6IHNpbm9uLnN0dWIoKVxuICAgICAgZXZlbnRIYW5kbGVyLl9jYWxsYmFja3MgPSBjYWxsYmFja3NcblxuICAgICAgZGVsZXRlZElkcyA9IGV2ZW50SGFuZGxlci5yZXNldENhbGxiYWNrcygpXG5cbiAgICAgIGV2ZW50SGFuZGxlci5fY2FsbGJhY2tzLnNob3VsZC5iZS5lbXB0eVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgZGVsZXRlZCBjYWxsYmFjayBpZHMnLCAtPlxuICAgICAgY2FsbGJhY2tzID1cbiAgICAgICAgYWJjZDogc2lub24uc3R1YigpXG4gICAgICAgIGVmZ2g6IHNpbm9uLnN0dWIoKVxuICAgICAgZXZlbnRIYW5kbGVyLl9jYWxsYmFja3MgPSBjYWxsYmFja3NcblxuICAgICAgZGVsZXRlZElkcyA9IGV2ZW50SGFuZGxlci5yZXNldENhbGxiYWNrcygpXG5cbiAgICAgIF8uY29udGFpbnMoZGVsZXRlZElkcywgJ2FiY2QnKS5zaG91bGQuYmUudHJ1ZVxuICAgICAgXy5jb250YWlucyhkZWxldGVkSWRzLCAnYWJjZCcpLnNob3VsZC5iZS50cnVlXG5cbiAgZGVzY3JpYmUgJyNnZXRTaWduYXR1cmVBcmdzKCknLCAtPlxuXG4gICAgc2VsZkpJRCA9IG51bGxcblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIGV2ZW50SGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXIoKVxuICAgICAgc2VsZkpJRCA9ICdzZWxmSklEJ1xuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICBzZWxmSklEID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCBzdG9yZSB0aGUgc2VsZkpJRCBwYXNzZWQgaW50byBpdCcsIC0+XG4gICAgICBldmVudEhhbmRsZXIuZ2V0U2lnbmF0dXJlQXJncyBzZWxmSklEXG4gICAgICBldmVudEhhbmRsZXIuc2hvdWxkLmhhdmUuYS5wcm9wZXJ0eSgnc2VsZkpJRCcpXG4gICAgICAgIC50aGF0LmVxdWFscyBzZWxmSklEXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBzZWxlY3RlZCB2YWx1ZXMnLCAtPlxuICAgICAgY29uZmlnID1cbiAgICAgICAgbnM6ICducydcbiAgICAgICAgbmFtZTogJ25hbWUnXG4gICAgICAgIHR5cGU6ICd0eXBlJ1xuICAgICAgICBpZDogJ2lkJ1xuICAgICAgICBmcm9tOiAnZnJvbSdcbiAgICAgICAgb3B0aW9uczoge31cblxuICAgICAgZXZlbnRIYW5kbGVyLmNvbmZpZyA9IGNvbmZpZ1xuICAgICAgZXZlbnRIYW5kbGVyLmdldFNpZ25hdHVyZUFyZ3Moc2VsZkpJRClcbiAgICAgICAgLnNob3VsZC5lcWwgWyducycsICduYW1lJywgJ3R5cGUnLCAnaWQnLCAnZnJvbScsIHt9XVxuXG4gICAgaXQgJ3Nob3VsZCB1c2Ugc2VsZkpJRCB3aGVuIHNwZWNpZmllZCBieSB0aGUgYGZyb21gIGZpZWxkJywgLT5cbiAgICAgIGNvbmZpZyA9XG4gICAgICAgIG5zOiAnbnMnXG4gICAgICAgIG5hbWU6ICduYW1lJ1xuICAgICAgICB0eXBlOiAndHlwZSdcbiAgICAgICAgaWQ6ICdpZCdcbiAgICAgICAgZnJvbTogRXZlbnRGaWx0ZXJzLlNFTEZfSklEXG4gICAgICAgIG9wdGlvbnM6IHt9XG5cbiAgICAgIGV2ZW50SGFuZGxlci5jb25maWcgPSBjb25maWdcbiAgICAgIGV2ZW50SGFuZGxlci5nZXRTaWduYXR1cmVBcmdzKHNlbGZKSUQpXG4gICAgICAgIC5zaG91bGQuZXFsIFsnbnMnLCAnbmFtZScsICd0eXBlJywgJ2lkJywgc2VsZkpJRCwge31dXG5cbiAgZGVzY3JpYmUgJyNpbnZva2VDYWxsYmFja3MoKScsIC0+XG5cbiAgICBjYWxsYmFjazEgPSBudWxsXG4gICAgY2FsbGJhY2syID0gbnVsbFxuICAgIHN0YW56YSA9IG51bGxcblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIGV2ZW50SGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXIoKVxuICAgICAgZXZlbnRIYW5kbGVyLmNvbmZpZy5maWx0ZXJzID0gW11cbiAgICAgIGV2ZW50SGFuZGxlci5zZWxmSklEID0gJ3NlbGZKSUQnXG4gICAgICBjYWxsYmFjazEgPSBzaW5vbi5zdHViKClcbiAgICAgIGNhbGxiYWNrMiA9IHNpbm9uLnN0dWIoKVxuICAgICAgZXZlbnRIYW5kbGVyLl9jYWxsYmFja3MgPVxuICAgICAgICBhYmNkOiBjYWxsYmFjazFcbiAgICAgICAgZWZnaDogY2FsbGJhY2syXG4gICAgICBzdGFuemEgPSBjb252ZXJ0WE1MVG9TdGFuemEgJzxzb21ldGhpbmc+PHggeG1sbnM9XCJodHRwOi8vamFiYmVyLm9yZy9cIj48L3g+PC9zb21ldGhpbmc+J1xuICAgICAgc2lub24uc3R1YihFdmVudEZpbHRlcnMsICdydW4nKS5yZXR1cm5zIHRydWVcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgRXZlbnRGaWx0ZXJzLnJ1bi5yZXN0b3JlKClcbiAgICAgIGNhbGxiYWNrMSA9IG51bGxcbiAgICAgIGNhbGxiYWNrMiA9IG51bGxcbiAgICAgIHN0YW56YSA9IG51bGxcblxuICAgIGl0ICdzaG91bGQgcnVuIGV2ZW50IGZpbHRlcnMnLCAtPlxuICAgICAgZXZlbnRIYW5kbGVyLmludm9rZUNhbGxiYWNrcyBzdGFuemFcbiAgICAgIEV2ZW50RmlsdGVycy5ydW4uc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aEV4YWN0bHkgc3RhbnphLCBldmVudEhhbmRsZXIuY29uZmlnLmZpbHRlcnMsIGV2ZW50SGFuZGxlci5zZWxmSklEXG5cbiAgICBpdCAnc2hvdWxkIGV4aXQgZWFybHkgaWYgaXQgZG9lcyBub3QgcGFzcyB0aGUgZmlsdGVycycsIC0+XG4gICAgICBFdmVudEZpbHRlcnMucnVuLnJldHVybnMgZmFsc2VcbiAgICAgIGV2ZW50SGFuZGxlci5pbnZva2VDYWxsYmFja3Moc3RhbnphKS5zaG91bGQuZXF1YWwgZXZlbnRIYW5kbGVyXG4gICAgICBjYWxsYmFjazEuc2hvdWxkLm5vdC5oYXZlLmJlZW4uY2FsbGVkXG4gICAgICBjYWxsYmFjazIuc2hvdWxkLm5vdC5oYXZlLmJlZW4uY2FsbGVkXG5cbiAgICBpdCAnc2hvdWxkIGludm9rZSBhbGwgY2FsbGJhY2tzJywgLT5cbiAgICAgIGV2ZW50SGFuZGxlci5pbnZva2VDYWxsYmFja3Mgc3RhbnphXG4gICAgICBjYWxsYmFjazEuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRPbmNlLmNhbGxlZFdpdGhFeGFjdGx5IHNpbm9uLm1hdGNoLm9iamVjdFxuICAgICAgICAjIHhtbDogc2lub24ubWF0Y2gub2JqZWN0XG4gICAgICAgICMganNvbjogc2lub24ubWF0Y2gub2JqZWN0XG4gICAgICAgICMgYWRhcHRlcnM6IHNpbm9uLm1hdGNoLm9iamVjdFxuICAgICAgY2FsbGJhY2syLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZS5jYWxsZWRXaXRoRXhhY3RseSBzaW5vbi5tYXRjaC5vYmplY3RcblxuICAgIGl0ICdzaG91bGQgY2F0Y2ggYW55IGNhbGxiYWNrIGVycm9ycycsIC0+XG4gICAgICBjYWxsYmFjazEudGhyb3dzIG5ldyBFcnJvciBcImNhbGxiYWNrIGVycm9yMVwiXG4gICAgICBleHBlY3QoLT4gZXZlbnRIYW5kbGVyLmludm9rZUNhbGxiYWNrcyBzdGFuemEpLnRvLm5vdC50aHJvdy5FcnJvclxuXG4gICAgaXQgJ3Nob3VsZCBiZSBhIGZsdWVudCBtZXRob2QgcmV0dXJuaW5nIHRoaXMnLCAtPlxuICAgICAgZXZlbnRIYW5kbGVyLmludm9rZUNhbGxiYWNrcyhzdGFuemEpLnNob3VsZC5lcXVhbCBldmVudEhhbmRsZXJcbiIsIntzaW5vbiwgYXNzZXJ0LCBleHBlY3QsIF99ID0gcmVxdWlyZSAnc3BlYy9zcGVjX2hlbHBlcidcblN0cm9waGUgPSByZXF1aXJlICdzdHJvcGhlJ1xuRXZlbnRNYW5hZ2VyID0gcmVxdWlyZSAnZXZlbnRzL2V2ZW50X21hbmFnZXInXG5FdmVudEhhbmRsZXIgPSByZXF1aXJlICdldmVudHMvZXZlbnRfaGFuZGxlcidcblV0aWxzID0gcmVxdWlyZSAndXRpbC91dGlscydcblxuZGVzY3JpYmUgJ0V2ZW50TWFuYWdlcicsIC0+XG5cbiAgY2xhc3MgRXZlbnRIYW5kbGVyU3R1YlxuICAgIGdldFN0cm9waGVIYW5kbGVyOiBzaW5vbi5zdHViKCkucmV0dXJucyBuZXcgU3Ryb3BoZS5IYW5kbGVyKClcbiAgICBzZXRTdHJvcGhlSGFuZGxlcjogc2lub24uc3R1YigpXG4gICAgYWRkQ2FsbGJhY2s6IHNpbm9uLnN0dWIoKVxuICAgIHJlbW92ZUNhbGxiYWNrOiBzaW5vbi5zdHViKClcbiAgICBoYXNDYWxsYmFja3M6IHNpbm9uLnN0dWIoKVxuICAgIHJlc2V0Q2FsbGJhY2tzOiBzaW5vbi5zdHViKClcbiAgICBnZXRTaWduYXR1cmVBcmdzOiBzaW5vbi5zdHViKClcbiAgICBpbnZva2VDYWxsYmFja3M6IHNpbm9uLnN0dWIoKVxuICAgIHJlc2V0U3Ryb3BoZUhhbmRsZXI6IHNpbm9uLnN0dWIoKVxuXG4gIGV2ZW50TWFuYWdlciA9IG51bGxcbiAgYWRkSGFuZGxlclN0dWIgPSBudWxsXG4gIGRlbGV0ZUhhbmRsZXJTdHViID0gbnVsbFxuICBldmVudHNDb25maWcgPSBudWxsXG4gIG9wdGlvbnMgPSBudWxsXG4gIHNlbGZKSUQgPSBudWxsXG4gIGxhenlTdHViID0gbnVsbFxuXG4gIGJlZm9yZSAtPlxuICAgIHNpbm9uLnN0dWIgVXRpbHMsICdjb25kaXRpb25hbCdcblxuICBhZnRlciAtPlxuICAgIFV0aWxzLmNvbmRpdGlvbmFsLnJlc3RvcmUoKVxuXG4gIGJlZm9yZUVhY2ggLT5cbiAgICBsYXp5U3R1YiA9IHNpbm9uLnN0dWIoKVxuICAgIFV0aWxzLmNvbmRpdGlvbmFsLnJldHVybnMgbGF6eVN0dWJcbiAgICBzZWxmSklEID0gXCJzZWxmamlkXCJcbiAgICBhZGRIYW5kbGVyU3R1YiA9IHNpbm9uLnN0dWIoKVxuICAgIGRlbGV0ZUhhbmRsZXJTdHViID0gc2lub24uc3R1YigpXG4gICAgZXZlbnRzQ29uZmlnID1cbiAgICAgICdwYXRoLnRvLmV2ZW50MSc6IHt9XG4gICAgICAncGF0aC50by5ldmVudDInOiB7fVxuICAgIG9wdGlvbnMgPVxuICAgICAgYWRkSGFuZGxlcjogYWRkSGFuZGxlclN0dWJcbiAgICAgIGRlbGV0ZUhhbmRsZXI6IGRlbGV0ZUhhbmRsZXJTdHViXG4gICAgICBjb25maWc6IGV2ZW50c0NvbmZpZ1xuICAgICAgaGFuZGxlckNsYXNzOiBFdmVudEhhbmRsZXJTdHViXG5cbiAgYWZ0ZXJFYWNoIC0+XG4gICAgbGF6eVN0dWIucmVzZXQoKVxuICAgIFV0aWxzLmNvbmRpdGlvbmFsLnJlc2V0KClcbiAgICBldmVudE1hbmFnZXIgPSBudWxsXG4gICAgYWRkSGFuZGxlclN0dWIucmVzZXQoKVxuICAgIGRlbGV0ZUhhbmRsZXJTdHViLnJlc2V0KClcbiAgICBldmVudHNDb25maWcgPSBudWxsXG4gICAgb3B0aW9ucyA9IG51bGxcbiAgICBzZWxmSklEID0gbnVsbFxuICAgIEV2ZW50TWFuYWdlci5kZXN0cm95KClcblxuICBkZXNjcmliZSAnY3JlYXRpbmcgYSBzaW5nbGV0b24gaW5zdGFuY2UnLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCBidWlsZCBhbiBldmVudHMgZGljdGlvbmFyeScsIC0+XG4gICAgICBldmVudE1hbmFnZXIgPSBFdmVudE1hbmFnZXIuZ2V0IG9wdGlvbnNcbiAgICAgIGV2ZW50TWFuYWdlci5zaG91bGQuaGF2ZS5hLnByb3BlcnR5KCdfZXZlbnRzRGljdGlvbmFyeScpXG4gICAgICBrZXlzID0gXy5rZXlzIGV2ZW50TWFuYWdlci5fZXZlbnRzRGljdGlvbmFyeVxuICAgICAgdmFsdWVzID0gXy52YWx1ZXMgZXZlbnRNYW5hZ2VyLl9ldmVudHNEaWN0aW9uYXJ5XG4gICAgICBcbiAgICAgICMga2V5cyBzaG91bGQgbWF0Y2ggdGhlIGV2ZW50c0NvbmZpZyBvYmplY3RcbiAgICAgIGtleXMuc2hvdWxkLmVxbCBfLmtleXMgZXZlbnRzQ29uZmlnXG4gICAgICAjIHZhbHVlcyBzaG91bGQgYWxsIGJlIGluc3RhbmNlcyBvZiBFdmVudEhhbmRsZXJcbiAgICAgIGZvciB2YWx1ZSBpbiB2YWx1ZXNcbiAgICAgICAgdmFsdWUuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgRXZlbnRIYW5kbGVyU3R1YlxuXG4gIGRlc2NyaWJlICcjdG9nZ2xlQ29ubmVjdGlvbigpJywgLT5cblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIGV2ZW50TWFuYWdlciA9IEV2ZW50TWFuYWdlci5nZXQgb3B0aW9uc1xuXG4gICAgaXQgJ3Nob3VsZCBzdG9yZSB0aGUgc2VsZkpJRCB3aGVuIGNvbm5lY3RlZCcsIC0+XG4gICAgICBldmVudE1hbmFnZXIudG9nZ2xlQ29ubmVjdGlvbiB0cnVlLCBzZWxmSklEXG4gICAgICBldmVudE1hbmFnZXIuX3NlbGZKSUQuc2hvdWxkLmVxdWFsIHNlbGZKSURcbiAgICAgIFxuICAgIGl0ICdzaG91bGQgYWRkIHN0cm9waGUgaGFuZGxlcnMgbGF6aWx5LCB3aGVuIGNvbm5lY3RlZCcsIC0+XG4gICAgICBVdGlscy5jb25kaXRpb25hbC5yZXR1cm5zIGxhenlTdHViXG4gICAgICBldmVudE1hbmFnZXIudG9nZ2xlQ29ubmVjdGlvbiB0cnVlLCBzZWxmSklEXG4gICAgICBsYXp5U3R1Yi5zaG91bGQuaGF2ZS5iZWVuLmNhbGxlZFR3aWNlXG4gICAgICAgIC5jYWxsZWRXaXRoIHNpbm9uLm1hdGNoLmluc3RhbmNlT2YoRXZlbnRIYW5kbGVyU3R1YiksIHNlbGZKSURcblxuICAgIGl0ICdzaG91bGQgY2FsbCAjcmVtb3ZlU3Ryb3BoZUhhbmRsZXJzIHdoZW4gZGlzY29ubmVjdGVkJywgLT5cbiAgICAgIGV2ZW50TWFuYWdlci50b2dnbGVDb25uZWN0aW9uIGZhbHNlXG4gICAgICBkZWxldGVIYW5kbGVyU3R1Yi5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRUd2ljZVxuXG4gIGRlc2NyaWJlICcjbGlzdGVuVG8oKScsIC0+XG5cbiAgICBwYXRoMSA9IG51bGxcbiAgICBwYXRoMiA9IG51bGxcbiAgICBjYWxsYmFjazEgPSBudWxsXG4gICAgY2FsbGJhY2syID0gbnVsbFxuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgZXZlbnRNYW5hZ2VyID0gRXZlbnRNYW5hZ2VyLmdldCBvcHRpb25zXG4gICAgICBldmVudE1hbmFnZXIuX3NlbGZKSUQgPSAnc2VsZkpJRCdcbiAgICAgIHBhdGgxID0gJ3BhdGgudG8uZXZlbnQxJ1xuICAgICAgcGF0aDIgPSAncGF0aC50by5ldmVudDInXG4gICAgICBjYWxsYmFjazEgPSBzaW5vbi5zdHViKClcbiAgICAgIGNhbGxiYWNrMiA9IHNpbm9uLnN0dWIoKVxuICAgICAgXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICBwYXRoMSA9IG51bGxcbiAgICAgIHBhdGgxID0gbnVsbFxuICAgICAgY2FsbGJhY2sxID0gbnVsbFxuICAgICAgY2FsbGJhY2syID0gbnVsbFxuXG4gICAgaXQgJ3Nob3VsZCBhZGQgYSBjYWxsYmFjayBmb3IgYSBzcGVjaWZpZWQgZXZlbnQgcGF0aCcsIC0+XG4gICAgICBldmVudE1hbmFnZXIubGlzdGVuVG8gcGF0aDEsIGNhbGxiYWNrMVxuICAgICAgZXZlbnRNYW5hZ2VyLl9ldmVudHNEaWN0aW9uYXJ5W3BhdGgxXS5hZGRDYWxsYmFjay5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoRXhhY3RseSBjYWxsYmFjazEsIGZhbHNlXG4gICAgICAgICBcbiAgICBpdCAnc2hvdWxkIHJldHVybiBhbiBpZCBzdHJpbmcnLCAtPlxuICAgICAgY2FsbGJhY2sgPSBzaW5vbi5zdHViKClcbiAgICAgIHBhdGgxSGFuZGxlciA9IGV2ZW50TWFuYWdlci5fZXZlbnRzRGljdGlvbmFyeVtwYXRoMV1cbiAgICAgIHBhdGgxSGFuZGxlci5nZXRTdHJvcGhlSGFuZGxlci5yZXR1cm5zIG51bGxcbiAgICAgIHBhdGgxSGFuZGxlci5hZGRDYWxsYmFjay5yZXR1cm5zIFwiYWJjZFwiXG4gICAgICBjYWxsYmFja0lkID0gZXZlbnRNYW5hZ2VyLmxpc3RlblRvIHBhdGgxLCBjYWxsYmFjazFcbiAgICAgIGNhbGxiYWNrMS5zaG91bGQuYmUuYS5zdHJpbmdcbiAgICAgIFxuICAgIGl0ICdzaG91bGQgYWRkIGEgU3Ryb3BoZSBIYW5kbGVyIGZvciBhbiBldmVudCBwYXRoIHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBsaXN0ZW5kIHRvJywgLT5cbiAgICAgIGNhbGxiYWNrID0gc2lub24uc3R1YigpXG4gICAgICBwYXRoMUhhbmRsZXIgPSBldmVudE1hbmFnZXIuX2V2ZW50c0RpY3Rpb25hcnlbcGF0aDFdXG4gICAgICBwYXRoMUhhbmRsZXIuZ2V0U3Ryb3BoZUhhbmRsZXIucmV0dXJucyBudWxsXG4gICAgICBwYXRoMUhhbmRsZXIuYWRkQ2FsbGJhY2sucmV0dXJucyBcImFiY2RcIlxuICAgICAgZXZlbnRNYW5hZ2VyLmxpc3RlblRvIHBhdGgxLCBjYWxsYmFjazFcbiAgICAgIGxhenlTdHViLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGggcGF0aDFIYW5kbGVyLCBldmVudE1hbmFnZXIuX3NlbGZKSURcbiAgICAgIFxuICAgIGl0ICdzaG91bGQgbm90IGluc3RhbnRpYXRlIGEgU3Ryb3BoZSBIYW5kbGVyIGZvciBhbiBldmVudCBwYXRoIHRoYXQgYWxyZWFkeSBoYXMgb25lJywgLT5cbiAgICAgIGNhbGxiYWNrID0gc2lub24uc3R1YigpXG4gICAgICBwYXRoMUhhbmRsZXIgPSBldmVudE1hbmFnZXIuX2V2ZW50c0RpY3Rpb25hcnlbcGF0aDFdXG4gICAgICBwYXRoMUhhbmRsZXIuZ2V0U3Ryb3BoZUhhbmRsZXIucmV0dXJucyBuZXcgU3Ryb3BoZS5IYW5kbGVyKClcbiAgICAgIHBhdGgxSGFuZGxlci5hZGRDYWxsYmFjay5yZXR1cm5zIFwiYWJjZFwiXG4gICAgICBldmVudE1hbmFnZXIubGlzdGVuVG8gcGF0aDEsIGNhbGxiYWNrMVxuICAgICAgbGF6eVN0dWIuc2hvdWxkLm5vdC5oYXZlLmJlZW4uY2FsbGVkXG5cbiAgICBpdCAnc2hvdWxkIHRocm93IGFuIGV4Y2VwdGlvbiB3aGVuIHRyeWluZyB0byBhZGQgYSBjYWxsYmFjayBmb3IgYW4gdW5zdXBwb3J0ZWQgZXZlbnQnLCAtPlxuICAgICAgZXhwZWN0KC0+IGxpc3RlblRvICdwYXRoLmRvZXMubm90LmV4aXN0JywgY2FsbGJhY2sxKS50by50aHJvdyBFcnJvclxuICAgICAgXG4gICAgICBwYXRoQ2FsbGJhY2tzID1cbiAgICAgICAgJ3BhdGguZG9lcy5ub3QuZXhpc3QnOiBjYWxsYmFjazFcbiAgICAgICAgJ2Fub3RoZXIucGF0aC5kb2VzLm5vdC5leGlzdCc6IGNhbGxiYWNrMlxuICAgICAgZXhwZWN0KC0+IGxpc3RlblRvIHBhdGhDYWxsYmFja3MpLnRvLnRocm93IEVycm9yXG5cbiAgZGVzY3JpYmUgJyNsaXN0ZW5Ub09uY2UoKScsIC0+XG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBldmVudE1hbmFnZXIgPSBFdmVudE1hbmFnZXIuZ2V0IG9wdGlvbnNcbiAgICAgIHNpbm9uLnN0dWIgZXZlbnRNYW5hZ2VyLCAnbGlzdGVuVG8nXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIGV2ZW50TWFuYWdlci5saXN0ZW5Uby5yZXN0b3JlKClcbiAgICAgIFxuICAgIGl0ICdzaG91bGQgY2FsbCAjbGlzdGVuVG8oKSB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cyBhbmQgYW4gYWRkaXRpb25hbCB0cnVlIGZsYWcnLCAtPlxuICAgICAgcGF0aCA9IFwic29tZS5ldmVudC5wYXRoXCJcbiAgICAgIGNhbGxiYWNrID0gc2lub24uc3R1YigpXG5cbiAgICAgIGV2ZW50TWFuYWdlci5saXN0ZW5Ub09uY2UgcGF0aCwgY2FsbGJhY2tcblxuICAgICAgZXZlbnRNYW5hZ2VyLmxpc3RlblRvLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGhFeGFjdGx5IHBhdGgsIGNhbGxiYWNrLCB0cnVlXG5cbiAgZGVzY3JpYmUgJyNzdG9wTGlzdGVuaW5nKCknLCAtPlxuXG4gICAgcGF0aDEgPSBudWxsXG4gICAgcGF0aDIgPSBudWxsXG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBldmVudE1hbmFnZXIgPSBFdmVudE1hbmFnZXIuZ2V0IG9wdGlvbnNcbiAgICAgIHBhdGgxID0gJ3BhdGgudG8uZXZlbnQxJ1xuICAgICAgcGF0aDIgPSAncGF0aC50by5ldmVudDInXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIHBhdGgxID0gbnVsbFxuICAgICAgcGF0aDIgPSBudWxsXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0aGUgaWQgb2YgdGhlIGNhbGxiYWNrIGJlaW5nIGRlbGV0ZWQnLCAtPlxuICAgICAgY2FsbGJhY2tJZCA9IFwiYWJjZFwiXG4gICAgICBwYXRoMUhhbmRsZXIgPSBldmVudE1hbmFnZXIuX2V2ZW50c0RpY3Rpb25hcnlbcGF0aDFdXG4gICAgICBwYXRoMUhhbmRsZXIucmVtb3ZlQ2FsbGJhY2sud2l0aEFyZ3MoY2FsbGJhY2tJZCkucmV0dXJucyAnYWJjZCdcbiAgICAgIFxuICAgICAgcmVzdWx0ID0gZXZlbnRNYW5hZ2VyLnN0b3BMaXN0ZW5pbmcgY2FsbGJhY2tJZFxuXG4gICAgICByZXN1bHQuc2hvdWxkLmVxdWFsICdhYmNkJ1xuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdW5kZWZpbmVkIGlmIG5vIGNhbGxiYWNrIGV4aXN0cyB3aXRoIHRoZSBzcGVjaWZpZWQgaWQnLCAtPlxuICAgICAgY2FsbGJhY2tJZCA9IFwiYWJjZFwiXG4gICAgICBwYXRoMUhhbmRsZXIgPSBldmVudE1hbmFnZXIuX2V2ZW50c0RpY3Rpb25hcnlbcGF0aDFdXG4gICAgICBwYXRoMUhhbmRsZXIucmVtb3ZlQ2FsbGJhY2sud2l0aEFyZ3MoY2FsbGJhY2tJZCkucmV0dXJucyBudWxsXG4gICAgICBcbiAgICAgIHJlc3VsdCA9IGV2ZW50TWFuYWdlci5zdG9wTGlzdGVuaW5nIGNhbGxiYWNrSWRcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG8ubm90LmV4aXN0XG5cbiAgICBpdCAnc2hvdWxkIGNhbGwgI3JlbW92ZUNhbGxiYWNrKCkgb24gZWFjaCBFdmVudEhhbmRsZXIgaW5zdGFuY2UnLCAtPlxuICAgICAgY2FsbGJhY2tJZCA9IFwiYWJjZFwiXG4gICAgICBldmVudE1hbmFnZXIuX2V2ZW50c0RpY3Rpb25hcnkgPVxuICAgICAgICAncGF0aDEnOiBwYXRoMUhhbmRsZXIgPSByZW1vdmVDYWxsYmFjazogc2lub24uc3R1YigpXG4gICAgICAgICdwYXRoMic6IHBhdGgySGFuZGxlciA9IHJlbW92ZUNhbGxiYWNrOiBzaW5vbi5zdHViKClcblxuICAgICAgZXZlbnRNYW5hZ2VyLnN0b3BMaXN0ZW5pbmcgY2FsbGJhY2tJZFxuXG4gICAgICBwYXRoMUhhbmRsZXIucmVtb3ZlQ2FsbGJhY2suc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aEV4YWN0bHkgY2FsbGJhY2tJZFxuICAgICAgcGF0aDJIYW5kbGVyLnJlbW92ZUNhbGxiYWNrLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGhFeGFjdGx5IGNhbGxiYWNrSWRcbiIsIntfLCBhc3NlcnQsIGV4cGVjdCwgc2lub259ID0gcmVxdWlyZSAnc3BlYy9zcGVjX2hlbHBlcidcbkV2ZW50cyA9IHJlcXVpcmUgJ2V2ZW50cy9ldmVudHMnXG5FdmVudEZpbHRlcnMgPSByZXF1aXJlICdldmVudHMvZXZlbnRfZmlsdGVycydcblxuZGVzY3JpYmUgJ0V2ZW50cycsIC0+XG5cbiAgZGVzY3JpYmUgJy5maWx0ZXJCeVJlY2lwaWVudCgpJywgLT5cblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIHNpbm9uLnN0dWIgRXZlbnRGaWx0ZXJzLCAnZmlsdGVyQnlSZWNpcGllbnQnXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIEV2ZW50RmlsdGVycy5maWx0ZXJCeVJlY2lwaWVudC5yZXN0b3JlKClcbiAgICAgXG4gICAgaXQgJ3Nob3VsZCBjYWxsICNmaWx0ZXJCeVJlY2lwaWVudCgpIG9uIEV2ZW50RmlsdGVycyB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cycsIC0+XG4gICAgICBFdmVudHMuZmlsdGVyQnlSZWNpcGllbnQgKC0+KSwgXCJqaWRcIlxuICAgICAgRXZlbnRGaWx0ZXJzLmZpbHRlckJ5UmVjaXBpZW50LnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGggc2lub24ubWF0Y2guZnVuYywgXCJqaWRcIlxuICAgICAgXG4gIGRlc2NyaWJlICcuZmlsdGVyQnlTZW5kZXIoKScsIC0+XG5cbiAgICBiZWZvcmUgLT5cbiAgICAgIHNpbm9uLnN0dWIgRXZlbnRGaWx0ZXJzLCAnZmlsdGVyQnlTZW5kZXInXG4gICBcbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIEV2ZW50RmlsdGVycy5maWx0ZXJCeVNlbmRlci5yZXN0b3JlKClcbiAgICAgIFxuICAgIGl0ICdzaG91bGQgY2FsbCAjZmlsdGVyQnlTZW5kZXIoKSBvbiBFdmVudEZpbHRlcnMgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMnLCAtPlxuICAgICAgRXZlbnRzLmZpbHRlckJ5U2VuZGVyICgtPiksIFwiamlkXCJcbiAgICAgIEV2ZW50RmlsdGVycy5maWx0ZXJCeVNlbmRlci5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoIHNpbm9uLm1hdGNoLmZ1bmMsIFwiamlkXCJcbiIsIntfLCBmaXh0dXJlcywgWDJKUywgUSwgYXNzZXJ0LCBleHBlY3QsIHNpbm9ufSA9IHJlcXVpcmUgJ3NwZWMvc3BlY19oZWxwZXInXG5cbmRlc2NyaWJlICdmcmFtZXdvcmsnLCAtPlxuXG4gIHgyanMgPSBudWxsXG4gIFxuICBiZWZvcmUgLT5cbiAgICB4MmpzID0gbmV3IFgySlMoKVxuXG4gIGFmdGVyIC0+XG4gICAgeDJqcyA9IG51bGxcblxuICBkZXNjcmliZSAnbG9hZGluZyBmaXh0dXJlcycsIC0+XG5cbiAgICBpdCAnc2hvdWxkIGxvYWQgYSBmaWxlJywgLT5cbiAgICAgIGZpeHR1cmVzLmxvYWQgJ2ZpeHR1cmUxLmh0bWwnXG4gICAgICBib2R5ID0gZml4dHVyZXMuYm9keSgpXG4gICAgICBqc29uID0geDJqcy54bWwyanNvbiB4MmpzLnBhcnNlWG1sU3RyaW5nIGZpeHR1cmVzLmJvZHkoKVxuICAgICAganNvbi50ZXN0aW5nLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIFwiVGhpcyBpcyBzb21lIGNvbnRlbnRcIlxuICAgICAgICAgICAgXG4gICAgaXQgJ3Nob3VsZCBub3QgYWNjZXNzIGEgcHJldmlvdXNseSBsb2FkZWQgZml4dHVyZScsIC0+XG4gICAgICAjIGluIHNwZWNfcnVubmVyLCBmaXh0dXJlcy5jbGVhblVwKCkgaXMgY2FsbGVkLlxuICAgICAgZXhwZWN0KGZpeHR1cmVzLmJvZHkoKSkudG8ubm90LmV4aXN0XG4gICAgICBcbiAgZGVzY3JpYmUgJ3VuaXQgdGVzdCBhc3NlcnRpb25zJywgLT5cbiAgICBcbiAgICBpdCAnc2hvdWxkIGFzc2VydCcsIC0+XG4gICAgICBhc3NlcnQgdHJ1ZVxuXG4gICAgaXQgJ3Nob3VsZCBleHBlY3QnLCAtPlxuICAgICAgZXhwZWN0KG51bGwpLnRvLmJlLm51bGxcbiAgXG4gIGRlc2NyaWJlICd1bmRlcnNjb3JlJywgLT5cbiAgICAgIFxuICAgIGl0ICdzaG91bGQgdXNlIHVuZGVyc2NvcmUnLCAtPlxuICAgICAgXy5pc0VtcHR5KHt9KS5zaG91bGQuYmUudHJ1ZVxuXG4gIHhkZXNjcmliZSAncHJvbWlzZXMnLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCBjYWxsIGEgZG9uZSBoYW5kbGVyIGFzeW5jaHJvbm91c2x5JywgKGRvbmUpIC0+XG4gICAgICBoYW5kbGVyID0gc2lub24uc3B5IChkYXRhKSAtPlxuICAgICAgICBoYW5kbGVyLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAgIC5jYWxsZWRXaXRoIFwiZGF0YVwiXG4gICAgICAgIGRvbmUoKVxuICAgICAgZGZkID0gUS5kZWZlcigpXG4gICAgICBkZmQucHJvbWlzZS50aGVuIGhhbmRsZXJcbiAgICAgIGRmZC5yZXNvbHZlIFwiZGF0YVwiXG5cbiAgICBpdCAnc2hvdWxkIGltbWVkaWF0ZWx5IHJlc29sdmUgYSBkZWZlcnJlZCBhbmQgYXNzZXJ0IHVzaW5nIGNoYWktYXMtcHJvbWlzZWQnLCAoZG9uZSkgLT5cbiAgICAgIGRmZCA9IFEuZGVmZXIoKVxuICAgICAgZGZkLnJlc29sdmUgXCJkYXRhXCJcbiAgICAgIGRmZC5wcm9taXNlLnNob3VsZC5ldmVudHVhbGx5LmVxdWFsKFwiZGF0YVwiKS5ub3RpZnkgZG9uZVxuXG4gICAgaXQgJ3Nob3VsZCBldmVudHVhbGx5IHJlc29sdmUgYSBkZWZlcnJlZCBhbmQgYXNzZXJ0IHVzaW5nIGNoYWktYXMtcHJvbWlzZWQnLCAoZG9uZSkgLT5cbiAgICAgIGRmZCA9IFEuZGVmZXIoKVxuICAgICAgZGZkLnByb21pc2Uuc2hvdWxkLmV2ZW50dWFsbHkuZXF1YWwoXCJkYXRhXCIpLm5vdGlmeSBkb25lXG4gICAgICBkZmQucmVzb2x2ZSBcImRhdGFcIlxuXG4gIGRlc2NyaWJlICdzaW5vbiB1c2VGYWtlVGltZXJzJywgLT5cblxuICAgIGNsb2NrID0gbnVsbFxuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgY2xvY2sgPSBzaW5vbi51c2VGYWtlVGltZXJzKClcblxuICAgIGFmdGVyRWFjaCAtPlxuICAgICAgY2xvY2sucmVzdG9yZSgpXG5cbiAgICBpdCAnc2hvdWxkIHdhaXQgZm9yIGEgZGVsYXknLCAtPlxuICAgICAgYSA9IDFcbiAgICAgIHRpbWUxID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgICAgXG4gICAgICBfLmRlbGF5IC0+XG4gICAgICAgIGEgPSAyXG4gICAgICAsIDEwMDBcblxuICAgICAgY2xvY2sudGljayAyMDAwXG4gICAgICB0aW1lMiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICBhLnNob3VsZC5lcXVhbCAyXG4gICAgICAodGltZTIgLSB0aW1lMSkuc2hvdWxkLmVxdWFsIDIwMDBcblxuICAgIGl0ICd0cnVlJywgLT5cbiAgICAgIGFzc2VydCB0cnVlXG5cbiAgICBpdCAnc2hvdWxkIHdhaXQgZm9yIHNldFRpbWVvdXQnLCAtPlxuICAgICAgYSA9IDFcbiAgICAgIHRpbWUxID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgICAgXG4gICAgICBzZXRUaW1lb3V0IC0+XG4gICAgICAgIGEgPSAyXG4gICAgICAsIDEwMDBcblxuICAgICAgY2xvY2sudGljayAyMDAwXG4gICAgICB0aW1lMiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICBhLnNob3VsZC5lcXVhbCAyXG4gICAgICAodGltZTIgLSB0aW1lMSkuc2hvdWxkLmVxdWFsIDIwMDBcbiIsImNoYWkgPSByZXF1aXJlICdjaGFpJ1xuXG5tb2R1bGUuZXhwb3J0cyA9XG4gIGZpeHR1cmVzOiByZXF1aXJlICdqcy1maXh0dXJlcydcbiAgWDJKUzogcmVxdWlyZSAneG1sLWpzb24tcGFyc2VyJyAjIGh0dHBzOi8vbGlicmFyaWVzLmlvL25wbS94bWwtanNvbi1wYXJzZXJcbiAgXzogcmVxdWlyZSAndW5kZXJzY29yZSdcbiAgUTogcmVxdWlyZSAncSdcbiAgY2hhaTogY2hhaVxuICBzaW5vbjogcmVxdWlyZSAnc2lub24nXG4gIHNpbm9uQ2hhaTogcmVxdWlyZSAnc2lub24tY2hhaSdcbiAgY2hhaUFzUHJvbWlzZWQ6IHJlcXVpcmUgJ2NoYWktYXMtcHJvbWlzZWQnXG4gIGFzc2VydDogY2hhaS5hc3NlcnRcbiAgZXhwZWN0OiBjaGFpLmV4cGVjdFxuICAjIFRyaW0gYWxsIHdoaXRlc3BhY2UgYmV0d2VlbiBYTUwgbm9kZXNcbiAgdHJpbUZpeHR1cmU6IChzdHIpIC0+XG4gICAgc3RyLnRyaW0oKS5yZXBsYWNlIC8oPihcXHMrfFxcbit8XFxyK3wgKTwpL2dtLCBcIj48XCJcbiAgIyBDb252ZXJ0IGFuIFhNTCBzdHJpbmcgdG8gYSBkb2N1bWVudCBTdGFuemEgb2JqZWN0XG4gIGNvbnZlcnRYTUxUb1N0YW56YTogKHhtbCkgLT5cbiAgICBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKClcbiAgICBkb20gPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nIHhtbCwgXCJ0ZXh0L3htbFwiXG4gICAgZG9tLmZpcnN0Q2hpbGRcbiIsIntYMkpTLCBzaW5vbiwgY2hhaSwgZml4dHVyZXMsIHNpbm9uQ2hhaSwgY2hhaUFzUHJvbWlzZWR9ID0gcmVxdWlyZSAnc3BlYy9zcGVjX2hlbHBlcidcblEgPSByZXF1aXJlICdxJ1xuXG4jIE5lZWQgdG8gaW1wb3J0IGVhY2ggaW5kaXZpZHVhbCB0ZXN0IHN1aXRlIGhlcmUuXG5yZXF1aXJlICdzcGVjL2ZyYW1ld29ya19zcGVjJ1xucmVxdWlyZSAnc3BlYy9zdWl0ZXMvdXRpbF9zdWl0ZV9zcGVjJ1xucmVxdWlyZSAnc3BlYy9zdWl0ZXMvY29ubmVjdGlvbl9zdWl0ZV9zcGVjJ1xucmVxdWlyZSAnc3BlYy9zdWl0ZXMvZXZlbnRzX3N1aXRlX3NwZWMnXG5yZXF1aXJlICdzcGVjL2FkYXB0ZXJzL2FkYXB0ZXJzX3NwZWMnXG5cbmJlZm9yZSAtPlxuICBmaXh0dXJlcy5wYXRoID0gJ2ZpeHR1cmVzJ1xuICBjaGFpLnVzZSBzaW5vbkNoYWlcbiAgY2hhaS51c2UgY2hhaUFzUHJvbWlzZWRcbiAgY2hhaS5zaG91bGQoKVxuICBcbiAgIyBQb2x5ZmlsbCwgYmVjYXVzZSBwaGFudG9tanMgZG9lc24ndCBzdXBwb3J0IHRoZSBiaW5kIGZ1bmN0aW9uIGFuZFxuICAjIGNoYWktYXMtcHJvbWlzZWQgcmVxdWlyZXMgaXQuXG4gIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID89ICh0aGlzcCkgLT5cbiAgICBmbiA9IHRoaXNcbiAgICAtPiBmbi5hcHBseSB0aGlzcCwgYXJndW1lbnRzXG4gIFxuYWZ0ZXJFYWNoIC0+XG4gIGZpeHR1cmVzLmNsZWFuVXAoKVxuIiwie2V4cGVjdCwgc2lub24sIF8sIGZpeHR1cmVzLCB0cmltRml4dHVyZX0gPSByZXF1aXJlICdzcGVjL3NwZWNfaGVscGVyJ1xuc3Ryb3BoZUJsb2NrbGlzdCA9IHJlcXVpcmUgJ3N0cm9waGUvc3Ryb3BoZV9ibG9ja2xpc3QnXG5cbmRlc2NyaWJlICdzdHJvcGhlQmxvY2tsaXN0JywgLT5cblxuICBzdGFuemEgPSBudWxsXG4gIGppZHMgPSBudWxsXG5cbiAgYWZ0ZXJFYWNoIC0+XG4gICAgc3RhbnphID0gbnVsbFxuICAgIGppZHMgPSBudWxsXG5cbiAgZGVzY3JpYmUgJyNnZXRCbG9ja2xpc3RTdGFuemEoKScsIC0+XG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHN0YW56YSBmb3IgZ2V0dGluZyB0aGUgYmxvY2tsaXN0JywgLT5cbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdibG9ja2xpc3QvZ2V0LnhtbCdcbiAgICAgIHN0YW56YSA9IHN0cm9waGVCbG9ja2xpc3QuZ2V0QmxvY2tsaXN0U3RhbnphKClcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgZGVzY3JpYmUgJyNnZXRCbG9ja1N0YW56YSgpJywgLT5cblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciBnZXR0aW5nIHRoZSBibG9jayBzdGFuemEnLCAtPlxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ2Jsb2NrbGlzdC9ibG9jay54bWwnXG4gICAgICBqaWRzID0gWydqaWQxJywgJ2ppZDInXVxuICAgICAgc3RhbnphID0gc3Ryb3BoZUJsb2NrbGlzdC5nZXRCbG9ja1N0YW56YSBqaWRzXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gIGRlc2NyaWJlICcjZ2V0VW5ibG9ja1N0YW56YSgpJywgLT5cblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciBnZXR0aW5nIHRoZSB1bmJsb2NrIHN0YW56YScsIC0+XG4gICAgICBmaXh0dXJlID0gZml4dHVyZXMucmVhZCAnYmxvY2tsaXN0L3VuYmxvY2sueG1sJ1xuICAgICAgamlkcyA9IFsnamlkMScsICdqaWQyJ11cbiAgICAgIHN0YW56YSA9IHN0cm9waGVCbG9ja2xpc3QuZ2V0VW5ibG9ja1N0YW56YSBqaWRzXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuIiwie2V4cGVjdCwgc2lub24sIF8sIGZpeHR1cmVzLCBYMkpTLCB0cmltRml4dHVyZX0gPSByZXF1aXJlICdzcGVjL3NwZWNfaGVscGVyJ1xuc3Ryb3BoZURpc2NvID0gcmVxdWlyZSAnc3Ryb3BoZS9zdHJvcGhlX2Rpc2NvJ1xuTVVDTlMgPSByZXF1aXJlICdlbnVtL211Y19ucydcblxuZGVzY3JpYmUgJ3N0cm9waGVEaXNjbycsIC0+XG5cbiAgZG9tYWluID0gJ3JldXRlcnMubmV0J1xuXG4gIGl0ICdjb250c3RydWN0cyBhbiA8aXEvPiBlbGVtZW50JywgLT5cbiAgICBlbGVtZW50ID0gc3Ryb3BoZURpc2NvLmdldERpc2NvU3RhbnphIGRvbWFpblxuICAgIGVsZW1lbnQubm9kZU5hbWUgaXMgJ0lRJ1xuXG4gIGl0ICdhZGRzIGEgPHF1ZXJ5Lz4gY2hpbGQgd2l0aCB0aGUgY29ycmVjdCBucycsIC0+XG4gICAgZWxlbWVudCA9IHN0cm9waGVEaXNjby5nZXREaXNjb1N0YW56YSBkb21haW5cbiAgICBlbGVtZW50LnRyZWUoKS5maXJzdENoaWxkLm5vZGVOYW1lIGlzICdRVUVSWScgYW5kXG4gICAgICBlbGVtZW50LnRyZWUoKS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSAneG1sbnMnIGlzIE1VQ05TLkRJU0NPX0lORk9cblxuICBpdCAnY29uc3RydWN0cyBhIGRpc2NvI2luZm8gZWxlbWVudCB3aXRoIHRoZSBwcm92aWRlZCBkb21haW4nLCAtPlxuICAgIGVsZW1lbnQgPSBzdHJvcGhlRGlzY28uZ2V0RGlzY29TdGFuemEgZG9tYWluXG4gICAgZWxlbWVudC50cmVlKCkuZ2V0QXR0cmlidXRlKCd0bycpIGlzIGRvbWFpblxuXG4gIGl0ICdtYXRjaGVzIGEga25vd24gZml4dHVyZScsIC0+XG4gICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ2Rpc2NvL2luZm8ueG1sJ1xuICAgIHN0YW56YSA9IHN0cm9waGVEaXNjby5nZXREaXNjb1N0YW56YSBkb21haW5cbiAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuIiwie3Npbm9uLCBhc3NlcnQsIHNob3VsZH0gPSByZXF1aXJlICdzcGVjL3NwZWNfaGVscGVyJ1xuU3Ryb3BoZUlPID0gcmVxdWlyZSAnc3Ryb3BoZS9zdHJvcGhlX2lvJ1xuXG5kZXNjcmliZSAnU3Ryb3BoZUlPJywgLT5cblxuICBkZXNjcmliZSAnU3Ryb3BoZSBldmVudCBsaXN0ZW5lcnMnLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCBoYXZlIGFuIGVtcHR5IGFycmF5IG9mIGxpc3RlbmVycyBmb3IgcmF3IGlucHV0IGJ5IGRlZmF1bHQnLCAtPlxuICAgICAgcmVzdWx0ID0gU3Ryb3BoZUlPLnJhd0lucHV0TGlzdGVuZXJzXG5cbiAgICAgIHJlc3VsdC5zaG91bGQuYmUuYW4uYXJyYXlcbiAgICAgIHJlc3VsdC5sZW5ndGguc2hvdWxkLmVxdWFsIDBcblxuICAgIGl0ICdzaG91bGQgaGF2ZSBhbiBlbXB0eSBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIHJhdyBvdXRwdXQgYnkgZGVmYXVsdCcsIC0+XG4gICAgICByZXN1bHQgPSBTdHJvcGhlSU8ucmF3T3V0cHV0TGlzdGVuZXJzXG5cbiAgICAgIHJlc3VsdC5zaG91bGQuYmUuYW4uYXJyYXlcbiAgICAgIHJlc3VsdC5sZW5ndGguc2hvdWxkLmVxdWFsIDBcblxuICAgIGl0ICdzaG91bGQgaGF2ZSBhbiBlbXB0eSBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIFhNTCBpbnB1dCBieSBkZWZhdWx0JywgLT5cbiAgICAgIHJlc3VsdCA9IFN0cm9waGVJTy54bWxJbnB1dExpc3RlbmVyc1xuXG4gICAgICByZXN1bHQuc2hvdWxkLmJlLmFuLmFycmF5XG4gICAgICByZXN1bHQubGVuZ3RoLnNob3VsZC5lcXVhbCAwXG5cbiAgICBpdCAnc2hvdWxkIGhhdmUgYW4gZW1wdHkgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciBYTUwgb3V0cHV0IGJ5IGRlZmF1bHQnLCAtPlxuICAgICAgcmVzdWx0ID0gU3Ryb3BoZUlPLnhtbE91dHB1dExpc3RlbmVyc1xuXG4gICAgICByZXN1bHQuc2hvdWxkLmJlLmFuLmFycmF5XG4gICAgICByZXN1bHQubGVuZ3RoLnNob3VsZC5lcXVhbCAwXG5cbiAgZGVzY3JpYmUgJyNhZGRJT0xpc3RlbmVyKCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCBwdXNoIGEgc2luZ2xlIGNhbGxiYWNrIGZ1bmN0aW9uIG9udG8gYSBsaXN0JywgLT5cbiAgICAgIGNiID0gc2lub24uc3R1YigpXG4gICAgICBsaXN0ID0gW11cblxuICAgICAgU3Ryb3BoZUlPLmFkZElPTGlzdGVuZXIgY2IsIGxpc3RcblxuICAgICAgbGlzdC5sZW5ndGguc2hvdWxkLmVxdWFsIDFcbiAgICAgIGxpc3RbMF0uc2hvdWxkLmVxdWFsIGNiXG5cbiAgICBpdCAnc2hvdWxkIHB1c2ggYW4gYXJyYXkgb2YgY2FsbGJhY2tzIGZ1bmN0aW9uIG9udG8gYSBsaXN0JywgLT5cbiAgICAgIGNiMSA9IHNpbm9uLnN0dWIoKVxuICAgICAgY2IyID0gc2lub24uc3R1YigpXG4gICAgICBsaXN0ID0gW11cblxuICAgICAgU3Ryb3BoZUlPLmFkZElPTGlzdGVuZXIgW2NiMSwgY2IyXSwgbGlzdFxuXG4gICAgICBsaXN0Lmxlbmd0aC5zaG91bGQuZXF1YWwgMlxuICAgICAgbGlzdFswXS5zaG91bGQuZXF1YWwgY2IxXG4gICAgICBsaXN0WzFdLnNob3VsZC5lcXVhbCBjYjJcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgZnVuY3Rpb24gdG8gcmVtb3ZlIGEgc2luZ2xlIGNhbGxiYWNrIGZyb20gdGhlIGxpc3QnLCAtPlxuICAgICAgY2IgPSBzaW5vbi5zdHViKClcbiAgICAgIGxpc3QgPSBbXVxuXG4gICAgICBzdWJqZWN0ID0gU3Ryb3BoZUlPLmFkZElPTGlzdGVuZXIgY2IsIGxpc3RcbiAgICAgIHN1YmplY3QoKVxuXG4gICAgICBsaXN0Lmxlbmd0aC5zaG91bGQuZXF1YWwgMFxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBmdW5jdGlvbiB0byByZW1vdmUgbXVsdGlwbGUgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3QnLCAtPlxuICAgICAgY2IxID0gc2lub24uc3R1YigpXG4gICAgICBjYjIgPSBzaW5vbi5zdHViKClcbiAgICAgIGxpc3QgPSBbXVxuXG4gICAgICBzdWJqZWN0ID0gU3Ryb3BoZUlPLmFkZElPTGlzdGVuZXIgW2NiMSwgY2IyXSwgbGlzdFxuICAgICAgc3ViamVjdCgpXG5cbiAgICAgIGxpc3QubGVuZ3RoLnNob3VsZC5lcXVhbCAwXG5cbiAgZGVzY3JpYmUgJyNjb25uZWN0SU9MaXN0ZW5lcnMoKScsIC0+XG5cbiAgICBpdCAnc2hvdWxkIGNvbm5lY3QgcmF3SW5wdXQgbGlzdGVuZXJzJywgLT5cbiAgICAgIGNhbGxiYWNrID0gc2lub24uc3R1YigpXG4gICAgICBjb25uZWN0aW9uID0ge31cbiAgICAgIG9wdGlvbnMgPVxuICAgICAgICBjb25uZWN0aW9uOiBjb25uZWN0aW9uXG4gICAgICAgIGdldFJhd0lucHV0TGlzdGVuZXJzOiAtPiBbY2FsbGJhY2tdXG5cbiAgICAgIFN0cm9waGVJTy5jb25uZWN0SU9MaXN0ZW5lcnMgb3B0aW9uc1xuXG4gICAgICBjb25uZWN0aW9uLnJhd0lucHV0IDEsIDIsIDNcblxuICAgICAgY2FsbGJhY2suc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aEV4YWN0bHkgMSwgMiwgM1xuXG4gICAgaXQgJ3Nob3VsZCBjb25uZWN0IHJhd091dHB1dCBsaXN0ZW5lcnMnLCAtPlxuICAgICAgY2FsbGJhY2sgPSBzaW5vbi5zdHViKClcbiAgICAgIGNvbm5lY3Rpb24gPSB7fVxuICAgICAgb3B0aW9ucyA9XG4gICAgICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb25cbiAgICAgICAgZ2V0UmF3T3V0cHV0TGlzdGVuZXJzOiAtPiBbY2FsbGJhY2tdXG5cbiAgICAgIFN0cm9waGVJTy5jb25uZWN0SU9MaXN0ZW5lcnMgb3B0aW9uc1xuXG4gICAgICBjb25uZWN0aW9uLnJhd091dHB1dCAxLCAyLCAzXG5cbiAgICAgIGNhbGxiYWNrLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGhFeGFjdGx5IDEsIDIsIDNcblxuICAgIGl0ICdzaG91bGQgY29ubmVjdCB4bWxJbnB1dCBsaXN0ZW5lcnMnLCAtPlxuICAgICAgY2FsbGJhY2sgPSBzaW5vbi5zdHViKClcbiAgICAgIGNvbm5lY3Rpb24gPSB7fVxuICAgICAgb3B0aW9ucyA9XG4gICAgICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb25cbiAgICAgICAgZ2V0WE1MSW5wdXRMaXN0ZW5lcnM6IC0+IFtjYWxsYmFja11cblxuICAgICAgU3Ryb3BoZUlPLmNvbm5lY3RJT0xpc3RlbmVycyBvcHRpb25zXG5cbiAgICAgIGNvbm5lY3Rpb24ueG1sSW5wdXQgMSwgMiwgM1xuXG4gICAgICBjYWxsYmFjay5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgIC5jYWxsZWRXaXRoRXhhY3RseSAxLCAyLCAzXG5cbiAgICBpdCAnc2hvdWxkIGNvbm5lY3QgeG1sT3V0cHV0IGxpc3RlbmVycycsIC0+XG4gICAgICBjYWxsYmFjayA9IHNpbm9uLnN0dWIoKVxuICAgICAgY29ubmVjdGlvbiA9IHt9XG4gICAgICBvcHRpb25zID1cbiAgICAgICAgY29ubmVjdGlvbjogY29ubmVjdGlvblxuICAgICAgICBnZXRYTUxPdXRwdXRMaXN0ZW5lcnM6IC0+IFtjYWxsYmFja11cblxuICAgICAgU3Ryb3BoZUlPLmNvbm5lY3RJT0xpc3RlbmVycyBvcHRpb25zXG5cbiAgICAgIGNvbm5lY3Rpb24ueG1sT3V0cHV0IDEsIDIsIDNcblxuICAgICAgY2FsbGJhY2suc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkT25jZVxuICAgICAgICAuY2FsbGVkV2l0aEV4YWN0bHkgMSwgMiwgM1xuIiwie2V4cGVjdCwgc2lub24sIF8sIGZpeHR1cmVzLCBYMkpTLCB0cmltRml4dHVyZSwgY29udmVydFhNTFRvU3RhbnphfSA9IHJlcXVpcmUgJ3NwZWMvc3BlY19oZWxwZXInXG5zdHJvcGhlTWVzc2FnaW5nID0gcmVxdWlyZSAnc3Ryb3BoZS9zdHJvcGhlX21lc3NhZ2luZydcblxuZGVzY3JpYmUgJ3N0cm9waGVNZXNzYWdpbmcnLCAtPlxuXG4gIGRlc2NyaWJlICcjZ2V0U2VuZFN0YW56YSgpJywgLT5cblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciBzZW5kaW5nIGEgbWVzc2FnZSB3aXRoIGRlZmF1bHQgdHlwZSBvZiBcXCdjaGF0XFwnJywgLT5cbiAgICAgIGZpeHR1cmUgPSBcIjxtZXNzYWdlIHRvPSdteS5ncm91cGNoYXRAY29uZmVyZW5jZS5yZXV0ZXJzLm5ldCdcbiAgICAgICAgICB0eXBlPSdjaGF0JyBpZD0nMTIzNDUnIHhtbG5zPSdqYWJiZXI6Y2xpZW50Jz5cbiAgICAgICAgICA8Ym9keT5UaGlzIGlzIHRoZSBtZXNzYWdlIGJvZHk8L2JvZHk+XG4gICAgICAgICAgPGFjdGl2ZSB4bWxucz0naHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvY2hhdHN0YXRlcycvPlxuICAgICAgICA8L21lc3NhZ2U+XCJcbiAgICAgIGlkID0gJzEyMzQ1J1xuICAgICAgamlkID0gXCJteS5ncm91cGNoYXRAY29uZmVyZW5jZS5yZXV0ZXJzLm5ldFwiXG4gICAgICBib2R5ID0gXCJUaGlzIGlzIHRoZSBtZXNzYWdlIGJvZHlcIlxuICAgICAgc3RhbnphID0gc3Ryb3BoZU1lc3NhZ2luZy5nZXRTZW5kU3RhbnphIGppZCwgYm9keSwgbnVsbCwgaWRcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHN0YW56YSBmb3Igc2VuZGluZyBhIG1lc3NhZ2Ugd2l0aCBhIHNwZWNpZmllZCB0eXBlJywgLT5cbiAgICAgIGZpeHR1cmUgPSBcIjxtZXNzYWdlIHRvPSdteS5ncm91cGNoYXRAY29uZmVyZW5jZS5yZXV0ZXJzLm5ldCdcbiAgICAgICAgICB0eXBlPSdzb21lVHlwZScgaWQ9JzEyMzQ1JyB4bWxucz0namFiYmVyOmNsaWVudCc+XG4gICAgICAgICAgPGJvZHk+VGhpcyBpcyB0aGUgbWVzc2FnZSBib2R5PC9ib2R5PlxuICAgICAgICAgIDxhY3RpdmUgeG1sbnM9J2h0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL2NoYXRzdGF0ZXMnLz5cbiAgICAgICAgPC9tZXNzYWdlPlwiXG4gICAgICBpZCA9ICcxMjM0NSdcbiAgICAgIGppZCA9IFwibXkuZ3JvdXBjaGF0QGNvbmZlcmVuY2UucmV1dGVycy5uZXRcIlxuICAgICAgYm9keSA9IFwiVGhpcyBpcyB0aGUgbWVzc2FnZSBib2R5XCJcbiAgICAgIHR5cGUgPSBcInNvbWVUeXBlXCJcbiAgICAgIHN0YW56YSA9IHN0cm9waGVNZXNzYWdpbmcuZ2V0U2VuZFN0YW56YSBqaWQsIGJvZHksIHR5cGUsIGlkXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgd2l0aCBkZWxpdmVyeSByZWNlaXB0IGZvciBUUiBqaWRzJywgLT5cbiAgICAgIGZpeHR1cmUgPSBcIjxtZXNzYWdlIHRvPSdmaXJzdC5sYXN0LmNvbXBhbnlAcmV1dGVycy5uZXQnXG4gICAgICAgICAgdHlwZT0nY2hhdCcgaWQ9JzEyMzQ1JyB4bWxucz0namFiYmVyOmNsaWVudCc+XG4gICAgICAgICAgPGJvZHk+VGhpcyBpcyB0aGUgbWVzc2FnZSBib2R5PC9ib2R5PlxuICAgICAgICAgIDxyZXF1ZXN0IHhtbG5zPSduaXRybzp4bXBwOnJlY2VpcHRzJy8+XG4gICAgICAgICAgPGFjdGl2ZSB4bWxucz0naHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvY2hhdHN0YXRlcycvPlxuICAgICAgICA8L21lc3NhZ2U+XCJcbiAgICAgIGlkID0gJzEyMzQ1J1xuICAgICAgamlkID0gXCJmaXJzdC5sYXN0LmNvbXBhbnlAcmV1dGVycy5uZXRcIlxuICAgICAgYm9keSA9IFwiVGhpcyBpcyB0aGUgbWVzc2FnZSBib2R5XCJcbiAgICAgIHN0YW56YSA9IHN0cm9waGVNZXNzYWdpbmcuZ2V0U2VuZFN0YW56YSBqaWQsIGJvZHksIG51bGwsIGlkXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gICAgIyBkaXNhYmxlZCBhcyB3ZSBhcmUgcmVxdWVzdGluZyBhIHJlY2VpcHQgZm9yIEFMTCB1c2VycyBhdCB0aGUgbW9tZW50XG4gICAgeGl0ICdzaG91bGQgbm90IHJlcXVlc3QgYSBkZWxpdmVyeSByZWNlaXB0IGZvciBub24tVFIgamlkcycsIC0+XG4gICAgICBmaXh0dXJlID0gXCI8bWVzc2FnZSB0bz0nZmlyc3QubGFzdC5jb21wYW55QGZlZGVyYXRlZC5uZXQnXG4gICAgICAgICAgdHlwZT0nY2hhdCcgaWQ9JzEyMzQ1JyB4bWxucz0namFiYmVyOmNsaWVudCc+XG4gICAgICAgICAgPGJvZHk+VGhpcyBpcyB0aGUgbWVzc2FnZSBib2R5PC9ib2R5PlxuICAgICAgICAgIDxhY3RpdmUgeG1sbnM9J2h0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL2NoYXRzdGF0ZXMnLz5cbiAgICAgICAgPC9tZXNzYWdlPlwiXG4gICAgICBpZCA9ICcxMjM0NSdcbiAgICAgIGppZCA9IFwiZmlyc3QubGFzdC5jb21wYW55QGZlZGVyYXRlZC5uZXRcIlxuICAgICAgYm9keSA9IFwiVGhpcyBpcyB0aGUgbWVzc2FnZSBib2R5XCJcbiAgICAgIHN0YW56YSA9IHN0cm9waGVNZXNzYWdpbmcuZ2V0U2VuZFN0YW56YSBqaWQsIGJvZHksIG51bGwsIGlkXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gIGl0ICdzaG91bGQgcmVxdWVzdCBhIGRlbGl2ZXJ5IHJlY2VpcHQgd2l0aCBjb3JyZWN0IG5zIGZvciBtYW5hZ2VkIGNoYXRyb29tcycsIC0+XG4gICAgZml4dHVyZSA9IFwiPG1lc3NhZ2UgdG89J3Jvb20ubmFtZUBsZWdhY3ljaGF0LnJldXRlcnMubmV0J1xuICAgICAgICB0eXBlPSdjaGF0JyBpZD0nMTIzNDUnIHhtbG5zPSdqYWJiZXI6Y2xpZW50Jz5cbiAgICAgICAgPGJvZHk+VGhpcyBpcyB0aGUgbWVzc2FnZSBib2R5PC9ib2R5PlxuICAgICAgICA8cmVxdWVzdCB4bWxucz0ndXJuOnhtcHA6cmVjZWlwdHMnLz5cbiAgICAgICAgPGFjdGl2ZSB4bWxucz0naHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvY2hhdHN0YXRlcycvPlxuICAgICAgPC9tZXNzYWdlPlwiXG4gICAgaWQgPSAnMTIzNDUnXG4gICAgamlkID0gXCJyb29tLm5hbWVAbGVnYWN5Y2hhdC5yZXV0ZXJzLm5ldFwiXG4gICAgYm9keSA9IFwiVGhpcyBpcyB0aGUgbWVzc2FnZSBib2R5XCJcbiAgICBzdGFuemEgPSBzdHJvcGhlTWVzc2FnaW5nLmdldFNlbmRTdGFuemEgamlkLCBib2R5LCBudWxsLCBpZFxuICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gIGl0ICdzaG91bGQgbm90IHJlcXVlc3QgYSBkZWxpdmVyeSByZWNlaXB0IGZvciBncm91cGNoYXQvYmlsYXRlcmFscycsIC0+XG4gICAgZml4dHVyZSA9IFwiPG1lc3NhZ2UgdG89J3Jvb20ubmFtZUBjb25mZXJlbmNlLnJldXRlcnMubmV0J1xuICAgICAgICB0eXBlPSdjaGF0JyBpZD0nMTIzNDUnIHhtbG5zPSdqYWJiZXI6Y2xpZW50Jz5cbiAgICAgICAgPGJvZHk+VGhpcyBpcyB0aGUgbWVzc2FnZSBib2R5PC9ib2R5PlxuICAgICAgICA8YWN0aXZlIHhtbG5zPSdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9jaGF0c3RhdGVzJy8+XG4gICAgICA8L21lc3NhZ2U+XCJcbiAgICBpZCA9ICcxMjM0NSdcbiAgICBqaWQgPSBcInJvb20ubmFtZUBjb25mZXJlbmNlLnJldXRlcnMubmV0XCJcbiAgICBib2R5ID0gXCJUaGlzIGlzIHRoZSBtZXNzYWdlIGJvZHlcIlxuICAgIHN0YW56YSA9IHN0cm9waGVNZXNzYWdpbmcuZ2V0U2VuZFN0YW56YSBqaWQsIGJvZHksIG51bGwsIGlkXG4gICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgZGVzY3JpYmUgJyNnZXRDaGF0SGlzdG9yeVN0YW56YSgpJywgLT5cblxuICAgICMgY3VycmVudGx5IHVzZXMgdXNlciBqaWQgZm9yIHRlc3RzLCBidXQgZ3JvdXBjaGF0IGppZHMgc2hvdWxkXG4gICAgIyByZXN1bHQgaW4gaWRlbnRpY2FsIHN0YW56YSAod2l0aCBkaWZmZXJlbnQgamlkLilcbiAgICBqaWQgPSAnc29tZS5qaWQudGhvbXNvbnJldXRlcnMuY29tQHJldXRlcnMubmV0J1xuICAgIGJlZm9yZUlEID0gJzEyMzQ1NidcbiAgICBhbHRlcm5hdGVNYXggPSAnMjAnXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHN0YW56YSBmb3IgcmV0cmVpdmluZyBtZXNzYWdlIGhpc3RvcnkgKGRlZmF1bHQgbWF4KScsIC0+XG4gICAgICBmaXh0dXJlID0gZml4dHVyZXMucmVhZCAnbWVzc2FnaW5nL2NoYXQvaGlzdG9yeV9yZXF1ZXN0LnhtbCdcbiAgICAgIHN0YW56YSA9IHN0cm9waGVNZXNzYWdpbmcuZ2V0Q2hhdEhpc3RvcnlTdGFuemEgamlkXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgZm9yIHJldHJlaXZpbmcgbW9yZSBtZXNzYWdlIGhpc3RvcnkgKGRlZmF1bHQgbWF4KScsIC0+XG4gICAgICBmaXh0dXJlID0gZml4dHVyZXMucmVhZCAnbWVzc2FnaW5nL2NoYXQvbW9yZV9oaXN0b3J5X3JlcXVlc3QueG1sJ1xuICAgICAgc3RhbnphID0gc3Ryb3BoZU1lc3NhZ2luZy5nZXRDaGF0SGlzdG9yeVN0YW56YSBqaWQsIGJlZm9yZUlEXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgZm9yIHJldHJlaXZpbmcgbWVzc2FnZSBoaXN0b3J5IChhbHQgbWF4KScsIC0+XG4gICAgICBmaXh0dXJlID0gZml4dHVyZXMucmVhZCAnbWVzc2FnaW5nL2NoYXQvYWx0X21heF9oaXN0b3J5X3JlcXVlc3QueG1sJ1xuICAgICAgc3RhbnphID0gc3Ryb3BoZU1lc3NhZ2luZy5nZXRDaGF0SGlzdG9yeVN0YW56YSBqaWQsIG51bGwsIDIwXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgZm9yIHJldHJlaXZpbmcgbW9yZSBtZXNzYWdlIGhpc3RvcnkgKGFsdCBtYXgpJywgLT5cbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdtZXNzYWdpbmcvY2hhdC9hbHRfbWF4X21vcmVfaGlzdG9yeV9yZXF1ZXN0LnhtbCdcbiAgICAgIHN0YW56YSA9IHN0cm9waGVNZXNzYWdpbmcuZ2V0Q2hhdEhpc3RvcnlTdGFuemEgamlkLCBiZWZvcmVJRCwgMjBcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgZGVzY3JpYmUgJyNnZXRHcm91cGNoYXRIaXN0b3J5U3RhbnphKCknLCAtPlxuXG4gICAgIyBjdXJyZW50bHkgdXNlcyB1c2VyIGppZCBmb3IgdGVzdHMsIGJ1dCBncm91cGNoYXQgamlkcyBzaG91bGRcbiAgICAjIHJlc3VsdCBpbiBpZGVudGljYWwgc3RhbnphICh3aXRoIGRpZmZlcmVudCBqaWQuKVxuICAgIGppZCA9ICdzb21lX2NoYXRyb29tLnJldXRlcnMuY29tQGxlZ2FjeWNoYXQucmV1dGVycy5uZXQnXG4gICAgYmVmb3JlSUQgPSAnMTIzNDU2J1xuICAgIGFsdGVybmF0ZU1heCA9ICcyMCdcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciByZXRyZWl2aW5nIG1lc3NhZ2UgaGlzdG9yeSAoZGVmYXVsdCBtYXgpJywgLT5cbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdtZXNzYWdpbmcvZ3JvdXBjaGF0L2hpc3RvcnlfcmVxdWVzdC54bWwnXG4gICAgICBzdGFuemEgPSBzdHJvcGhlTWVzc2FnaW5nLmdldEdyb3VwY2hhdEhpc3RvcnlTdGFuemEgamlkXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgZm9yIHJldHJlaXZpbmcgbW9yZSBtZXNzYWdlIGhpc3RvcnkgKGRlZmF1bHQgbWF4KScsIC0+XG4gICAgICBmaXh0dXJlID0gZml4dHVyZXMucmVhZCAnbWVzc2FnaW5nL2dyb3VwY2hhdC9tb3JlX2hpc3RvcnlfcmVxdWVzdC54bWwnXG4gICAgICBzdGFuemEgPSBzdHJvcGhlTWVzc2FnaW5nLmdldEdyb3VwY2hhdEhpc3RvcnlTdGFuemEgamlkLCBiZWZvcmVJRFxuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciByZXRyZWl2aW5nIG1lc3NhZ2UgaGlzdG9yeSAoYWx0IG1heCknLCAtPlxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ21lc3NhZ2luZy9ncm91cGNoYXQvYWx0X21heF9oaXN0b3J5X3JlcXVlc3QueG1sJ1xuICAgICAgc3RhbnphID0gc3Ryb3BoZU1lc3NhZ2luZy5nZXRHcm91cGNoYXRIaXN0b3J5U3RhbnphIGppZCwgbnVsbCwgMjBcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHN0YW56YSBmb3IgcmV0cmVpdmluZyBtb3JlIG1lc3NhZ2UgaGlzdG9yeSAoYWx0IG1heCknLCAtPlxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ21lc3NhZ2luZy9ncm91cGNoYXQvYWx0X21heF9tb3JlX2hpc3RvcnlfcmVxdWVzdC54bWwnXG4gICAgICBzdGFuemEgPSBzdHJvcGhlTWVzc2FnaW5nLmdldEdyb3VwY2hhdEhpc3RvcnlTdGFuemEgamlkLCBiZWZvcmVJRCwgMjBcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cblxuICBkZXNjcmliZSAnI2dldE1hbmFnZWRIaXN0b3J5U3RhbnphKCknLCAtPlxuXG4gICAgIyBjdXJyZW50bHkgdXNlcyB1c2VyIGppZCBmb3IgdGVzdHMsIGJ1dCBncm91cGNoYXQgamlkcyBzaG91bGRcbiAgICAjIHJlc3VsdCBpbiBpZGVudGljYWwgc3RhbnphICh3aXRoIGRpZmZlcmVudCBqaWQuKVxuICAgIGppZCA9ICdzb21lX2NoYXRyb29tLnJldXRlcnMuY29tQGxlZ2FjeWNoYXQucmV1dGVycy5uZXQnXG4gICAgYmVmb3JlSUQgPSAnMTIzNDU2J1xuICAgIGFsdGVybmF0ZU1heCA9ICcyMCdcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciByZXRyZWl2aW5nIG1lc3NhZ2UgaGlzdG9yeSAoZGVmYXVsdCBtYXgpJywgLT5cbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdtZXNzYWdpbmcvbWFuYWdlZC9oaXN0b3J5X3JlcXVlc3QueG1sJ1xuICAgICAgc3RhbnphID0gc3Ryb3BoZU1lc3NhZ2luZy5nZXRNYW5hZ2VkSGlzdG9yeVN0YW56YSBqaWRcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHN0YW56YSBmb3IgcmV0cmVpdmluZyBtb3JlIG1lc3NhZ2UgaGlzdG9yeSAoZGVmYXVsdCBtYXgpJywgLT5cbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdtZXNzYWdpbmcvbWFuYWdlZC9tb3JlX2hpc3RvcnlfcmVxdWVzdC54bWwnXG4gICAgICBzdGFuemEgPSBzdHJvcGhlTWVzc2FnaW5nLmdldE1hbmFnZWRIaXN0b3J5U3RhbnphIGppZCwgYmVmb3JlSURcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHN0YW56YSBmb3IgcmV0cmVpdmluZyBtZXNzYWdlIGhpc3RvcnkgKGFsdCBtYXgpJywgLT5cbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdtZXNzYWdpbmcvbWFuYWdlZC9hbHRfbWF4X2hpc3RvcnlfcmVxdWVzdC54bWwnXG4gICAgICBzdGFuemEgPSBzdHJvcGhlTWVzc2FnaW5nLmdldE1hbmFnZWRIaXN0b3J5U3RhbnphIGppZCwgbnVsbCwgMjBcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHN0YW56YSBmb3IgcmV0cmVpdmluZyBtb3JlIG1lc3NhZ2UgaGlzdG9yeSAoYWx0IG1heCknLCAtPlxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ21lc3NhZ2luZy9tYW5hZ2VkL2FsdF9tYXhfbW9yZV9oaXN0b3J5X3JlcXVlc3QueG1sJ1xuICAgICAgc3RhbnphID0gc3Ryb3BoZU1lc3NhZ2luZy5nZXRNYW5hZ2VkSGlzdG9yeVN0YW56YSBqaWQsIGJlZm9yZUlELCAyMFxuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICBkZXNjcmliZSAnI2dldFR5cGluZ1N0YW56YSgpJywgLT5cbiAgICBqaWQgPSAnc29tZS51c2VyLnRob21zb25yZXV0ZXJzLmNvbUByZXV0ZXJzLm5ldCdcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciBub3RpZnlpbmcgcGllcnMgYWJvdXQgXCJjaGF0c3RhdGVzXCIgZXZlbnQnLCAtPlxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ21lc3NhZ2luZy9jaGF0L2NoYXRzdGF0ZXMueG1sJ1xuICAgICAgc3RhbnphID0gc3Ryb3BoZU1lc3NhZ2luZy5nZXRUeXBpbmdTdGFuemEgamlkXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuZC5pbnN0YW5jZU9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcbiIsIntleHBlY3QsIHNpbm9uLCBfLCBmaXh0dXJlcywgWDJKUywgdHJpbUZpeHR1cmV9ID0gcmVxdWlyZSAnc3BlYy9zcGVjX2hlbHBlcidcbnN0cm9waGVNVUMgPSByZXF1aXJlICdzdHJvcGhlL3N0cm9waGVfbXVjJ1xuTVVDRmllbGQgPSByZXF1aXJlICdlbnVtL211Y19maWVsZCdcbk1VQ1JvbGUgPSByZXF1aXJlICdlbnVtL211Y19yb2xlJ1xuXG5kZXNjcmliZSAnc3Ryb3BoZU1VQycsIC0+XG5cbiAgc2VsZkpJRCA9ICdzZWxmLmppZC50aG9tc29ucmV1dGVycy5jb21AcmV1dGVycy5uZXQnXG4gIHVzZXJKSUQgPSAndXNlci5qaWQudGhvbXNvbnJldXRlcnMuY29tQHJldXRlcnMubmV0J1xuICBncm91cGNoYXRKSUQgPSAnbXkuZ3JvdXBjaGF0QGNvbmZlcmVuY2UucmV1dGVycy5uZXQnXG4gIGdyb3VwY2hhdFJJRCA9ICdzb21lLnVzZXIudGhvbXNvbnJldXRlcnMuY29tX19yZXV0ZXJzLm5ldCdcbiAgZ3JvdXBjaGF0TmFtZSA9ICdNeSBHcm91cGNoYXQnXG5cbiAgZGVzY3JpYmUgJyNnZXRKb2luU3RhbnphKCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgZm9yIGpvaW5pbmcgYSBncm91cGNoYXQnLCAtPlxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ211Yy9qb2luLnhtbCdcbiAgICAgIHN0YW56YSA9IHN0cm9waGVNVUMuZ2V0Sm9pblN0YW56YSBncm91cGNoYXRKSUQsIGdyb3VwY2hhdFJJRFxuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICBkZXNjcmliZSAnI2dldExlYXZlU3RhbnphKCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdGhlIGJhc2UgZm9ybSBzdGFuemEgdG8gbGVhdmUgYSBncm91cGNoYXQnLCAtPlxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ211Yy9sZWF2ZS54bWwnXG4gICAgICBzdGFuemEgPSBzdHJvcGhlTVVDLmdldExlYXZlU3RhbnphIGdyb3VwY2hhdEpJRFxuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICBkZXNjcmliZSAnI2dldERlc3Ryb3lHcm91cGNoYXRTdGFuemEoKScsIC0+XG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHN0YW56YSBmb3IgZGVzdHJveWluZyBhIGdyb3VwY2hhdCcsIC0+XG4gICAgICBmaXh0dXJlID0gZml4dHVyZXMucmVhZCAnbXVjL2Rlc3Ryb3kueG1sJ1xuICAgICAgc3RhbnphID0gc3Ryb3BoZU1VQy5nZXREZXN0cm95R3JvdXBjaGF0U3RhbnphIGdyb3VwY2hhdEpJRFxuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICBkZXNjcmliZSAnI2dldEdyb3VwY2hhdENvbmZpZ0Zvcm0oKScsIC0+XG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0aGUgYmFzZSBmb3JtIHN0YW56YSB0byBjb25maWd1cmUgYSBncm91cGNoYXQnLCAtPlxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ211Yy9mb3JtLnhtbCdcbiAgICAgIHN0YW56YSA9IHN0cm9waGVNVUMuZ2V0R3JvdXBjaGF0Q29uZmlnRm9ybSBncm91cGNoYXRKSUQsXG4gICAgICAgIE1VQ0ZpZWxkLlJPT01fTkFNRSwgZ3JvdXBjaGF0TmFtZVxuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICBkZXNjcmliZSAnI2dldFJvb21EaXNjb1N0YW56YSgpJywgLT5cblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRoZSBiYXNlIGZvcm0gc3RhbnphIHRvIHBlcmZvcm0gZ3JvdXBjaGF0IGRpc2NvJywgLT5cbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdtdWMvZGlzY28ueG1sJ1xuICAgICAgc3RhbnphID0gc3Ryb3BoZU1VQy5nZXRSb29tRGlzY29TdGFuemEgZ3JvdXBjaGF0SklEXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gIGRlc2NyaWJlICcjZ2V0TWVtYmVyTGlzdFN0YW56YSgpJywgLT5cblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRoZSBiYXNlIGZvcm0gc3RhbnphIHRvIHJlcXVlc3QgZ3JvdXBjaGF0IG1lbWJlciBsaXN0JywgLT5cbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdtdWMvbWVtYmVycy54bWwnXG4gICAgICBhZmZpbGlhdGlvbnMgPSBbTVVDUm9sZS5PV05FUiwgTVVDUm9sZS5BRE1JTl1cbiAgICAgIHN0YW56YSA9IHN0cm9waGVNVUMuZ2V0TWVtYmVyTGlzdFN0YW56YSBncm91cGNoYXRKSUQsIGFmZmlsaWF0aW9uc1xuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICBkZXNjcmliZSAnI2dldE1lZGlhdGVkSW52aXRlU3RhbnphKCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdGhlIGJhc2UgZm9ybSBzdGFuemEgdG8gcmVxdWVzdCBncm91cGNoYXQgbWVtYmVyIGxpc3QnLCAtPlxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ211Yy9tZWRpYXRlZF9pbnZpdGUueG1sJ1xuICAgICAgaW52aXRlZXMgPSBbdXNlckpJRF1cbiAgICAgIHN0YW56YSA9IHN0cm9waGVNVUMuZ2V0TWVkaWF0ZWRJbnZpdGVTdGFuemEgZ3JvdXBjaGF0SklELCBzZWxmSklELCBpbnZpdGVlc1xuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICBkZXNjcmliZSAnI2dldFNlYXJjaFN0YW56YSgpJywgLT5cblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRoZSBzZWFyY2ggc3RhbnphIHRvIHF1ZXJ5IGZvciBncm91cGNoYXRzJywgLT5cbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdtdWMvc2VhcmNoLnhtbCdcbiAgICAgIHNlYXJjaFN0cmluZyA9ICdzb21lIHNlYXJjaCdcblxuICAgICAgc3RhbnphID0gc3Ryb3BoZU1VQy5nZXRTZWFyY2hTdGFuemEgJ2xlZ2FjeWNoYXQucmV1dGVycy5uZXQnLCBzZWFyY2hTdHJpbmdcblxuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICBkZXNjcmliZSAnI2dldEtpY2tTdGFuemEoKScsIC0+XG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0aGUgYmFzZSBmb3JtIHN0YW56YSB0byByZXF1ZXN0IGdyb3VwY2hhdCBtZW1iZXIgbGlzdCcsIC0+XG4gICAgICBmaXh0dXJlID0gZml4dHVyZXMucmVhZCAnbXVjL21lZGlhdGVkX2ludml0ZS54bWwnXG4gICAgICBpbnZpdGVlcyA9IFt1c2VySklEXVxuICAgICAgc3RhbnphID0gc3Ryb3BoZU1VQy5nZXRNZWRpYXRlZEludml0ZVN0YW56YSBncm91cGNoYXRKSUQsIHNlbGZKSUQsIGludml0ZWVzXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuIiwie2V4cGVjdCwgc2lub24sIF8sIGZpeHR1cmVzLCBYMkpTLCB0cmltRml4dHVyZX0gPSByZXF1aXJlICdzcGVjL3NwZWNfaGVscGVyJ1xuUHJlc2VuY2VUeXBlID0gcmVxdWlyZSAnZW51bS9wcmVzZW5jZV90eXBlJ1xuUHJlc2VuY2VTaG93ID0gcmVxdWlyZSAnZW51bS9wcmVzZW5jZV9zaG93J1xuc3Ryb3BoZVByZXNlbmNlID0gcmVxdWlyZSAnc3Ryb3BoZS9zdHJvcGhlX3ByZXNlbmNlJ1xuXG5kZXNjcmliZSAnc3Ryb3BoZVByZXNlbmNlJywgLT5cblxuICBkZXNjcmliZSAnI2dldFByZXNlbmNlU3RhbnphKCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgU3Ryb3BoZS5CdWlsZGVyJywgLT5cbiAgICAgIHN0cm9waGVQcmVzZW5jZS5nZXRQcmVzZW5jZVN0YW56YSgpLnNob3VsZC5iZS5hblxuICAgICAgICAuaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgcGxhaW4gcHJlc2VuY2Ugc3RhbnphJywgLT5cbiAgICAgIGZpeHR1cmUgPSAgXCI8cHJlc2VuY2UgeG1sbnM9J2phYmJlcjpjbGllbnQnLz5cIlxuICAgICAgc3RhbnphID0gc3Ryb3BoZVByZXNlbmNlLmdldFByZXNlbmNlU3RhbnphKClcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHByZXNlbmNlIHN0YW56YSBhZGRyZXNzZWQgdG8gYSBjb250YWN0IGppZCcsIC0+XG4gICAgICBmaXh0dXJlID0gIFwiPHByZXNlbmNlIHhtbG5zPSdqYWJiZXI6Y2xpZW50JyB0bz0nZmFrZWppZCcvPlwiXG4gICAgICBzdGFuemEgPSBzdHJvcGhlUHJlc2VuY2UuZ2V0UHJlc2VuY2VTdGFuemEgXCJmYWtlamlkXCJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHByZXNlbmNlIHN0YW56YSB0byBhIGNvbnRhY3Qgd2l0aCBhIHN1YnNjcmlwdGlvbiB0eXBlJywgLT5cbiAgICAgIGZpeHR1cmUgPSAgXCI8cHJlc2VuY2UgeG1sbnM9J2phYmJlcjpjbGllbnQnIHRvPSdmYWtlamlkJyB0eXBlPSdzdWJzY3JpYmUnLz5cIlxuICAgICAgamlkID0gXCJmYWtlamlkXCJcbiAgICAgIHN0YW56YSA9IHN0cm9waGVQcmVzZW5jZS5nZXRQcmVzZW5jZVN0YW56YSBqaWQsIFByZXNlbmNlVHlwZS5TVUJTQ1JJQkVcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHByZXNlbmNlIHN0YW56YSB3aXRoIGEgc2hvdyB0eXBlJywgLT5cbiAgICAgIGZpeHR1cmUgPSAgXCI8cHJlc2VuY2UgeG1sbnM9J2phYmJlcjpjbGllbnQnPjxzaG93PmF3YXk8L3Nob3c+PC9wcmVzZW5jZT5cIlxuICAgICAgc3RhbnphID0gc3Ryb3BoZVByZXNlbmNlLmdldFByZXNlbmNlU3RhbnphIFwiXCIsIFwiXCIsIFByZXNlbmNlU2hvdy5BV0FZXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gIGRlc2NyaWJlICcjZ2V0VmlzaWJsZVN0YW56YSgpJywgLT5cblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciBcXCd2aXNpYmxlXFwnJywgLT5cbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdwcmVzZW5jZS92aXNpYmxlLnhtbCdcbiAgICAgIHN0YW56YSA9IHN0cm9waGVQcmVzZW5jZS5nZXRWaXNpYmxlU3RhbnphKClcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHN0YW56YSBmb3IgXFwnaW52aXNpYmxlXFwnJywgLT5cbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdwcmVzZW5jZS9pbnZpc2libGUueG1sJ1xuICAgICAgc3RhbnphID0gc3Ryb3BoZVByZXNlbmNlLmdldFZpc2libGVTdGFuemEgZmFsc2VcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG4iLCJ7ZXhwZWN0LCBzaW5vbiwgXywgZml4dHVyZXMsIFgySlMsIHRyaW1GaXh0dXJlfSA9IHJlcXVpcmUgJ3NwZWMvc3BlY19oZWxwZXInXG5QcmVzZW5jZVR5cGUgPSByZXF1aXJlICdlbnVtL3ByZXNlbmNlX3R5cGUnXG5zdHJvcGhlUm9zdGVyID0gcmVxdWlyZSAnc3Ryb3BoZS9zdHJvcGhlX3Jvc3RlcidcblxuZGVzY3JpYmUgJ3N0cm9waGVSb3N0ZXInLCAtPlxuICAgXG4gIGRlc2NyaWJlICcjZ2V0Um9zdGVyU3RhbnphKCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgZm9yIGdldHRpbmcgdGhlIHJvc3RlcicsIC0+XG4gICAgICBmaXh0dXJlID0gZml4dHVyZXMucmVhZCAncm9zdGVyL2dldC54bWwnXG4gICAgICBzdGFuemEgPSBzdHJvcGhlUm9zdGVyLmdldFJvc3RlclN0YW56YSgpXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuICBcbiAgZGVzY3JpYmUgJyNnZXRBZGRTdGFuemEoKScsIC0+XG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHN0YW56YSBmb3IgYWRkaW5nIGEgY29udGFjdCB0byB0aGUgcm9zdGVyJywgLT5cbiAgICAgIGppZCA9IFwibXlqaWRcIlxuICAgICAgbmFtZSA9IFwiTXkgTmFtZVwiXG4gICAgICBmaXh0dXJlID0gZml4dHVyZXMucmVhZCAncm9zdGVyL2FkZC54bWwnXG4gICAgICBncm91cHMgPSBbJ0dyb3VwIE9uZScsICdHcm91cCBUd28nXVxuICAgICAgc3RhbnphID0gc3Ryb3BoZVJvc3Rlci5nZXRBZGRTdGFuemEgamlkLCBuYW1lLCBncm91cHNcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgZGVzY3JpYmUgJyNnZXRSZW1vdmVTdGFuemEoKScsIC0+XG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHN0YW56YSBmb3IgcmVtb3ZpbmlnIGEgY29udGFjdCBmcm9tIHRoZSByb3N0ZXInLCAtPlxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ3Jvc3Rlci9yZW1vdmUueG1sJ1xuICAgICAgamlkID0gJ2NvbnRhY3R0b3JlbW92ZWppZCdcbiAgICAgIHN0YW56YSA9IHN0cm9waGVSb3N0ZXIuZ2V0UmVtb3ZlU3RhbnphIGppZFxuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICBkZXNjcmliZSAnI2dldFByZXNlbmNlU3Vic2NyaXB0aW9uU3RhbnphKCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgZm9yIHByZXNlbmNlIFxcJ3N1YnNjcmliZVxcJyB0byBhIHVzZXInLCAtPlxuICAgICAgZml4dHVyZSA9IFwiPHByZXNlbmNlIHhtbG5zPSdqYWJiZXI6Y2xpZW50JyB0bz0nZmFrZWppZCcgdHlwZT0nc3Vic2NyaWJlJy8+XCJcbiAgICAgIGppZCA9IFwiZmFrZWppZFwiXG4gICAgICBzdGFuemEgPSBzdHJvcGhlUm9zdGVyLmdldFByZXNlbmNlU3Vic2NyaXB0aW9uU3RhbnphIGppZCwgUHJlc2VuY2VUeXBlLlNVQlNDUklCRVxuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciBwcmVzZW5jZSBcXCdzdWJzY3JpYmVkXFwnIHRvIGEgdXNlcicsIC0+XG4gICAgICBmaXh0dXJlID0gXCI8cHJlc2VuY2UgeG1sbnM9J2phYmJlcjpjbGllbnQnIHRvPSdmYWtlamlkJyB0eXBlPSdzdWJzY3JpYmVkJy8+XCJcbiAgICAgIGppZCA9IFwiZmFrZWppZFwiXG4gICAgICBzdGFuemEgPSBzdHJvcGhlUm9zdGVyLmdldFByZXNlbmNlU3Vic2NyaXB0aW9uU3RhbnphIGppZCwgUHJlc2VuY2VUeXBlLlNVQlNDUklCRURcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHN0YW56YSBmb3IgcHJlc2VuY2UgXFwndW5zdWJzY3JpYmVcXCcgdG8gYSB1c2VyJywgLT5cbiAgICAgIGZpeHR1cmUgPSBcIjxwcmVzZW5jZSB4bWxucz0namFiYmVyOmNsaWVudCcgdG89J2Zha2VqaWQnIHR5cGU9J3Vuc3Vic2NyaWJlJy8+XCJcbiAgICAgIGppZCA9IFwiZmFrZWppZFwiXG4gICAgICBzdGFuemEgPSBzdHJvcGhlUm9zdGVyLmdldFByZXNlbmNlU3Vic2NyaXB0aW9uU3RhbnphIGppZCwgUHJlc2VuY2VUeXBlLlVOU1VCU0NSSUJFXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgZm9yIHByZXNlbmNlIFxcJ3Vuc3Vic2NyaWJlZFxcJyB0byBhIHVzZXInLCAtPlxuICAgICAgZml4dHVyZSA9IFwiPHByZXNlbmNlIHhtbG5zPSdqYWJiZXI6Y2xpZW50JyB0bz0nZmFrZWppZCcgdHlwZT0ndW5zdWJzY3JpYmVkJy8+XCJcbiAgICAgIGppZCA9IFwiZmFrZWppZFwiXG4gICAgICBzdGFuemEgPSBzdHJvcGhlUm9zdGVyLmdldFByZXNlbmNlU3Vic2NyaXB0aW9uU3RhbnphIGppZCwgUHJlc2VuY2VUeXBlLlVOU1VCU0NSSUJFRFxuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcbiIsIntleHBlY3QsIHNpbm9uLCBfLCBmaXh0dXJlcywgWDJKUywgdHJpbUZpeHR1cmV9ID0gcmVxdWlyZSAnc3BlYy9zcGVjX2hlbHBlcidcbnN0cm9waGVTdG9yYWdlID0gcmVxdWlyZSAnc3Ryb3BoZS9zdHJvcGhlX3N0b3JhZ2UnXG5cbmRlc2NyaWJlICdzdHJvcGhlU3RvcmFnZScsIC0+XG5cbiAgZGVzY3JpYmUgJyNnZXRQcmVmZXJlbmNlc1N0YW56YSgpJywgLT5cblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgU3Ryb3BoZS5CdWlsZGVyIGluc3RhbmNlJywgLT5cbiAgICAgIHJlc3VsdCA9IHN0cm9waGVTdG9yYWdlLmdldFByZWZlcmVuY2VzU3RhbnphKClcblxuICAgICAgcmVzdWx0LnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgZm9yIGdldHRpbmcgcHJlZmVyZW5jZXMnLCAtPlxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ3ByZWZlcmVuY2VzL2dldC54bWwnXG5cbiAgICAgIHJlc3VsdCA9IHN0cm9waGVTdG9yYWdlLmdldFByZWZlcmVuY2VzU3RhbnphKClcblxuICAgICAgcmVzdWx0LnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICBkZXNjcmliZSAnI3NldFByZWZlcmVuY2VzU3RhbnphKCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gbnVsbCBpZiBubyBwcmVmZXJlbmNlcyBhcmUgcGFzc2VkJywgLT5cbiAgICAgIGV4cGVjdChzdHJvcGhlU3RvcmFnZS5zZXRQcmVmZXJlbmNlc1N0YW56YSgpKS50by5iZS5udWxsXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIFN0cm9waGUuQnVpbGRlciBpbnN0YW5jZScsIC0+XG4gICAgICBwcmVmZXJlbmNlcyA9IHByb3AxOiBcInZhbDFcIiwgcHJvcDI6IFwidmFsMlwiXG5cbiAgICAgIHJlc3VsdCA9IHN0cm9waGVTdG9yYWdlLnNldFByZWZlcmVuY2VzU3RhbnphIHByZWZlcmVuY2VzXG5cbiAgICAgIHJlc3VsdC5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciBzZXR0aW5nIHByZWZlcmVuY2VzJywgLT5cbiAgICAgIHByZWZlcmVuY2VzID0gcHJvcDE6IFwidmFsMVwiLCBwcm9wMjogXCJ2YWwyXCJcbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdwcmVmZXJlbmNlcy9zZXQueG1sJ1xuXG4gICAgICByZXN1bHQgPSBzdHJvcGhlU3RvcmFnZS5zZXRQcmVmZXJlbmNlc1N0YW56YSBwcmVmZXJlbmNlc1xuXG4gICAgICBfLnVuZXNjYXBlKHJlc3VsdC50b1N0cmluZygpKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gIGRlc2NyaWJlICcjZ2V0Qm9va21hcmtzU3RhbnphKCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBTdHJvcGhlLkJ1aWxkZXIgaW5zdGFuY2UnLCAtPlxuICAgICAgcmVzdWx0ID0gc3Ryb3BoZVN0b3JhZ2UuZ2V0Qm9va21hcmtzU3RhbnphKClcblxuICAgICAgcmVzdWx0LnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgZm9yIGdldHRpbmcgYm9va21hcmtzJywgLT5cbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdib29rbWFya3MvZ2V0LnhtbCdcblxuICAgICAgcmVzdWx0ID0gc3Ryb3BoZVN0b3JhZ2UuZ2V0Qm9va21hcmtzU3RhbnphKClcblxuICAgICAgcmVzdWx0LnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICBkZXNjcmliZSAnI3NldEJvb2ttYXJrc1N0YW56YSgpJywgLT5cblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgU3Ryb3BoZS5CdWlsZGVyIGluc3RhbmNlJywgLT5cbiAgICAgIGNoYXRyb29tcyA9IFtcbiAgICAgICAgamlkOiBcImppZG9mY2hhdHJvb20xXCIsIHR5cGU6ICdjb25mZXJlbmNlJ1xuICAgICAgLFxuICAgICAgICBqaWQ6IFwiamlkb2ZjaGF0cm9vbTJcIiwgdHlwZTogJ2NvbmZlcmVuY2UnXG4gICAgICBdXG4gICAgICByZXN1bHQgPSBzdHJvcGhlU3RvcmFnZS5zZXRCb29rbWFya3NTdGFuemEgY2hhdHJvb21zXG5cbiAgICAgIHJlc3VsdC5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciBzZXR0aW5nIGJvb2ttYXJrcycsIC0+XG4gICAgICBjaGF0cm9vbXMgPSBbXG4gICAgICAgIGppZDogXCJqaWRvZmNoYXRyb29tMVwiLCB0eXBlOiAnY29uZmVyZW5jZSdcbiAgICAgICxcbiAgICAgICAgamlkOiBcImppZG9mY2hhdHJvb20yXCIsIHR5cGU6ICdjb25mZXJlbmNlJ1xuICAgICAgXVxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ2Jvb2ttYXJrcy9zZXQueG1sJ1xuXG4gICAgICByZXN1bHQgPSBzdHJvcGhlU3RvcmFnZS5zZXRCb29rbWFya3NTdGFuemEgY2hhdHJvb21zXG5cbiAgICAgIHJlc3VsdC50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG4iLCJ7ZXhwZWN0LCBzaW5vbiwgXywgZml4dHVyZXMsIFgySlMsIHRyaW1GaXh0dXJlfSA9IHJlcXVpcmUgJ3NwZWMvc3BlY19oZWxwZXInXG5QcmVzZW5jZVR5cGUgPSByZXF1aXJlICdlbnVtL3ByZXNlbmNlX3R5cGUnXG5zdHJvcGhlWWFob29HYXRld2F5ID0gcmVxdWlyZSAnc3Ryb3BoZS9zdHJvcGhlX3lhaG9vX2dhdGV3YXknXG5cbmRlc2NyaWJlICdzdHJvcGhlWWFob29HYXRld2F5JywgLT5cbiAgIFxuICBkZXNjcmliZSAnI2dldFJvc3RlclN0YW56YSgpJywgLT5cblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciBnZXR0aW5nIHRoZSByb3N0ZXInLCAtPlxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ3Jvc3Rlci9nZXQueG1sJ1xuICAgICAgc3RhbnphID0gc3Ryb3BoZVlhaG9vR2F0ZXdheS5nZXRSb3N0ZXJTdGFuemEoKVxuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcbiAgXG4gIGRlc2NyaWJlICcjZ2V0QWRkU3RhbnphKCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgZm9yIGFkZGluZyBhIGNvbnRhY3QgdG8gdGhlIHJvc3RlcicsIC0+XG4gICAgICBqaWQgPSBcIm15amlkXCJcbiAgICAgIG5hbWUgPSBcIk15IE5hbWVcIlxuICAgICAgZml4dHVyZSA9IGZpeHR1cmVzLnJlYWQgJ3Jvc3Rlci9hZGQueG1sJ1xuICAgICAgZ3JvdXBzID0gWydHcm91cCBPbmUnLCAnR3JvdXAgVHdvJ11cbiAgICAgIHN0YW56YSA9IHN0cm9waGVZYWhvb0dhdGV3YXkuZ2V0QWRkU3RhbnphIGppZCwgbmFtZSwgZ3JvdXBzXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gIGRlc2NyaWJlICcjZ2V0UmVtb3ZlU3RhbnphKCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgZm9yIHJlbW92aW5pZyBhIGNvbnRhY3QgZnJvbSB0aGUgcm9zdGVyJywgLT5cbiAgICAgIGZpeHR1cmUgPSBmaXh0dXJlcy5yZWFkICdyb3N0ZXIvcmVtb3ZlLnhtbCdcbiAgICAgIGppZCA9ICdjb250YWN0dG9yZW1vdmVqaWQnXG4gICAgICBzdGFuemEgPSBzdHJvcGhlWWFob29HYXRld2F5LmdldFJlbW92ZVN0YW56YSBqaWRcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgZGVzY3JpYmUgJyNnZXRQcmVzZW5jZVN1YnNjcmlwdGlvblN0YW56YSgpJywgLT5cblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciBwcmVzZW5jZSBcXCdzdWJzY3JpYmVcXCcgdG8gYSB1c2VyJywgLT5cbiAgICAgIGZpeHR1cmUgPSBcIjxwcmVzZW5jZSB4bWxucz0namFiYmVyOmNsaWVudCcgdG89J2Zha2VqaWQnIHR5cGU9J3N1YnNjcmliZScvPlwiXG4gICAgICBqaWQgPSBcImZha2VqaWRcIlxuICAgICAgc3RhbnphID0gc3Ryb3BoZVlhaG9vR2F0ZXdheS5nZXRQcmVzZW5jZVN1YnNjcmlwdGlvblN0YW56YSBqaWQsIFByZXNlbmNlVHlwZS5TVUJTQ1JJQkVcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHN0YW56YSBmb3IgcHJlc2VuY2UgXFwnc3Vic2NyaWJlZFxcJyB0byBhIHVzZXInLCAtPlxuICAgICAgZml4dHVyZSA9IFwiPHByZXNlbmNlIHhtbG5zPSdqYWJiZXI6Y2xpZW50JyB0bz0nZmFrZWppZCcgdHlwZT0nc3Vic2NyaWJlZCcvPlwiXG4gICAgICBqaWQgPSBcImZha2VqaWRcIlxuICAgICAgc3RhbnphID0gc3Ryb3BoZVlhaG9vR2F0ZXdheS5nZXRQcmVzZW5jZVN1YnNjcmlwdGlvblN0YW56YSBqaWQsIFByZXNlbmNlVHlwZS5TVUJTQ1JJQkVEXG4gICAgICBzdGFuemEuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgU3Ryb3BoZS5CdWlsZGVyXG4gICAgICBzdGFuemEudG9TdHJpbmcoKS5zaG91bGQuZXF1YWwgdHJpbUZpeHR1cmUgZml4dHVyZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBzdGFuemEgZm9yIHByZXNlbmNlIFxcJ3Vuc3Vic2NyaWJlXFwnIHRvIGEgdXNlcicsIC0+XG4gICAgICBmaXh0dXJlID0gXCI8cHJlc2VuY2UgeG1sbnM9J2phYmJlcjpjbGllbnQnIHRvPSdmYWtlamlkJyB0eXBlPSd1bnN1YnNjcmliZScvPlwiXG4gICAgICBqaWQgPSBcImZha2VqaWRcIlxuICAgICAgc3RhbnphID0gc3Ryb3BoZVlhaG9vR2F0ZXdheS5nZXRQcmVzZW5jZVN1YnNjcmlwdGlvblN0YW56YSBqaWQsIFByZXNlbmNlVHlwZS5VTlNVQlNDUklCRVxuICAgICAgc3RhbnphLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIFN0cm9waGUuQnVpbGRlclxuICAgICAgc3RhbnphLnRvU3RyaW5nKCkuc2hvdWxkLmVxdWFsIHRyaW1GaXh0dXJlIGZpeHR1cmVcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgc3RhbnphIGZvciBwcmVzZW5jZSBcXCd1bnN1YnNjcmliZWRcXCcgdG8gYSB1c2VyJywgLT5cbiAgICAgIGZpeHR1cmUgPSBcIjxwcmVzZW5jZSB4bWxucz0namFiYmVyOmNsaWVudCcgdG89J2Zha2VqaWQnIHR5cGU9J3Vuc3Vic2NyaWJlZCcvPlwiXG4gICAgICBqaWQgPSBcImZha2VqaWRcIlxuICAgICAgc3RhbnphID0gc3Ryb3BoZVlhaG9vR2F0ZXdheS5nZXRQcmVzZW5jZVN1YnNjcmlwdGlvblN0YW56YSBqaWQsIFByZXNlbmNlVHlwZS5VTlNVQlNDUklCRURcbiAgICAgIHN0YW56YS5zaG91bGQuYmUuYW4uaW5zdGFuY2VvZiBTdHJvcGhlLkJ1aWxkZXJcbiAgICAgIHN0YW56YS50b1N0cmluZygpLnNob3VsZC5lcXVhbCB0cmltRml4dHVyZSBmaXh0dXJlXG4iLCJyZXF1aXJlICdzcGVjL3NwZWNfaGVscGVyJ1xuXG4jIEFkZCBhbnkgc3BlYyBmaWxlcyB0byB0aGlzIHN1aXRlLlxuZGVzY3JpYmUgJ0Nvbm5lY3Rpb24gU3VpdGUnLCAtPlxuICByZXF1aXJlICdzcGVjL2Nvbm5lY3Rpb25fc3BlYydcbiAgcmVxdWlyZSAnc3BlYy9jb21wb25lbnRzL3Jvc3Rlcl9zcGVjJ1xuICByZXF1aXJlICdzcGVjL2NvbXBvbmVudHMvc3RvcmFnZV9zcGVjJ1xuICByZXF1aXJlICdzcGVjL2NvbXBvbmVudHMvbXVjX3NwZWMnXG4gIHJlcXVpcmUgJ3NwZWMvY29tcG9uZW50cy9ibG9ja2xpc3Rfc3BlYydcbiAgcmVxdWlyZSAnc3BlYy9jb21wb25lbnRzL21lc3NhZ2luZ19zcGVjJ1xuICByZXF1aXJlICdzcGVjL2NvbXBvbmVudHMvZ2F0ZXdheV9zcGVjJ1xuICByZXF1aXJlICdzcGVjL3N0cm9waGUvc3Ryb3BoZV9kaXNjb19zcGVjJ1xuICByZXF1aXJlICdzcGVjL3N0cm9waGUvc3Ryb3BoZV9yb3N0ZXJfc3BlYydcbiAgcmVxdWlyZSAnc3BlYy9zdHJvcGhlL3N0cm9waGVfbXVjX3NwZWMnXG4gIHJlcXVpcmUgJ3NwZWMvc3Ryb3BoZS9zdHJvcGhlX3N0b3JhZ2Vfc3BlYydcbiAgcmVxdWlyZSAnc3BlYy9zdHJvcGhlL3N0cm9waGVfYmxvY2tsaXN0X3NwZWMnXG4gIHJlcXVpcmUgJ3NwZWMvc3Ryb3BoZS9zdHJvcGhlX21lc3NhZ2luZ19zcGVjJ1xuICAjIHJlcXVpcmUgJ3NwZWMvc3Ryb3BoZS9zdHJvcGhlX3lhaG9vX3NwZWMnXG4gIHJlcXVpcmUgJ3NwZWMvc3Ryb3BoZS9zdHJvcGhlX3ByZXNlbmNlX3NwZWMnXG4gIHJlcXVpcmUgJ3NwZWMvc3Ryb3BoZS9zdHJvcGhlX2lvX3NwZWMnXG4iLCJyZXF1aXJlICdzcGVjL3NwZWNfaGVscGVyJ1xuXG4jIEFkZCBhbnkgc3BlYyBmaWxlcyB0byB0aGlzIHN1aXRlLlxuZGVzY3JpYmUgJ0V2ZW50cyBTdWl0ZScsIC0+XG4gIHJlcXVpcmUgJ3NwZWMvZXZlbnRzL2V2ZW50c19zcGVjJ1xuICByZXF1aXJlICdzcGVjL2V2ZW50cy9ldmVudF9tYW5hZ2VyX3NwZWMnXG4gIHJlcXVpcmUgJ3NwZWMvZXZlbnRzL2V2ZW50X2hhbmRsZXJfc3BlYydcbiAgcmVxdWlyZSAnc3BlYy9ldmVudHMvZXZlbnRfZmlsdGVyc19zcGVjJ1xuIiwicmVxdWlyZSAnc3BlYy9zcGVjX2hlbHBlcidcblxuIyBBZGQgYW55IHNwZWMgZmlsZXMgdG8gdGhpcyBzdWl0ZS5cbmRlc2NyaWJlICdVdGlsJywgLT5cbiAgcmVxdWlyZSAnc3BlYy91dGlsL3V0aWxzX3NwZWMnXG4gIHJlcXVpcmUgJ3NwZWMvdXRpbC9saW1pdF9zcGVjJ1xuICByZXF1aXJlICdzcGVjL3V0aWwvcmF0ZV9saW1pdGVyX3NwZWMnXG4gIHJlcXVpcmUgJ3NwZWMvdXRpbC9yZXRyeWVyX3NwZWMnXG4gIHJlcXVpcmUgJ3NwZWMvdXRpbC9tYXRjaGVyc19zcGVjJ1xuIiwie18sIHNpbm9ufSA9IHJlcXVpcmUgJ3NwZWMvc3BlY19oZWxwZXInXG5fLm1peGluIHJlcXVpcmUgJ3V0aWwvbGltaXQnXG5cbmRlc2NyaWJlICdfLmxpbWl0KCknLCAtPlxuXG4gIEVSUk9SX0RFRkFVTFQgPSBudWxsXG4gIEVSUk9SX01BWF8wID0gbnVsbFxuICBFUlJPUl9DQUxMX01BWF9JTkRFRklOSVRFID0gbnVsbFxuXG4gIGZ1bmMgPSBudWxsXG4gIGVycm9yTXNnID0gbnVsbFxuICBjbG9jayA9IG51bGxcblxuICAjIGhlbHBlciBmdW5jdGlvbiB0byBsb29wIHRocm91Z2ggYW5kIHRlc3QgbXVsdGlwbGUgY2FsbHMgdG8gdGhlIHJhdGUgbGltaXRlZCBmdW5jdGlvblxuICBhc3NlcnRDYWxscyA9IChmdW5jLCBsaW1pdGVkRnVuYywgY2FsbHMsIGN1c3RvbUVycm9yTXNnID0gZXJyb3JNc2cpIC0+XG4gICAgIyBsb29wIHRocm91Z2ggYW4gYXJyYXkgb2YgY2FsbHNcbiAgICBmb3IgY2FsbCwgaSBpbiBjYWxsc1xuICAgICAgW21vbWVudCwgcGFzc10gPSBjYWxsXG4gIFxuICAgICAgaWYgcGFzc1xuICAgICAgICAjIHRlc3QgdGhlIGNhbGxzIGV4cGVjdGVkIHRvIHBhc3NcbiAgICAgICAgbGltaXRlZEZ1bmMobW9tZW50KS5zaG91bGQuZXF1YWwgbW9tZW50XG4gICAgICAgIGZ1bmMud2l0aEFyZ3MobW9tZW50KS5zaG91bGQuaGF2ZS5iZWVuLmNhbGxlZE9uY2VcbiAgICAgIGVsc2VcbiAgICAgICAgIyB0ZXN0IHRoZSBjYWxscyBleHBlY3RlZCB0byBmYWlsXG4gICAgICAgIGxpbWl0ZWRGdW5jKG1vbWVudCkuc2hvdWxkLmVxbCBuZXcgRXJyb3IgY3VzdG9tRXJyb3JNc2dcbiAgICAgICAgZnVuYy53aXRoQXJncyhtb21lbnQpLnNob3VsZC5ub3QuaGF2ZS5iZWVuLmNhbGxlZFxuXG4gICAgICBpZiBuZXh0ID0gY2FsbHNbaSArIDFdXG4gICAgICAgIGNsb2NrLnRpY2sgbmV4dFswXSAtIG1vbWVudFxuXG4gIGJlZm9yZSAtPlxuICAgIEVSUk9SX0RFRkFVTFQgPSBcIllvdSBoYXZlIGV4Y2VlZGVkIHRoZSBudW1iZXIgb2YgYWxsb3dhYmxlIGZ1bmN0aW9uIGNhbGxzXG4gICAgICBmb3IgdGhpcyB0aW1lIHBlcmlvZFwiXG4gICAgRVJST1JfTUFYXzAgPSBcIlRoZSBhbGxvd2FibGUgbnVtYmVyIG9mIGZ1bmN0aW9uIGNhbGxzIGlzIDBcIlxuICAgIEVSUk9SX0NBTExfTUFYX0lOREVGSU5JVEUgPSBcIllvdSBoYXZlIGV4Y2VlZGVkIHRoZSBudW1iZXIgb2YgYWxsb3dhYmxlIGZ1bmN0aW9uIGNhbGxzXCJcblxuICBhZnRlciAtPlxuICAgIEVSUk9SX0RFRkFVTFQgPSBudWxsXG4gICAgRVJST1JfTUFYXzAgPSBudWxsXG4gICAgRVJST1JfQ0FMTF9NQVhfSU5ERUZJTklURSA9IG51bGxcbiAgXG4gIGJlZm9yZUVhY2ggLT5cbiAgICBmdW5jID0gc2lub24uc3B5IChhcmcpIC0+IGFyZ1xuICAgIGVycm9yTXNnID0gRVJST1JfREVGQVVMVFxuICAgIGNsb2NrID0gc2lub24udXNlRmFrZVRpbWVycygpXG4gIFxuICBhZnRlckVhY2ggLT5cbiAgICBmdW5jLnJlc2V0KClcbiAgICBjbG9jay5yZXN0b3JlKClcbiAgICBlcnJvck1zZyA9IG51bGxcblxuICBpdCAnc2hvdWxkIHByZXZlbnQgYWxsIGNhbGxzIGlmIGBtYXhgIGlzIDAnLCAtPlxuICAgIGxpbWl0ZWRGdW5jID0gXy5saW1pdCBmdW5jLCBtYXg6IDBcbiAgICBlcnJvck1zZyA9IEVSUk9SX01BWF8wXG4gICAgbGltaXRlZEZ1bmMoMSkuc2hvdWxkLmVxbCBuZXcgRXJyb3IgZXJyb3JNc2dcbiAgICBmdW5jLnNob3VsZC5ub3QuaGF2ZS5iZWVuLmNhbGxlZE9uY2VcblxuICBpdCAnc2hvdWxkIGFsbG93IGEgbGltaXRlZCBudW1iZXIgb2YgY2FsbHMgdG8gYSBmdW5jdGlvbiB3aXRoaW4gYSBzcGVjaWZpZWQgdGltZScsIC0+XG4gICAgbGltaXRlZEZ1bmMgPSBfLmxpbWl0IGZ1bmNcbiAgICBsaW1pdGVkRnVuYygxKS5zaG91bGQuZXF1YWwgMVxuICAgIGZ1bmMuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRPbmNlXG5cbiAgaXQgJ3Nob3VsZCBsaW1pdCB0aGUgbnVtYmVyIG9mIGZ1bmN0aW9uIGNhbGxzIHdpdGhpbiBhIHNwZWNpZmllZCB0aW1lJywgLT5cbiAgICBsaW1pdGVkRnVuYyA9IF8ubGltaXQgZnVuY1xuICAgIGxpbWl0ZWRGdW5jKDEpLnNob3VsZC5lcXVhbCAxXG4gICAgbGltaXRlZEZ1bmMoMikuc2hvdWxkLmVxbCBuZXcgRXJyb3IgZXJyb3JNc2dcbiAgICBmdW5jLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZVxuXG4gIGl0ICdzaG91bGQgYWxsb3cgYSBsaW1pdGVkIG51bWJlciBvZiBjYWxscyB0byBhIGZ1bmN0aW9uIHdpdGhpbiBhIHNwZWNpZmllZCB0aW1lJywgLT5cbiAgICBsaW1pdGVkRnVuYyA9IF8ubGltaXQgZnVuYywgbWF4OiAyLCB0aW1lOiAxMDAwXG4gICAgbGltaXRlZEZ1bmMoMSkuc2hvdWxkLmVxdWFsIDFcbiAgICBsaW1pdGVkRnVuYygyKS5zaG91bGQuZXF1YWwgMlxuICAgIGZ1bmMuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRUd2ljZVxuICBcbiAgaXQgJ3Nob3VsZCBsaW1pdCB0aGUgZnVuY3Rpb24gY2FsbHMgd2l0aGluIGEgc3BlY2lmaWVkIHRpbWUnLCAtPlxuICAgIGxpbWl0ZWRGdW5jID0gXy5saW1pdCBmdW5jLCBtYXg6IDIsIHRpbWU6IDEwMDBcbiAgICBsaW1pdGVkRnVuYygxKS5zaG91bGQuZXF1YWwgMVxuICAgIGxpbWl0ZWRGdW5jKDIpLnNob3VsZC5lcXVhbCAyXG4gICAgbGltaXRlZEZ1bmMoMykuc2hvdWxkLmVxbCBuZXcgRXJyb3IgZXJyb3JNc2dcblxuICAgIGZ1bmMuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRUd2ljZVxuICAgIGZ1bmMuZmlyc3RDYWxsLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkV2l0aCAxXG4gICAgZnVuYy5zZWNvbmRDYWxsLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkV2l0aCAyXG5cbiAgaXQgJ3Nob3VsZCBhbGxvdyBtdWx0aXBsZSBjYWxscyBhZnRlciB0aGUgdGltZSBwZXJpb2QgaGFzIGVsYXBzZWQnLCAtPlxuICAgIGxpbWl0ZWRGdW5jID0gXy5saW1pdCBmdW5jLCBtYXg6IDEsIHRpbWU6IDEwMDBcbiAgICBsaW1pdGVkRnVuYygxKS5zaG91bGQuZXF1YWwgMVxuXG4gICAgY2xvY2sudGljayAxNTAwXG4gICAgbGltaXRlZEZ1bmMoMikuc2hvdWxkLmVxdWFsIDJcbiAgICBmdW5jLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkVHdpY2VcbiBcbiAgaXQgJ3Nob3VsZCByYXRlIGxpbWl0IGNhbGxzIG92ZXIgdGltZScsIC0+XG4gICAgY2FsbHMgPSBbWzAsIHRydWVdLCBbNTAwLCB0cnVlXSwgWzYwMCwgZmFsc2VdLCBbODAwLCBmYWxzZV0sIFsxMTAwLCB0cnVlXSxcbiAgICAgIFsxMzAwLCB0cnVlXSwgWzE1MDAsIGZhbHNlXSwgWzIyMDAsIHRydWVdLCBbMzUwMCwgdHJ1ZV0sIFs1MDAwLCB0cnVlXSxcbiAgICAgIFs1MzAwLCB0cnVlXSwgWzU1MDAsIGZhbHNlXV1cblxuICAgIGxpbWl0ZWRGdW5jID0gXy5saW1pdCBmdW5jLCBtYXg6IDIsIHRpbWU6IDEwMDBcbiAgICBhc3NlcnRDYWxscyBmdW5jLCBsaW1pdGVkRnVuYywgY2FsbHNcblxuICBpdCAnc2hvdWxkIHJhdGUgbGltaXQgYSBmdW5jdGlvbiBwcmVjaXNlbHknLCAtPlxuICAgIGNhbGxzID0gW1swLCB0cnVlXSwgWzEwMDAsIHRydWVdLCBbMzAwMCwgdHJ1ZV1dXG5cbiAgICBsaW1pdGVkRnVuYyA9IF8ubGltaXQgZnVuYywgbWF4OiAxLCB0aW1lOiAxMDAwXG4gICAgYXNzZXJ0Q2FsbHMgZnVuYywgbGltaXRlZEZ1bmMsIGNhbGxzXG4gICAgXG4gIGRlc2NyaWJlICdyZXR1cm4gdmFsdWVzJywgLT5cbiAgXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBmdW5jdGlvbicsIC0+XG4gICAgICBfLmxpbWl0KGZ1bmMpLnNob3VsZC5iZS5hICdmdW5jdGlvbidcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgd3JhcHBlZCB2ZXJzaW9uIG9mIHRoZSBzYW1lIGZ1bmMgcGFzc2VkIGluJywgLT5cbiAgICAgIGxpbWl0ZWRGdW5jID0gXy5saW1pdCBmdW5jXG4gICAgICBsaW1pdGVkRnVuYyAxLCAyXG4gICAgICBmdW5jLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZS5jYWxsZWRXaXRoIDEsIDJcblxuICBkZXNjcmliZSAnc3BlY2lmeWluZyBvcHRpb24gcHJvcGVydGllcycsIC0+XG4gIFxuICAgIGl0ICdzaG91bGQgYWNjZXB0IGNvbnRleHQgdGhhdCBpcyBwYXNzZWQgaW4nLCAtPlxuICAgICAgb2JqID0gcHJvcDogJ3ZhbCdcbiAgICAgIHNweSA9IHNpbm9uLnNweSAoYXJnKSAtPlxuICAgICAgICB0aGlzLnNob3VsZC5lcXVhbCBvYmpcbiAgICAgICAgYXJnXG5cbiAgICAgIGxpbWl0ZWRGdW5jID0gXy5saW1pdCBzcHksIGNvbnRleHQ6IG9ialxuICAgICAgbGltaXRlZEZ1bmMoMSkuc2hvdWxkLmVxdWFsIDFcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2UnLCAtPlxuICAgICAgbWVzc2FnZSA9IFwiWW91IGNhbGxlZCBpdCB0b28gbWFueSB0aW1lcyFcIlxuICAgICAgbGltaXRlZEZ1bmMgPSBfLmxpbWl0IGZ1bmMsIGVycm9yTWVzc2FnZTogbWVzc2FnZVxuICAgICAgbGltaXRlZEZ1bmMoMSkuc2hvdWxkLmVxdWFsIDFcbiAgICAgIGxpbWl0ZWRGdW5jKDIpLnNob3VsZC5lcWwgbmV3IEVycm9yIG1lc3NhZ2VcbiAgICAgIFxuICAgICAgZnVuYy5zaG91bGQuaGF2ZS5iZWVuLmNhbGxlZE9uY2UuY2FsbGVkV2l0aCAxXG5cbiAgZGVzY3JpYmUgJ2ludmFsaWQgb3B0aW9ucycsIC0+XG5cbiAgICBpdCAnc2hvdWxkIGRlZmF1bHQgdG8gYG1heDogMWAgd2hlbiByZWNlaXZpbmcgYSBuZWdhdGl2ZSB2YWx1ZScsIC0+XG4gICAgICBsaW1pdGVkRnVuYyA9IF8ubGltaXQgZnVuYywgbWF4OiAtMSwgdGltZTogMTAwMFxuICAgICAgbGltaXRlZEZ1bmMoMSkuc2hvdWxkLmVxdWFsIDFcbiAgICAgIGxpbWl0ZWRGdW5jKDIpLnNob3VsZC5lcWwgRXJyb3IgZXJyb3JNc2dcbiAgICAgIGZ1bmMuc2hvdWxkLmhhdmUuYmVlbi5jYWxsT25jZVxuXG4gICAgaXQgJ3Nob3VsZCBkcm9wIGZsb2F0IHZhbHVlcyBmb3IgbWF4IHRpbWUnLCAtPlxuICAgICAgbGltaXRlZEZ1bmMgPSBfLmxpbWl0IGZ1bmMsIG1heDogMi44LCB0aW1lOiAxMDAwXG4gICAgICBsaW1pdGVkRnVuYygxKS5zaG91bGQuZXF1YWwgMVxuICAgICAgbGltaXRlZEZ1bmMoMikuc2hvdWxkLmVxdWFsIDJcbiAgICAgIGxpbWl0ZWRGdW5jKDMpLnNob3VsZC5lcWwgRXJyb3IgZXJyb3JNc2dcbiAgICAgIGZ1bmMuc2hvdWxkLmhhdmUuYmVlbi5jYWxsT25jZVxuXG4gICAgaXQgJ3Nob3VsZCBkZWZhdWx0IHRvIGB0aW1lOiAxMDAwYCB3aGVuIHJlY2VpdmluZyBhIG5lZ2F0aXZlIHZhbHVlJywgLT5cbiAgICAgIGNhbGxzID0gW1swLCB0cnVlXSwgWzUwMCwgZmFsc2VdLCBbMTAwMCwgdHJ1ZV0sIFszMDAwLCB0cnVlXV1cbiAgICAgIGxpbWl0ZWRGdW5jID0gXy5saW1pdCBmdW5jLCBtYXg6IDEsIHRpbWU6IC01MDAwXG4gICAgICBhc3NlcnRDYWxscyBmdW5jLCBsaW1pdGVkRnVuYywgY2FsbHNcblxuICAgIGl0ICdzaG91bGQgZHJvcCBmbG9hdCB2YWx1ZXMgZm9yIHRpbWUnLCAtPlxuICAgICAgY2FsbHMgPSBbWzAsIHRydWVdLCBbMTAwMCwgZmFsc2VdLCBbMjAwMCwgdHJ1ZV0sIFs0MDAwLCB0cnVlXV1cbiAgICAgIGxpbWl0ZWRGdW5jID0gXy5saW1pdCBmdW5jLCBtYXg6IDEsIHRpbWU6IDIwMDAuNVxuICAgICAgYXNzZXJ0Q2FsbHMgZnVuYywgbGltaXRlZEZ1bmMsIGNhbGxzXG5cbiAgZGVzY3JpYmUgJ211bHRpcGxlIGluc3RhbmNlcyBvZiByYXRlIGxpbWl0ZWQgZnVuY3Rpb25zJywgLT5cblxuICAgIGZ1bmMyID0gbnVsbFxuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgZnVuYzIgPSBzaW5vbi5zcHkgKGFyZykgLT4gYXJnXG5cbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIGZ1bmMyLnJlc2V0KClcblxuICAgIGl0ICdzaG91bGQgcmF0ZSBsaW1pdCBzZXBhcmF0ZWx5IGZvciBkaWZmZXJlbnQgZnVuY3Rpb25zJywgLT5cbiAgICAgIGNhbGxzMSA9IFtbMCwgdHJ1ZV0sIFsxMDAwLCB0cnVlXSwgWzE1MDAsIGZhbHNlXSwgWzIwMDAsIHRydWVdXVxuICAgICAgbGltaXRlZEZ1bmMxID0gXy5saW1pdCBmdW5jLCBtYXg6IDEsIHRpbWU6IDEwMDBcbiAgICAgIGFzc2VydENhbGxzIGZ1bmMsIGxpbWl0ZWRGdW5jMSwgY2FsbHMxXG4gICAgICBcbiAgICAgIGNhbGxzMiA9IFtbMCwgdHJ1ZV0sIFszMDAsIHRydWVdLCBbNjAwLCB0cnVlXSwgWzkwMCwgZmFsc2VdLCBbMTAwMCwgdHJ1ZV1dXG4gICAgICBsaW1pdGVkRnVuYzIgPSBfLmxpbWl0IGZ1bmMyLCBtYXg6IDMsIHRpbWU6IDEwMDBcbiAgICAgIGFzc2VydENhbGxzIGZ1bmMyLCBsaW1pdGVkRnVuYzIsIGNhbGxzMlxuXG4gIGRlc2NyaWJlICdsaW1pdGluZyBhIGZ1bmN0aW9uIGluZGVmaW5pdGVseScsIC0+XG5cbiAgICBpdCAnc2hvdWxkIG5ldmVyIHJlc2V0IHRoZSB0aW1lciBvbmNlIHRoZSBtYXggY2FsbHMgYXJlIHJlYWNoZWQnLCAtPlxuICAgICAgY2FsbHMgPSBbWzAsIHRydWVdLCBbNTAwLCB0cnVlXSwgWzEwMDAsIGZhbHNlXSwgWzMwMDAsIGZhbHNlXSwgWzEwMDAwLCBmYWxzZV1dXG4gICAgICBsaW1pdGVkRnVuYyA9IF8ubGltaXQgZnVuYywgbWF4OiAyLCB0aW1lOiAwXG4gICAgICBlcnJvck1zZyA9IEVSUk9SX0NBTExfTUFYX0lOREVGSU5JVEVcbiAgICAgIGFzc2VydENhbGxzIGZ1bmMsIGxpbWl0ZWRGdW5jLCBjYWxscywgZXJyb3JNc2dcblxuICBkZXNjcmliZSAncmV1c2luZyBfLmxpbWl0ICcsIC0+XG5cbiAgICBpdCAnc2hvdWxkIGFsbG93IGZvciByYXRlIGxpbWl0aW5nIG9mIHRoZSBzYW1lIGZ1bmN0aW9uIG11bHRpcGxlIHRpbWVzJywgLT5cbiAgICAgIGxpbWl0ZWRGdW5jMSA9IF8ubGltaXQgZnVuYywgbWF4OiAxXG4gICAgICBsaW1pdGVkRnVuYzIgPSBfLmxpbWl0IGZ1bmMsIG1heDogM1xuXG4gIGRlc2NyaWJlICduZXN0aW5nIChmdXJ0aGVyIGxpbWl0aW5nKSBhbHJlYWR5IGxpbWl0ZWQgZnVuY3Rpb25zJywgLT5cblxuICAgIGl0ICdzaG91bGQgYWxsb3cgZm9yIGxpbWl0aW5nIGFuIGFscmVhZHkgbGltaXRlZCBmdW5jdGlvbicsIC0+XG4gICAgICBsaW1pdGVkRnVuYzEgPSBfLmxpbWl0IGZ1bmMsIG1heDogMSwgZXJyb3JNZXNzYWdlOiBcIkVycm9yMVwiXG4gICAgICBsaW1pdGVkRnVuYzIgPSBfLmxpbWl0IGxpbWl0ZWRGdW5jMSwgbWF4OiAxLCBlcnJvck1lc3NhZ2U6IFwiRXJyb3IyXCJcbiAgICAgIGxpbWl0ZWRGdW5jMigxKS5zaG91bGQuZXF1YWwgMVxuICAgICAgbGltaXRlZEZ1bmMyKDIpLnNob3VsZC5lcWwgbmV3IEVycm9yIFwiRXJyb3IyXCJcblxuICAgIGl0ICdzaG91bGQgdXNlIG5lc3RlZCBsaW1pdGluZyBhbmQgaG9ub3IgdGhlIHN0cmljdGVyIGxpbWl0IHdoZW4gZmlyc3QnLCAtPlxuICAgICAgbGltaXRlZEZ1bmMxID0gXy5saW1pdCBmdW5jLCBtYXg6IDEsIGVycm9yTWVzc2FnZTogXCJFcnJvcjFcIlxuICAgICAgbGltaXRlZEZ1bmMyID0gXy5saW1pdCBsaW1pdGVkRnVuYzEsIG1heDogMiwgZXJyb3JNZXNzYWdlOiBcIkVycm9yMlwiXG4gICAgICBsaW1pdGVkRnVuYzIoMSkuc2hvdWxkLmVxdWFsIDFcbiAgICAgIGxpbWl0ZWRGdW5jMigyKS5zaG91bGQuZXFsIG5ldyBFcnJvciBcIkVycm9yMVwiXG5cbiAgICBpdCAnc2hvdWxkIHVzZSBuZXN0ZWQgbGltaXRpbmcgYW5kIGhvbm9yIHRoZSBzdHJpY3RlciBsaW1pdCB3aGVuIHNlY29uZCcsIC0+XG4gICAgICBsaW1pdGVkRnVuYzEgPSBfLmxpbWl0IGZ1bmMsIG1heDogMiwgZXJyb3JNZXNzYWdlOiBcIkVycm9yMVwiXG4gICAgICBsaW1pdGVkRnVuYzIgPSBfLmxpbWl0IGxpbWl0ZWRGdW5jMSwgbWF4OiAxLCBlcnJvck1lc3NhZ2U6IFwiRXJyb3IyXCJcbiAgICAgIGxpbWl0ZWRGdW5jMigxKS5zaG91bGQuZXF1YWwgMVxuICAgICAgbGltaXRlZEZ1bmMyKDIpLnNob3VsZC5lcWwgbmV3IEVycm9yIFwiRXJyb3IyXCJcbiIsIntfLCBzaW5vbn0gPSByZXF1aXJlICdzcGVjL3NwZWNfaGVscGVyJ1xuTWF0Y2hlcnMgPSByZXF1aXJlICd1dGlsL21hdGNoZXJzJ1xuXG5kZXNjcmliZSAnTWF0Y2hlcnMnLCAtPlxuICAgIFxuICBkZXNjcmliZSAnLmlzR3JvdXBjaGF0KCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgaWYgcGFzc2VkIG5vdGhpbmcnLCAtPlxuICAgICAgTWF0Y2hlcnMuaXNHcm91cGNoYXQoKS5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBhbiBlbXB0eSBzdHJpbmcnLCAtPlxuICAgICAgTWF0Y2hlcnMuaXNHcm91cGNoYXQoJycpLnNob3VsZC5iZS5mYWxzZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgZm9yIG51bGwnLCAtPlxuICAgICAgTWF0Y2hlcnMuaXNHcm91cGNoYXQobnVsbCkuc2hvdWxkLmJlLmZhbHNlXG5cbiAgICBpdCAnc2hvdWxkIGRldGVjdCByZXR1cm4gZmFsc2UgZm9yIG5vbi1jaGF0cm9vbSB0ZXh0IHZhbHVlcycsIC0+XG4gICAgICByZXN1bHQgPSBNYXRjaGVycy5pc0dyb3VwY2hhdCAnYWRzZmFzZGYnXG5cbiAgICAgIHJlc3VsdC5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgZGV0ZWN0IHJldHVybiBmYWxzZSBmb3Igbm9uLWNoYXRyb29tIG51bWVyaWMgdmFsdWVzJywgLT5cbiAgICAgIHJlc3VsdCA9IE1hdGNoZXJzLmlzR3JvdXBjaGF0ICcxMjM0NTYnXG5cbiAgICAgIHJlc3VsdC5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRydWUgaWYgcGFzc2VkIGFuIGlkIGZvciBhIG1hbmFnZWQgY2hhdHJvb20gaWQgKFdDUCknLCAtPlxuICAgICAgcmVzdWx0ID0gTWF0Y2hlcnMuaXNHcm91cGNoYXQgJ0BsZWdhY3ljaGF0LnJvb21hc2RmYXNkZmFzJ1xuXG4gICAgICByZXN1bHQuc2hvdWxkLmJlLnRydWVcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRydWUgaWYgcGFzc2VkIGFuIGlkIGZvciBhIFhNUFAgZ3JvdXBjaGF0IGlkJywgLT5cbiAgICAgIHJlc3VsdCA9IE1hdGNoZXJzLmlzR3JvdXBjaGF0ICdAY29uZmVyZW5jZS5hc2RmYXNkZmFzJ1xuXG4gICAgICByZXN1bHQuc2hvdWxkLmJlLnRydWVcblxuICBkZXNjcmliZSAnLmlzTWFuYWdlZEdyb3VwY2hhdCgpJywgLT5cblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIGlmIHBhc3NlZCBub3RoaW5nJywgLT5cbiAgICAgIE1hdGNoZXJzLmlzTWFuYWdlZEdyb3VwY2hhdCgpLnNob3VsZC5iZS5mYWxzZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgZm9yIGFuIGVtcHR5IHN0cmluZycsIC0+XG4gICAgICBNYXRjaGVycy5pc01hbmFnZWRHcm91cGNoYXQoJycpLnNob3VsZC5iZS5mYWxzZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgZm9yIG51bGwnLCAtPlxuICAgICAgTWF0Y2hlcnMuaXNNYW5hZ2VkR3JvdXBjaGF0KG51bGwpLnNob3VsZC5iZS5mYWxzZVxuXG4gICAgaXQgJ3Nob3VsZCBkZXRlY3QgcmV0dXJuIGZhbHNlIGZvciBub24tY2hhdHJvb20gdGV4dCB2YWx1ZXMnLCAtPlxuICAgICAgcmVzdWx0ID0gTWF0Y2hlcnMuaXNNYW5hZ2VkR3JvdXBjaGF0ICdhZHNmYXNkZidcblxuICAgICAgcmVzdWx0LnNob3VsZC5iZS5mYWxzZVxuXG4gICAgaXQgJ3Nob3VsZCBkZXRlY3QgcmV0dXJuIGZhbHNlIGZvciBub24tY2hhdHJvb20gbnVtZXJpYyB2YWx1ZXMnLCAtPlxuICAgICAgcmVzdWx0ID0gTWF0Y2hlcnMuaXNNYW5hZ2VkR3JvdXBjaGF0ICcxMjM0NTYnXG5cbiAgICAgIHJlc3VsdC5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRydWUgaWYgcGFzc2VkIGFuIGlkIGZvciBhIG1hbmFnZWQgZ3JvdXBjaGF0IGlkIChXQ1ApJywgLT5cbiAgICAgIHJlc3VsdCA9IE1hdGNoZXJzLmlzTWFuYWdlZEdyb3VwY2hhdCAnc29tZXRoaW5nQGxlZ2FjeWNoYXQucm9vbWFzZGZhc2RmYXMnXG5cbiAgICAgIHJlc3VsdC5zaG91bGQuYmUudHJ1ZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgaWYgcGFzc2VkIGFueSBvdGhlciBpZCcsIC0+XG4gICAgICByZXN1bHQgPSBNYXRjaGVycy5pc01hbmFnZWRHcm91cGNoYXQgJ0Bhbnl0aGluZ2Vsc2UuYXNkZmFzZGZhcydcblxuICAgICAgcmVzdWx0LnNob3VsZC5iZS5mYWxzZVxuXG4gIGRlc2NyaWJlICcuaXNCaWxhdGVyYWxHcm91cGNoYXQoKScsIC0+XG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSBpZiBwYXNzZWQgbm90aGluZycsIC0+XG4gICAgICBNYXRjaGVycy5pc0JpbGF0ZXJhbEdyb3VwY2hhdCgpLnNob3VsZC5iZS5mYWxzZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgZm9yIGFuIGVtcHR5IHN0cmluZycsIC0+XG4gICAgICBNYXRjaGVycy5pc0JpbGF0ZXJhbEdyb3VwY2hhdCgnJykuc2hvdWxkLmJlLmZhbHNlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSBmb3IgbnVsbCcsIC0+XG4gICAgICBNYXRjaGVycy5pc0JpbGF0ZXJhbEdyb3VwY2hhdChudWxsKS5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgZGV0ZWN0IHJldHVybiBmYWxzZSBmb3Igbm9uLWNoYXRyb29tIHRleHQgdmFsdWVzJywgLT5cbiAgICAgIHJlc3VsdCA9IE1hdGNoZXJzLmlzQmlsYXRlcmFsR3JvdXBjaGF0ICdhZHNmYXNkZidcblxuICAgICAgcmVzdWx0LnNob3VsZC5iZS5mYWxzZVxuXG4gICAgaXQgJ3Nob3VsZCBkZXRlY3QgcmV0dXJuIGZhbHNlIGZvciBub24tY2hhdHJvb20gbnVtZXJpYyB2YWx1ZXMnLCAtPlxuICAgICAgcmVzdWx0ID0gTWF0Y2hlcnMuaXNCaWxhdGVyYWxHcm91cGNoYXQgJzEyMzQ1NidcblxuICAgICAgcmVzdWx0LnNob3VsZC5iZS5mYWxzZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSBpZiBwYXNzZWQgYW4gaWQgZm9yIGEgYmlsYXRlcmFsIGdyb3VwY2hhdCcsIC0+XG4gICAgICByZXN1bHQgPSBNYXRjaGVycy5pc0JpbGF0ZXJhbEdyb3VwY2hhdCAnc29tZXRoaW5nQGNvbmZlcmVuY2Uucm9vbWFzZGZhc2RmYXMnXG5cbiAgICAgIHJlc3VsdC5zaG91bGQuYmUudHJ1ZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgaWYgcGFzc2VkIGFueSBvdGhlciBpZCcsIC0+XG4gICAgICByZXN1bHQgPSBNYXRjaGVycy5pc0JpbGF0ZXJhbEdyb3VwY2hhdCAnQGFueXRoaW5nZWxzZS5hc2RmYXNkZmFzJ1xuXG4gICAgICByZXN1bHQuc2hvdWxkLmJlLmZhbHNlXG5cbiAgZGVzY3JpYmUgJy5pc1lhaG9vKCknLCAtPlxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgaWYgcGFzc2VkIG5vdGhpbmcnLCAtPlxuICAgICAgTWF0Y2hlcnMuaXNZYWhvbygpLnNob3VsZC5iZS5mYWxzZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgZm9yIGFuIGVtcHR5IHN0cmluZycsIC0+XG4gICAgICBNYXRjaGVycy5pc1lhaG9vKCcnKS5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBudWxsJywgLT5cbiAgICAgIE1hdGNoZXJzLmlzWWFob28obnVsbCkuc2hvdWxkLmJlLmZhbHNlXG5cbiAgICBpdCAnc2hvdWxkIGRldGVjdCByZXR1cm4gZmFsc2UgZm9yIG5vbi1jaGF0cm9vbSB0ZXh0IHZhbHVlcycsIC0+XG4gICAgICByZXN1bHQgPSBNYXRjaGVycy5pc1lhaG9vICdhZHNmYXNkZidcblxuICAgICAgcmVzdWx0LnNob3VsZC5iZS5mYWxzZVxuXG4gICAgaXQgJ3Nob3VsZCBkZXRlY3QgcmV0dXJuIGZhbHNlIGZvciBub24tY2hhdHJvb20gbnVtZXJpYyB2YWx1ZXMnLCAtPlxuICAgICAgcmVzdWx0ID0gTWF0Y2hlcnMuaXNZYWhvbyAnMTIzNDU2J1xuXG4gICAgICByZXN1bHQuc2hvdWxkLmJlLmZhbHNlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0cnVlIGlmIHBhc3NlZCBhIFlhaG9vIGVtYWlsIGFkZHJlc3MnLCAtPlxuICAgICAgcmVzdWx0ID0gTWF0Y2hlcnMuaXNZYWhvbyAnc29tZXRoaW5nQHlhaG9vLmNvbSdcblxuICAgICAgcmVzdWx0LnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0cnVlIGlmIHBhc3NlZCBhIFJvY2tldG1haWwgZW1haWwgYWRkcmVzcycsIC0+XG4gICAgICByZXN1bHQgPSBNYXRjaGVycy5pc1lhaG9vICdzb21ldGhpbmdAcm9ja2V0bWFpbC5jb20nXG5cbiAgICAgIHJlc3VsdC5zaG91bGQuYmUudHJ1ZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSBpZiBwYXNzZWQgYSBZbWFpbCBlbWFpbCBhZGRyZXNzJywgLT5cbiAgICAgIHJlc3VsdCA9IE1hdGNoZXJzLmlzWWFob28gJ3NvbWV0aGluZ0B5bWFpbC5jb20nXG5cbiAgICAgIHJlc3VsdC5zaG91bGQuYmUudHJ1ZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSBpZiBwYXNzZWQgYSBub24gLmNvbSBZYWhvbyBlbWFpbCBhZGRyZXNzJywgLT5cbiAgICAgIHJlc3VsdCA9IE1hdGNoZXJzLmlzWWFob28gJ3NvbWV0aGluZ0B5YWhvby5jby5pbCdcblxuICAgICAgcmVzdWx0LnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiB0cnVlIGlmIHBhc3NlZCBhIFlhaG9vIHN1YmRvbWFpbiBlbWFpbCBhZGRyZXNzJywgLT5cbiAgICAgIHJlc3VsdCA9IE1hdGNoZXJzLmlzWWFob28gJ3NvbWV0aGluZ0B5YWhvby5yZXVhc21iLm5ldCdcblxuICAgICAgcmVzdWx0LnNob3VsZC5iZS50cnVlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSBpZiBwYXNzZWQgYW55IG90aGVyIGlkJywgLT5cbiAgICAgIHJlc3VsdCA9IE1hdGNoZXJzLmlzWWFob28gJ0Bhbnl0aGluZ2Vsc2UuYXNkZmFzZGZhcydcblxuICAgICAgcmVzdWx0LnNob3VsZC5iZS5mYWxzZVxuICAgICAgXG4gIGRlc2NyaWJlICcuaXNOaXRyb0NvbnRhY3QoKScsIC0+XG4gICAgXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgaWYgcGFzc2VkIG5vdGhpbmcnLCAtPlxuICAgICAgTWF0Y2hlcnMuaXNOaXRyb0NvbnRhY3QoKS5zaG91bGQuYmUuZmFsc2VcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBhbiBlbXB0eSBzdHJpbmcnLCAtPlxuICAgICAgTWF0Y2hlcnMuaXNOaXRyb0NvbnRhY3QoJycpLnNob3VsZC5iZS5mYWxzZVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgZm9yIG51bGwnLCAtPlxuICAgICAgTWF0Y2hlcnMuaXNOaXRyb0NvbnRhY3QobnVsbCkuc2hvdWxkLmJlLmZhbHNlXG5cbiAgICBpdCAnc2hvdWxkIGRldGVjdCByZXR1cm4gZmFsc2UgZm9yIG5vbi10ciBqaWQgdGV4dCB2YWx1ZXMnLCAtPlxuICAgICAgcmVzdWx0ID0gTWF0Y2hlcnMuaXNOaXRyb0NvbnRhY3QgJ2Fkc2Zhc2RmJ1xuICAgICAgcmVzdWx0LnNob3VsZC5iZS5mYWxzZVxuICAgICAgXG4gICAgaXQgJ3Nob3VsZCBkZXRlY3QgcmV0dXJuIGZhbHNlIGZvciBub24tdHIgamlkIG51bWVyaWMgdmFsdWVzJywgLT5cbiAgICAgIHJlc3VsdCA9IE1hdGNoZXJzLmlzTml0cm9Db250YWN0ICcxMjM0NTYnXG4gICAgICByZXN1bHQuc2hvdWxkLmJlLmZhbHNlXG4gICAgXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSBpZiBwYXNzZWQgYW4gamlkIGZvciBhIFRSIGNvbnRhY3QgaW4gQmV0YS9BbHBoYScsIC0+XG4gICAgICByZXN1bHQgPSBNYXRjaGVycy5pc05pdHJvQ29udGFjdCAnZmlyc3QubGFzdC53aGF0ZXZlci5jb21AcmV1YXNtYi5uZXQnXG4gICAgICByZXN1bHQuc2hvdWxkLmJlLnRydWVcbiAgICBcbiAgICBpdCAnc2hvdWxkIHJldHVybiB0cnVlIGlmIHBhc3NlZCBhbiBqaWQgd2l0aCByZXNvdXJjZSBmb3IgYSBUUiBjb250YWN0IGluIEJldGEvQWxwaGEnLCAtPlxuICAgICAgcmVzdWx0ID0gTWF0Y2hlcnMuaXNOaXRyb0NvbnRhY3QgJ2ZpcnN0Lmxhc3Qud2hhdGV2ZXIuY29tQHJldWFzbWIubmV0L2VtJ1xuICAgICAgcmVzdWx0LnNob3VsZC5iZS50cnVlXG4gICAgICBcbiAgICBpdCAnc2hvdWxkIHJldHVybiB0cnVlIGlmIHBhc3NlZCBhbiBqaWQgZm9yIGEgVFIgY29udGFjdCBpbiBQcm9kJywgLT5cbiAgICAgIHJlc3VsdCA9IE1hdGNoZXJzLmlzTml0cm9Db250YWN0ICdmaXJzdC5sYXN0LndoYXRldmVyLmNvbUByZXV0ZXJzLm5ldCdcbiAgICAgIHJlc3VsdC5zaG91bGQuYmUudHJ1ZVxuICAgICAgXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gdHJ1ZSBpZiBwYXNzZWQgYW4gamlkIHdpdGggcmVzb3VyY2UgZm9yIGEgVFIgY29udGFjdCBpbiBQcm9kJywgLT5cbiAgICAgIHJlc3VsdCA9IE1hdGNoZXJzLmlzTml0cm9Db250YWN0ICdmaXJzdC5sYXN0LndoYXRldmVyLmNvbUByZXV0ZXJzLm5ldC9lbSdcbiAgICAgIHJlc3VsdC5zaG91bGQuYmUudHJ1ZVxuICAgIFxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGZhbHNlIGlmIHBhc3NlZCBhbiBqaWQgZm9yIGEgbWFuYWdlZCBncm91cGNoYXQgamlkIEJldGEvQWxwaGEnLCAtPlxuICAgICAgcmVzdWx0ID0gTWF0Y2hlcnMuaXNOaXRyb0NvbnRhY3QgJ3NvbWV0aGluZ0BsZWdhY3ljaGF0LnJldWFzbWIubmV0J1xuICAgICAgcmVzdWx0LnNob3VsZC5iZS5mYWxzZVxuICAgICAgXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgaWYgcGFzc2VkIGFuIGppZCBmb3IgYSBYTVBQIGdyb3VwY2hhdCBqaWQgQmV0YS9BbHBoYScsIC0+XG4gICAgICByZXN1bHQgPSBNYXRjaGVycy5pc05pdHJvQ29udGFjdCAnc29tZXRoaW5nQGNvbmZlcmVuY2UucmV1YXNtYi5uZXQnXG4gICAgICByZXN1bHQuc2hvdWxkLmJlLmZhbHNlXG4gICAgXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gZmFsc2UgaWYgcGFzc2VkIGFuIGppZCBmb3IgYSBtYW5hZ2VkIGdyb3VwY2hhdCBqaWQgUHJvZCcsIC0+XG4gICAgICByZXN1bHQgPSBNYXRjaGVycy5pc05pdHJvQ29udGFjdCAnc29tZXRoaW5nQGxlZ2FjeWNoYXQucmV1dGVycy5uZXQnXG4gICAgICByZXN1bHQuc2hvdWxkLmJlLmZhbHNlXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBmYWxzZSBpZiBwYXNzZWQgYW4gamlkIGZvciBhIFhNUFAgZ3JvdXBjaGF0IGppZCBQcm9kJywgLT5cbiAgICAgIHJlc3VsdCA9IE1hdGNoZXJzLmlzTml0cm9Db250YWN0ICdzb21ldGhpbmdAY29uZmVyZW5jZS5yZXV0ZXJzLm5ldCdcbiAgICAgIHJlc3VsdC5zaG91bGQuYmUuZmFsc2VcbiIsIntfLCBzaW5vbiwgZXhwZWN0fSA9IHJlcXVpcmUgJ3NwZWMvc3BlY19oZWxwZXInXG5SYXRlTGltaXRlciA9IHJlcXVpcmUgJ3V0aWwvcmF0ZV9saW1pdGVyJ1xuXG5kZXNjcmliZSAnUmF0ZUxpbWl0ZXInLCAtPlxuXG4gIHJhdGVMaW1pdGVyID0gbnVsbFxuICBmdW5jID0gbnVsbFxuICBvcHRpb25zID0gbnVsbFxuIFxuICBiZWZvcmVFYWNoIC0+XG4gICAgZnVuYyA9IHNpbm9uLnNweSAoYXJnKSAtPiBhcmdcbiAgICBvcHRpb25zID0gbWF4OiAxLCB0aW1lOiAxMDAwLCBjb250ZXh0OiB3aW5kb3csIGVycm9yTWVzc2FnZTogXCJFcnJvclwiXG4gXG4gIGFmdGVyRWFjaCAtPlxuICAgIGZ1bmMucmVzZXQoKVxuICAgIG9wdGlvbnMgPSBudWxsXG5cbiAgZGVzY3JpYmUgJyNjb25zdHJ1Y3RvcigpJywgLT5cblxuICAgIGJlZm9yZUVhY2ggLT5cbiAgICAgIHNpbm9uLnN0dWIgUmF0ZUxpbWl0ZXI6OiwgJ2FkZEFsaWFzJ1xuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICBSYXRlTGltaXRlcjo6LmFkZEFsaWFzLnJlc3RvcmUoKVxuXG4gICAgaXQgJ3Nob3VsZCBhZGQgYW4gYWxpYXMgY2FsbGVkIGBpbnZva2VgJywgLT5cbiAgICAgIHJhdGVMaW1pdGVyID0gbmV3IFJhdGVMaW1pdGVyIGZ1bmMsIG9wdGlvbnNcbiAgICAgIHJhdGVMaW1pdGVyLmFkZEFsaWFzLnNob3VsZC5oYXZlLmJlZW5cbiAgICAgICAgLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGhFeGFjdGx5ICdpbnZva2UnLCBvcHRpb25zXG5cbiAgICBpdCAnc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIHRoZSBmdW5jdGlvbiBwYXNzZWQgaW4gaXMgbnVsbCcsIC0+XG4gICAgICBleHBlY3QoLT4gbmV3IFJhdGVMaW1pdGVyIG51bGwsIG9wdGlvbnMpLnRvLnRocm93IEVycm9yXG4gICAgICBleHBlY3QoLT4gbmV3IFJhdGVMaW1pdGVyIG51bGwsIG9wdGlvbnMpLnRvLnRocm93IFJhdGVMaW1pdGVyLkVSUk9SX0ZVTkNUSU9OX01JU1NJTkdcbiAgICAgIHJhdGVMaW1pdGVyLmFkZEFsaWFzLnNob3VsZC5ub3QuaGF2ZS5iZWVuLmNhbGxlZFxuICAgICAgICBcbiAgICBpdCAnc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIHRoZSBmdW5jdGlvbiBwYXNzZWQgaW4gaXMgdW5kZWZpbmVkJywgLT5cbiAgICAgIGV4cGVjdCgtPiBuZXcgUmF0ZUxpbWl0ZXIgdW5kZWZpbmVkLCBvcHRpb25zKS50by50aHJvdyBFcnJvclxuICAgICAgZXhwZWN0KC0+IG5ldyBSYXRlTGltaXRlciB1bmRlZmluZWQsIG9wdGlvbnMpLnRvLnRocm93IFJhdGVMaW1pdGVyLkVSUk9SX0ZVTkNUSU9OX01JU1NJTkdcbiAgICAgIHJhdGVMaW1pdGVyLmFkZEFsaWFzLnNob3VsZC5ub3QuaGF2ZS5iZWVuLmNhbGxlZFxuXG4gICAgaXQgJ3Nob3VsZCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZnVuY3Rpb24gcGFzc2VkIGluIGlzIG5vdCBhIHJlYWwgZnVuY3Rpb24nLCAtPlxuICAgICAgZXhwZWN0KC0+IG5ldyBSYXRlTGltaXRlciB7fSwgb3B0aW9ucykudG8udGhyb3cgRXJyb3JcbiAgICAgIGV4cGVjdCgtPiBuZXcgUmF0ZUxpbWl0ZXIge30sIG9wdGlvbnMpLnRvLnRocm93IFJhdGVMaW1pdGVyLkVSUk9SX0ZVTkNUSU9OX01JU1NJTkdcbiAgICAgIGV4cGVjdCgtPiBuZXcgUmF0ZUxpbWl0ZXIgMSwgb3B0aW9ucykudG8udGhyb3cgRXJyb3JcbiAgICAgIGV4cGVjdCgtPiBuZXcgUmF0ZUxpbWl0ZXIgMSwgb3B0aW9ucykudG8udGhyb3cgUmF0ZUxpbWl0ZXIuRVJST1JfRlVOQ1RJT05fTUlTU0lOR1xuICAgICAgZXhwZWN0KC0+IG5ldyBSYXRlTGltaXRlciBcIjFcIiwgb3B0aW9ucykudG8udGhyb3cgRXJyb3JcbiAgICAgIGV4cGVjdCgtPiBuZXcgUmF0ZUxpbWl0ZXIgXCIxXCIsIG9wdGlvbnMpLnRvLnRocm93IFJhdGVMaW1pdGVyLkVSUk9SX0ZVTkNUSU9OX01JU1NJTkdcbiAgICAgIHJhdGVMaW1pdGVyLmFkZEFsaWFzLnNob3VsZC5ub3QuaGF2ZS5iZWVuLmNhbGxlZFxuXG4gIGRlc2NyaWJlICcjYWRkQWxpYXMoKScsIC0+XG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBzaW5vbi5zcHkgXywgJ2xpbWl0J1xuICAgICAgcmF0ZUxpbWl0ZXIgPSBuZXcgUmF0ZUxpbWl0ZXIgZnVuYywgb3B0aW9uc1xuICAgICAgXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICBfLmxpbWl0LnJlc3RvcmUoKVxuICAgICAgcmF0ZUxpbWl0ZXIgPSBudWxsXG5cbiAgICBpdCAnc2hvdWxkIHJldHVybiBhIHJhdGUgbGltaXRlZCB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbicsIC0+XG4gICAgICBhbGlhcyA9IHJhdGVMaW1pdGVyLmFkZEFsaWFzICdhbGlhczEnXG4gICAgICBfLmlzRnVuY3Rpb24oYWxpYXMpLnNob3VsZC5iZS50cnVlXG4gICAgICBcbiAgICBpdCAnc2hvdWxkIHJhdGUgbGltaXQgYSBmdW5jdGlvbiBwYXNzZWQgaW4sIHVzaW5nIGRlZmF1bHQgb3B0aW9ucycsIC0+XG4gICAgICByYXRlTGltaXRlci5hZGRBbGlhcyAnYWxpYXMxJ1xuICAgICAgXy5saW1pdC5zaG91bGQuaGF2ZS5iZWVuXG4gICAgICAgIC5jYWxsZWRUd2ljZVxuICAgICAgICAuY2FsbGVkV2l0aEV4YWN0bHkgcmF0ZUxpbWl0ZXIuaW52b2tlLCBzaW5vbi5tYXRjaFxuICAgICAgICAgIG1heDogMVxuICAgICAgICAgIHRpbWU6IDEwMDBcbiAgICAgICAgICBjb250ZXh0OiB3aW5kb3dcbiAgICAgICAgICBlcnJvck1lc3NhZ2U6IFwiRXJyb3JcIlxuXG4gICAgaXQgJ3Nob3VsZCBvdmVycmlkZSBkZWZhdWx0IHZhbHVlcyBpZiBwYXNzaW5nIGluIG5ldyBvcHRpb25zJywgLT5cbiAgICAgIG5ld09wdGlvbnMgPSBtYXg6IDIsIHRpbWU6IDIwMDAsIGNvbnRleHQ6IHRoaXMsIGVycm9yTWVzc2FnZTogXCJOZXcgRXJyb3JcIlxuICAgICAgcmF0ZUxpbWl0ZXIuYWRkQWxpYXMgJ2FsaWFzMScsIG5ld09wdGlvbnNcbiAgICAgIF8ubGltaXQuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAuY2FsbGVkVHdpY2VcbiAgICAgICAgLmNhbGxlZFdpdGhFeGFjdGx5IHJhdGVMaW1pdGVyLmludm9rZSwgc2lub24ubWF0Y2hcbiAgICAgICAgICBtYXg6IDJcbiAgICAgICAgICB0aW1lOiAyMDAwXG4gICAgICAgICAgZXJyb3JNZXNzYWdlOiBcIk5ldyBFcnJvclwiXG5cbiAgICBpdCAnc2hvdWxkIGFkZCBhIHB1YmxpYyBtZXRob2Qgd2l0aCBhIHJhdGUgbGltaXRlZCB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbicsIC0+XG4gICAgICByYXRlTGltaXRlci5hZGRBbGlhcyAnYWxpYXMxJ1xuICAgICAgcmF0ZUxpbWl0ZXIuYWxpYXMxKDEpLnNob3VsZC5lcXVhbCAxXG4gICAgICByYXRlTGltaXRlci5hbGlhczEoMikuc2hvdWxkLmVxbCBuZXcgRXJyb3Igb3B0aW9ucy5lcnJvck1lc3NhZ2VcblxuICBkZXNjcmliZSAnbXVsdGlwbGUgYWxpYXNlcyBhbmQgcmF0ZSBsaW1pdGluZycsIC0+XG5cbiAgICBvcmlnaW5hbEVycm9yTXNnID0gbnVsbFxuICAgIGFsaWFzRXJyb3JNc2cgPSBudWxsXG5cbiAgICBiZWZvcmVFYWNoIC0+XG4gICAgICBvcmlnaW5hbEVycm9yTXNnID0gXCJPcmlnaW5hbCBFcnJvclwiXG4gICAgICBhbGlhc0Vycm9yTXNnID0gXCJBbGlhcyBFcnJvclwiXG4gICAgICByYXRlTGltaXRlciA9IG5ldyBSYXRlTGltaXRlciBmdW5jLCBtYXg6IDIsIHRpbWU6IDEwMDAsIGVycm9yTWVzc2FnZTogb3JpZ2luYWxFcnJvck1zZ1xuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICBvcmlnaW5hbEVycm9yTXNnID0gbnVsbFxuICAgICAgYWxpYXNFcnJvck1zZyA9IG51bGxcblxuICAgIGl0ICdzaG91bGQgbGltaXQgdGhlIGNhbGxzIHRvIHRoZSBzdHJpY3RlciBsaW1pdGVyIHdoZW4gc3RyaWN0ZXIgaXMgZGVmYXVsdCcsIC0+XG4gICAgICBhbGlhczFPcHRpb25zID0gbWF4OiAzLCB0aW1lOiAxMDAwLCBlcnJvck1lc3NhZ2U6IGFsaWFzRXJyb3JNc2dcbiAgICAgIGFsaWFzMSA9IHJhdGVMaW1pdGVyLmFkZEFsaWFzICdhbGlhczEnLCBhbGlhczFPcHRpb25zXG4gICAgICBhbGlhczEoMSkuc2hvdWxkLmVxdWFsIDFcbiAgICAgIGFsaWFzMSgyKS5zaG91bGQuZXF1YWwgMlxuICAgICAgYWxpYXMxKDMpLnNob3VsZC5lcWwgbmV3IEVycm9yIG9yaWdpbmFsRXJyb3JNc2dcbiAgICAgXG4gICAgaXQgJ3Nob3VsZCBsaW1pdCB0aGUgY2FsbHMgdG8gdGhlIHN0cmljdGVyIGxpbWl0ZXIgd2hlbiBzdHJpY3RlciBpcyBhbiBhbGlhcycsIC0+XG4gICAgICBhbGlhczFPcHRpb25zID0gbWF4OiAxLCB0aW1lOiAxMDAwLCBlcnJvck1lc3NhZ2U6IGFsaWFzRXJyb3JNc2dcbiAgICAgIGFsaWFzMSA9IHJhdGVMaW1pdGVyLmFkZEFsaWFzICdhbGlhczEnLCBhbGlhczFPcHRpb25zXG4gICAgICBhbGlhczEoMSkuc2hvdWxkLmVxdWFsIDFcbiAgICAgIGFsaWFzMSgxKS5zaG91bGQuZXFsIG5ldyBFcnJvciBhbGlhc0Vycm9yTXNnXG5cbiAgICBpdCAnc2hvdWxkIGxpbWl0IHRoZSBjYWxscyBmcm9tIG11bHRpcGxlIGFsaWFzZXMgdG8gc3RyaWN0ZXN0IG9mIGxpbWl0cycsIC0+XG4gICAgICBhbGlhc09wdGlvbnMgPSBtYXg6IDIsIHRpbWU6IDEwMDAsIGVycm9yTWVzc2FnZTogYWxpYXNFcnJvck1zZ1xuICAgICAgYWxpYXMxID0gcmF0ZUxpbWl0ZXIuYWRkQWxpYXMgJ2FsaWFzMScsIGFsaWFzT3B0aW9uc1xuICAgICAgYWxpYXMyID0gcmF0ZUxpbWl0ZXIuYWRkQWxpYXMgJ2FsaWFzMicsIGFsaWFzT3B0aW9uc1xuXG4gICAgICBhbGlhczEoMSkuc2hvdWxkLmVxdWFsIDFcbiAgICAgIGFsaWFzMigyKS5zaG91bGQuZXF1YWwgMlxuXG4gICAgICAjIFRoaXJkIGNhbGwgZXhjZWVkcyB0aGUgbWF4IGRlZmluZWQgd2hlbiBpbnN0YW50aWF0aW5nIFJhdGVMaW1pdGVyXG4gICAgICBhbGlhczEoMykuc2hvdWxkLmVxbCBuZXcgRXJyb3Igb3JpZ2luYWxFcnJvck1zZ1xuIiwie18sIHNpbm9uLCBhc3NlcnQsIGV4cGVjdH0gPSByZXF1aXJlICdzcGVjL3NwZWNfaGVscGVyJ1xuUSA9IHJlcXVpcmUgJ3EnXG5fLm1peGluIHJlcXVpcmUgJ3V0aWwvcmV0cnllcidcblxuZGVzY3JpYmUgJ18ucmV0cnkoKScsIC0+XG5cbiAgaXQgJ3Nob3VsZCBhY2NlcHQgYSBjb250ZXh0IGZvciB0aGUgZnVuY3Rpb24gY2FsbCcsIChkb25lKSAtPlxuICAgIGNvbnRleHQgPSB7fVxuICAgIGZ1bmMgPSBzaW5vbi5zcHkgKG9iaiA9IHt9KSAtPlxuICAgICAgdGhpcy5zaG91bGQuZXF1YWwgY29udGV4dFxuICAgICAgUSgpXG5cbiAgICBzdWJqZWN0ID0gXy5yZXRyeSBmdW5jLCBjb250ZXh0OiBjb250ZXh0XG4gICAgc3ViamVjdCgpLnNob3VsZC5ldmVudHVhbGx5LmJlLmZ1bGZpbGxlZC5ub3RpZnkgZG9uZVxuXG4gIGRlc2NyaWJlICdyZXRyeWluZyBzeW5jaG9ub3VzIGZ1bmN0aW9ucycsIC0+XG5cbiAgICAjIGhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSBzaW5vbiBzcHkgdGhhdCByZXR1cm5zIHRydWUsIG9ubHkgb24gdGhlIHRoaXJkIHRpbWUgaXQncyBjYWxsZWRcbiAgICBnZXRQcm9taXNlU3B5UmV0dXJuc1RydWVPblRoaXJkQ2FsbCA9IC0+XG4gICAgICBmdW5jQ2FsbHMgPSAwXG4gICAgICBzaW5vbi5zcHkgLT4gKytmdW5jQ2FsbHMgaXMgM1xuXG4gICAgaXQgJ3Nob3VsZCBmdWxmaWxsIGEgcHJvbWlzZSBvbmNlIGl0cyBmdW5jdGlvbiBjYWxsIHN1Y2NlZWRzIG9uIHRoZSBmaXJzdCBhdHRlbXB0JywgKGRvbmUpIC0+XG4gICAgICBmdW5jID0gc2lub24uc3R1YigpLnJldHVybnMgdHJ1ZVxuXG4gICAgICBzdWJqZWN0ID0gXy5yZXRyeSBmdW5jXG5cbiAgICAgIHN1YmplY3QoKS5zaG91bGQuZXZlbnR1YWxseS5iZS5mdWxmaWxsZWQudGhlbiAtPlxuICAgICAgICBmdW5jLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZVxuICAgICAgLnNob3VsZC5ub3RpZnkgZG9uZVxuXG4gICAgaXQgJ3Nob3VsZCBmYWlsIGEgcHJvbWlzZSBvbmNlIGl0cyBmdW5jdGlvbiBjYWxsIGZhaWxzIG9uIHRoZSBmaXJzdCBhdHRlbXB0JywgKGRvbmUpIC0+XG4gICAgICBmdW5jID0gc2lub24uc3R1YigpLnJldHVybnMgZmFsc2VcblxuICAgICAgc3ViamVjdCA9IF8ucmV0cnkgZnVuY1xuXG4gICAgICBzdWJqZWN0KCkuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWQudGhlbiAtPlxuICAgICAgICBmdW5jLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZVxuICAgICAgLnNob3VsZC5ub3RpZnkgZG9uZVxuXG4gICAgaXQgJ3Nob3VsZCByZWplY3QgYSBwcm9taXNlIG9uY2UgZnVuY3Rpb24gZmFpbHMgYSBtYXggb2YgMyB0aW1lcycsIChkb25lKSAtPlxuICAgICAgZnVuYyA9IHNpbm9uLnN0dWIoKS5yZXR1cm5zIGZhbHNlXG4gICAgICBzdWJqZWN0ID0gXy5yZXRyeSBmdW5jLCBtYXg6IDNcbiAgICAgIFxuICAgICAgc3ViamVjdCgpLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkLnRoZW4gLT5cbiAgICAgICAgZnVuYy5zaG91bGQuaGF2ZS5iZWVuLmNhbGxlZFRocmljZVxuICAgICAgLnNob3VsZC5ub3RpZnkgZG9uZVxuXG4gICAgaXQgJ3Nob3VsZCBmdWxmaWxsIGEgcHJvbWlzZSBvbmNlIGl0cyBmdW5jdGlvbiBjYWxsIHN1Y2NlZWRzIG9uIHRoZSB0aGlyZCBhdHRlbXB0JywgKGRvbmUpIC0+XG4gICAgICBmdW5jID0gZ2V0UHJvbWlzZVNweVJldHVybnNUcnVlT25UaGlyZENhbGwoKVxuICAgICAgc3ViamVjdCA9IF8ucmV0cnkgZnVuYywgbWF4OiAzXG5cbiAgICAgIHN1YmplY3QoKS5zaG91bGQuZXZlbnR1YWxseS5iZS5mdWxmaWxsZWQudGhlbiAtPlxuICAgICAgICBmdW5jLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkVGhyaWNlXG4gICAgICAuc2hvdWxkLm5vdGlmeSBkb25lXG5cbiAgZGVzY3JpYmUgJ3JldHJ5aW5nIGFzeW5jaG9ub3VzIGZ1bmN0aW9ucycsIC0+XG5cbiAgICAjIGhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSBzaW5vbiBzcHkgdGhhdCByZXR1cm5zIGEgZmFpbGVkIHByb21pc2UgdHdpY2UgYmVmb3JlXG4gICAgIyByZXR1cm5pbmcgYSBmdWxmaWxsZWQgcHJvbWlzZSBvbiBpdHMgdGhpcmQgY2FsbFxuICAgIGdldFByb21pc2VTcHlGdWxmaWxsZWRPblRoaXJkQ2FsbCA9IC0+XG4gICAgICBmdW5jQ2FsbHMgPSAwXG4gICAgICBzaW5vbi5zcHkgLT5cbiAgICAgICAgaWYgKytmdW5jQ2FsbHMgaXMgMyB0aGVuIFEoKSBlbHNlIFEucmVqZWN0KClcblxuICAgIGl0ICdzaG91bGQgZnVsZmlsbCBhIHByb21pc2Ugb25jZSBpdHMgZnVuY3Rpb25hbCBjYWxsIHN1Y2NlZWRzIG9uIHRoZSBmaXJzdCBhdHRlbXB0JywgKGRvbmUpIC0+XG4gICAgICBmdW5jID0gc2lub24uc3R1YigpLnJldHVybnMgUSgpXG5cbiAgICAgIHN1YmplY3QgPSBfLnJldHJ5IGZ1bmNcblxuICAgICAgc3ViamVjdCgpLnNob3VsZC5ldmVudHVhbGx5LmJlLmZ1bGZpbGxlZC50aGVuIC0+XG4gICAgICAgIGZ1bmMuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRPbmNlXG4gICAgICAuc2hvdWxkLm5vdGlmeSBkb25lXG5cbiAgICBpdCAnc2hvdWxkIGZhaWwgYSBwcm9taXNlIG9uY2UgaXRzIGZ1bmN0aW9uYWwgY2FsbCBmYWlscyBvbiB0aGUgZmlyc3QgYXR0ZW1wdCcsIChkb25lKSAtPlxuICAgICAgZnVuYyA9IHNpbm9uLnN0dWIoKS5yZXR1cm5zIFEucmVqZWN0KClcblxuICAgICAgc3ViamVjdCA9IF8ucmV0cnkgZnVuY1xuICAgICAgXG4gICAgICBzdWJqZWN0KCkuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWQudGhlbiAtPlxuICAgICAgICBmdW5jLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZVxuICAgICAgLnNob3VsZC5ub3RpZnkgZG9uZVxuXG4gICAgaXQgJ3Nob3VsZCByZWplY3QgYSBwcm9taXNlIG9uY2UgZmFpbGVkIGNhbGxzIHJlYWNoZXMgdGhlIG1heCBvZiAzJywgKGRvbmUpIC0+XG4gICAgICBmdW5jID0gc2lub24uc3R1YigpLnJldHVybnMgUS5yZWplY3QoKVxuICAgICAgc3ViamVjdCA9IF8ucmV0cnkgZnVuYywgbWF4OiAzXG4gICAgICBcbiAgICAgIHN1YmplY3QoKS5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZC50aGVuIC0+XG4gICAgICAgIGZ1bmMuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRUaHJpY2VcbiAgICAgIC5zaG91bGQubm90aWZ5IGRvbmVcblxuICAgIGl0ICdzaG91bGQgYWNjZXB0IGEgbWF4IG51bWJlciBvZiBhdHRlbXB0cycsIChkb25lKSAtPlxuICAgICAgZnVuYyA9IGdldFByb21pc2VTcHlGdWxmaWxsZWRPblRoaXJkQ2FsbCgpXG4gICAgICBzdWJqZWN0ID0gXy5yZXRyeSBmdW5jLCBtYXg6IDNcbiAgICAgIFxuICAgICAgc3ViamVjdCgpLnNob3VsZC5ldmVudHVhbGx5LmJlLmZ1bGZpbGxlZC50aGVuIC0+XG4gICAgICAgIGZ1bmMuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRUaHJpY2VcbiAgICAgIC5zaG91bGQubm90aWZ5IGRvbmVcblxuICAgIGl0ICdzaG91bGQgYWNjZXB0IGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgd2FpdCBpbnRlcnZhbCcsIChkb25lKSAtPlxuICAgICAgZnVuYyA9IGdldFByb21pc2VTcHlGdWxmaWxsZWRPblRoaXJkQ2FsbCgpXG4gICAgICBnZXRXYWl0ID0gc2lub24uc3B5IC0+IDIwMFxuICAgICAgICBcbiAgICAgIHN1YmplY3QgPSBfLnJldHJ5IGZ1bmMsIG1heDogMywgd2FpdDogZ2V0V2FpdFxuXG4gICAgICBzdWJqZWN0KCkuc2hvdWxkLmV2ZW50dWFsbHkuYmUuZnVsZmlsbGVkLnRoZW4gLT5cbiAgICAgICAgZnVuYy5zaG91bGQuaGF2ZS5iZWVuLmNhbGxlZFRocmljZVxuICAgICAgICBnZXRXYWl0LnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkVHdpY2VcbiAgICAgIC5zaG91bGQubm90aWZ5IGRvbmVcblxuICAgIGl0ICdzaG91bGQgYWNjZXB0IGEgd2FpdCBmdW5jdGlvbiBhbmQgaW52b2tlIGl0IGF0IGVhY2ggaW50ZXJ2YWwnLCAoZG9uZSkgLT5cbiAgICAgIGZ1bmMgPSBnZXRQcm9taXNlU3B5RnVsZmlsbGVkT25UaGlyZENhbGwoKVxuICAgICAgZ2V0V2FpdCA9IHNpbm9uLnNweSgpXG4gICAgICAgIFxuICAgICAgc3ViamVjdCA9IF8ucmV0cnkgZnVuYywgbWF4OiAzLCB3YWl0OiBnZXRXYWl0XG5cbiAgICAgIHN1YmplY3QoKS5zaG91bGQuZXZlbnR1YWxseS5iZS5mdWxmaWxsZWQudGhlbiAtPlxuICAgICAgICBmdW5jLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkVGhyaWNlXG4gICAgICAgIGdldFdhaXQuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRUd2ljZVxuICAgICAgICBnZXRXYWl0LndpdGhBcmdzKDEpLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZVxuICAgICAgICBnZXRXYWl0LndpdGhBcmdzKDIpLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZVxuICAgICAgLnNob3VsZC5ub3RpZnkgZG9uZVxuXG4gICAgaXQgJ2l0IHNob3VsZCByZXBvcnQgaW5jcmVtZW50YWwgcHJvZ3Jlc3Mgd2l0aCBlYWNoIGF0dGVtcHQgbnVtYmVyJywgKGRvbmUpIC0+XG4gICAgICBmdW5jID0gZ2V0UHJvbWlzZVNweUZ1bGZpbGxlZE9uVGhpcmRDYWxsKClcbiAgICAgIHByb2dyZXNzU3R1YiA9IHNpbm9uLnN0dWIoKVxuXG4gICAgICBzdWJqZWN0ID0gXy5yZXRyeSBmdW5jLCBtYXg6IDMsIHdhaXQ6IDEwMCwgcHJvZ3Jlc3M6IHByb2dyZXNzU3R1YlxuXG4gICAgICBzdWJqZWN0KCkuc2hvdWxkLmV2ZW50dWFsbHkuYmUuZnVsZmlsbGVkLnRoZW4gLT5cbiAgICAgICAgcHJvZ3Jlc3NTdHViLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkVHdpY2VcbiAgICAgICAgICAuY2FsbGVkV2l0aCBzaW5vbi5tYXRjaC5vYmplY3QsIDEsIDMsIDEwMFxuICAgICAgICAgIC5jYWxsZWRXaXRoIHNpbm9uLm1hdGNoLm9iamVjdCwgMiwgMywgMTAwXG4gICAgICAuc2hvdWxkLm5vdGlmeSBkb25lXG5cbiAgICBpdCAnc2hvdWxkIGJlIGFibGUgdG8gcGFzcyBhcmd1bWVudHMgdGhyb3VnaCB0aGUgcmV0cnllciB0byB0aGUgZnVuY3Rpb24gY2FsbCcsIChkb25lKSAtPlxuICAgICAgZnVuYyA9IHNpbm9uLnN0dWIoKS5yZXR1cm5zIFEoKVxuICAgICAgc3ViamVjdCA9IF8ucmV0cnkgZnVuY1xuICAgICAgXG4gICAgICBzdWJqZWN0KFwiYVwiLCBcImJcIiwgXCJjXCIpLnNob3VsZC5ldmVudHVhbGx5LmJlLmZ1bGZpbGxlZC50aGVuIC0+XG4gICAgICAgIGZ1bmMuc2hvdWxkLmhhdmUuYmVlblxuICAgICAgICAgIC5jYWxsZWRPbmNlXG4gICAgICAgICAgLmNhbGxlZFdpdGggXCJhXCIsIFwiYlwiLCBcImNcIiwgYXR0ZW1wdDogMVxuICAgICAgLnNob3VsZC5ub3RpZnkgZG9uZVxuIiwie3Npbm9uLCBleHBlY3QsIF99ID0gcmVxdWlyZSAnc3BlYy9zcGVjX2hlbHBlcidcblV0aWxzID0gcmVxdWlyZSAndXRpbC91dGlscydcblxuZGVzY3JpYmUgJ1V0aWxzJywgLT5cblxuICBkZXNjcmliZSAnI2NvbmRpdGlvbmFsKCknLCAtPlxuXG4gICAgZnVuYyA9IG51bGxcblxuICAgIGJlZm9yZSAtPlxuICAgICAgZnVuYyA9IHNpbm9uLnN0dWIoKVxuXG4gICAgYWZ0ZXIgLT5cbiAgICAgIGZ1bmMgPSBudWxsXG4gICAgICBcbiAgICBhZnRlckVhY2ggLT5cbiAgICAgIGZ1bmMucmVzZXQoKVxuXG4gICAgaXQgJ3Nob3VsZCByZXR1cm4gYSBmdW5jdGlvbicsIC0+XG4gICAgICBjb25kaXRpb24gPSAtPiB0cnVlXG4gICAgICBVdGlscy5jb25kaXRpb25hbChmdW5jLCBjb25kaXRpb24pLnNob3VsZC5iZS5hLkZ1bmN0aW9uXG5cbiAgICBpdCAnc2hvdWxkIGFsbG93IHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBjb25kaXRpb24gaXMgbWV0JywgLT5cbiAgICAgIGNvbmRpdGlvbiA9IC0+IHRydWVcbiAgICAgIGNvbmRpdGlvbmFsRnVuYyA9IFV0aWxzLmNvbmRpdGlvbmFsIGZ1bmMsIGNvbmRpdGlvblxuICAgICAgY29uZGl0aW9uYWxGdW5jKClcbiAgICAgIGZ1bmMuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRPbmNlXG5cbiAgICBpdCAnc2hvdWxkIGFsbG93IHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCBhcmdzIHdoZW4gY29uZGl0aW9uIGlzIG1ldCcsIC0+XG4gICAgICBjb25kaXRpb24gPSAtPiB0cnVlXG4gICAgICBjb25kaXRpb25hbEZ1bmMgPSBVdGlscy5jb25kaXRpb25hbCBmdW5jLCBjb25kaXRpb25cbiAgICAgIGNvbmRpdGlvbmFsRnVuYyAndGVzdCdcbiAgICAgIGZ1bmMuc2hvdWxkLmhhdmUuYmVlbi5jYWxsZWRPbmNlLmNhbGxlZFdpdGhFeGFjdGx5ICd0ZXN0J1xuXG4gICAgaXQgJ3Nob3VsZCBhbGxvdyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gdG8gcmV0dXJuIGl0cyBvd24gdmFsdWUgd2hlbiBjb25kaXRpb24gaXMgbWV0JywgLT5cbiAgICAgIGZ1bmMucmV0dXJucyAncmV0dXJuIHZhbHVlJ1xuICAgICAgY29uZGl0aW9uID0gLT4gdHJ1ZVxuICAgICAgY29uZGl0aW9uYWxGdW5jID0gVXRpbHMuY29uZGl0aW9uYWwgZnVuYywgY29uZGl0aW9uXG4gICAgICBjb25kaXRpb25hbEZ1bmMoKS5zaG91bGQuZXF1YWwgJ3JldHVybiB2YWx1ZSdcbiAgICAgIFxuICAgIGl0ICdzaG91bGQgcmV0dXJuIG1ha2UgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHJldHVybiBudWxsIGlmIGNvbmRpdGlvbiBpcyBub3QgbWV0JywgLT5cbiAgICAgIGNvbmRpdGlvbiA9IC0+IGZhbHNlXG4gICAgICBjb25kaXRpb25hbEZ1bmMgPSBVdGlscy5jb25kaXRpb25hbCBmdW5jLCBjb25kaXRpb25cbiAgICAgIGV4cGVjdChjb25kaXRpb25hbEZ1bmMoKSkudG8uYmUubnVsbFxuICAgICAgZnVuYy5zaG91bGQubm90LmhhdmUuYmVlbi5jYWxsZWRcblxuICBkZXNjcmliZSAnI3JldHVybkJvb2xlYW4oKScsIC0+XG5cbiAgICBmdW5jID0gbnVsbFxuXG4gICAgYmVmb3JlRWFjaCAtPlxuICAgICAgZnVuYyA9IHNpbm9uLnN0dWIoKVxuXG4gICAgYWZ0ZXJFYWNoIC0+XG4gICAgICBmdW5jLnJlc2V0KClcblxuICAgIGl0ICdzaG91bGQgZGVjb3JhdGUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBieSBkZWZhdWx0JywgLT5cbiAgICAgIFV0aWxzLnJldHVybkJvb2xlYW4oZnVuYykoKS5zaG91bGQuYmUudHJ1ZVxuICAgICAgVXRpbHMucmV0dXJuQm9vbGVhbihmdW5jLCBudWxsKSgpLnNob3VsZC5iZS50cnVlXG4gICAgICBVdGlscy5yZXR1cm5Cb29sZWFuKGZ1bmMsIHVuZGVmaW5lZCkoKS5zaG91bGQuYmUudHJ1ZVxuICAgICAgZnVuYy5zaG91bGQuaGF2ZS5iZWVuLmNhbGxlZFRocmljZVxuXG4gICAgaXQgJ3Nob3VsZCBkZWNvcmF0ZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIHdoZW4gc3BlY2lmaWVkJywgLT5cbiAgICAgIGJvb2xGdW5jID0gVXRpbHMucmV0dXJuQm9vbGVhbiBmdW5jLCB0cnVlXG4gICAgICBib29sRnVuYygpLnNob3VsZC5iZS50cnVlXG4gICAgICBmdW5jLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZVxuXG4gICAgaXQgJ3Nob3VsZCBkZWNvcmF0ZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBmYWxzZSB3aGVuIHNwZWNpZmllZCcsIC0+XG4gICAgICBib29sRnVuYyA9IFV0aWxzLnJldHVybkJvb2xlYW4gZnVuYywgZmFsc2VcbiAgICAgIGJvb2xGdW5jKCkuc2hvdWxkLmJlLmZhbHNlXG4gICAgICBmdW5jLnNob3VsZC5oYXZlLmJlZW4uY2FsbGVkT25jZVxuXG4gICAgaXQgJ3Nob3VsZCBkZWNvcmF0ZSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgYXJncyBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24nLCAtPlxuICAgICAgYm9vbEZ1bmMgPSBVdGlscy5yZXR1cm5Cb29sZWFuIGZ1bmNcbiAgICAgIGJvb2xGdW5jIFwiYVwiLCBcImJcIlxuICAgICAgZnVuYy5zaG91bGQuaGF2ZS5iZWVuLmNhbGxlZE9uY2VcbiAgICAgICAgLmNhbGxlZFdpdGhFeGFjdGx5IFwiYVwiLCBcImJcIlxuXG4gICAgaXQgJ3Nob3VsZCBjb2VyY2UgYSB2YWx1ZSB0byB0cnVlJywgLT5cbiAgICAgIFV0aWxzLnJldHVybkJvb2xlYW4oZnVuYywgMSkoKS5zaG91bGQuYmUudHJ1ZVxuICAgICAgVXRpbHMucmV0dXJuQm9vbGVhbihmdW5jLCAxMCkoKS5zaG91bGQuYmUudHJ1ZVxuICAgICAgVXRpbHMucmV0dXJuQm9vbGVhbihmdW5jLCB7fSkoKS5zaG91bGQuYmUudHJ1ZVxuICAgICAgVXRpbHMucmV0dXJuQm9vbGVhbihmdW5jLCBcImFcIikoKS5zaG91bGQuYmUudHJ1ZVxuICAgICAgVXRpbHMucmV0dXJuQm9vbGVhbihmdW5jLCBbXCJhXCJdLmxlbmd0aCkoKS5zaG91bGQuYmUudHJ1ZVxuICAgICAgXG4gICAgaXQgJ3Nob3VsZCBjb2VyY2UgYSB2YWx1ZSB0byBmYWxzZScsIC0+XG4gICAgICBVdGlscy5yZXR1cm5Cb29sZWFuKGZ1bmMsIDApKCkuc2hvdWxkLmJlLmZhbHNlXG4gICAgICBVdGlscy5yZXR1cm5Cb29sZWFuKGZ1bmMsIFwiXCIpKCkuc2hvdWxkLmJlLmZhbHNlXG4gICAgICBVdGlscy5yZXR1cm5Cb29sZWFuKGZ1bmMsIFtdLmxlbmd0aCkoKS5zaG91bGQuYmUuZmFsc2VcblxuICBkZXNjcmliZSAnI2FycmF5JywgLT5cbiAgICBcbiAgICBpdCAnc2hvdWxkIHJldHVybiBhbiBhcnJheSBpZiBwYXNzZWQgb25lJywgLT5cbiAgICAgIGFycmF5ID0gW11cbiAgICAgIFV0aWxzLmFycmF5KGFycmF5KS5zaG91bGQuZXF1YWwgYXJyYXlcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIGFuIGFycmF5IGlmIHBhc3NlZCBhbiBvYmplY3QnLCAtPlxuICAgICAgb2JqID0gXCJ2YWx1ZVwiXG4gICAgICBhcnJheSA9IFV0aWxzLmFycmF5IG9ialxuICAgICAgYXJyYXkuc2hvdWxkLmJlLmFuLmluc3RhbmNlb2YgQXJyYXlcbiAgICAgIGFycmF5WzBdLnNob3VsZC5lcXVhbCBcInZhbHVlXCJcblxuICAgIGl0ICdzaG91bGQgcmV0dXJuIHRoZSBzYW1lIGFycmF5IGlmIHBhc3NlZCBhbiBhcnJheScsIC0+XG4gICAgICBhcnJheSA9IFtcImFcIiwgXCJiXCJdXG4gICAgICBVdGlscy5hcnJheShhcnJheSkuc2hvdWxkLmVxdWFsIGFycmF5XG4gICAgICBcbiAgICBpdCAnc2hvdWxkIGNvbnZlcnQgbXVsdGlwbGUgc3RyaW5ncyB0byBtdWx0aXBsZSBhcnJheXMnLCAtPlxuICAgICAgYXJncyA9IFtcImFcIiwgXCJiXCIsIFwiY1wiXVxuICAgICAgW2EsIGIsIGNdID0gVXRpbHMuYXJyYXkuYXBwbHkgdGhpcywgYXJnc1xuXG4gICAgICBhLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIEFycmF5XG4gICAgICBhWzBdLnNob3VsZC5lcXVhbCBcImFcIlxuXG4gICAgICBiLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIEFycmF5XG4gICAgICBiWzBdLnNob3VsZC5lcXVhbCBcImJcIlxuXG4gICAgICBjLnNob3VsZC5iZS5hbi5pbnN0YW5jZW9mIEFycmF5XG4gICAgICBjWzBdLnNob3VsZC5lcXVhbCBcImNcIlxuIiwie18sIHNpbm9ufSA9IHJlcXVpcmUgJ3NwZWMvc3BlY19oZWxwZXInXG5yZXF1aXJlICd1dGlsL3htcHBfdXRpbHMnXG5cbiMgZGVzY3JpYmUgJ1hNUFBVdGlscycsIC0+XG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcblN0cm9waGUgPSByZXF1aXJlICdzdHJvcGhlJ1xuXG4jIFJldHJpZXZlIGFuIElRIHN0YW56YSBmb3IgZ2V0dGluZyB0aGUgYmxvY2tsaXN0IGZyb20gTml0cm9cbiNcbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSBzdGFuemFcbiNcbiMgQGV4YW1wbGVcbiMgICA8aXEgdHlwZT0nZ2V0JyB4bWxucz0namFiYmVyOmNsaWVudCc+XG4jICAgICA8YmxvY2tsaXN0IHhtbG5zPSd1cm46eG1wcDpibG9ja2luZycvPlxuIyAgIDwvaXE+XG4jXG4jIEBzZWUgaHR0cDovL3N0cm9waGUuaW0vc3Ryb3BoZWpzL2RvYy8xLjIuMy9maWxlcy9zdHJvcGhlLWpzLmh0bWwjJGlxXG5leHBvcnRzLmdldEJsb2NrbGlzdFN0YW56YSA9IC0+XG4gIGdldElRU3RhbnphICdibG9ja2xpc3QnXG5cbiMgUmV0cmlldmUgYW4gSVEgc3RhbnphIGZvciBibG9ja2luZyBjb250YWN0c1xuI1xuIyBAcGFyYW0gamlkcyBbQXJyYXk8U3RyaW5nPl0gbGlzdCBvZiBjb250YWN0IGppZHMgdG8gYmxvY2tcbiNcbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSBzdGFuemFcbiNcbiMgQGV4YW1wbGVcbiMgICA8aXEgdHlwZT0nc2V0JyB4bWxucz0namFiYmVyOmNsaWVudCc+XG4jICAgICA8YmxvY2sgeG1sbnM9J3Vybjp4bXBwOmJsb2NraW5nJz5cbiMgICAgICAgPGl0ZW0gamlkPSdqaWQxJy8+XG4jICAgICAgIDxpdGVtIGppZD0namlkMicvPlxuIyAgICAgPC9ibG9jaz5cbiMgICA8L2lxPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRpcVxuZXhwb3J0cy5nZXRCbG9ja1N0YW56YSA9IChqaWRzKSAtPlxuICBnZXRJUVN0YW56YSAnYmxvY2snLCAnc2V0Jywgamlkc1xuICBcbiMgUmV0cmlldmUgYW4gSVEgc3RhbnphIGZvciB1bmJsb2NraW5nIGNvbnRhY3RzXG4jXG4jIEBwYXJhbSBqaWRzIFtBcnJheTxTdHJpbmc+XSBsaXN0IG9mIGNvbnRhY3QgamlkcyB0byB1bmJsb2NrXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gc3RhbnphXG4jXG4jIEBleGFtcGxlXG4jICAgPGlxIHR5cGU9J3NldCcgeG1sbnM9J2phYmJlcjpjbGllbnQnPlxuIyAgICAgPHVuYmxvY2sgeG1sbnM9J3Vybjp4bXBwOmJsb2NraW5nJz5cbiMgICAgICAgPGl0ZW0gamlkPSdqaWQxJy8+XG4jICAgICAgIDxpdGVtIGppZD0namlkMicvPlxuIyAgICAgPC91bmJsb2NrPlxuIyAgIDwvaXE+XG4jXG4jIEBzZWUgaHR0cDovL3N0cm9waGUuaW0vc3Ryb3BoZWpzL2RvYy8xLjIuMy9maWxlcy9zdHJvcGhlLWpzLmh0bWwjJGlxXG5leHBvcnRzLmdldFVuYmxvY2tTdGFuemEgPSAoamlkcykgLT5cbiAgZ2V0SVFTdGFuemEgJ3VuYmxvY2snLCAnc2V0Jywgamlkc1xuXG4jIEJ1aWxkIElRIHN0YW56YVxuI1xuIyBAcGFyYW0gbmFtZSBbU3RyaW5nXSBuYW1lIG9mIHRoZSBlbGVtZW50XG4jIEBwYXJhbSB0eXBlIFtTdHJpbmddIGVpdGhlciAnZ2V0JyAoZGVmYXVsdCkgb3IgJ3NldCdcbiMgQHBhcmFtIGppZHMgW0FycmF5PFN0cmluZz5dIGxpc3Qgb2YgY29udGFjdCBqaWRzIHRvIHVuYmxvY2tcbiNcbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSBzdGFuemFcbiNcbiMgQGV4YW1wbGVcbiMgICA8aXEgdHlwZT0nc2V0JyB4bWxucz0namFiYmVyOmNsaWVudCc+XG4jICAgICA8YmxvY2sgeG1sbnM9J3Vybjp4bXBwOmJsb2NraW5nJz5cbiMgICAgICAgPGl0ZW0gamlkPSdqaWQxJy8+XG4jICAgICAgIDxpdGVtIGppZD0namlkMicvPlxuIyAgICAgPC9ibG9jaz5cbiMgICA8L2lxPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRpcVxuZ2V0SVFTdGFuemEgPSAobmFtZSwgdHlwZSA9ICdnZXQnLCBqaWRzID0gW10pIC0+XG4gIHN0YW56YSA9ICRpcSh0eXBlOiB0eXBlKS5jIG5hbWUsIHhtbG5zOiAndXJuOnhtcHA6YmxvY2tpbmcnXG4gIHN0YW56YS5jKCdpdGVtJywgamlkOiBqaWQpLnVwKCkgZm9yIGppZCBpbiBqaWRzXG4gIHN0YW56YVxuIiwiTVVDTlMgPSByZXF1aXJlICdlbnVtL211Y19ucydcbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSB0byBwZXJmb3JtIGEgc2VydmVyICdkaXNjbydcbiNcbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSA8aXE+IHN0YW56YVxuI1xuIyBAZXhhbXBsZVxuIyAgIDxpcSB0bz0ncmV1dGVycy5uZXQnIHR5cGU9J2dldCc+XG4jICAgICA8cXVlcnkgeG1sbnM9J2h0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL2Rpc2NvI2luZm8nLz5ncnVcbiMgICA8L2lxPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRpcVxuZXhwb3J0cy5nZXREaXNjb1N0YW56YSA9IChqaWQpIC0+XG4gICRpcSB0bzogamlkLCB0eXBlOiAnZ2V0J1xuICAgIC5jICdxdWVyeScsIHhtbG5zOiBNVUNOUy5ESVNDT19JTkZPXG4gIC51cCgpXG4iLCJVdGlscyA9IHJlcXVpcmUgJ3V0aWwvdXRpbHMnXG5fID0gcmVxdWlyZSAndW5kZXJzY29yZSdcblxuZ2V0TGlzdGVuZXJJbnZva2VyID0gKGdldExpc3RlbmVyc0ZuKSAtPlxuICAoYXJncy4uLikgLT5cbiAgICBnZXRMaXN0ZW5lcnNGbigpLmZvckVhY2ggKGYpIC0+XG4gICAgICBmLmFwcGx5IG51bGwsIGFyZ3NcblxubW9kdWxlLmV4cG9ydHMgPVxuXG4gICMgQHByb3BlcnR5IFtBcnJheTxGdW5jdGlvbj5dIEFuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgcmF3IGlucHV0IGV2ZW50cy5cbiAgcmF3SW5wdXRMaXN0ZW5lcnM6IFtdXG5cbiAgIyBAcHJvcGVydHkgW0FycmF5PEZ1bmN0aW9uPl0gQW4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciByYXcgb3V0cHV0IGV2ZW50cy5cbiAgcmF3T3V0cHV0TGlzdGVuZXJzOiBbXVxuXG4gICMgQHByb3BlcnR5IFtBcnJheTxGdW5jdGlvbj5dIEFuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgWE1MIG91dHB1dCBldmVudHMuXG4gIHhtbElucHV0TGlzdGVuZXJzOiBbXVxuXG4gICMgQHByb3BlcnR5IFtBcnJheTxGdW5jdGlvbj5dIEFuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgWE1MIG91dHB1dCBldmVudHMuXG4gIHhtbE91dHB1dExpc3RlbmVyczogW11cblxuICBjb25uZWN0SU9MaXN0ZW5lcnM6IChvcHRpb25zID0ge30pIC0+XG4gICAge2Nvbm5lY3Rpb259ID0gb3B0aW9uc1xuICAgIHtnZXRSYXdJbnB1dExpc3RlbmVycywgZ2V0UmF3T3V0cHV0TGlzdGVuZXJzfSA9IG9wdGlvbnNcbiAgICB7Z2V0WE1MSW5wdXRMaXN0ZW5lcnMsIGdldFhNTE91dHB1dExpc3RlbmVyc30gPSBvcHRpb25zXG5cbiAgICBjb25uZWN0aW9uLnJhd0lucHV0ID0gZ2V0TGlzdGVuZXJJbnZva2VyIGdldFJhd0lucHV0TGlzdGVuZXJzXG4gICAgY29ubmVjdGlvbi5yYXdPdXRwdXQgPSBnZXRMaXN0ZW5lckludm9rZXIgZ2V0UmF3T3V0cHV0TGlzdGVuZXJzXG4gICAgY29ubmVjdGlvbi54bWxJbnB1dCA9IGdldExpc3RlbmVySW52b2tlciBnZXRYTUxJbnB1dExpc3RlbmVyc1xuICAgIGNvbm5lY3Rpb24ueG1sT3V0cHV0ID0gZ2V0TGlzdGVuZXJJbnZva2VyIGdldFhNTE91dHB1dExpc3RlbmVyc1xuXG4gICMgQWRkIGEgY2FsbGJhY2sgZm9yIGFuIElPIGV2ZW50IGZyb20gU3Ryb3BoZS4gVGhpcyBtZXRob2QgcHJvZHVjZXMgYSBuZXdcbiAgIyBhcnJheSBhbmQgbmV2ZXIgbXV0YXRlcyB0aGUgb3JpZ2luYWwuXG4gICNcbiAgIyBAcGFyYW0gY2FsbGJhY2sgW0Z1bmN0aW9uLCBBcnJheTxGdW5jdGlvbj5dIFRoZSBjYWxsYmFjayhzKSB0byBhZGQuXG4gICMgQHBhcmFtIGxpc3QgW0FycmF5PEZ1bmN0aW9uPl0gVGhlIGxpc3QgdG8gYWRkIHRoZSBjYWxsYmFjayB0by5cbiAgI1xuICAjIEByZXR1cm4gW0Z1bmN0aW9uXSBBIHJlbW92ZSBmdW5jdGlvbiBmb3IgdGhlIGNhbGxiYWNrKHMpIGp1c3QgYWRkZWQuXG4gIGFkZElPTGlzdGVuZXI6IChjYWxsYmFjaywgbGlzdCkgLT5cbiAgICBsaXN0ZW5lcnMgPSBVdGlscy5hcnJheSBjYWxsYmFja1xuICAgIGxpc3RlbmVycy5mb3JFYWNoIChjYikgLT4gbGlzdC5wdXNoIGNiXG4gICAgIyBSZXR1cm4gYSByZW1vdmUgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBjYWxsYmFjayhzKSBub3cgYmVpbmcgYWRkZWQgYW5kXG4gICAgIyByZXR1cm5zIHRoYXQgY2FsbGJhY2socykuXG4gICAgLT5cbiAgICAgIGZpcnN0Q2FsbGJhY2sgPSBpZiBfLmlzQXJyYXkgY2FsbGJhY2sgdGhlbiBjYWxsYmFja1swXSBlbHNlIGNhbGxiYWNrXG4gICAgICBpbmRleCA9IGxpc3QuaW5kZXhPZiBmaXJzdENhbGxiYWNrXG4gICAgICBsaXN0LnNwbGljZSBpbmRleCwgbGlzdGVuZXJzLmxlbmd0aFxuIiwiU3Ryb3BoZSA9IHJlcXVpcmUgJ3N0cm9waGUnXG5NZXNzYWdlVHlwZSA9IHJlcXVpcmUgJ2VudW0vbWVzc2FnZV90eXBlJ1xuSGlzdG9yeU5TID0gcmVxdWlyZSAnZW51bS9oaXN0b3J5X25zJ1xuQUNLTlMgPSByZXF1aXJlICdlbnVtL2Fja19ucydcbk1hdGNoZXJzID0gcmVxdWlyZSAndXRpbC9tYXRjaGVycydcbkNoYXRTdGF0ZXNOUyA9IHJlcXVpcmUgJ2VudW0vY2hhdF9zdGF0ZXNfbnMnXG4jIENvbnN0YW50IGZvciBtYXggbnVtYmVyIG9mIGhpc3RvcnkgbWVzc2FnZSB0byByZXRyaWV2ZSBhdCBhIHRpbWVcbkhJU1RPUllfTUFYID0gNTBcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIGZvciBzZW5kaW5nIGEgbWVzc2FnZSB0byBOaXRyb1xuI1xuIyBAcGFyYW0gamlkIFtTdHJpbmddIGNvbnZlcnNhdGlvbiBqaWRcbiMgQHBhcmFtIGJvZHkgW1N0cmluZ10gbWVzc2FnZSBib2R5IHRleHRcbiMgQHBhcmFtIGppZCBbU3RyaW5nXSB0eXBlLCBlLmcuIE1lc3NhZ2VUeXBlLkNIQVQgb3IgTWVzc2FnZVR5cGUuR1JPVVBDSEFUXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gbWVzc2FnZSBzdGFuemFcbiNcbiMgQGV4YW1wbGVcbiNcbiNcbiMgQHNlZSBodHRwOi8vc3Ryb3BoZS5pbS9zdHJvcGhlanMvZG9jLzEuMi4zL2ZpbGVzL3N0cm9waGUtanMuaHRtbCMkbWVzc2FnZVxuZXhwb3J0cy5nZXRTZW5kU3RhbnphID0gKGppZCwgYm9keSwgdHlwZSA9IE1lc3NhZ2VUeXBlLkNIQVQsIGlkKSAtPlxuICByZXR1cm4gbnVsbCB1bmxlc3MgamlkIGFuZCBib2R5XG5cbiAgbWVzc2FnZSA9ICRtc2cgdG86IGppZCwgdHlwZTogdHlwZSwgaWQ6IGlkXG4gICAgLmMgJ2JvZHknLCB7fSwgYm9keVxuICAjIHJlcXVlc3QgcmVjZWlwdCBmb3IgMS0xIHVzaW5nIE5JVFJPX1JFQ0VJUFRTIG5hbWVzcGFjZVxuICB1bmxlc3MgTWF0Y2hlcnMuaXNHcm91cGNoYXQgamlkXG4gICAgbWVzc2FnZS5jKCdyZXF1ZXN0JywgeG1sbnM6IEFDS05TLk5JVFJPX1JFQ0VJUFRTKS51cCgpXG4gICMgcmVxdWVzdCByZWNlaXB0IGZvciBtYW5hZ2VkIGNoYXQgdXNpbmcgU1RBTkRBUkRfUkVDRUlQVFNcbiAgaWYgTWF0Y2hlcnMuaXNNYW5hZ2VkR3JvdXBjaGF0IGppZFxuICAgIG1lc3NhZ2UuYygncmVxdWVzdCcsIHhtbG5zOiBBQ0tOUy5TVEFOREFSRF9SRUNFSVBUUykudXAoKVxuICAjIGFkZCBjaGF0IHN0YXRlcyBub3RpY2VcbiAgbWVzc2FnZS5jKCdhY3RpdmUnLCB4bWxuczogQ2hhdFN0YXRlc05TLkNIQVRfU1RBVEVTKS51cCgpXG4gIGlmIHR5cGUgaXMgTWVzc2FnZVR5cGUuR1JPVVBDSEFUXG4gICAgbWVzc2FnZS5jICd4JywgeG1sbnM6ICdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWMnXG5cbiAgcmV0dXJuIG1lc3NhZ2VcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIHRvIHJldHJpZXZlIGNoYXQgaGlzdG9yeVxuI1xuIyBAcGFyYW0gamlkIFtTdHJpbmddIGNoYXQodXNlcilcbiMgQHBhcmFtIGJlZm9yZSBbU3RyaW5nXSBvcHRpb25hbCAoZGVmYXVsdCBpcyBsYXRlc3QpIG1lc3NhZ2UgaWQgdG8gc3RhcnQgd2l0aFxuIyAgIChnb2luZyBiYWNrd2FyZHMpXG4jIEBwYXJhbSBbU3RyaW5nfE51bWJlcl0gbWF4IG9wdGlvbmFsIChkZWZhdWx0IGlzIDUwKSBudW1iZXIgb2YgbWVzc2FnZXMgdG9cbiMgICByZXRyaWV2ZVxuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIDxpcT4gc3RhbnphXG4jIEBleGFtcGxlXG4jICAgPGlxXG4jICAgICB4bWxucz1cImphYmJlcjpjbGllbnRcIlxuIyAgICAgdG89XCJzb21lLnVzZXIudGhvbXNvbnJldXRlcnMuY29tQHJldXRlcnMubmV0XCJcbiMgICAgIHR5cGU9XCJnZXRcIj5cbiMgICAgICAgPHF1ZXJ5IHhtbG5zPVwidXJuOnhtcHA6bWFtOnRtcFwiPlxuIyAgICAgICAgIDx3aXRoPnNvbWUudXNlci50aG9tc29ucmV1dGVycy5jb21AcmV1dGVycy5uZXQ8L3dpdGg+XG4jICAgICAgICAgPHNldCB4bWxucz1cImh0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL3JzbVwiPlxuIyAgICAgICAgICAgPG1heD41MDwvbWF4PlxuIyAgICAgICAgICAgPGJlZm9yZT4zNDIzNDIzPC9iZWZvcmU+XG4jICAgICAgICAgPC9zZXQ+XG4jICAgICAgIDwvcXVlcnk+XG4jICAgPC9pcT5cbiMgQHNlZSBodHRwOi8veG1wcC5vcmcvZXh0ZW5zaW9ucy94ZXAtMDMxMy5odG1sXG5leHBvcnRzLmdldENoYXRIaXN0b3J5U3RhbnphID0gKGppZCwgYmVmb3JlLCBtYXggPSBISVNUT1JZX01BWCkgLT5cbiAgc3RhbnphID0gJGlxIHhtbG5zOiBTdHJvcGhlLk5TLkNMSUVOVCwgdHlwZTogJ3NldCdcbiAgICAuYyAncXVlcnknLCB4bWxuczogSGlzdG9yeU5TLkNIQVRfSElTVE9SWVxuICAgICAgLmMoJ3dpdGgnKS50KGppZCkudXAoKVxuICAgICAgIyBzZXQgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QgKGxpbWl0LCBjb3VudCwgZXRjLilcbiAgICAgIC5jKCdzZXQnLCB4bWxuczogSGlzdG9yeU5TLlJTTSlcbiAgIyBzZXQgY2hhdCBtZXNzYWdlIDxtYXg+LCBkZWZhdWx0cyB0byA1MFxuICBzdGFuemEuY25vZGUgZ2V0TWF4U3RhbnphKG1heCkudHJlZSgpICMgY25vZGUgdGFrZXMgYSBET00gZWwsIG5vdCBidWlsZGVyXG4gIHN0YW56YS51cCgpXG4gICMgd2Ugb25seSB3YW50IHRvIGFwcGVuZCBhIDxiZWZvcmU+IHN0YW56YSBpZiB0aGUgY2FsbGVyIHByb3ZpZGVkIGFcbiAgIyAnYmVmb3JlJyB2YWx1ZS4gRGVmYXVsdCBpcyB0byBzdGFydCB3aXRoIGxhdGVzdC5cbiAgaWYgYmVmb3JlU3RhbnphID0gZ2V0QmVmb3JlU3RhbnphIGJlZm9yZVxuICAgIHN0YW56YS5jbm9kZSBiZWZvcmVTdGFuemEudHJlZSgpICMgY25vZGUgdGFrZXMgYSBET00gZWwsIG5vdCBhIGJ1aWxkZXJcbiAgICBzdGFuemEudXAoKVxuICBzdGFuemFcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIHRvIHJldHJpZXZlIGdyb3VwY2hhdCBoaXN0b3J5XG4jXG4jIEBwYXJhbSBqaWQgW1N0cmluZ10gZ3JvdXBjaGF0IGppZFxuIyBAcGFyYW0gYmVmb3JlIFtTdHJpbmddIG9wdGlvbmFsIChkZWZhdWx0IGlzIGxhdGVzdCkgbWVzc2FnZSBpZCB0byBzdGFydCB3aXRoXG4jICAgKGdvaW5nIGJhY2t3YXJkcylcbiMgQHBhcmFtIFtTdHJpbmd8TnVtYmVyXSBtYXggb3B0aW9uYWwgKGRlZmF1bHQgaXMgNTApIG51bWJlciBvZiBtZXNzYWdlcyB0b1xuIyAgIHJldHJpZXZlXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gPGlxPiBzdGFuemFcbiMgQGV4YW1wbGVcbiMgICA8aXFcbiMgICAgIHhtbG5zPVwiamFiYmVyOmNsaWVudFwiXG4jICAgICB0bz1cInNvbWUudXNlci50aG9tc29ucmV1dGVycy5jb21AcmV1dGVycy5uZXRcIlxuIyAgICAgdHlwZT1cImdldFwiPlxuIyAgICAgICA8cXVlcnkgeG1sbnM9XCJ1cm46eG1wcDptYW06dG1wXCI+XG4jICAgICAgICAgPHNldCB4bWxucz1cImh0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL3JzbVwiPlxuIyAgICAgICAgICAgPG1heD41MDwvbWF4PlxuIyAgICAgICAgICAgPGJlZm9yZT4zNDIzNDIzPC9iZWZvcmU+XG4jICAgICAgICAgPC9zZXQ+XG4jICAgICAgIDwvcXVlcnk+XG4jICAgPC9pcT5cbiMgQHNlZSBodHRwOi8veG1wcC5vcmcvZXh0ZW5zaW9ucy94ZXAtMDMxMy5odG1sXG5leHBvcnRzLmdldEdyb3VwY2hhdEhpc3RvcnlTdGFuemEgPSAoamlkLCBiZWZvcmUsIG1heCA9IEhJU1RPUllfTUFYKSAtPlxuICBzdGFuemEgPSAkaXEgeG1sbnM6IFN0cm9waGUuTlMuQ0xJRU5ULCB0eXBlOiAnc2V0JywgdG86IGppZFxuICAgIC5jICdxdWVyeScsIHhtbG5zOiBIaXN0b3J5TlMuQ0hBVF9ISVNUT1JZXG4gICAgICAjIHNldCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdCAobGltaXQsIGNvdW50LCBldGMuKVxuICAgICAgLmMoJ3NldCcsIHhtbG5zOiBIaXN0b3J5TlMuUlNNKVxuICAjIHNldCBjaGF0IG1lc3NhZ2UgPG1heD4sIGRlZmF1bHRzIHRvIDUwXG4gIHN0YW56YS5jbm9kZSBnZXRNYXhTdGFuemEobWF4KS50cmVlKCkgIyBjbm9kZSB0YWtlcyBhIERPTSBlbCwgbm90IGJ1aWxkZXJcbiAgc3RhbnphLnVwKClcbiAgIyB3ZSBvbmx5IHdhbnQgdG8gYXBwZW5kIGEgPGJlZm9yZT4gc3RhbnphIGlmIHRoZSBjYWxsZXIgcHJvdmlkZWQgYVxuICAjICdiZWZvcmUnIHZhbHVlLiBEZWZhdWx0IGlzIHRvIHN0YXJ0IHdpdGggbGF0ZXN0LlxuICBpZiBiZWZvcmVTdGFuemEgPSBnZXRCZWZvcmVTdGFuemEgYmVmb3JlXG4gICAgc3RhbnphLmNub2RlIGJlZm9yZVN0YW56YS50cmVlKCkgIyBjbm9kZSB0YWtlcyBhIERPTSBlbCwgbm90IGEgYnVpbGRlclxuICAgIHN0YW56YS51cCgpXG4gIHN0YW56YVxuXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSB0byByZXRyaWV2ZSBtYW5hZ2VkL2xlZ2FjeSBncm91cGNoYXQgaGlzdG9yeSxcbiMgd2hpY2ggaXMgc2ltaWxhciB0byBnZXRIaXN0b3J5U3RhbnphLCBidXQgZG9lcyBoYXZlIGltcG9ydGFudCBkaWZmZXJlbmNlcy5cbiMgKEUuZy4sIG5vIDx3aXRoLz4gc3RhbnphLCBkaWZmZXJlbnQgTlMuKVxuI1xuIyBAcGFyYW0gamlkIFtTdHJpbmddIGNoYXQodXNlcikvZ3JvdXBjaGF0IGppZFxuIyBAcGFyYW0gYmVmb3JlIFtTdHJpbmddIG9wdGlvbmFsIChkZWZhdWx0IGlzIGxhdGVzdCkgbWVzc2FnZSBpZCB0byBzdGFydCB3aXRoXG4jICAgKGdvaW5nIGJhY2t3YXJkcylcbiMgQHBhcmFtIFtTdHJpbmd8TnVtYmVyXSBtYXggb3B0aW9uYWwgKGRlZmF1bHQgaXMgNTApIG51bWJlciBvZiBtZXNzYWdlcyB0b1xuIyAgIHJldHJpZXZlXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gPGlxPiBzdGFuemFcbiMgQGV4YW1wbGVcbiMgICA8aXFcbiMgICAgIHhtbG5zPVwiamFiYmVyOmNsaWVudFwiXG4jICAgICB0bz1cInNvbWVfY2hhdHJvb20uZG9tYWluLmNvbUBsZWdhY3ljaGF0LnJldXRlcnMubmV0XCJcbiMgICAgIHR5cGU9XCJzZXRcIj5cbiMgICAgICAgPHF1ZXJ5IHhtbG5zPVwiamFiYmVyOmlxOnNlYXJjaFwiPlxuIyAgICAgICAgIDxzZXQgeG1sbnM9XCJodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9yc21cIj5cbiMgICAgICAgICAgIDxtYXg+NTA8L21heD5cbiMgICAgICAgICAgIDxiZWZvcmU+MzQyMzQyMzwvYmVmb3JlPlxuIyAgICAgICAgIDwvc2V0PlxuIyAgICAgICA8L3F1ZXJ5PlxuIyAgIDwvaXE+XG4jIEBzZWUgaHR0cDovL3htcHAub3JnL2V4dGVuc2lvbnMveGVwLTAzMTMuaHRtbFxuZXhwb3J0cy5nZXRNYW5hZ2VkSGlzdG9yeVN0YW56YSA9IChqaWQsIGJlZm9yZSwgbWF4ID0gSElTVE9SWV9NQVgpIC0+XG4gIHN0YW56YSA9ICRpcSB4bWxuczogU3Ryb3BoZS5OUy5DTElFTlQsIHRvOiBqaWQsIHR5cGU6ICdzZXQnXG4gICAgLmMgJ3F1ZXJ5JywgeG1sbnM6IEhpc3RvcnlOUy5TRUFSQ0hcbiAgICAgICMgc2V0IG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0IChsaW1pdCwgY291bnQsIGV0Yy4pXG4gICAgICAuYyAnc2V0JywgeG1sbnM6IEhpc3RvcnlOUy5SU01cbiAgIyBzZXQgY2hhdCBtZXNzYWdlIDxtYXg+LCBkZWZhdWx0cyB0byA1MFxuICBzdGFuemEuY25vZGUgZ2V0TWF4U3RhbnphKG1heCkudHJlZSgpICMgY25vZGUgdGFrZXMgYSBET00gZWwsIG5vdCBidWlsZGVyXG4gIHN0YW56YS51cCgpXG4gICMgd2Ugb25seSB3YW50IHRvIGFwcGVuZCBhIDxiZWZvcmU+IHN0YW56YSBpZiB0aGUgY2FsbGVyIHByb3ZpZGVkIGFcbiAgIyAnYmVmb3JlJyB2YWx1ZS4gRGVmYXVsdCBpcyB0byBzdGFydCB3aXRoIGxhdGVzdC5cbiAgaWYgYmVmb3JlU3RhbnphID0gZ2V0QmVmb3JlU3RhbnphIGJlZm9yZVxuICAgIHN0YW56YS5jbm9kZSBiZWZvcmVTdGFuemEudHJlZSgpICMgY25vZGUgdGFrZXMgYSBET00gZWwsIG5vdCBhIGJ1aWxkZXJcbiAgICBzdGFuemEudXAoKVxuICBzdGFuemFcblxuXG4jIFJldHJpZXZlIFN0cm9waGUuQnVpbGRlciBzdGFuemEgdG8gbm90aWZ5IHBpZXJzIGFib3V0IFwiY2hhdHN0YXRlc1wiIHN0YXR1cy5cbiNcbiMgQHBhcmFtIGppZCBbU3RyaW5nXSB1c2VyIHRvIG5vdGlmeVxuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIGNoYXRzdGF0ZXMgbWVzc2FnZSBzdGFuemEuXG5leHBvcnRzLmdldFR5cGluZ1N0YW56YSA9IChqaWQpIC0+XG4gICRtc2coe3RvOiBqaWR9KS5jKCdjb21wb3NpbmcnLCB7XG4gICAgeG1sbnM6ICdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9jaGF0c3RhdGVzJ1xuICB9KVxuXG4jIFJldHJpZXZlIFN0cm9waGUuQnVpbGRlciBzdGFuemEgdG8gc3BlY2lmeSBtZXNzYWdlIGxpbWl0IGluIGNoYXQgaGlzdG9yeVxuIyBOT1RFOiBEZWZhdWx0IGlzIDUwLlxuI1xuIyBAcGFyYW0gbWF4IFtOdW1iZXJdIG51bWJlciBvZiBtZXNzYWdlcyB0byByZXRyaWV2ZS5cbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSA9IDxtYXg+IHN0YW56YSB3aXRoICdtYXgnIGFzIHZhbHVlXG4jIEBleGFtcGxlXG4jICAgPG1heD41MDwvbWF4PlxuZ2V0TWF4U3RhbnphID0gKG1heCA9IEhJU1RPUllfTUFYKSAtPlxuICBuZXcgU3Ryb3BoZS5CdWlsZGVyKCdtYXgnLCB7fSkudCBtYXhcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIHRvIHNwZWNpZnkgbWVzc2FnZSBJRCB0byBzdGFydCB3aXRoXG4jIHdoZW4gZ29pbmcgJ2JhY2t3YXJkcycgaW50byBoaXN0b3J5IHJlc3VsdCBzZXQuXG4jXG4jIEBwYXJhbSBiZWZvcmUgW1N0cmluZ3xOdW1iZXJdICdoaXN0b3J5LWlkJyBvZiBtZXNzYWdlIHRvIHN0YXJ0IHdpdGhcbiMgICAoZ29pbmcgYmFja3dhcmRzKVxuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIDxiZWZvcmU+IHN0YW56YSB3aXRoICdpZCcgYXMgbm9kZSB2YWx1ZVxuIyBAZXhhbXBsZVxuIyAgIDxsYXN0PjU1NTEyMTI8L2xhc3Q+XG5nZXRCZWZvcmVTdGFuemEgPSAoYmVmb3JlKSAtPlxuICBzdGFuemEgPSBuZXcgU3Ryb3BoZS5CdWlsZGVyKCdiZWZvcmUnLCB7fSlcbiAgaWYgYmVmb3JlIHRoZW4gc3RhbnphLnQgYmVmb3JlXG4gIHN0YW56YVxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5TdHJvcGhlID0gcmVxdWlyZSAnc3Ryb3BoZSdcbk1VQ0ZpZWxkID0gcmVxdWlyZSAnZW51bS9tdWNfZmllbGQnXG5NVUNOUyA9IHJlcXVpcmUgJ2VudW0vbXVjX25zJ1xuTVVDUm9sZSA9IHJlcXVpcmUgJ2VudW0vbXVjX3JvbGUnXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSB0byBqb2luIGEgZ3JvdXBjaGF0IChtdWMpXG4jXG4jIEBwYXJhbSBqaWQgW1N0cmluZ10gZ3JvdXBjaGF0IGppZFxuIyBAcGFyYW0gcmVzb3VyY2VJZCBbU3RyaW5nXSByZXNvdXJjZSBpZFxuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIDxwcmVzZW5jZT4gc3RhbnphXG4jXG4jIEBleGFtcGxlXG4jICAgPHByZXNlbmNlXG4jICAgICB0bz0nbXkuZ3JvdXBjaGF0QGNvbmZlcmVuY2UucmV1dGVycy5uZXQvc29tZS51c2VyLnRob21zb25yZXV0ZXJzLmNvbV9fcmV1dGVycy5uZXQnXG4jICAgICB4bWxucz0namFiYmVyOmNsaWVudCc+XG4jICAgICAgIDx4IHhtbG5zPSdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWMnLz5cbiMgICA8L3ByZXNlbmNlPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRwcmVzXG5leHBvcnRzLmdldEpvaW5TdGFuemEgPSAoamlkLCByZXNvdXJjZUlkKSAtPlxuICAkcHJlcyB0bzogXCIje2ppZH0vI3tyZXNvdXJjZUlkfVwiXG4gICAgLmMgJ3gnLCB4bWxuczogTVVDTlMuUk9PVFxuXG4jIFJldHJpZXZlIFN0cm9waGUuQnVpbGRlciBzdGFuemEgZm9yIGxlYXZpbmcgYSBncm91cGNoYXQgKG11YylcbiNcbiMgQHBhcmFtIGppZCBbU3RyaW5nXSBncm91cGNoYXQgamlkXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gPGlxPiBzdGFuemFcbiNcbiMgQGV4YW1wbGVcbiMgICA8cHJlc2VuY2VcbiMgICAgIHRvPSdteS5ncm91cGNoYXRAY29uZmVyZW5jZS5yZXV0ZXJzLm5ldC9zb21lLnVzZXIudGhvbXNvbnJldXRlcnMuY29tX19yZXV0ZXJzLm5ldCdcbiMgICAgIHR5cGU9J3VuYXZhaWxhYmxlJz5cbiMgICAgICAgPHggeG1sbnM9J2h0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL211YycvPlxuIyAgIDwvcHJlc2VuY2U+XG4jXG4jIEBzZWUgaHR0cDovL3N0cm9waGUuaW0vc3Ryb3BoZWpzL2RvYy8xLjIuMy9maWxlcy9zdHJvcGhlLWpzLmh0bWwjJHByZXNcbmV4cG9ydHMuZ2V0TGVhdmVTdGFuemEgPSAoamlkKSAtPlxuICAkcHJlcyB0bzogamlkLCB0eXBlOiAndW5hdmFpbGFibGUnXG4gICAgLmMgJ3gnLCB4bWxuczogTVVDTlMuUk9PVFxuXG4jIFJldHJpZXZlIFN0cm9waGUuQnVpbGRlciBzdGFuemEgZm9yIGRlc3Ryb3lpbmcgYSBOaXRybyBncm91cGNoYXRcbiNcbiMgQHBhcmFtIGppZCBbU3RyaW5nXSBncm91cGNoYXQgamlkXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gc3RhbnphXG4jXG4jIEBleGFtcGxlXG4jICAgPGlxIHRvPSdteS5ncm91cGNoYXRAY29uZmVyZW5jZS5yZXV0ZXJzLm5ldCcgdHlwZT0nc2V0JyB4bWxucz0namFiYmVyOmNsaWVudCc+XG4jICAgICA8cXVlcnkgeG1sbnM9J2h0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL211YyNvd25lcic+XG4jICAgICAgIDxkZXN0cm95Lz5cbiMgICAgIDwvcXVlcnk+XG4jICAgPC9pcT5cbiNcbiMgQHNlZSBodHRwOi8vc3Ryb3BoZS5pbS9zdHJvcGhlanMvZG9jLzEuMi4zL2ZpbGVzL3N0cm9waGUtanMuaHRtbCMkaXFcbmV4cG9ydHMuZ2V0RGVzdHJveUdyb3VwY2hhdFN0YW56YSA9IChqaWQpIC0+XG4gICRpcSB0bzogamlkLCB0eXBlOiAnc2V0J1xuICAgIC5jICdxdWVyeScsIHhtbG5zOiBNVUNOUy5PV05FUlxuICAgICAgLmMgJ2Rlc3Ryb3knXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSB0byBjcmVhdGUgYSBncm91cGNoYXQgY29uZmlnIGZvcm0uIFRoaXMgaXMgbm9taW5hbGx5XG4jIHJlcXVpcmVkIHRvICd1bmxvY2snIGEgZ3JvdXBjaGF0LCBidXQgaXQgaXMgbW9yZSBvZnRlbiB0aGFuIG5vdCB1c2VkIHRvIGNvbmZpZ3VyZVxuIyBwcm9wZXJ0aWVzIG9uIHRoZSByb29tIC0gZS5nLiwgcm9vbW5hbWUuXG4jXG4jIEBwYXJhbSBqaWQgW1N0cmluZ10gZ3JvdXBjaGF0IGppZFxuIyBAcGFyYW0gZmllbGROYW1lIFtTdHJpbmddIGZpZWxkIG5hbWUgYXR0cmlidXRlIGluIHRoZSA8ZmllbGQ+IGVsZW1lbnRcbiMgQHBhcmFtIGZpZWxkVmFsdWUgW1N0cmluZ10gPHZhbHVlPiB2YWx1ZSB3aXRoaW4gdGhlIDxmaWVsZD4gZWxlbWVudFxuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIGJ1aWxkZXIgb2JqZWN0IHdpdGggcG9pbnRlciBzZXQgdG8gPHgvPiBzdGFuemFcbiNcbiMgQGV4YW1wbGVcbiMgICA8aXEgdG89J215Lmdyb3VwY2hhdEBjb25mZXJlbmNlLnJldXRlcnMubmV0JyB0eXBlPSdzZXQnIHhtbG5zPSdqYWJiZXI6Y2xpZW50Jz5cbiMgICAgIDxxdWVyeSB4bWxucz0naHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvbXVjI293bmVyJz5cbiMgICAgICAgPHggeG1sbnM9J2phYmJlcjp4OmRhdGEnIHR5cGU9J3N1Ym1pdCc+XG4jICAgICAgICAgPGZpZWxkIHZhcj0nRk9STV9UWVBFJz5cbiMgICAgICAgICAgIDx2YWx1ZT5odHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWMjcm9vbWNvbmZpZzwvdmFsdWU+XG4jICAgICAgICAgPC9maWVsZD5cbiMgICAgICAgICA8ZmllbGQgdmFyPSdtdWMjcm9vbWNvbmZpZ19yb29tbmFtZSc+XG4jICAgICAgICAgICA8dmFsdWU+TXkgR3JvdXBjaGF0PC92YWx1ZT5cbiMgICAgICAgICA8L2ZpZWxkPlxuIyAgICAgICA8L3g+XG4jICAgICA8L3F1ZXJ5PlxuIyAgIDwvaXE+XG4jXG4jIEBzZWUgaHR0cDovL3N0cm9waGUuaW0vc3Ryb3BoZWpzL2RvYy8xLjIuMy9maWxlcy9zdHJvcGhlLWpzLmh0bWwjJGlxXG5leHBvcnRzLmdldEdyb3VwY2hhdENvbmZpZ0Zvcm0gPSAoamlkLCBmaWVsZE5hbWUsIGZpZWxkVmFsdWUpIC0+XG4gIHN0YW56YSA9ICRpcSB0bzogamlkLCB0eXBlOiAnc2V0J1xuICAgIC5jICdxdWVyeScsIHhtbG5zOiBNVUNOUy5PV05FUlxuICAgICAgLmMgJ3gnLCB4bWxuczogJ2phYmJlcjp4OmRhdGEnLCB0eXBlOiAnc3VibWl0J1xuICAgICAgICAuYyAnZmllbGQnLCB2YXI6IE1VQ0ZpZWxkLkZPUk1fVFlQRVxuICAgICAgICAgIC5jICd2YWx1ZSdcbiAgICAgICAgICAgIC50IFwiI3tNVUNOUy5ST09UfSNyb29tY29uZmlnXCJcbiAgICAgICAgICAgIC51cCgpXG4gICAgICAgICAgLnVwKClcbiAgIyBBZGQgZ3JvdXBjaGF0IGNvbmZpZyB0byBzdGFuemFcbiAgc3RhbnphLmMgJ2ZpZWxkJywgdmFyOiBmaWVsZE5hbWVcbiAgICAuYyAndmFsdWUnIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRtc2dcbiAgICAgIC50IGZpZWxkVmFsdWVcbiAgICAgIC51cCgpXG4gICAgLnVwKClcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIHRvIHBlcmZvcm0gYSByb29tICdkaXNjbydcbiNcbiMgQHBhcmFtIGppZCBbU3RyaW5nXSB1c2VyIGppZCBvZiB0aGUgZ3JvdXBjaGF0XG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gPGlxPiBzdGFuemFcbiNcbiMgQGV4YW1wbGVcbiMgICA8aXEgdG89J215Lmdyb3VwY2hhdEBjb25mZXJlbmNlLnJldXRlcnMubmV0JyB0eXBlPSdnZXQnPlxuIyAgICAgPHF1ZXJ5IHhtbG5zPSdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9kaXNjbyNpbmZvJy8+Z3J1XG4jICAgPC9pcT5cbiNcbiMgQHNlZSBodHRwOi8vc3Ryb3BoZS5pbS9zdHJvcGhlanMvZG9jLzEuMi4zL2ZpbGVzL3N0cm9waGUtanMuaHRtbCMkaXFcbmV4cG9ydHMuZ2V0Um9vbURpc2NvU3RhbnphID0gKGppZCkgLT5cbiAgJGlxIHRvOiBqaWQsIHR5cGU6ICdnZXQnXG4gICAgLmMgJ3F1ZXJ5JywgeG1sbnM6IE1VQ05TLkRJU0NPX0lORk9cbiAgLnVwKClcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIHRvIHBlcmZvcm0gYSByb29tICdkaXNjbydcbiNcbiMgQHBhcmFtIGppZCBbU3RyaW5nXSB1c2VyIGppZCBvZiB0aGUgZ3JvdXBjaGF0XG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gPGlxPiBzdGFuemFcbiNcbiMgQGV4YW1wbGVcbiMgICA8aXEgdG89J215Lmdyb3VwY2hhdEBsZWdhY3ljaGF0LnJldXRlcnMubmV0JyB0eXBlPSdnZXQnPlxuIyAgICAgPHF1ZXJ5IHhtbG5zPSdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWMjb3duZXInLz5cbiMgICA8L2lxPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRpcVxuZXhwb3J0cy5nZXRNYW5hZ2VkUm9vbURpc2NvU3RhbnphID0gKGppZCkgLT5cbiAgJGlxIHRvOiBqaWQsIHR5cGU6ICdnZXQnXG4gICAgLmMgJ3F1ZXJ5JywgeG1sbnM6IE1VQ05TLk9XTkVSXG4gIC51cCgpXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIGlxIHN0YW56YSBmb3IgcmV0cmlldmluZyBhIGdyb3VwY2hhdCBtZW1iZXIgbGlzdFxuI1xuIyBAcGFyYW0gamlkIFtTdHJpbmddIHVzZXIgamlkIG9mIHRoZSBncm91cGNoYXRcbiMgQHBhcmFtIGFmZmlsaWF0aW9ucyBbU3RyaW5nLCBBcnJheTxTdHJpbmc+XSBsaXN0IG9mIG1lbWJlciByb2xlcyB3ZSBhcmUgaW50ZXJlc3RlZCBpblxuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIDxxdWVyeT4gc3RhbnphIChubyBhZmZpbGlhdGlvbnMgYXR0YWNoZWQpXG4jXG4jIEBleGFtcGxlXG4jICAgPGlxIHRvPSdteS5ncm91cGNoYXRAY29uZmVyZW5jZS5yZXV0ZXJzLm5ldCcgdHlwZT0nZ2V0Jz5cbiMgICAgIDxxdWVyeSB4bWxucz0naHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvbXVjI2FkbWluJz5cbiMgICAgICAgPGl0ZW0gYWZmaWxpYXRpb249J293bmVyJy8+XG4jICAgICAgIDxpdGVtIGFmZmlsaWF0aW9uPSdwYXJ0aWNpcGFudCcvPlxuIyAgICAgPC9xdWVyeT5cbiMgICA8L2lxPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRpcVxuZXhwb3J0cy5nZXRNZW1iZXJMaXN0U3RhbnphID0gKGppZCwgYWZmaWxpYXRpb25zID0gW10pIC0+XG4gIHN0YW56YSA9ICRpcSB0bzogamlkLCB0eXBlOiAnZ2V0J1xuICBzdGFuemEuYyAncXVlcnknLCB4bWxuczogTVVDTlMuQURNSU5cbiAgc3RhbnphLmMoJ2l0ZW0nLCBhZmZpbGlhdGlvbjogYWZmaWxpYXRpb24pLnVwKCkgZm9yIGFmZmlsaWF0aW9uIGluIGFmZmlsaWF0aW9uc1xuICBzdGFuemFcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIGZvciBzZW5kaW5nIGEgJ21lZGlhdGVkJyBpbnZpdGUgdG8gYSB1c2VyLlxuIyBXaGlsZSB0aGUgbWVzc2FnZSBpcyBhZGRyZXNzZWQgdG8gdGhlIGdyb3VwY2hhdCwgdGhlIGdyb3VwY2hhdCB3aWxsIGluIHR1cm5cbiMgZGVsaXZlciB0aGUgaW52aXRlcyB0byBzcGVjaWZpZWQgdXNlcnMuICBUbyBhZGQgdXNlcnMgdG8gdGhlIGludml0ZSxcbiNcbiMgQHBhcmFtIGppZCBbU3RyaW5nXSBncm91cGNoYXQgamlkXG4jIEBwYXJhbSBzZWxmSklEIFtTdHJpbmddIHNlbGYgamlkXG4jIEBwYXJhbSBzZWxmSklEIFtTdHJpbmddIGxpc3Qgb2YgdXNlciBKSURzIHRvIGludml0ZVxuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIDx4PiBzdGFuemEgdG8gd2hpY2ggd2Ugd2lsbCBhZGQgPGludml0ZT4gc3Rhbnphc1xuI1xuIyBAZXhhbXBsZVxuIyAgIDxtZXNzYWdlIHRvPSdteS5ncm91cGNoYXRAY29uZmVyZW5jZS5yZXV0ZXJzLm5ldCc+XG4jICAgICA8eCB4bWxucz0naHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvbXVjI3VzZXInPlxuIyAgICAgICA8aW52aXRlIHRvPSdzb21lLnVzZXIudGhvbXNvbnJldXRlcnMuY29tQHJldXRlcnMubmV0Jz5cbiMgICAgIDwveD5cbiMgICA8L21lc3NhZ2U+XG4jXG4jIEBzZWUgaHR0cDovL3htcHAub3JnL2V4dGVuc2lvbnMveGVwLTAwNDUuaHRtbCNpbnZpdGUtbWVkaWF0ZWRcbmV4cG9ydHMuZ2V0TWVkaWF0ZWRJbnZpdGVTdGFuemEgPSAoamlkLCBzZWxmSklELCBpbnZpdGVlcyA9IFtdLCB0eXBlID0gJycpIC0+XG4gIHN0YW56YSA9ICRtc2cgdG86IGppZFxuICAgIC5jICd4JywgeG1sbnM6IE1VQ05TLlVTRVJcbiAgZm9yIGludml0ZWUgaW4gaW52aXRlZXNcbiAgICBzdGFuemEuYyAnaW52aXRlJywge3RvOiBpbnZpdGVlLCBmcm9tOiBzZWxmSklEfVxuICAgIGlmIHR5cGVcbiAgICAgIHN0YW56YS5jICdyZWFzb24nLCB7fSwgSlNPTi5zdHJpbmdpZnkge3R5cGU6IHR5cGV9XG4gICAgc3RhbnphLnVwKClcbiAgc3RhbnphXG5cbiMgRGVjbGluZSBhIG1lZGlhdGVkIGludml0ZS4gIFRoZSBkZWNsaW5lIDxtZXNzYWdlLz4gaXMgc2VudCB0byB0aGUgZ3JvdXBjaGF0IGppZCxcbiMgYnV0IHRoZSA8ZGVjbGluZS8+IHN0YW56YSBsZXRzIHRoZSBncm91cGNoYXQga25vdyB3aG8gdG8gbm90aWZ5IGFib3V0IHRoZSByZWplY3Rpb25cbiNcbiMgQHBhcmFtIGppZCBbU3RyaW5nXSBpZCBvZiBncm91cGNoYXRcbiMgQHBhcmFtIGludml0ZXIgW1N0cmluZ10gaWQgb2YgdXNlciB0byBub3RpZnkgYWJvdXQgcmVqZWN0aW9uIChwcmVzdW1hYmx5IHRoZSBpbnZpdGVyKVxuIyBAcGFyYW0gcmVhc29uIFtTdHJpbmddIG9wdGlvbmFsIHZhbHVlIGZvciBub3RpY2UgdGV4dC5cbiNcbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSBidWlsZGVyIG9iamVjdCB0byBzZW5kXG4jIEBleGFtcGxlXG4jICAgPG1lc3NhZ2VcbiMgICAgIGZyb209J2hlY2F0ZUBzaGFrZXNwZWFyZS5saXQvYnJvb20nXG4jICAgICBpZD0namsydnM2MXYnXG4jICAgICB0bz0nY292ZW5AY2hhdC5zaGFrZXNwZWFyZS5saXQnPlxuIyAgICAgPHggeG1sbnM9J2h0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL211YyN1c2VyJz5cbiMgICAgICAgPGRlY2xpbmUgdG89J2Nyb25lMUBzaGFrZXNwZWFyZS5saXQnPlxuIyAgICAgICAgIDxyZWFzb24+XG4jICAgICAgICAgICBTb3JyeSwgSSdtIHRvbyBidXN5IHJpZ2h0IG5vdy5cbiMgICAgICAgICA8L3JlYXNvbj5cbiMgICAgICAgPC9kZWNsaW5lPlxuIyAgICAgPC94PlxuIyAgIDwvbWVzc2FnZT5cbiNcbiMgQHNlZSBodHRwOi8veG1wcC5vcmcvZXh0ZW5zaW9ucy94ZXAtMDA0NS5odG1sI2ludml0ZS1tZWRpYXRlZFxuZXhwb3J0cy5nZXREZWNsaW5lTWVkaWF0ZWRJbnZpdGVTdGFuemEgPSAoamlkLCBpbnZpdGVyLCByZWFzb24gPSAnJykgLT5cbiAgIyBjcmVhdGUgbWFpbiBtZXNzYWdlIHN0YW56YVxuICAkcmVqZWN0SW52aXRlTWVzc2FnZSA9ICRtc2cgdG86IGppZFxuICAgIC5jICd4JywgeG1sbnM6ICdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9tdWMjdXNlcidcbiAgICAuYyBcImRlY2xpbmVcIiwgdG86IGludml0ZXJcbiAgIyBpZiB0aGVyZSBpcyBhIHNwZWNpZmljIHJlYXNvbiwgYXBwZW5kIGl0IHRvIHRoZSA8ZGVjbGluZS8+XG4gIHVubGVzcyBfLmlzRW1wdHkgcmVhc29uXG4gICAgJHJlamVjdEludml0ZU1lc3NhZ2UuYyAncmVhc29uJywge30sIHJlYXNvblxuXG4gICRyZWplY3RJbnZpdGVNZXNzYWdlXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSBmb3Igc2VuZGluZyBhICdzZWFyY2gnIHJlcXVlc3QuXG4jXG4jIEBwYXJhbSBtYXRjaCBbU3RyaW5nXSBtYXRjaCBvbiBzdHJpbmdcbiMgQHBhcmFtIGppZCBbU3RyaW5nXSBzZWFyY2ggY29tcG9uZW50IGppZFxuIyBAcGFyYW0gbWF4IFtJbnRlZ2VyXSB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVzdWx0cyByZXF1ZXN0ZWQsIGRlZmF1bHQgaXMgNVxuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIHN0YW56YSB0byBzZWFyY2hcbiNcbiMgQGV4YW1wbGVcbiMgICA8aXEgdG89J2xlZ2FjeWNoYXQucmV1dGVycy5uZXQnIHR5cGU9J3NldCc+XG4jICAgICA8cXVlcnkgeG1sbnM9J2phYmJlcjppcTpzZWFyY2gnPlxuIyAgICAgICA8c2V0IHhtbG5zPSdodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9yc20nPlxuIyAgICAgICAgIDxtYXg+NTwvbWF4PlxuIyAgICAgICA8L3NldD5cbiMgICAgICAgPG5hbWU+Q01BVGVzdDwvbmFtZT5cbiMgICAgIDwvcXVlcnk+XG4jICAgPC9pcT5cbiNcbiMgQHNlZSBodHRwOi8vc3Ryb3BoZS5pbS9zdHJvcGhlanMvZG9jLzEuMi4zL2ZpbGVzL3N0cm9waGUtanMuaHRtbCMkbXNnXG5leHBvcnRzLmdldFNlYXJjaFN0YW56YSA9IChqaWQsIG1hdGNoID0gJycsIG1heCA9IDUpIC0+XG4gICRpcSB7eG1sbnM6ICdqYWJiZXI6Y2xpZW50JywgdG86IGppZCwgdHlwZTogJ3NldCd9XG4gICAgLmMgJ3F1ZXJ5Jywge3htbG5zOiAnamFiYmVyOmlxOnNlYXJjaCd9XG4gICAgICAuYyAnc2V0Jywge3htbG5zOiAnaHR0cDovL2phYmJlci5vcmcvcHJvdG9jb2wvcnNtJ31cbiAgICAgICAgLmMgJ21heCcsIHt9LCBtYXgudG9TdHJpbmcoKVxuICAgICAgICAudXAoKVxuICAgICAgLmMgJ25hbWUnLCB7fSwgbWF0Y2hcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIGZvciBraWNraW5nIGEgdXNlciBmcm9tIGEgZ3JvdXBjaGF0LlxuI1xuIyBAcGFyYW0gamlkIFtTdHJpbmddIGdyb3VwY2hhdCBpZFxuIyBAcGFyYW0gdXNlcnMgW2FycmF5XSBsaXN0IG9mIHVzZXJzIHRvIGtpY2tcbiMgQGV4YW1wbGVcbiMgICA8aXEgZnJvbT0nZmx1ZWxsZW5Ac2hha2VzcGVhcmUubGl0L3BkYSdcbiMgICAgICAgaWQ9J2tpY2sxJ1xuIyAgICAgICB0bz0naGFyZmxldXJAY2hhdC5zaGFrZXNwZWFyZS5saXQnXG4jICAgICAgIHR5cGU9J3NldCc+XG4jICAgICA8cXVlcnkgeG1sbnM9J2h0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL211YyNhZG1pbic+XG4jICAgICAgIDxpdGVtIGppZD0ncGlzdG9sQHNoYWtlc3BlYXJlLmxpdCcgYWZmaWxpYXRpb249J25vbmUnPlxuIyAgICAgICAgIDxyZWFzb24+QXZhdW50LCB5b3UgY3VsbGlvbiE8L3JlYXNvbj5cbiMgICAgICAgPC9pdGVtPlxuIyAgICAgPC9xdWVyeT5cbiMgICA8L2lxPlxuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIHN0YW56YSB0byBraWNrXG5leHBvcnRzLmdldEtpY2tTdGFuemEgPSAoamlkLCB1c2VycyA9IFtdLCByZWFzb24pIC0+XG4gIHN0YW56YSA9ICRpcSB0bzogamlkLCB0eXBlOiAnc2V0J1xuICAgIC5jICdxdWVyeScsIHhtbG5zOiBNVUNOUy5BRE1JTlxuXG4gIGZvciB1c2VyIGluIHVzZXJzXG4gICAgc3RhbnphLmMgJ2l0ZW0nLCB7amlkOiB1c2VyLCBhZmZpbGlhdGlvbjogTVVDUm9sZS5OT05FfVxuICAgIHVubGVzcyBfLmlzRW1wdHkgcmVhc29uXG4gICAgICBzdGFuemEuYygncmVhc29uJywge30sIHJlYXNvbikudXAoKVxuICAgIHN0YW56YS51cCgpXG5cbiAgcmV0dXJuIHN0YW56YVxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5TdHJvcGhlID0gcmVxdWlyZSAnc3Ryb3BoZSdcblhNUFBQcmVzZW5jZSA9IHJlcXVpcmUgJ2VudW0veG1wcF9wcmVzZW5jZSdcblxuZXhwb3J0cy5QUkVTRU5DRSA9ICdwcmVzZW5jZSdcbmV4cG9ydHMuVklTSUJMRSA9ICd2aXNpYmxlJ1xuZXhwb3J0cy5JTlZJU0lCTEUgPSAnaW52aXNpYmxlJ1xuXG4jIFJldHJpZXZlIFN0cm9waGUuQnVpbGRlciBzdGFuemEgZm9yIGEgcHJlc2VuY2Ugc3Vic2NyaXB0aW9uIHJlcXVlc3Qgb3IgY29uZmlybWF0aW9uXG4jXG4jIEBwYXJhbSBqaWQgW1N0cmluZ10gdXNlciBqaWQgb2YgdGhlIGNvbnRhY3RcbiMgQHBhcmFtIHR5cGUgW1N0cmluZ10gUHJlc2VuY2VUeXBlIGNvbnN0YW50XG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gcHJlc2VuY2Ugc3RhbnphXG4jXG4jIEBleGFtcGxlXG4jICAgLy8gR2V0IGEgYmFzaWMgcHJlc2VuY2Ugc3RhbnphXG4jICAgZ2V0UHJlc2VuY2VTdGFuemEoKTtcbiMgICAvLz0+IDxwcmVzZW5jZSB4bWxucz0namFiYmVyOmNsaWVudCcvPlxuI1xuIyBAZXhhbXBsZVxuIyAgIC8vIEdldCBhIHN0YW56YSBzcGVjaWZ5aW5nIG9ubHkgYSB1c2VyIGppZFxuIyAgIHZhciBqaWQgPSBcInNvbWVndXlqaWRcIlxuIyAgIGdldFByZXNlbmNlU3RhbnphKGppZCk7XG4jICAgLy89PiA8cHJlc2VuY2UgdG89J3NvbWVndXlqaWQnIHhtbG5zPSdqYWJiZXI6Y2xpZW50Jy8+XG4jXG4jIEBleGFtcGxlXG4jICAgLy8gR2V0IGEgc3RhbnphIHNwZWNpZnlpbmcgdXNlciBqaWQgYW5kIHR5cGVcbiMgICB2YXIgamlkID0gXCJzb21lZ3V5amlkXCJcbiMgICBnZXRQcmVzZW5jZVN0YW56YShqaWQsIFByZXNlbmNlVHlwZS5TVUJTQ1JJQkUpO1xuIyAgIC8vPT4gPHByZXNlbmNlIHRvPSdzb21lZ3V5amlkJyB0eXBlPSdzdWJzY3JpYmUnIHhtbG5zPSdqYWJiZXI6Y2xpZW50Jy8+XG4jXG4jIEBleGFtcGxlXG4jICAgLy8gR2V0IGEgc3RhbnphIHNwZWNpZnlpbmcgYSBwcmVzZW5jZSBzaG93XG4jICAgZ2V0UHJlc2VuY2VTdGFuemEoJycsICcnLCBQcmVzZW5jZVNob3cuQVdBWSk7XG4jICAgLy89PiA8cHJlc2VuY2UgdG89J3NvbWVndXlqaWQnIHhtbG5zPSdqYWJiZXI6Y2xpZW50Jz5cbiMgICAgICAgICAgIDxzaG93PmF3YXk8L3Nob3c+XG4jICAgICAgICA8L3ByZXNlbmNlPlxuI1xuIyBAc2VlIFByZXNlbmNlVHlwZVxuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRwcmVzXG5leHBvcnRzLmdldFByZXNlbmNlU3RhbnphID0gKGppZCA9ICcnLCB0eXBlID0gJycsIHNob3cgPSAnJykgLT5cbiAgc3RhbnphID0gJHByZXMoKVxuXG4gIGlmIGppZCBhbmQgXy5pc1N0cmluZyBqaWRcbiAgICBzdGFuemEuYXR0cnMgdG86IGppZFxuXG4gIGlmIHR5cGUgYW5kIF8uaXNTdHJpbmcgdHlwZVxuICAgIHN0YW56YS5hdHRycyB0eXBlOiB0eXBlXG5cbiAgaWYgc2hvdyBhbmQgXy5pc1N0cmluZyBzaG93XG4gICAgc3RhbnphLmMoJ3Nob3cnKS50IHNob3dcblxuICBzdGFuemFcblxuIyBSZXRyaWV2ZSBhIFN0cm9waGUuQnVpbGRlciBmb3Igc2V0dGluZyAndmlzaWJsZScgcHJlc2VuY2UuXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gaXEgc3RhbnphIGZvciB2aXNpYmxlIHByZXNlbmNlXG4jXG4jIEBleGFtcGxlXG4jICAgLy8gR2V0IGEgc3RhbnphIGZvciAndmlzaWJsZSdcbiMgICBnZXRWaXNpYmxlU3RhbnphKCk7IC8vIGRlZmF1bHQgYXJnIHZhbHVlIGlzIHRydWVcbiMgICAvLz0+IDxpcSBmcm9tPSdiaWxib0B0b2xraWVuLmxpdC9zaGlyZScgaWQ9J3ZpczEnIHR5cGU9J3NldCc+XG4jICAgICAgICAgICA8dmlzaWJsZSB4bWxucz0ndXJuOnhtcHA6aW52aXNpYmxlOjAnLz5cbiMgICAgICAgIDwvaXE+XG4jXG4jICAgLy8gR2V0IGEgc3RhbnphIGZvciAnaW52aXNpYmxlJ1xuIyAgIGdldFZpc2libGVTdGFuemEoZmFsc2UpO1xuIyAgIC8vPT4gPGlxIGZyb209J2JpbGJvQHRvbGtpZW4ubGl0L3NoaXJlJyBpZD0ndmlzMScgdHlwZT0nc2V0Jz5cbiMgICAgICAgICAgIDxpbnZpc2libGUgeG1sbnM9J3Vybjp4bXBwOmludmlzaWJsZTowJy8+XG4jICAgICAgICA8L2lxPlxuZXhwb3J0cy5nZXRWaXNpYmxlU3RhbnphID0gKHZpc2libGUgPSB0cnVlKSAtPlxuICBub2RlTmFtZSA9IGlmIHZpc2libGUgdGhlbiBAVklTSUJMRSBlbHNlIEBJTlZJU0lCTEVcbiAgJGlxKHR5cGU6ICdzZXQnKS5jIG5vZGVOYW1lLCB4bWxuczogJ3Vybjp4bXBwOmludmlzaWJsZTowJ1xuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5TdHJvcGhlID0gcmVxdWlyZSAnc3Ryb3BoZSdcbnN0cm9waGVQcmVzZW5jZSA9IHJlcXVpcmUgJ3N0cm9waGUvc3Ryb3BoZV9wcmVzZW5jZSdcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIGZvciBnZXR0aW5nIHRoZSByb3N0ZXIgZnJvbSBOaXRyb1xuI1xuIyBAcGFyYW0gYWRkcmVzcyBbU3RyaW5nXSBvcHRpb25hbCBhZGRyZXNzIGZvciB0aGUgJ3RvJyBmaWVsZFxuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIHN0YW56YVxuI1xuIyBAZXhhbXBsZVxuIyAgIC8vIEdldCBhIHN0YW56YSBmb3Igcm9zdGVyIGl0ZW1zXG4jICAgZ2V0Um9zdGVyU3RhbnphKCk7XG4jICAgLy89PlxuIyAgIDxpcSB0eXBlPSdnZXQnIHhtbG5zPSdqYWJiZXI6Y2xpZW50Jz5cbiMgICAgIDxxdWVyeSB4bWxucz0namFiYmVyOmlxOnJvc3RlcicvPlxuIyAgIDwvaXE+XG4jXG4jIEBleGFtcGxlXG4jICAgLy8gR2V0IGEgc3RhbnphIGZvciByb3N0ZXIgaXRlbXMgYXQgYSBzcGVjaWZpZWQgYWRkcmVzc1xuIyAgIGdldFJvc3RlclN0YW56YSBcInlhaG9vLnJldXNhbWIuY29tXCJcbiMgICAvLz0+XG4jICAgPGlxIHR5cGU9J2dldCcgeG1sbnM9J2phYmJlcjpjbGllbnQnIHRvPSd5YWhvby5yZXVzYW1iLmNvbSc+XG4jICAgICA8cXVlcnkgeG1sbnM9J2phYmJlcjppcTpyb3N0ZXInLz5cbiMgICA8L2lxPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRpcVxuZXhwb3J0cy5nZXRSb3N0ZXJTdGFuemEgPSAoYWRkcmVzcyA9ICcnKSAtPlxuICBzdGFuemEgPSAkaXEgdHlwZTogJ2dldCdcbiAgaWYgYWRkcmVzcyBhbmQgXy5pc1N0cmluZyBhZGRyZXNzXG4gICAgc3RhbnphLmF0dHJzIHRvOiBhZGRyZXNzXG4gIHN0YW56YS5jICdxdWVyeScsIHhtbG5zOiAnamFiYmVyOmlxOnJvc3RlcidcbiAgc3RhbnphXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSBmb3IgYWRkaW5nIGEgdXNlciB0byB0aGUgcm9zdGVyXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gc3RhbnphXG4jXG4jIEBleGFtcGxlXG4jICAgPGlxIHR5cGU9J3NldCcgeG1sbnM9J2phYmJlcjpjbGllbnQnPlxuIyAgICAgPHF1ZXJ5IHhtbG5zPSdqYWJiZXI6aXE6cm9zdGVyJy8+XG4jICAgPC9pcT5cbiNcbiMgQHNlZSBodHRwOi8vc3Ryb3BoZS5pbS9zdHJvcGhlanMvZG9jLzEuMi4zL2ZpbGVzL3N0cm9waGUtanMuaHRtbCMkaXFcbmV4cG9ydHMuZ2V0QWRkU3RhbnphID0gKGppZCwgbmFtZSwgZ3JvdXBzID0gW10pIC0+XG4gIHN0YW56YSA9ICRpcSh0eXBlOiAnc2V0JykuYyAncXVlcnknLCB4bWxuczogJ2phYmJlcjppcTpyb3N0ZXInXG4gIGl0ZW1EYXRhID0gamlkOiBqaWRcbiAgaWYgdHlwZW9mIG5hbWUgaXMgJ3N0cmluZycgYW5kIG5hbWUubGVuZ3RoXG4gICAgaXRlbURhdGEubmFtZSA9IG5hbWVcbiAgc3RhbnphLmMgJ2l0ZW0nLCBpdGVtRGF0YVxuICAjIEFkZCBhIGdyb3VwIGVsZW1lbnQgZm9yIGVhY2ggZ3JvdXBcbiAgc3RhbnphLmMoJ2dyb3VwJykudChncm91cCkudXAoKSBmb3IgZ3JvdXAgaW4gZ3JvdXBzXG4gIHN0YW56YVxuXG4jIFJldHJpZXZlIFN0cm9waGUuQnVpbGRlciBzdGFuemEgZm9yIHJlbW92aW5nIGEgdXNlciBmcm9tIHRoZSByb3N0ZXJcbiNcbiMgQHBhcmFtIGppZCBbU3RyaW5nXSB1c2VyIGppZCBvZiB0aGUgdXNlciB3ZSBhcmUgcmVtb3ZpbmdcbiNcbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSBzdGFuemFcbiNcbiMgQGV4YW1wbGVcbiMgICA8aXEgdHlwZT0nc2V0JyB4bWxucz0namFiYmVyOmNsaWVudCc+XG4jICAgICA8cXVlcnkgeG1sbnM9J2phYmJlcjppcTpyb3N0ZXInPlxuIyAgICAgICA8aXRlbSBqaWQ9J2NvbnRhY3R0b2FkZGppZCcgbmFtZT0nQ29udGFjdCB0byBBZGQnPlxuIyAgICAgICAgIDxncm91cD5Hcm91cCBOYW1lPC9ncm91cD5cbiMgICAgICAgPC9pdGVtPlxuIyAgICAgPC9xdWVyeT5cbiMgICA8L2lxPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRpcVxuZXhwb3J0cy5nZXRSZW1vdmVTdGFuemEgPSAoamlkKSAtPlxuICByZXR1cm4gbnVsbCB1bmxlc3MgamlkXG4gICRpcSB0eXBlOiAnc2V0J1xuICAgIC5jICdxdWVyeScsIHhtbG5zOiBTdHJvcGhlLk5TLlJPU1RFUlxuICAgIC5jICdpdGVtJyxcbiAgICAgIGppZDogamlkXG4gICAgICBzdWJzY3JpcHRpb246ICdyZW1vdmUnXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSBmb3IgYSBwcmVzZW5jZSBzdWJzY3JpcHRpb24gcmVxdWVzdCBvciBjb25maXJtYXRpb25cbiNcbiMgQHBhcmFtIGppZCBbU3RyaW5nXSB1c2VyIGppZCBvZiB0aGUgY29udGFjdFxuIyBAcGFyYW0gdHlwZSBbU3RyaW5nXSBQcmVzZW5jZVR5cGUgY29uc3RhbnRcbiNcbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSBwcmVzZW5jZSBzdGFuemFcbiNcbiMgQGV4YW1wbGVcbiMgICA8cHJlc2VuY2UgdG89J2Zha2VqaWQnIHR5cGU9J3N1YnNjcmliZScgeG1sbnM9J2phYmJlcjpjbGllbnQnLz5cbiNcbiMgQGV4YW1wbGVcbiMgICA8cHJlc2VuY2UgdG89J2Zha2VqaWQnIHR5cGU9J3N1YnNjcmliZWQnIHhtbG5zPSdqYWJiZXI6Y2xpZW50Jy8+XG4jXG4jIEBleGFtcGxlXG4jICAgPHByZXNlbmNlIHRvPSdmYWtlamlkJyB0eXBlPSd1bnN1YnNjcmliZScgeG1sbnM9J2phYmJlcjpjbGllbnQnLz5cbiNcbiMgQGV4YW1wbGVcbiMgICA8cHJlc2VuY2UgdG89J2Zha2VqaWQnIHR5cGU9J3Vuc3Vic2NyaWJlZCcgeG1sbnM9J2phYmJlcjpjbGllbnQnLz5cbiNcbiMgQHNlZSBQcmVzZW5jZVR5cGVcbiMgQHNlZSBodHRwOi8vc3Ryb3BoZS5pbS9zdHJvcGhlanMvZG9jLzEuMi4zL2ZpbGVzL3N0cm9waGUtanMuaHRtbCMkcHJlc1xuZXhwb3J0cy5nZXRQcmVzZW5jZVN1YnNjcmlwdGlvblN0YW56YSA9IChqaWQsIHR5cGUpIC0+XG4gIHN0cm9waGVQcmVzZW5jZS5nZXRQcmVzZW5jZVN0YW56YSBqaWQsIHR5cGVcbiIsIl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xuU3Ryb3BoZSA9IHJlcXVpcmUgJ3N0cm9waGUnXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSBmb3IgZ2V0dGluZyBwcmVmZXJlbmNlcyBmcm9tIE5pdHJvXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gc3RhbnphXG4jXG4jIEBleGFtcGxlXG4jICAgPGlxIGlkPVwic2RzZGZnc2RmZ1wiIHR5cGU9XCJnZXRcIiB4bWxucz1cImphYmJlcjpjbGllbnRcIlxuIyAgICAgZnJvbT1cInBhdWwuZ3VlcnJhMS50aG9tc29ucmV1dGVycy5jb21AYXJyYXkxMi5tc2d0c3QucmV1dGVycy5jb21cIj5cbiMgICAgIDxxdWVyeSB4bWxucz1cImphYmJlcjppcTpwcml2YXRlXCI+XG4jICAgICAgIDxzdG9yYWdlIHhtbG5zPVwic3RvcmFnZTpib29rbWFya3NcIi8+XG4jICAgICAgPC9xdWVyeT5cbiMgICA8L2lxPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRpcVxuZXhwb3J0cy5nZXRQcmVmZXJlbmNlc1N0YW56YSA9IC0+XG4gIG5ldyBTdHJvcGhlLkJ1aWxkZXIgJ2lxJywgdHlwZTogJ2dldCdcbiAgICAuYyAncXVlcnknLCB4bWxuczogJ2phYmJlcjppcTpwcml2YXRlJ1xuICAgIC5jICdzdG9yYWdlJywgeG1sbnM6ICdzdG9yYWdlOnByZWZlcmVuY2VzJ1xuICAgIC5jICdwcmVmZXJlbmNlcycsIHhtbG5zOiAndHJtOmRlc2t0b3AnXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSBmb3Igc2V0dGluZyBwcmVmZXJlbmNlcyB0byBOaXRyb1xuI1xuIyBAcGFyYW0gcHJlZmVyZW5jZXMgW09iamVjdF0gSlNPTiBvYmplY3QgY29udGFpbmluZyBwcmVmZXJlbmNlcyB0byBzYXZlXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gc3RhbnphXG4jXG4jIEBleGFtcGxlXG4jICAgPGlxIGlkPVwic2RzZGZnc2RmZ1wiIHR5cGU9XCJnZXRcIiB4bWxucz1cImphYmJlcjpjbGllbnRcIlxuIyAgICAgZnJvbT1cInBhdWwuZ3VlcnJhMS50aG9tc29ucmV1dGVycy5jb21AYXJyYXkxMi5tc2d0c3QucmV1dGVycy5jb21cIj5cbiMgICAgIDxxdWVyeSB4bWxucz1cImphYmJlcjppcTpwcml2YXRlXCI+XG4jICAgICAgIDxzdG9yYWdlIHhtbG5zPVwic3RvcmFnZTpib29rbWFya3NcIj5cbiMgICAgICAgICA8cHJlZmVyZW5jZXMgeG1sbnM9XCJ0cm06ZGVza3RvcFwiPjwvcHJlZmVyZW5jZXM+XG4jICAgICAgIDwvc3RvcmFnZT5cbiMgICAgICA8L3F1ZXJ5PlxuIyAgIDwvaXE+XG4jXG4jIEBzZWUgaHR0cDovL3N0cm9waGUuaW0vc3Ryb3BoZWpzL2RvYy8xLjIuMy9maWxlcy9zdHJvcGhlLWpzLmh0bWwjJGlxXG5leHBvcnRzLnNldFByZWZlcmVuY2VzU3RhbnphID0gKHByZWZlcmVuY2VzID0ge30pIC0+XG4gIHJldHVybiBudWxsIGlmIF8uaXNFbXB0eSBwcmVmZXJlbmNlc1xuICBwcmVmZXJlbmNlc1N0ciA9IEpTT04uc3RyaW5naWZ5IHByZWZlcmVuY2VzXG5cbiAgbmV3IFN0cm9waGUuQnVpbGRlciAnaXEnLCB0eXBlOiAnc2V0J1xuICAgIC5jICdxdWVyeScsIHhtbG5zOiAnamFiYmVyOmlxOnByaXZhdGUnXG4gICAgLmMgJ3N0b3JhZ2UnLCB4bWxuczogJ3N0b3JhZ2U6cHJlZmVyZW5jZXMnXG4gICAgLmMgJ3ByZWZlcmVuY2VzJywgeG1sbnM6ICd0cm06ZGVza3RvcCdcbiAgICAudCBwcmVmZXJlbmNlc1N0clxuICAgIC51cCgpXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSBmb3Igc2V0dGluZyBnbG9iYWwgcHJlZmVyZW5jZXMgdG8gTml0cm9cbiNcbiMgQHBhcmFtIHByZWZlcmVuY2VzIFtYTUxEb2N1bWVudF0gWE1MIERvY3VtZW50IGNvbnRhaW5pbmcgcHJlZmVyZW5jZXMgdG8gc2F2ZVxuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIHN0YW56YVxuI1xuIyBAZXhhbXBsZVxuIyAgIDxpcSBpZD1cInNkc2RmZ3NkZmdcIiB0eXBlPVwiZ2V0XCIgeG1sbnM9XCJqYWJiZXI6Y2xpZW50XCJcbiMgICAgIGZyb209XCJwYXVsLmd1ZXJyYTEudGhvbXNvbnJldXRlcnMuY29tQGFycmF5MTIubXNndHN0LnJldXRlcnMuY29tXCI+XG4jICAgICA8cXVlcnkgeG1sbnM9XCJqYWJiZXI6aXE6cHJpdmF0ZVwiPlxuIyAgICAgICA8c3RvcmFnZSB4bWxucz1cInN0b3JhZ2U6cHJlZmVyZW5jZXNcIj5cbiMgICAgICAgPC9zdG9yYWdlPlxuIyAgICAgIDwvcXVlcnk+XG4jICAgPC9pcT5cbiNcbiMgQHNlZSBodHRwOi8vc3Ryb3BoZS5pbS9zdHJvcGhlanMvZG9jLzEuMi4zL2ZpbGVzL3N0cm9waGUtanMuaHRtbCMkaXFcbmV4cG9ydHMuc2V0R2xvYmFsUHJlZmVyZW5jZXNTdGFuemEgPSAoeG1sKSAtPlxuICByZXR1cm4gbnVsbCB1bmxlc3MgeG1sXG5cbiAgbmV3IFN0cm9waGUuQnVpbGRlciAnaXEnLCB0eXBlOiAnc2V0J1xuICAgIC5jICdxdWVyeScsIHhtbG5zOiAnamFiYmVyOmlxOnByaXZhdGUnXG4gICAgLmMgJ3N0b3JhZ2UnLCB4bWxuczogJ3N0b3JhZ2U6cHJlZmVyZW5jZXMnXG4gICAgLmNub2RlIHhtbFxuICAgIC51cCgpXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSBmb3Igc2V0dGluZyBlbSBwcmVmZXJlbmNlcyB0byBOaXRyb1xuI1xuIyBAcGFyYW0gcHJlZmVyZW5jZXMgW1hNTERvY3VtZW50XSBYTUwgRG9jdW1lbnQgY29udGFpbmluZyBwcmVmZXJlbmNlcyB0byBzYXZlXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gc3RhbnphXG4jXG4jIEBleGFtcGxlXG4jICAgPGlxIGlkPVwic2RzZGZnc2RmZ1wiIHR5cGU9XCJnZXRcIiB4bWxucz1cImphYmJlcjpjbGllbnRcIlxuIyAgICAgZnJvbT1cInBhdWwuZ3VlcnJhMS50aG9tc29ucmV1dGVycy5jb21AYXJyYXkxMi5tc2d0c3QucmV1dGVycy5jb21cIj5cbiMgICAgIDxxdWVyeSB4bWxucz1cImphYmJlcjppcTpwcml2YXRlXCI+XG4jICAgICAgIDxzdG9yYWdlIHhtbG5zPVwic3RvcmFnZTpodHRwczovL2NvbGxhYi50aG9tc29ucmV1dGVycy5jb20vc3RvcmFnZS9lbVwiPlxuIyAgICAgICA8L3N0b3JhZ2U+XG4jICAgICAgPC9xdWVyeT5cbiMgICA8L2lxPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRpcVxuZXhwb3J0cy5zZXRFTVByZWZlcmVuY2VzU3RhbnphID0gKHhtbCkgLT5cbiAgcmV0dXJuIG51bGwgdW5sZXNzIHhtbFxuXG4gIG5ldyBTdHJvcGhlLkJ1aWxkZXIgJ2lxJywgdHlwZTogJ3NldCdcbiAgICAuYyAncXVlcnknLCB4bWxuczogJ2phYmJlcjppcTpwcml2YXRlJ1xuICAgIC5jICdzdG9yYWdlJywgeG1sbnM6ICdodHRwczovL2NvbGxhYi50aG9tc29ucmV1dGVycy5jb20vc3RvcmFnZS9lbSdcbiAgICAuY25vZGUgeG1sXG4gICAgLnVwKClcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIGZvciBzZXR0aW5nIGJsYXN0cyBwcmVmZXJlbmNlcyB0byBOaXRyb1xuI1xuIyBAcGFyYW0gcHJlZmVyZW5jZXMgW1hNTERvY3VtZW50XSBYTUwgRG9jdW1lbnQgY29udGFpbmluZyBwcmVmZXJlbmNlcyB0byBzYXZlXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gc3RhbnphXG4jXG4jIEBleGFtcGxlXG4jICAgPGlxIGlkPVwic2RzZGZnc2RmZ1wiIHR5cGU9XCJnZXRcIiB4bWxucz1cImphYmJlcjpjbGllbnRcIlxuIyAgICAgZnJvbT1cInBhdWwuZ3VlcnJhMS50aG9tc29ucmV1dGVycy5jb21AYXJyYXkxMi5tc2d0c3QucmV1dGVycy5jb21cIj5cbiMgICAgIDxxdWVyeSB4bWxucz1cImphYmJlcjppcTpwcml2YXRlXCI+XG4jICAgICAgIDxzdG9yYWdlIHhtbG5zPVwic3RvcmFnZTpodHRwczovL2NvbGxhYi50aG9tc29ucmV1dGVycy5jb20vc3RvcmFnZS9ibGFzdHNcIj5cbiMgICAgICAgPC9zdG9yYWdlPlxuIyAgICAgIDwvcXVlcnk+XG4jICAgPC9pcT5cbiNcbiMgQHNlZSBodHRwOi8vc3Ryb3BoZS5pbS9zdHJvcGhlanMvZG9jLzEuMi4zL2ZpbGVzL3N0cm9waGUtanMuaHRtbCMkaXFcbmV4cG9ydHMuc2V0Qmxhc3RQcmVmZXJlbmNlc1N0YW56YSA9ICh4bWwpIC0+XG4gIHJldHVybiBudWxsIHVubGVzcyB4bWxcblxuICBuZXcgU3Ryb3BoZS5CdWlsZGVyICdpcScsIHR5cGU6ICdzZXQnXG4gICAgLmMgJ3F1ZXJ5JywgeG1sbnM6ICdqYWJiZXI6aXE6cHJpdmF0ZSdcbiAgICAuYyAnc3RvcmFnZScsIHhtbG5zOiAnaHR0cHM6Ly9jb2xsYWIudGhvbXNvbnJldXRlcnMuY29tL3N0b3JhZ2UvYmxhc3RzJ1xuICAgIC5jbm9kZSB4bWxcbiAgICAudXAoKVxuXG4jIFJldHJpZXZlIFN0cm9waGUuQnVpbGRlciBzdGFuemEgZm9yIHNldHRpbmcgY29udmVyc2F0aW9ucyBwcmVmZXJlbmNlcyB0byBOaXRyb1xuI1xuIyBAcGFyYW0gcHJlZmVyZW5jZXMgW1hNTERvY3VtZW50XSBYTUwgRG9jdW1lbnQgY29udGFpbmluZyBwcmVmZXJlbmNlcyB0byBzYXZlXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gc3RhbnphXG4jXG4jIEBleGFtcGxlXG4jICAgPGlxIGlkPVwic2RzZGZnc2RmZ1wiIHR5cGU9XCJnZXRcIiB4bWxucz1cImphYmJlcjpjbGllbnRcIlxuIyAgICAgZnJvbT1cInBhdWwuZ3VlcnJhMS50aG9tc29ucmV1dGVycy5jb21AYXJyYXkxMi5tc2d0c3QucmV1dGVycy5jb21cIj5cbiMgICAgIDxxdWVyeSB4bWxucz1cImphYmJlcjppcTpwcml2YXRlXCI+XG4jICAgICAgIDxzdG9yYWdlIHhtbG5zPVwic3RvcmFnZTpodHRwczovL2NvbGxhYi50aG9tc29ucmV1dGVycy5jb20vc3RvcmFnZS9jb252ZXJzYXRpb25zXCI+XG4jICAgICAgIDwvc3RvcmFnZT5cbiMgICAgICA8L3F1ZXJ5PlxuIyAgIDwvaXE+XG4jXG4jIEBzZWUgaHR0cDovL3N0cm9waGUuaW0vc3Ryb3BoZWpzL2RvYy8xLjIuMy9maWxlcy9zdHJvcGhlLWpzLmh0bWwjJGlxXG5leHBvcnRzLnNldENvbnZlcnNhdGlvblByZWZlcmVuY2VzU3RhbnphID0gKHhtbCkgLT5cbiAgcmV0dXJuIG51bGwgdW5sZXNzIHhtbFxuXG4gIG5ldyBTdHJvcGhlLkJ1aWxkZXIgJ2lxJywgdHlwZTogJ3NldCdcbiAgICAuYyAncXVlcnknLCB4bWxuczogJ2phYmJlcjppcTpwcml2YXRlJ1xuICAgIC5jICdzdG9yYWdlJywgeG1sbnM6ICdodHRwczovL2NvbGxhYi50aG9tc29ucmV1dGVycy5jb20vc3RvcmFnZS9jb252ZXJzYXRpb25zJ1xuICAgIC5jbm9kZSB4bWxcbiAgICAudXAoKVxuXG4jIFJldHJpZXZlIFN0cm9waGUuQnVpbGRlciBzdGFuemEgZm9yIHNldHRpbmcgYWxlcnRzIHByZWZlcmVuY2VzIHRvIE5pdHJvXG4jXG4jIEBwYXJhbSBwcmVmZXJlbmNlcyBbWE1MRG9jdW1lbnRdIFhNTCBEb2N1bWVudCBjb250YWluaW5nIHByZWZlcmVuY2VzIHRvIHNhdmVcbiNcbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSBzdGFuemFcbiNcbiMgQGV4YW1wbGVcbiMgICA8aXEgaWQ9XCJzZHNkZmdzZGZnXCIgdHlwZT1cImdldFwiIHhtbG5zPVwiamFiYmVyOmNsaWVudFwiXG4jICAgICBmcm9tPVwicGF1bC5ndWVycmExLnRob21zb25yZXV0ZXJzLmNvbUBhcnJheTEyLm1zZ3RzdC5yZXV0ZXJzLmNvbVwiPlxuIyAgICAgPHF1ZXJ5IHhtbG5zPVwiamFiYmVyOmlxOnByaXZhdGVcIj5cbiMgICAgICAgPHN0b3JhZ2UgeG1sbnM9XCJzdG9yYWdlOmh0dHBzOi8vY29sbGFiLnRob21zb25yZXV0ZXJzLmNvbS9zdG9yYWdlL2FsZXJ0c1wiPlxuIyAgICAgICA8L3N0b3JhZ2U+XG4jICAgICAgPC9xdWVyeT5cbiMgICA8L2lxPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRpcVxuZXhwb3J0cy5zZXRBbGVydFByZWZlcmVuY2VzU3RhbnphID0gKHhtbCkgLT5cbiAgcmV0dXJuIG51bGwgdW5sZXNzIHhtbFxuXG4gIG5ldyBTdHJvcGhlLkJ1aWxkZXIgJ2lxJywgdHlwZTogJ3NldCdcbiAgICAuYyAncXVlcnknLCB4bWxuczogJ2phYmJlcjppcTpwcml2YXRlJ1xuICAgIC5jICdzdG9yYWdlJywgeG1sbnM6ICdodHRwczovL2NvbGxhYi50aG9tc29ucmV1dGVycy5jb20vc3RvcmFnZS9hbGVydHMnXG4gICAgLmNub2RlIHhtbFxuICAgIC51cCgpXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSBmb3IgZ2V0dGluZyBnbG9iYWwgcHJlZmVyZW5jZXMgZnJvbSBOaXRyb1xuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIHN0YW56YVxuI1xuIyBAZXhhbXBsZVxuIyAgIDxpcSBpZD1cInNkc2RmZ3NkZmdcIiB0eXBlPVwiZ2V0XCIgeG1sbnM9XCJqYWJiZXI6Y2xpZW50XCJcbiMgICAgIGZyb209XCJwYXVsLmd1ZXJyYTEudGhvbXNvbnJldXRlcnMuY29tQGFycmF5MTIubXNndHN0LnJldXRlcnMuY29tXCI+XG4jICAgICA8cXVlcnkgeG1sbnM9XCJqYWJiZXI6aXE6cHJpdmF0ZVwiPlxuIyAgICAgICA8c3RvcmFnZSB4bWxucz1cInN0b3JhZ2U6cHJlZmVyZW5jZXNcIiAvPlxuIyAgICAgIDwvcXVlcnk+XG4jICAgPC9pcT5cbiNcbiMgQHNlZSBodHRwOi8vc3Ryb3BoZS5pbS9zdHJvcGhlanMvZG9jLzEuMi4zL2ZpbGVzL3N0cm9waGUtanMuaHRtbCMkaXFcbmV4cG9ydHMuZ2V0R2xvYmFsUHJlZmVyZW5jZXNTdGFuemEgPSAtPlxuICBuZXcgU3Ryb3BoZS5CdWlsZGVyICdpcScsIHR5cGU6ICdnZXQnXG4gICAgLmMgJ3F1ZXJ5JywgeG1sbnM6ICdqYWJiZXI6aXE6cHJpdmF0ZSdcbiAgICAuYyAnc3RvcmFnZScsIHhtbG5zOiAnc3RvcmFnZTpwcmVmZXJlbmNlcydcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIGZvciBnZXR0aW5nIGVtIHByZWZlcmVuY2VzIGZyb20gTml0cm9cbiNcbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSBzdGFuemFcbiNcbiMgQGV4YW1wbGVcbiMgICA8aXEgaWQ9XCJzZHNkZmdzZGZnXCIgdHlwZT1cImdldFwiIHhtbG5zPVwiamFiYmVyOmNsaWVudFwiXG4jICAgICBmcm9tPVwicGF1bC5ndWVycmExLnRob21zb25yZXV0ZXJzLmNvbUBhcnJheTEyLm1zZ3RzdC5yZXV0ZXJzLmNvbVwiPlxuIyAgICAgPHF1ZXJ5IHhtbG5zPVwiamFiYmVyOmlxOnByaXZhdGVcIj5cbiMgICAgICAgPHN0b3JhZ2UgeG1sbnM9XCJzdG9yYWdlOmh0dHBzOi8vY29sbGFiLnRob21zb25yZXV0ZXJzLmNvbS9zdG9yYWdlL2VtXCIgLz5cbiMgICAgICA8L3F1ZXJ5PlxuIyAgIDwvaXE+XG4jXG4jIEBzZWUgaHR0cDovL3N0cm9waGUuaW0vc3Ryb3BoZWpzL2RvYy8xLjIuMy9maWxlcy9zdHJvcGhlLWpzLmh0bWwjJGlxXG5leHBvcnRzLmdldEVNUHJlZmVyZW5jZXNTdGFuemEgPSAtPlxuICBuZXcgU3Ryb3BoZS5CdWlsZGVyICdpcScsIHR5cGU6ICdnZXQnXG4gICAgLmMgJ3F1ZXJ5JywgeG1sbnM6ICdqYWJiZXI6aXE6cHJpdmF0ZSdcbiAgICAuYyAnc3RvcmFnZScsIHhtbG5zOiAnaHR0cHM6Ly9jb2xsYWIudGhvbXNvbnJldXRlcnMuY29tL3N0b3JhZ2UvZW0nXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSBmb3IgZ2V0dGluZyBibGFzdHMgcHJlZmVyZW5jZXMgZnJvbSBOaXRyb1xuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIHN0YW56YVxuI1xuIyBAZXhhbXBsZVxuIyAgIDxpcSBpZD1cInNkc2RmZ3NkZmdcIiB0eXBlPVwiZ2V0XCIgeG1sbnM9XCJqYWJiZXI6Y2xpZW50XCJcbiMgICAgIGZyb209XCJwYXVsLmd1ZXJyYTEudGhvbXNvbnJldXRlcnMuY29tQGFycmF5MTIubXNndHN0LnJldXRlcnMuY29tXCI+XG4jICAgICA8cXVlcnkgeG1sbnM9XCJqYWJiZXI6aXE6cHJpdmF0ZVwiPlxuIyAgICAgICA8c3RvcmFnZSB4bWxucz1cInN0b3JhZ2U6aHR0cHM6Ly9jb2xsYWIudGhvbXNvbnJldXRlcnMuY29tL3N0b3JhZ2UvYmxhc3RzXCIgLz5cbiMgICAgICA8L3F1ZXJ5PlxuIyAgIDwvaXE+XG4jXG4jIEBzZWUgaHR0cDovL3N0cm9waGUuaW0vc3Ryb3BoZWpzL2RvYy8xLjIuMy9maWxlcy9zdHJvcGhlLWpzLmh0bWwjJGlxXG5leHBvcnRzLmdldEJsYXN0c1ByZWZlcmVuY2VzU3RhbnphID0gLT5cbiAgbmV3IFN0cm9waGUuQnVpbGRlciAnaXEnLCB0eXBlOiAnZ2V0J1xuICAgIC5jICdxdWVyeScsIHhtbG5zOiAnamFiYmVyOmlxOnByaXZhdGUnXG4gICAgLmMgJ3N0b3JhZ2UnLCB4bWxuczogJ2h0dHBzOi8vY29sbGFiLnRob21zb25yZXV0ZXJzLmNvbS9zdG9yYWdlL2JsYXN0cydcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIGZvciBnZXR0aW5nIGNvbnZlcnNhdGlvbnMgcHJlZmVyZW5jZXMgZnJvbSBOaXRyb1xuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIHN0YW56YVxuI1xuIyBAZXhhbXBsZVxuIyAgIDxpcSBpZD1cInNkc2RmZ3NkZmdcIiB0eXBlPVwiZ2V0XCIgeG1sbnM9XCJqYWJiZXI6Y2xpZW50XCJcbiMgICAgIGZyb209XCJwYXVsLmd1ZXJyYTEudGhvbXNvbnJldXRlcnMuY29tQGFycmF5MTIubXNndHN0LnJldXRlcnMuY29tXCI+XG4jICAgICA8cXVlcnkgeG1sbnM9XCJqYWJiZXI6aXE6cHJpdmF0ZVwiPlxuIyAgICAgICA8c3RvcmFnZSB4bWxucz1cInN0b3JhZ2U6aHR0cHM6Ly9jb2xsYWIudGhvbXNvbnJldXRlcnMuY29tL3N0b3JhZ2UvY29udmVyc2F0aW9uc1wiIC8+XG4jICAgICAgPC9xdWVyeT5cbiMgICA8L2lxPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRpcVxuZXhwb3J0cy5nZXRDb252ZXJzYXRpb25QcmVmZXJlbmNlc1N0YW56YSA9IC0+XG4gIG5ldyBTdHJvcGhlLkJ1aWxkZXIgJ2lxJywgdHlwZTogJ2dldCdcbiAgICAuYyAncXVlcnknLCB4bWxuczogJ2phYmJlcjppcTpwcml2YXRlJ1xuICAgIC5jICdzdG9yYWdlJywgeG1sbnM6ICdodHRwczovL2NvbGxhYi50aG9tc29ucmV1dGVycy5jb20vc3RvcmFnZS9jb252ZXJzYXRpb25zJ1xuXG4jIFJldHJpZXZlIFN0cm9waGUuQnVpbGRlciBzdGFuemEgZm9yIGdldHRpbmcgYWxlcnRzIHByZWZlcmVuY2VzIGZyb20gTml0cm9cbiNcbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSBzdGFuemFcbiNcbiMgQGV4YW1wbGVcbiMgICA8aXEgaWQ9XCJzZHNkZmdzZGZnXCIgdHlwZT1cImdldFwiIHhtbG5zPVwiamFiYmVyOmNsaWVudFwiXG4jICAgICBmcm9tPVwicGF1bC5ndWVycmExLnRob21zb25yZXV0ZXJzLmNvbUBhcnJheTEyLm1zZ3RzdC5yZXV0ZXJzLmNvbVwiPlxuIyAgICAgPHF1ZXJ5IHhtbG5zPVwiamFiYmVyOmlxOnByaXZhdGVcIj5cbiMgICAgICAgPHN0b3JhZ2UgeG1sbnM9XCJzdG9yYWdlOmh0dHBzOi8vY29sbGFiLnRob21zb25yZXV0ZXJzLmNvbS9zdG9yYWdlL2FsZXJ0c1wiIC8+XG4jICAgICAgPC9xdWVyeT5cbiMgICA8L2lxPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRpcVxuZXhwb3J0cy5nZXRBbGVydHNQcmVmZXJlbmNlc1N0YW56YSA9IC0+XG4gIG5ldyBTdHJvcGhlLkJ1aWxkZXIgJ2lxJywgdHlwZTogJ2dldCdcbiAgICAuYyAncXVlcnknLCB4bWxuczogJ2phYmJlcjppcTpwcml2YXRlJ1xuICAgIC5jICdzdG9yYWdlJywgeG1sbnM6ICdodHRwczovL2NvbGxhYi50aG9tc29ucmV1dGVycy5jb20vc3RvcmFnZS9hbGVydHMnXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSBmb3Igc2V0dGluZyBibGFuayBwcmVmZXJlbmNlcyB0byBOaXRyb1xuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIHN0YW56YVxuZXhwb3J0cy5jbGVhclByZWZlcmVuY2VzU3RhbnphID0gLT5cbiAgbmV3IFN0cm9waGUuQnVpbGRlciAnaXEnLCB0eXBlOiAnc2V0J1xuICAgIC5jICdxdWVyeScsIHhtbG5zOiAnamFiYmVyOmlxOnByaXZhdGUnXG4gICAgLmMgJ3N0b3JhZ2UnLCB4bWxuczogJ3N0b3JhZ2U6cHJlZmVyZW5jZXMnXG4gICAgLmMgJ3ByZWZlcmVuY2VzJywgeG1sbnM6ICd0cm06ZGVza3RvcCdcbiAgICAudCAnJ1xuICAgIC51cCgpXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSBmb3Igc2V0dGluZyBibGFuayBnbG9iYWwgcHJlZmVyZW5jZXMgdG8gTml0cm9cbiNcbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSBzdGFuemFcbmV4cG9ydHMuY2xlYXJHbG9iYWxQcmVmZXJlbmNlc1N0YW56YSA9IC0+XG4gIG5ldyBTdHJvcGhlLkJ1aWxkZXIgJ2lxJywgdHlwZTogJ3NldCdcbiAgICAuYyAncXVlcnknLCB4bWxuczogJ2phYmJlcjppcTpwcml2YXRlJ1xuICAgIC5jICdzdG9yYWdlJywgeG1sbnM6ICdzdG9yYWdlOnByZWZlcmVuY2VzJ1xuICAgIC50ICcnXG4gICAgLnVwKClcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIGZvciBzZXR0aW5nIGJsYW5rIGVtIHByZWZlcmVuY2VzIHRvIE5pdHJvXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gc3RhbnphXG5leHBvcnRzLmNsZWFyRU1QcmVmZXJlbmNlc1N0YW56YSA9IC0+XG4gIG5ldyBTdHJvcGhlLkJ1aWxkZXIgJ2lxJywgdHlwZTogJ3NldCdcbiAgICAuYyAncXVlcnknLCB4bWxuczogJ2phYmJlcjppcTpwcml2YXRlJ1xuICAgIC5jICdzdG9yYWdlJywgeG1sbnM6ICdodHRwczovL2NvbGxhYi50aG9tc29ucmV1dGVycy5jb20vc3RvcmFnZS9lbSdcbiAgICAudCAnJ1xuICAgIC51cCgpXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSBmb3Igc2V0dGluZyBibGFuayBibGFzdHMgcHJlZmVyZW5jZXMgdG8gTml0cm9cbiNcbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSBzdGFuemFcbmV4cG9ydHMuY2xlYXJCbGFzdHNQcmVmZXJlbmNlc1N0YW56YSA9IC0+XG4gIG5ldyBTdHJvcGhlLkJ1aWxkZXIgJ2lxJywgdHlwZTogJ3NldCdcbiAgICAuYyAncXVlcnknLCB4bWxuczogJ2phYmJlcjppcTpwcml2YXRlJ1xuICAgIC5jICdzdG9yYWdlJywgeG1sbnM6ICdodHRwczovL2NvbGxhYi50aG9tc29ucmV1dGVycy5jb20vc3RvcmFnZS9ibGFzdHMnXG4gICAgLnQgJydcbiAgICAudXAoKVxuXG4jIFJldHJpZXZlIFN0cm9waGUuQnVpbGRlciBzdGFuemEgZm9yIHNldHRpbmcgYmxhbmsgYmxhc3RzIHByZWZlcmVuY2VzIHRvIE5pdHJvXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gc3RhbnphXG5leHBvcnRzLmNsZWFyQ29udmVyc2F0aW9uc1ByZWZlcmVuY2VzU3RhbnphID0gLT5cbiAgbmV3IFN0cm9waGUuQnVpbGRlciAnaXEnLCB0eXBlOiAnc2V0J1xuICAgIC5jICdxdWVyeScsIHhtbG5zOiAnamFiYmVyOmlxOnByaXZhdGUnXG4gICAgLmMgJ3N0b3JhZ2UnLCB4bWxuczogJ2h0dHBzOi8vY29sbGFiLnRob21zb25yZXV0ZXJzLmNvbS9zdG9yYWdlL2NvbnZlcnNhdGlvbnMnXG4gICAgLnQgJydcbiAgICAudXAoKVxuXG4jIFJldHJpZXZlIFN0cm9waGUuQnVpbGRlciBzdGFuemEgZm9yIHNldHRpbmcgYmxhbmsgYmxhc3RzIHByZWZlcmVuY2VzIHRvIE5pdHJvXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gc3RhbnphXG5leHBvcnRzLmNsZWFyQWxlcnRzUHJlZmVyZW5jZXNTdGFuemEgPSAtPlxuICBuZXcgU3Ryb3BoZS5CdWlsZGVyICdpcScsIHR5cGU6ICdzZXQnXG4gICAgLmMgJ3F1ZXJ5JywgeG1sbnM6ICdqYWJiZXI6aXE6cHJpdmF0ZSdcbiAgICAuYyAnc3RvcmFnZScsIHhtbG5zOiAnaHR0cHM6Ly9jb2xsYWIudGhvbXNvbnJldXRlcnMuY29tL3N0b3JhZ2UvYWxlcnRzJ1xuICAgIC50ICcnXG4gICAgLnVwKClcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIGZvciBnZXR0aW5nIGJvb2ttYXJrcyBmcm9tIE5pdHJvXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gc3RhbnphXG4jXG4jIEBleGFtcGxlXG4jICAgPGlxIGlkPVwic2RzZGZnc2RmZ1wiIHR5cGU9XCJnZXRcIiB4bWxucz1cImphYmJlcjpjbGllbnRcIlxuIyAgICAgZnJvbT1cInBhdWwuZ3VlcnJhMS50aG9tc29ucmV1dGVycy5jb21AYXJyYXkxMi5tc2d0c3QucmV1dGVycy5jb21cIj5cbiMgICAgIDxxdWVyeSB4bWxucz1cImphYmJlcjppcTpwcml2YXRlXCI+XG4jICAgICAgIDxzdG9yYWdlIHhtbG5zPVwic3RvcmFnZTpib29rbWFya3NcIi8+XG4jICAgICA8L3F1ZXJ5PlxuIyAgIDwvaXE+XG4jXG4jIEBzZWUgaHR0cDovL3N0cm9waGUuaW0vc3Ryb3BoZWpzL2RvYy8xLjIuMy9maWxlcy9zdHJvcGhlLWpzLmh0bWwjJGlxXG5leHBvcnRzLmdldEJvb2ttYXJrc1N0YW56YSA9IC0+XG4gIG5ldyBTdHJvcGhlLkJ1aWxkZXIgJ2lxJywgdHlwZTogJ2dldCdcbiAgICAuYyAncXVlcnknLCB4bWxuczogJ2phYmJlcjppcTpwcml2YXRlJ1xuICAgIC5jICdzdG9yYWdlJywgeG1sbnM6ICdzdG9yYWdlOmJvb2ttYXJrcydcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIGZvciBzZXR0aW5nIGJvb2ttYXJrcyB0byBOaXRyb1xuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIHN0YW56YVxuI1xuIyBAZXhhbXBsZVxuIyAgIDxpcSB0eXBlPSdzZXQnIHhtbG5zPSdqYWJiZXI6Y2xpZW50Jz5cbiMgICAgIDxxdWVyeSB4bWxucz0namFiYmVyOmlxOnByaXZhdGUnPlxuIyAgICAgICA8c3RvcmFnZSB4bWxucz0nc3RvcmFnZTpib29rbWFya3MnPlxuIyAgICAgICAgIDxjb25mZXJlbmNlIGppZD0nZ3JvdXBjaGF0LTQ3MzE0QGNvbmZlcmVuY2UucmV1YXNtYi5uZXQnXG4jICAgICAgICAgICBuYW1lPSdYTVBQIENoYXRyb29tIDEnIGF1dG9qb2luPSdmYWxzZScvPlxuIyAgICAgICAgIDxjb25mZXJlbmNlIGppZD0nbml0cm9AY29uZmVyZW5jZS5yZXVhc21iLm5ldCdcbiMgICAgICAgICAgIG5hbWU9J1hNUFAgQ2hhdHJvb20gMicgYXV0b2pvaW49J3RydWUnLz5cbiMgICAgICAgPC9zdG9yYWdlPlxuIyAgICAgPC9xdWVyeT5cbiMgICA8L2lxPlxuI1xuIyBAc2VlIGh0dHA6Ly9zdHJvcGhlLmltL3N0cm9waGVqcy9kb2MvMS4yLjMvZmlsZXMvc3Ryb3BoZS1qcy5odG1sIyRpcVxuZXhwb3J0cy5zZXRCb29rbWFya3NTdGFuemEgPSAoY2hhdHJvb21zKSAtPlxuICBzYiA9IG5ldyBTdHJvcGhlLkJ1aWxkZXIgJ2lxJywgdHlwZTogJ3NldCdcbiAgICAuYyAncXVlcnknLCB4bWxuczogJ2phYmJlcjppcTpwcml2YXRlJ1xuICAgIC5jICdzdG9yYWdlJywgeG1sbnM6ICdzdG9yYWdlOmJvb2ttYXJrcydcbiAgc2IuYyhjaGF0cm9vbS50eXBlLCBjaGF0cm9vbSkudXAoKSBmb3IgY2hhdHJvb20gaW4gY2hhdHJvb21zXG4gIHNiXG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcblN0cm9waGUgPSByZXF1aXJlICdzdHJvcGhlJ1xuc3Ryb3BoZVJvc3RlciA9IHJlcXVpcmUgJ3N0cm9waGUvc3Ryb3BoZV9yb3N0ZXInXG5zdHJvcGhlUHJlc2VuY2UgPSByZXF1aXJlICdzdHJvcGhlL3N0cm9waGVfcHJlc2VuY2UnXG5cbmV4cG9ydHMuZ2V0UmVnaXN0ZXJTdGFuemEgPSAoYWRkcmVzcywgdXNlcm5hbWUsIHBhc3N3b3JkLCBhdXRvTG9naW4gPSBmYWxzZSkgLT5cbiAgaW5mbyA9IHRvOiBhZGRyZXNzLCB0eXBlOiAnc2V0J1xuICBpcSA9ICRpcSBpbmZvXG4gICAgLmMgJ3F1ZXJ5JywgeG1sbnM6ICdqYWJiZXI6aXE6cmVnaXN0ZXInXG4gICAgLmMgJ3gnLCB4bWxuczogJ2phYmJlcjp4OmRhdGEnLCB0eXBlOiAnc3VibWl0J1xuICAgIC5jICdmaWVsZCcsIHZhcjogJ0ZPUk1fVFlQRSdcbiAgICAuYyAndmFsdWUnXG4gICAgICAudCAnamFiYmVyOmlxOnJlZ2lzdGVyJ1xuICAgICAgLnVwKClcbiAgICAudXAoKVxuXG4gIGlxLmMgJ2ZpZWxkJywgdmFyOiAndXNlcm5hbWUnXG4gICAgLmMgJ3ZhbHVlJ1xuICAgICAgLnQgdXNlcm5hbWVcbiAgICAgICAgLnVwKClcbiAgICAgIC51cCgpXG4gICAgLmMgJ2ZpZWxkJywgdmFyOiAncGFzc3dvcmQnXG4gICAgICAuYyAndmFsdWUnXG4gICAgICAgIC50IHBhc3N3b3JkXG4gICAgICAgIC51cCgpXG4gICAgICAudXAoKVxuXG4gIGlmIGF1dG9Mb2dpblxuICAgIGlxLmMgJ2ZpZWxkJywgdmFyOiAnYXV0b2xvZ2luJ1xuICAgICAgLmMgJ3ZhbHVlJ1xuICAgICAgICAudCAnMSdcbiAgICAgICAgLnVwKClcbiAgICAgIC51cCgpXG5cbiAgcmV0dXJuIGlxXG5cbmV4cG9ydHMuZ2V0VW5yZWdpc3RlclN0YW56YSA9IChhZGRyZXNzKSAtPlxuICBpbmZvID0gdG86IGFkZHJlc3MsIHR5cGU6ICdzZXQnXG4gICRpcSBpbmZvXG4gICAgLmMgJ3F1ZXJ5JywgeG1sbnM6ICdqYWJiZXI6aXE6cmVnaXN0ZXInXG4gICAgLmMgJ3JlbW92ZSdcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIGZvciBnZXR0aW5nIHRoZSByb3N0ZXIgZnJvbSBOaXRyb1xuI1xuIyBAcGFyYW0gYWRkcmVzcyBbU3RyaW5nXSBvcHRpb25hbCBhZGRyZXNzIGZvciB0aGUgJ3RvJyBmaWVsZFxuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIHN0YW56YVxuZXhwb3J0cy5nZXRSb3N0ZXJTdGFuemEgPSAoYWRkcmVzcykgLT5cbiAgcmV0dXJuIG51bGwgdW5sZXNzIGFkZHJlc3NcbiAgc3Ryb3BoZVJvc3Rlci5nZXRSb3N0ZXJTdGFuemEgYWRkcmVzc1xuXG4jIFJldHJpZXZlIFN0cm9waGUuQnVpbGRlciBzdGFuemEgZm9yIGEgcHJlc2VuY2Ugc3Vic2NyaXB0aW9uIHJlcXVlc3Qgb3IgY29uZmlybWF0aW9uXG4jXG4jIEBwYXJhbSBqaWQgW1N0cmluZ10gdXNlciBqaWQgb2YgdGhlIGNvbnRhY3RcbiMgQHBhcmFtIHR5cGUgW1N0cmluZ10gUHJlc2VuY2VUeXBlIGNvbnN0YW50XG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gcHJlc2VuY2Ugc3RhbnphXG4jXG4jIEBzZWUgc3Ryb3BoZS9zdHJvcGhlX3ByZXNlbmNlXG5leHBvcnRzLmdldFN1YnNjcmlwdGlvblN0YW56YSA9IChhZGRyZXNzLCB0eXBlLCBzaG93KSAtPlxuICByZXR1cm4gbnVsbCB1bmxlc3MgYWRkcmVzcyBhbmQgdHlwZVxuICBzdHJvcGhlUHJlc2VuY2UuZ2V0UHJlc2VuY2VTdGFuemEgYWRkcmVzcywgdHlwZSwgc2hvd1xuXG4jIFJldHJpZXZlIFN0cm9waGUuQnVpbGRlciBzdGFuemEgdG8gYWRkIGEgY29udGFjdCB2aWEgWWFob28hIHhtcHAgZ2F0ZXdheVxuI1xuIyBAcGFyYW0gamlkIFtTdHJpbmddICBjb250YWN0IGlkXG4jXG4jIEByZXR1cm4gW1N0cm9waGUuQnVpbGRlcl0gcHJlc2VuY2Ugc3RhbnphIHRvIGFkZCBjb250YWN0XG4jXG4jIEBzZWUgc3Ryb3BoZS9zdHJvcGhlX3ByZXNlbmNlXG5leHBvcnRzLmdldEFkZENvbnRhY3RTdGFuemEgPSAoamlkKSAtPlxuICByZXR1cm4gbnVsbCB1bmxlc3MgamlkXG4gIHN0cm9waGVQcmVzZW5jZS5nZXRQcmVzZW5jZVN0YW56YSBqaWQsICdzdWJzY3JpYmUnXG5cbiMgUmV0cmlldmUgU3Ryb3BoZS5CdWlsZGVyIHN0YW56YSB0byBhZGQgYSBjb250YWN0IHZpYSBZYWhvbyEgeG1wcCBnYXRld2F5XG4jXG4jIEBwYXJhbSBqaWQgW1N0cmluZ10gIGNvbnRhY3QgaWRcbiNcbiMgQHJldHVybiBbU3Ryb3BoZS5CdWlsZGVyXSBwcmVzZW5jZSBzdGFuemEgdG8gYWRkIGNvbnRhY3RcbiNcbiMgQHNlZSBzdHJvcGhlL3N0cm9waGVfcHJlc2VuY2VcbmV4cG9ydHMuZ2V0QWxsb3dDb250YWN0U3RhbnphID0gKGppZCkgLT5cbiAgcmV0dXJuIG51bGwgdW5sZXNzIGppZFxuICBzdHJvcGhlUHJlc2VuY2UuZ2V0UHJlc2VuY2VTdGFuemEgamlkLCAnc3Vic2NyaWJlZCdcblxuIyBSZXRyaWV2ZSBTdHJvcGhlLkJ1aWxkZXIgc3RhbnphIHRvIHJlbW92ZSBhIGNvbnRhY3QgdmlhIFlhaG9vISB4bXBwIGdhdGV3YXlcbiNcbiMgQHBhcmFtIGppZCBbU3RyaW5nXSAgY29udGFjdCBpZFxuI1xuIyBAcmV0dXJuIFtTdHJvcGhlLkJ1aWxkZXJdIHByZXNlbmNlIHN0YW56YSB0byByZW1vdmUgY29udGFjdFxuI1xuIyBAc2VlIHN0cm9waGUvc3Ryb3BoZV9wcmVzZW5jZVxuZXhwb3J0cy5nZXRSZW1vdmVDb250YWN0U3RhbnphID0gKGppZCkgLT5cbiAgcmV0dXJuIG51bGwgdW5sZXNzIGppZFxuICBzdHJvcGhlUHJlc2VuY2UuZ2V0UHJlc2VuY2VTdGFuemEgamlkLCAndW5zdWJzY3JpYmUnXG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcblxuRVJST1JfREVGQVVMVCA9IFwiWW91IGhhdmUgZXhjZWVkZWQgdGhlIG51bWJlciBvZiBhbGxvd2FibGUgZnVuY3Rpb24gY2FsbHNcbiAgZm9yIHRoaXMgdGltZSBwZXJpb2RcIlxuRVJST1JfTUFYXzAgPSBcIlRoZSBhbGxvd2FibGUgbnVtYmVyIG9mIGZ1bmN0aW9uIGNhbGxzIGlzIDBcIlxuRVJST1JfQ0FMTF9NQVhfSU5ERUZJTklURSA9IFwiWW91IGhhdmUgZXhjZWVkZWQgdGhlIG51bWJlciBvZiBhbGxvd2FibGUgZnVuY3Rpb24gY2FsbHNcIlxuXG4jIFV0aWxpdHkgbWV0aG9kIHJldHVybmluZyBhIGNvcHkgb2YgYSBmdW5jdGlvbiB0aGF0IGNhbiBvbmx5IGJlIGludm9rZWRcbiMgICBhIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMgd2l0aGluIGEgZ2l2ZW4gdGltZSBwZXJpb2RcbiNcbiMgQHBhcmFtIGZ1bmMgW0Z1bmN0aW9uXSB0aGUgZnVuY3Rpb24gdG8gd3JhcCB3aXRoIHRoZSByYXRlIGxpbWl0YXRpb25cbiMgQHBhcmFtIG9wdGlvbnMgW09iZWpjdF0gYW4gb2JqZWN0IG9mIG9wdGlvbnNcbiMgQG9wdGlvbiBvcHRpb25zIG1heCBbTnVtYmVyXSBhIHBvc2l0aXZlIGludGVnZXIgZm9yIHRoZSBtYXhpbXVtIG51bWJlciBvZlxuIyAgIGNhbGxzIHRvIHRoZSBmdW5jdGlvbiwgZGVmYXVsdCBpcyAxXG4jIEBvcHRpb24gb3B0aW9ucyB0aW1lIFtOdW1iZXJdIHRoZSB0aW1lIHBlcmlvZCBpbiBtaWxsaXNlY29uZHMgZm9yIHRyYWNraW5nXG4jICAgYW5kIGxpbWl0aW5nIHRoZSBudW1iZXIgb2YgZnVuY3Rpb24gY2FsbHMsIGRlZmF1bHQgaXMgMTAwMFxuIyBAb3B0aW9uIG9wdGlvbnMgY29udGV4dCBbT2JqZWN0XSB0aGUgY29udGV4dCBmb3IgdGhlIGZ1bmN0aW9uIHdoZW4gaW52b2tlZFxuIyBAb3B0aW9uIG9wdGlvbnMgZXJyb3JNZXNzYWdlIFtTdHJpbmddIGFuIGN1c3RvbSBtZXNzYWdlIHJldHVybmVkIHdoZW4gdGhlXG4jICAgZnVuY3Rpb24gaXMgaW52b2tlZCBiZXlvbmQgdGhlIHJhdGUgcGVybWl0dGVkIGluIHRoZSBzcGVjaWZpZWQgdGltZVxuIyAgIHBlcmlvZFxuI1xuIyBAcmV0dXJuIFtGdW5jdGlvbiwgRXJyb3JdIGEgY29weSBvZiB0aGUgZnVuY3Rpb24gdGhhdCB3aGVuIGNhbGxlZCBlaXRoZXJcbiMgICByZXR1cm5zIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIG9yIGFuIEVycm9yIGlmIGNhbGxlZFxuIyAgIHRvbyBtYW55IHRpbWVzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHBlcmlvZFxuI1xuIyBAZXhhbXBsZVxuIyAgIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG4jICAgXy5taXhpbihyZXF1aXJlKCdsaW1paXQnKSk7XG4jXG4jICAgZnVuYyA9IGZ1bmN0aW9uKCl7XG4jICAgICByZXR1cm4gdHJ1ZTtcbiMgICB9O1xuIyAgIGxpbWl0ZWRGdW5jID0gXy5saW1pdChmdW5jLCB7bWF4OiAyfSk7XG4jICAgbGltaXRlZEZ1bmMoKTsgLy8gLT4gdHJ1ZVxuIyAgIGxpbWl0ZWRGdW5jKCk7IC8vIC0+IHRydWVcbiMgICBsaW1pdGVkRnVuY3t9OyAvLyAtPiBFcnJvclxuI1xuZXhwb3J0cy5saW1pdCA9IChmdW5jLCBvcHRpb25zID0ge30pIC0+XG4gIHttYXgsIHRpbWUsIGNvbnRleHQsIGVycm9yTWVzc2FnZX0gPSBfLmRlZmF1bHRzIG9wdGlvbnMsXG4gICAgY29udGV4dDogd2luZG93XG4gICAgZXJyb3JNZXNzYWdlOiBFUlJPUl9ERUZBVUxUXG4gIG1heCA9IHBvc2l0aXZlSW50IG1heCwgMVxuICB0aW1lID0gcG9zaXRpdmVJbnQgdGltZSwgMTAwMFxuICBjYWxscyA9IFtdXG4gIG5vUmVzZXQgPSBpZiB0aW1lIHRoZW4gZmFsc2UgZWxzZSB0cnVlXG5cbiAgLT5cbiAgICBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgIFxuICAgIGlmIG1heCBpcyAwXG4gICAgICByZXR1cm4gbmV3IEVycm9yIEVSUk9SX01BWF8wXG4gICAgaWYgKGNhbGxzLmxlbmd0aCA+PSBtYXgpIGFuZCBub1Jlc2V0XG4gICAgICByZXR1cm4gbmV3IEVycm9yIEVSUk9SX0NBTExfTUFYX0lOREVGSU5JVEVcbiAgICAgIFxuICAgICMgTG9vayBiYWNrIGluIHRoZSBjYWxscyBhcnJheSBhdCBhIHNwZWNpZmljIGNhbGxcbiAgICBpZiAocmVmSW5kZXggPSBjYWxscy5sZW5ndGggLSBtYXgpID49IDBcbiAgICAgICMgQ2hlY2sgZm9yIGEgdmFsaWQgaW52b2NhdGlvbiB0byBjb21wYXJlIGFnYWluc3RcbiAgICAgIGlmIChyZWZUaW1lID0gY2FsbHNbcmVmSW5kZXhdKSA+PSAwXG4gICAgICAgICMgV2UgYXJlIHN0aWxsIHdpdGhpbiB0aGUgdGltZSBwZXJpb2RcbiAgICAgICAgaWYgbm93IC0gcmVmVGltZSA8IHRpbWVcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yIGVycm9yTWVzc2FnZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgIyBSZXNldCB0aGUgdGltZSBwZXJpb2RcbiAgICAgICAgICBjYWxscyA9IFtdXG5cbiAgICBjYWxscy5wdXNoIG5vd1xuICAgIGZ1bmMuYXBwbHkgY29udGV4dCwgYXJndW1lbnRzXG5cbiMgRm9yY2UgYSB2YWx1ZSB0byBhIHBvc2l0aXZlIGludGVnZXIgb3IgcmV0dXJuIGEgZGVmYXVsdCB2YWx1ZVxuIyBAcHJpdmF0ZVxuI1xuIyBAcGFyYW0gbiBbT2JqZWN0XSBhbiBvYmplY3QsIGV4cGVjdGVkIHRvIGJlIGEgTnVtYmVyLCB0aGF0IHdpbGwgYmUgdmFsaWRhdGVkXG4jIEBwYXJhbSBkZWZhdWx0VmFsIFtOdW1iZXJdIGEgTnVtYmVyIHRvIHVzZSBhcyBhIGRlZmF1bHRcbiNcbiMgQHJldHVybiBbTnVtYmVyXSB0aGUgdmFsaWRhdGVkIHBvc2l0aXZlIEludGVnZXJcbnBvc2l0aXZlSW50ID0gKG4sIGRlZmF1bHRWYWwpIC0+XG4gIG51bSA9IE51bWJlciBuXG4gIGlmIG51bSA+PSAwXG4gICAgfn5udW1cbiAgZWxzZVxuICAgIGRlZmF1bHRWYWxcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzXG4iLCIjIFV0aWwgbWV0aG9kcyBmb3IgbWF0Y2hpbmcgamlkIHN0cmluZ3NcblxuIyBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIEpJRCBwb2ludHMgdG8gYSBtYW5hZ2VkIG9yIGJpbGF0ZXJhbCBncm91cGNoYXRcbiNcbiMgQHBhcmFtIGppZCBbU3RyaW5nXSB0byB0ZXN0XG4jXG4jIEByZXR1cm4gW0Jvb2xlYW5dIGlzIGEgbWFuYWdlZCBncm91cGNoYXQgb3IgYSBiaWxhdGVyYWwgZ3JvdXBjaGF0XG5leHBvcnRzLmlzR3JvdXBjaGF0ID0gKGppZCkgLT5cbiAgL0AoY29uZmVyZW5jZXxsZWdhY3ljaGF0KVxcLi9pLnRlc3QgamlkXG5cbiMgRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBKSUQgcG9pbnRzIHRvIGEgbWFuYWdlZCAobXVjIGFkYXB0ZXIpIGdyb3VwY2hhdFxuI1xuIyBAcGFyYW0gamlkIFtTdHJpbmddIHRvIHRlc3RcbiNcbiMgQHJldHVybiBbQm9vbGVhbl0gaXMgbWFuYWdlZCBncm91cGNoYXRcbmV4cG9ydHMuaXNNYW5hZ2VkR3JvdXBjaGF0ID0gKGppZCkgLT5cbiAgL0BsZWdhY3ljaGF0XFwuL2kudGVzdCBqaWRcblxuIyBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIEpJRCBwb2ludHMgdG8gYSBiaWxhdGVyYWwgZ3JvdXBjaGF0XG4jXG4jIEBwYXJhbSBqaWQgW1N0cmluZ10gdG8gdGVzdFxuI1xuIyBAcmV0dXJuIFtCb29sZWFuXSBpcyBhIGJpbGF0ZXJhbCBjaGF0XG5leHBvcnRzLmlzQmlsYXRlcmFsR3JvdXBjaGF0ID0gKGppZCkgLT5cbiAgL0Bjb25mZXJlbmNlXFwuL2kudGVzdCBqaWRcblxuIyBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIEpJRCBpcyBmb3IgYSBZYWhvbyBjb250YWN0XG4jXG4jIEBwYXJhbSBqaWQgW1N0cmluZ10gamlkIHRvIHRlc3RcbiNcbiMgQHJldHVybiBbQm9vbGVhbl1cbmV4cG9ydHMuaXNZYWhvbyA9IChqaWQpIC0+XG4gIC8uKkAoeWFob298cm9ja2V0bWFpbHx5bWFpbClcXC4vLnRlc3QgamlkXG5cblxuIyBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIEpJRCBpcyBpbiB0aGUgVGhvbXNvbiBSZXV0ZXJzIG5ldHdvcmsuXG4jXG4jIEBwYXJhbSBqaWQgW1N0cmluZ10gamlkIHRvIHRlc3RcbiNcbiMgQHJldHVybiBbQm9vbGVhbl1cbmV4cG9ydHMuaXNOaXRyb0NvbnRhY3QgPSAoamlkKSAtPlxuICAvLipAKHJldWFzbWJ8cmV1dGVycylcXC5uZXQvLnRlc3QgamlkXG4iLCJcbiMgRGVjb3JhdGUgYSBmdW5jdGlvbiBieSBuZWdhdGluZyBpdHMgcmV0dXJuIHZhbHVlLCBhc3N1bWVkIG9yIGNvbnNpZGVyZWRcbiMgICB0byBiZSBib29sZWFuXG4jIEBwYXJhbSBmdW5jIFtGdW5jdGlvbl0gYSBmdW5jdGlvbiB0byBkZWNvcmF0ZVxuI1xuIyBAcmV0dXJuIFtCb29sZWFuXSB0aGUgbmVnYXRpb24gb2YgdGhlIGRlY29yYXRlZCBmdW5jdGlvbidzIHJldHVybiB2YWx1ZVxubW9kdWxlLmV4cG9ydHMubm90ID0gKGZ1bmMpIC0+XG4gIC0+IG5vdCBmdW5jLmFwcGx5IHRoaXMsIGFyZ3VtZW50c1xuIiwiUSA9IHJlcXVpcmUgJ3EnXG5cbiMgQ3JlYXRlIGEgUSBwcm9taXNlIHRoYXQgYWxyZWFkeSBoYXMgYSBmYWlsIGhhbmRsZXIgdG8gbG9nIEpTIGVycm9ycyBvclxuIyBhc3luYyBlcnJvcnMgYW5kIHRoZW4gcmUtdGhyb3cgdGhlIGVycm9yXG4jXG4jIGZuIFtGdW5jdGlvbl0gdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZCB0byBRLlByb21pc2VcbiNcbiMgQHJldHVybiBbUHJvbWlzZV0gYSBRIFByb21pc2Vcbm1vZHVsZS5leHBvcnRzID0gKGZuKSAtPlxuICBRLlByb21pc2UgZm5cbiAgICAuZmFpbCAoZGF0YSA9IHt9KSAtPlxuICAgICAgZXJyb3IgPSBpZiBkYXRhIGluc3RhbmNlb2YgRXJyb3IgdGhlbiBkYXRhIGVsc2UgbmV3IEVycm9yKClcbiAgICAgIGVycm9yLmRhdGEgPSBkYXRhXG4gICAgICB0aHJvdyBlcnJvclxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5fLm1peGluIHJlcXVpcmUgJ3V0aWwvbGltaXQnXG5cbiMgVXRpbGl0eSBjbGFzcyB1c2VkIHRvIHJhdGUgbGltaXQgYSBmdW5jdGlvbiB3aXRoIGFsaWFzIG1ldGhvZHMgdGhhdCBjYW4gYWxsXG4jIGJlIHJhdGUgbGltaXRlZCBzZXBhcmF0ZWx5IGJ1dCBhbHNvIHVsdGltYXRlbHkgZm9yIHRoZSBmdW5jdGlvbi5cbiNcbiMgVGhpcyBjbGFzcyBoYXMgdmlydHVhbCBtZXRob2RzIHNpbmNlIGl0IGFsbG93cyBmb3IgdGhlIGR5bmFtaWMgYWRkaXRvblxuIyAgIG9mIGFsaWFzIG1ldGhvZHMgdG8gYmUgYXR0YWNoZWQgdG8gZWFjaCBpbnN0YW5jZS5cbiNcbiMgQG1ldGhvZCAjaW52b2tlKClcbiMgICBUaGUgZGVmYXVsdCBhbGlhcyBtZXRob2QgZm9yIGVhY2ggaW5zdGFuY2UgaXMgaW52b2tlKCkgd2hpY2ggaXMgYSBwb2ludGVyXG4jICAgdG8gYSByYXRlLWxpbWl0ZWQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb24gdGhhdCB3YXMgcGFzc2VkIGludG8gdGhlXG4jICAgY29uc3RydWN0b3IgYWxvbmcgd2l0aCBpdHMgcmF0ZSBsaW1pdGluZyBwYXJhbWV0ZXJzLlxuIyAgIEByZXR1cm4gW09iamVjdCwgRXJyb3JdIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIG9yXG4jICAgICBhbiBFcnJvciBvYmplY3QgaWYgdGhlIGNhbGwgaGFzIGV4Y2VlZGVkIHRoZSBhbGxvd2FibGUgbWF4IGNhbGxzXG5jbGFzcyBSYXRlTGltaXRlclxuXG4gIEBFUlJPUl9GVU5DVElPTl9NSVNTSU5HOiBcIkZ1bmN0aW9uIGlzIG1pc3Npbmcgb3IgaW52YWxpZFwiXG5cbiAgIyBAcHJvcGVydHkgW0Z1bmN0aW9uXSBmdW5jdGlvbiB0byBiZSByYXRlIGxpbWl0ZWRcbiAgIyBAcHJpdmF0ZVxuICBfZnVuYzogbnVsbFxuXG4gICMgQHByb3BlcnR5IFtOdW1iZXJdIGEgcG9zaXRpdmUgaW50ZWdlciBmb3IgdGhlIG1heGltdW0gbnVtYmVyIG9mXG4gICMgICBjYWxscyB0byB0aGUgZnVuY3Rpb25cbiAgIyBAcHJpdmF0ZVxuICBfbWF4OiBudWxsXG5cbiAgIyBAcHJvcGVydHkgW051bWJlcl0gdGhlIHRpbWUgcGVyaW9kIGluIG1pbGxpc2Vjb25kcyBmb3IgdHJhY2tpbmdcbiAgIyAgIGFuZGxpbWl0aW5nIHRoZSBudW1iZXIgb2YgZnVuY3Rpb24gY2FsbHNcbiAgIyBAcHJpdmF0ZVxuICBfdGltZTogbnVsbFxuXG4gICMgQHByb3BlcnR5IFtPYmplY3RdIHRoZSBjb250ZXh0IGZvciB0aGUgZnVuY3Rpb24gd2hlbiBpbnZva2VkXG4gICMgQHByaXZhdGVcbiAgX2NvbnRleHQ6IG51bGxcblxuICAjIEBwcm9wZXJ0eSBbU3RyaW5nXSBhbiBjdXN0b20gbWVzc2FnZSByZXR1cm5lZCB3aGVuIHRoZSBmdW5jdGlvbiBpc1xuICAjICAgaW52b2tlZCBiZXlvbmQgdGhlIHJhdGUgcGVybWl0dGVkIGluIHRoZSBzcGVjaWZpZWQgdGltZSBwZXJpb2RcbiAgIyBAcHJpdmF0ZVxuICBfZXJyb3JNZXNzYWdlOiBudWxsXG5cbiAgIyBDb25zdHJ1Y3RvciBtZXRob2RcbiAgI1xuICAjIEBwYXJhbSBmdW5jIFtGdW5jdGlvbl0gdGhlIGZ1bmN0aW9uIHRvIHdyYXAgd2l0aCB0aGUgcmF0ZSBsaW1pdGF0aW9uXG4gICMgQHBhcmFtIG9wdGlvbnMgW09iZWpjdF0gYW4gb2JqZWN0IG9mIG9wdGlvbnNcbiAgIyBAb3B0aW9uIG9wdGlvbnMgbWF4IFtOdW1iZXJdIGEgcG9zaXRpdmUgaW50ZWdlciBmb3IgdGhlIG1heGltdW0gbnVtYmVyIG9mXG4gICMgICBjYWxscyB0byB0aGUgZnVuY3Rpb24sIGRlZmF1bHQgaXMgMVxuICAjIEBvcHRpb24gb3B0aW9ucyB0aW1lIFtOdW1iZXJdIHRoZSB0aW1lIHBlcmlvZCBpbiBtaWxsaXNlY29uZHMgZm9yIHRyYWNraW5nXG4gICMgICBhbmQgbGltaXRpbmcgdGhlIG51bWJlciBvZiBmdW5jdGlvbiBjYWxscywgZGVmYXVsdCBpcyAxMDAwXG4gICMgQG9wdGlvbiBvcHRpb25zIGNvbnRleHQgW09iamVjdF0gdGhlIGNvbnRleHQgZm9yIHRoZSBmdW5jdGlvbiB3aGVuIGludm9rZWRcbiAgIyBAb3B0aW9uIG9wdGlvbnMgZXJyb3JNZXNzYWdlIFtTdHJpbmddIGFuIGN1c3RvbSBtZXNzYWdlIHJldHVybmVkIHdoZW4gdGhlXG4gICMgICBmdW5jdGlvbiBpcyBpbnZva2VkIGJleW9uZCB0aGUgcmF0ZSBwZXJtaXR0ZWQgaW4gdGhlIHNwZWNpZmllZCB0aW1lXG4gICMgICBwZXJpb2RcbiAgI1xuICAjIEByZXR1cm4gW1JhdGVMaW1pdGVyXVxuICBjb25zdHJ1Y3RvcjogKGZ1bmMsIG9wdGlvbnMgPSB7fSkgLT5cbiAgICAjIGRlc3RydWN0dXJpbmcgYXNzaWdubWVudCBoZXJlIGlzIHRvIHNldCB0aGUgdmFsdWVzIG9mIHByaXZhdGUgdmFycyBvblxuICAgICMgdGhpcyBpbnN0YW5jZSBmb3IgcmV1c2UgYXMgZGVmYXVsdHMgd2hlbiBjYWxsaW5nICNhZGRBbGlhcygpLlxuICAgIHttYXgsIHRpbWUsIGNvbnRleHQsIGVycm9yTWVzc2FnZX0gPSBvcHRpb25zXG5cbiAgICBAX2Z1bmMgPSBmdW5jXG4gICAgQF9tYXggPSBtYXhcbiAgICBAX3RpbWUgPSB0aW1lXG4gICAgQF9jb250ZXh0ID0gY29udGV4dFxuICAgIEBfZXJyb3JNZXNzYWdlID0gZXJyb3JNZXNzYWdlXG4gICAgXG4gICAgdGhyb3cgbmV3IEVycm9yIEBjb25zdHJ1Y3Rvci5FUlJPUl9GVU5DVElPTl9NSVNTSU5HIHVubGVzcyBfLmlzRnVuY3Rpb24gQF9mdW5jXG4gICBcbiAgICBAYWRkQWxpYXMgJ2ludm9rZScsIG9wdGlvbnNcbiAgICByZXR1cm4gdGhpc1xuICAgIFxuICAjIEFkZCBhbiBhbGlhcyBtZXRob2QsIGFsc28gcmF0ZS1saW1pdGVkLCB0byB0aGlzIGluc3RhbmNlLlxuICAjXG4gICMgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIGFsaWFzIGZ1bmN0aW9uXG4gICMgQHBhcmFtIG9wdGlvbnMgW09iZWpjdF0gYW4gb2JqZWN0IG9mIG9wdGlvbnNcbiAgIyBAb3B0aW9uIG9wdGlvbnMgbWF4IFtOdW1iZXJdIGEgcG9zaXRpdmUgaW50ZWdlciBmb3IgdGhlIG1heGltdW0gbnVtYmVyIG9mXG4gICMgICBjYWxscyB0byB0aGUgZnVuY3Rpb24sIGRlZmF1bHQgaXMgMVxuICAjIEBvcHRpb24gb3B0aW9ucyB0aW1lIFtOdW1iZXJdIHRoZSB0aW1lIHBlcmlvZCBpbiBtaWxsaXNlY29uZHMgZm9yIHRyYWNraW5nXG4gICMgICBhbmRsaW1pdGluZyB0aGUgbnVtYmVyIG9mIGZ1bmN0aW9uIGNhbGxzLCBkZWZhdWx0IGlzIDEwMDBcbiAgIyBAb3B0aW9uIG9wdGlvbnMgY29udGV4dCBbT2JqZWN0XSB0aGUgY29udGV4dCBmb3IgdGhlIGZ1bmN0aW9uIHdoZW4gaW52b2tlZFxuICAjIEBvcHRpb24gb3B0aW9ucyBlcnJvck1lc3NhZ2UgW1N0cmluZ10gYW4gY3VzdG9tIG1lc3NhZ2UgcmV0dXJuZWQgd2hlbiB0aGVcbiAgIyAgIGZ1bmN0aW9uIGlzIGludm9rZWQgYmV5b25kIHRoZSByYXRlIHBlcm1pdHRlZCBpbiB0aGUgc3BlY2lmaWVkIHRpbWVcbiAgIyAgIHBlcmlvZFxuICAjXG4gICMgQGV4YW1wbGVcbiAgIyAgIHJlcXVpcmUoJ3JhdGVfbGltaXRlcicpO1xuICAjXG4gICMgICBmdW5jID0gZnVuY3Rpb24oKXtcbiAgIyAgICAgcmV0dXJuIHRydWU7XG4gICMgICB9O1xuICAjXG4gICMgICAvLyBXcmFwIHRoZSBmdW5jdGlvbiBzbyB0aGF0IGl0IE5FVkVSIGdldHMgY2FsbGVkIG1vcmUgdGhhblxuICAjICAgLy8gNSB0aW1lcyB3aGl0aGluIDEgbWludHV0ZS5cbiAgIyAgIGRvU29tZXRoaW5nID0gUmF0ZUxpbWl0ZXIoZnVuYywge21heDogNSwgdGltZTogNjAgKiAxMDAwfSk7XG4gICNcbiAgIyAgIC8vIFlvdSBjYW4gY2FsbCB0aGUgcmF0ZSBsaW1pdGVkIGZ1bmN0aW9uIHVzaW5nICNpbnZva2UoKVxuICAjICAgLy8gcGFzc2luZyBhbnkgYXJncyB0byB0aGUgZnVuY3Rpb24geW91IHdvdWxkIG5vcm1hbGx5IHBhc3MuXG4gICMgICBkb1NvbWV0aGluZy5pbnZva2UoKTtcbiAgI1xuICAjICAgLy8gQWRkIGFuIGFsaWFzIGZ1bmN0aW9uIHRoYXQgcmF0ZSBsaW1pdHMgdG8gMTAgdGltZXMgZXZlcnkgNSBtaW50dWVzLlxuICAjICAgZG9Tb21ldGhpbmcuYWRkQWxpYXMoJ3doZW5UaGlzSGFwcGVucycsIHttYXg6IDEwLCB0aW1lOiA1ICogNjAgKiAxMDAwfSk7XG4gICNcbiAgIyAgIC8vIEFkZCBhbm90aGVyIGFsaWFzIGZ1bmN0aW9uIHRoYXQgcmF0ZSBsaW1pdHMgdG8gNiB0aW1lcyBldmVyeSAzIG1pbnR1ZXMuXG4gICMgICBkb1NvbWV0aGluZy5hZGRBbGlhcygnd2hlblRoYXRIYXBwZW5zJywge21heDogNiwgdGltZTogMyAqIDYwICogMTAwMH0pO1xuICAjXG4gICMgICBkb1NvbWV0aGluZy53aGVuVGhpc0hhcHBlbnMoKTtcbiAgIyAgIGRvU29tZXRoaW5nLndoZW5UaGF0SGFwcGVucygpO1xuICAjICAgZG9Tb21ldGhpbmcud2hlblRoaXNIYXBwZW5zKCk7XG4gICMgICBkb1NvbWV0aGluZy53aGVuVGhhdEhhcHBlbnMoKTtcbiAgIyAgIC8vIGV0Yy4uLlxuICAjXG4gICMgICAvLyBDYWxsaW5nIGRvU29tZXRoaW5nLndoZW5UaGlzSGFwcGVucygpIG9yIGRvU29tZXRoaW5nLndoZW5UaGF0SGFwcGVucygpXG4gICMgICAvLyB3aWxsIGJlIHJhdGUgbGltaXRlZCBlYWNoIGFjY29yZGluZyB0byBpdHMgc2VwYXJhdGUgYnVzaW5lc3MgbG9naWNcbiAgIyAgIC8vIGJ1dCwgdWx0aW1hdGVseSwgdGhlIGZ1bmN0aW9uIHdpbGwgbmV2ZXIgYmUgY2FsbGVkIG1vcmUgdGhhbiA1IHRpbWVzXG4gICMgICAvLyB3aXRoaW4gMSBtaW50dWUuXG4gICNcbiAgIyBAcmV0dXJuIFtGdW5jdGlvbl0gdGhlIHJhdGUtbGltaXRlZCBhbGlhcyBmdW5jdGlvblxuICBhZGRBbGlhczogKG5hbWUsIG9wdGlvbnMgPSB7fSkgLT5cbiAgICAjIFVzZSB0aGUgcHJpdmF0ZWx5IHN0b3JlZCB2YXJzIGFzIGRlZmF1bHRzIGluIGNhc2Ugb3B0aW9ucyBpcyBvbWl0dGVkXG4gICAgIyBieSB0aGUgY2FsbGVyLlxuICAgIG9wdHMgPSBfLmRlZmF1bHRzIG9wdGlvbnMsXG4gICAgICBtYXg6IEBfbWF4XG4gICAgICB0aW1lOiBAX3RpbWVcbiAgICAgIGNvbnRleHQ6IEBfY29udGV4dFxuICAgICAgZXJyb3JNZXNzYWdlOiBAX2Vycm9yTWVzc2FnZVxuXG4gICAgcmV0dXJuIG51bGwgdW5sZXNzIG5hbWVcbiAgICBcbiAgICAjIFVzZSBuYW1lIHRvIHNldCBhIHB1YmxpYyBtZXRob2QgYXMgYSByYXRlIGxpbWl0ZWQgZnVuY3Rpb25cbiAgICBAW25hbWVdID0gXy5saW1pdCBAaW52b2tlIG9yIEBfZnVuYywgb3B0c1xuICAgICAgICBcbm1vZHVsZS5leHBvcnRzID0gUmF0ZUxpbWl0ZXJcbiIsIl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xuUSA9IHJlcXVpcmUgJ3EnXG5fLm1peGluIHJlcXVpcmUgJ3V0aWwvdXRpbHMnXG5cbkFUVEVNUFRfRkFJTEVEID0gXCJBdHRlbXB0IGZhaWxlZDpcIlxuQUxMX0FUVEVNUFRTX0ZBSUxFRCA9IFwiQWxsIGF0dGVtcHRzIGhhdmUgZmFpbGVkLlwiXG5USU1FRF9PVVQgPSBcIlRoZSByZXRyeWVyIGhhcyB0aW1lZCBvdXQuXCJcblxuIyBHZXQgYSBjbG9zdXJlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gYXR0ZW1wdCBhdCBjYWxsaW5nIHRoZSBhY3Rpb24gZnVuY3Rpb24uXG4jIFRoZSBmdW5jdGlvbiB0byBiZSB3cmFwcGVkIGNhbiBiZSBzeW5jIG9yIGFzeW5jLiBJZiBzeW5jIHRoZW4gaXQgc2hvdWxkIHJldHVyblxuIyBhIHZhbHVlIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQgZm9yIGl0cyB0cnV0aHktbmVzcy5cbiNcbiMgVGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHRoZSByZXRyeWVyIHdpbGwgcmV0dXJuIGEgUSBwcm9taXNlLlxuI1xuIyBAb3B0aW9uIGZ1bmMgW0Z1bmN0aW9uXSB0aGUgZnVuY3Rpb24gdG8gdHJ5IG9yIHJldHJ5IHNldmVyYWwgdGltZXNcbiMgQHBhcmFtIG9wdGlvbnMgW09iamVjdF0gYW4gb2JqZWN0IG9mIG9iamVjdCB0byBzZXQgdXAgdGhlIGNsb3N1cmUgZW52aXJvbm1lbnRcbiMgQG9wdGlvbiBvcHRpb25zIG1heCBbSW50ZWdlcl0gdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IHRoZSBmdW5jdGlvblxuIyBAb3B0aW9uIG9wdGlvbnMgd2FpdCBbSW50ZWdlciwgRnVuY3Rpb25dIHdhaXQgdGltZSBpbiBtaWxsaXNlY29uZHMgb3IgYVxuIyAgIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGNhbGN1bGF0ZWQgd2FpdCBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcbiMgICB3YWl0IGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIDEpIHRoZSBsYXN0IGZhaWxlZCBhdHRlbXB0IG51bWJlciwgMikgbWF4IGF0dGVtcHRzXG4jIEBvcHRpb24gcHJvZ3Jlc3MgW0Z1bmN0aW9uXSBsaWtlIGEgI25vdGlmeSB0byByZXBvcnQgb24gaW5jcmVtZW50YWwgcHJvZ3Jlc3NcbiMgICBwcm9ncmVzcyBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCAxKSB0aGUgbGFzdCBmYWlsZWQgYXR0ZW1wdCBudW1iZXIsXG4jICAgMikgbWF4IGF0dGVtcHRzLCAzKSBuZXh0IHdhaXQgaW50ZXJ2YWxcbiMgQG9wdGlvbiBvcHRpb25zIHRpbWVvdXQgW0ludGVnZXJdIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSBnaXZpbmcgdXAgb25cbiMgQG9wdGlvbiBvcHRpb25zIG1heCBbSW50ZWdlcl0gdGhlIG1heCBudW1iZXIgb2YgdHJpZXMgYmVmb3JlIGdpdmluZyB1cFxuIyBAb3B0aW9uIG9wdGlvbnMgY29udGV4dCBbT2JqZWN0XSB0aGUgY29udGV4dCBvZiB0aGUgZnVuY3Rpb24gYmVpbmcgcmV0cmllZFxuI1xuIyBAcmV0dXJuIFtGdW5jdGlvbl0gYSBjbG9zdXJlIHRoYXQgd2lsbCBwZXJmb3JtIHJldHJ5IGF0dGVtcHQocylcbiNcbiMgQGV4YW1wbGVcbiMgICAvLyBXcmFwIGEgZnVuY3Rpb24gaW4gXy5yZXRyeSgpXG4jICAgdmFyIGF0dGVtcHQgPSAwO1xuIyAgIHZhciBmdW5jID0gZnVuY3Rpb24oKXtcbiMgICAgIHJldHVybiAoKythdHRlbXB0ID09PSAzKVxuIyAgIH1cbiMgICByZXRyeWVyID0gXy5yZXRyeShmdW5jKTtcbiMgICAvLz0+IFJldHVybnMgYSBRIFByb21pc2UgdGhhdCBpcyByZXNvbHZlZCBvbiB0aGUgdGhpcmQgYXR0ZW1wdFxuIyAgIHJldHJ5ZXIoKTtcbiNcbiMgQGV4YW1wbGVcbiMgICAvLyBXcmFwIGEgZnVuY3Rpb24gaW4gXy5yZXRyeSgpIGFuZCBwYXNzIGluIGEgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHdhaXQgaW50ZXJ2YWxcbiMgICB2YXIgYXR0ZW1wdCA9IDA7XG4jICAgdmFyIGZ1bmMgPSBmdW5jdGlvbigpe1xuIyAgICAgcmV0dXJuICgrK2F0dGVtcHQgPT09IDMpXG4jICAgfVxuIyAgIHZhciBnZXRXYWl0ID0gZnVuY3Rpb24oYXR0ZW1wdCl7XG4jICAgICByZXR1cm4gYXR0ZW1wdCAqIDEwMDBcbiMgICB9XG4jICAgcmV0cnllciA9IF8ucmV0cnkoZnVuYywge21heDogNSwgd2FpdDogZ2V0V2FpdH0pO1xuIyAgIC8vIFRoZSB3YWl0IGludGVydmFsIGJldHdlZW4gYXR0ZW1wdHMgd2lsbCBpbmNyZWFzZSBieSAxIHNlY29uZCB3aXRoIGVhY2ggYXR0ZW1wdC5cbiMgICByZXRyeWVyKCk7XG5leHBvcnRzLnJldHJ5ID0gKGZ1bmMsIG9wdGlvbnMgPSB7fSkgLT5cbiAgIyBAdG9kbyBhZGQgdGltZW91dCBvcHRpb24gYW5kIGF1dG8gY2FsbCBhdHRlbXB0IHdpdGggY2FuY2VsIGZsYWdcbiAge21heCwgd2FpdCwgdGltZW91dCwgY29udGV4dCwgcHJvZ3Jlc3N9ID0gXy5kZWZhdWx0cyBvcHRpb25zLFxuICAgIHRpbWVvdXQ6IDIgKiA2MCAqIDEwMDAgIyAyIG1pbnV0ZXNcbiAgICBjb250ZXh0OiBudWxsXG5cbiAgbWF4ID0gdmFsaWRhdGVNYXhSZXRyaWVzIG1heCwgMVxuICB3YWl0ID0gXy50b0Z1bmN0aW9uIHdhaXQgb3IgMFxuXG4gICMgSW5pdGlhbGl6ZSB3aXRoIGF0dGVtcHQgY291bnQgMFxuICBhdHRlbXB0ID0gMFxuXG4gICMgQ3JlYXRlIGEgbmV3IGRlZmVycmVkIHdoaWNoIHdyYXBzIGFsbCBhdHRlbXB0cyBhcyBhIHdob2xlXG4gIGRmZCA9IFEuZGVmZXIoKVxuXG4gIHRpbWVvdXRJZCA9IG51bGxcbiAgaW50ZXJ2YWxUaW1lb3V0ID0gbnVsbFxuXG4gICMgUmV0dXJuIGEgY2xvc3VyZSB3aXRoIGFjY2VzcyB0byByZXRyeSB2YXJzLCBpLmUuIGRlZmVycmVkLCBhdHRlbXB0LCBtYXgsXG4gICMgY29udGV4dCwgYW5kIHRoZSBvcmlnaW5hbCBhcmd1bWVudHMgYmVpbmcgcGFzc2VkIHRvIHRoZSByZXRyaWVkIGZ1bmN0aW9uXG4gICMgQHRvZG8gYWRkIHtjYW5jZWw6IHRydWV9IHRvIGFib3J0XG4gIGludm9rZSA9IChhcmdzLi4uKSAtPlxuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQgLT5cbiAgICAgIG1zZyA9IFRJTUVEX09VVFxuICAgICAgZGZkLnJlamVjdCBuZXcgRXJyb3IgbXNnXG4gICAgICBjbGVhclRpbWVvdXQgaW50ZXJ2YWxUaW1lb3V0XG4gICAgLCB0aW1lb3V0XG5cbiAgICBmdW5jQXJncyA9IGFyZ3MuY29uY2F0IFthdHRlbXB0OiArK2F0dGVtcHRdXG5cbiAgICAjIGZ1bmMgY2FuIHJldHVybiBhIHByb21pc2Ugb3IgYSBzeW5jaHJvbm91cyByZXR1cm4gdmFsdWVcbiAgICByZXRWYWwgPSBmdW5jLmFwcGx5IGNvbnRleHQsIGZ1bmNBcmdzXG5cbiAgICAjIEFkZCBzdWNjZXNzL2ZhaWwgaGFuZGxlcnMgdG8gdGhlIHByb21pc2Ugb3Igc2ltcGx5IGNhbGwgdGhlbSAoZm9yIHN5bmMpXG4gICAgb25GYWlsID0gKGVycm9yKSAtPlxuICAgICAgaWYgYXR0ZW1wdCA8IG1heFxuICAgICAgICBjb25zb2xlLmxvZyBcIiN7QVRURU1QVF9GQUlMRUR9ICN7YXR0ZW1wdH0gb2YgI3ttYXh9XCJcbiAgICAgICAgd2FpdEludGVydmFsID0gd2FpdCBhdHRlbXB0LCBtYXhcblxuICAgICAgICAjIENhbGwgdGhlIHByb2dyZXNzIGZ1bmN0aW9uIHdoaWNoIGFjdHMgbGlrZSAjbm90aWZ5XG4gICAgICAgICMgKHdoaWNoIHdhcyBkZXByZWNhdGVkIGZvciBwcm9taXNlcylcbiAgICAgICAgaWYgXy5pc0Z1bmN0aW9uIHByb2dyZXNzXG4gICAgICAgICAgcHJvZ3Jlc3MgcmV0VmFsLCBhdHRlbXB0LCBtYXgsIHdhaXRJbnRlcnZhbFxuXG4gICAgICAgICMgVGhpcyB0aW1lb3V0IGlzIGZvciB0aGUgd2FpdCBpbnRlcnZhbCBiZXR3ZWVuIGF0dGVtcHRzXG4gICAgICAgIGludGVydmFsVGltZW91dCA9IHNldFRpbWVvdXQgKC0+IGludm9rZS5hcHBseSBjb250ZXh0LCBhcmdzKSwgd2FpdEludGVydmFsXG4gICAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUubG9nIEFMTF9BVFRFTVBUU19GQUlMRURcbiAgICAgICAgZGZkLnJlamVjdCBuZXcgRXJyb3IgQUxMX0FUVEVNUFRTX0ZBSUxFRFxuXG4gICAgUSByZXRWYWxcbiAgICAgICMgTm9ybWFsaXplIGFzeW5jIHdpdGggc3luYyByZXR1cm4gdmFsdWVzXG4gICAgICAudGhlbiAoZGF0YSkgLT5cbiAgICAgICAgIyBkYXRhIGlzIGEgc3luYyByZXR1cm4gdmFsdWUgc28gdGhyb3cgZXhjZXB0aW9uIGJ1dCBvbmx5IHdoZW4gZmFsc3lcbiAgICAgICAgaWYgZGF0YSBpcyByZXRWYWxcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IgXCJTeW5jcm9ub3VzIHJldHVybiB2YWx1ZSBpcyBmYWxzeVwiIHVubGVzcyBkYXRhXG4gICAgICAgICMgY2xlYXIgdGhlIHRpbWVvdXRcbiAgICAgICAgY2xlYXJUaW1lb3V0IHRpbWVvdXRJZFxuICAgICAgICBkYXRhXG4gICAgICAudGhlbiBkZmQucmVzb2x2ZVxuICAgICAgLmNhdGNoIG9uRmFpbFxuXG4gICAgIyBUaGUgcHJvbWlzZSBpcyByZXR1cm5lZCB0byB0aGUgaW5pdGlhbCBjYWxsZXJcbiAgICBkZmQucHJvbWlzZVxuXG4jIEZvcmNlIGEgdmFsdWUgdG8gYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHJldHVybiBhIGRlZmF1bHQgdmFsdWVcbiMgQHByaXZhdGVcbiNcbiMgQHBhcmFtIG4gW09iamVjdF0gYW4gb2JqZWN0LCBleHBlY3RlZCB0byBiZSBhIE51bWJlciwgdGhhdCB3aWxsIGJlIHZhbGlkYXRlZFxuIyBAcGFyYW0gZGVmYXVsdCBbTnVtYmVyXSBhIE51bWJlciB0byB1c2UgYXMgYSBkZWZhdWx0XG4jXG4jIEByZXR1cm4gW051bWJlcl0gdGhlIHZhbGlkYXRlZCBwb3NpdGl2ZSBJbnRlZ2VyXG52YWxpZGF0ZU1heFJldHJpZXMgPSAobiwgZGVmYXVsdFZhbHVlKSAtPlxuICBpZiB0eXBlb2YgbiBpcyAnbnVtYmVyJyBhbmQgTWF0aC5yb3VuZChuKSBpcyBuIGFuZCBuID49IDFcbiAgICBuXG4gIGVsc2VcbiAgICBjb25zb2xlLndhcm4gXCJbUmV0cnllcl0gbWF4IHJldHJpZXMgdmFsdWUgaXMgYW4gaW52YWxpZCBudW1iZXIsXG4gICAgICB1c2luZyBkZWZhdWx0IHZhbHVlIG9mICN7ZGVmYXVsdFZhbHVlfS5cIlxuICAgIGRlZmF1bHRWYWx1ZVxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5cbiMgV3JhcCBhIGZ1bmN0aW9uIHNvIHRoYXQgaXQgb25seSBnZXRzIGNhbGxlZCBpZiBhIHNlY29uZCBjb25kaXRpb25hbCBmdW5jdGlvblxuIyBpcyBmaXJzdCBpbnZva2VkIGFuZCByZXR1cm5zIHRydWVcbiNcbiMgQHBhcmFtIGZ1bmMgW0Z1bmN0aW9uXSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4jIEBwYXJhbSBbZnVuY3Rpb25dIHRoZSBjb25kaXRpb25hbCBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIHRydWUgaW4gb3JkZXJcbiMgICBmb3IgZnVuYyB0byBiZSBpbnZva2VkXG4jXG4jIEBleGFtcGxlXG4jICAgdmFyIGZ1bmMgPSBmdW5jdGlvbigpeyByZXR1cm4gY29uc29sZS5sb2coXCJkbyB0aGlzXCIpOyB9O1xuIyAgIHZhciBjb25kaXRpb24gPSBmdW5jdGlvbigpeyByZXR1cm4gdHJ1ZSB9O1xuIyAgIHZhciBjb25kaXRpb25hbEZ1bmMgPSBVdGlscy5jb25kaXRpb25hbChmdW5jLCBjb25kaXRpb24pO1xuIyAgIC8vIHJldHVybnMgXCJkbyB0aGlzXCJcbiMgICBjb25kaXRpb25hbEZ1bmMoKTtcbiNcbiMgQGV4YW1wbGVcbiMgICB2YXIgZnVuYyA9IGZ1bmN0aW9uKCl7IHJldHVybiBjb25zb2xlLmxvZyhcIndpbGwgbm90IGRvIHRoaXNcIik7IH07XG4jICAgdmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZSB9O1xuIyAgIHZhciBjb25kaXRpb25hbEZ1bmMgPSBVdGlscy5jb25kaXRpb25hbChmdW5jLCBjb25kaXRpb24pO1xuIyAgIC8vIGZ1bmMgd2lsbCBub3QgYmUgaW52b2tlZFxuIyAgIC8vIHJldHVybnMgbnVsbFxuIyAgIGNvbmRpdGlvbmFsRnVuYygpO1xuI1xuIyBAcmV0dXJuIFtGdW5jdGlvbl0gYSB3cmFwcGVkIGZ1bmN0aW9uIGRlcGVuZGVudCB0aGUgcmV0dXJuIHZhbHVlIG9mIGNvbmRpdGlvblxuZXhwb3J0cy5jb25kaXRpb25hbCA9IChmdW5jLCBjb25kaXRpb24pIC0+XG4gIHJldHVybiBmdW5jIHVubGVzcyB0eXBlb2YgY29uZGl0aW9uIGlzICdmdW5jdGlvbidcbiAgLT5cbiAgICBpZiBjb25kaXRpb24uYXBwbHkgbnVsbCwgYXJndW1lbnRzXG4gICAgICBmdW5jLmFwcGx5IG51bGwsIGFyZ3VtZW50c1xuICAgIGVsc2VcbiAgICAgIG51bGxcblxuIyBEZWNvcmF0b3IgdG8gaW52b2tlIGEgZnVuY3Rpb24gYW5kIHJldHVybiB0cnVlXG4jXG4jIEBwYXJhbSBmdW5jIFtGdW5jdGlvbl0gYSBmdW5jdGlvbiB0byBkZWNvcmF0ZVxuIyBAcGFyYW0gYm9vbCBbQm9vbGVhbl0gdGhlIGJvb2xlYW4gdmFsdWUgdG8gcmV0dXJuXG4jXG4jIEByZXR1cm4gW0Jvb2xlYW5dIGFsd2F5cyByZXR1cm5zIGEgYm9vbGVhbiB2YWx1ZVxuZXhwb3J0cy5yZXR1cm5Cb29sZWFuID0gKGZ1bmMsIGJvb2wgPSB0cnVlKSAtPlxuICAjIFJldHVybiBkZWNvcmF0ZWQgZnVuY3Rpb24sIHJldHVybmluZyBjb2VyY2VkIGJvb2xlYW5cbiAgLT5cbiAgICBmdW5jLmFwcGx5IG51bGwsIGFyZ3VtZW50c1xuICAgICEhYm9vbFxuXG4jIENoZWNrIHRoYXQgYW4gb2JqZWN0IGlzIGFuIGFycmF5IG9yIHJldHVybiBpdCBhcyB0aGUgZmlyc3QgYW5kIG9ubHkgZWxlbWVudFxuIyBvZiBhbiBhcnJheS5cbiNcbiMgQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5cyBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiMgQGV4YW1wbGUgXy5hcnJheShbMV0sIDIpIHJldHVybnMgYSB0dXBsZSwgW1sxXSwgWzJdXVxuI1xuIyBAcmV0dXJuIFtBcnJheV1cbmV4cG9ydHMuYXJyYXkgPSAtPlxuICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwgYXJndW1lbnRzLCAwXG5cbiAgY29udmVydFRvQXJyYXkgPSAob2JqKSAtPlxuICAgIGlmIF8uaXNBcnJheSBvYmpcbiAgICAgIG9ialxuICAgIGVsc2VcbiAgICAgIF8uY29tcGFjdCBbb2JqXVxuXG4gIGlmIGFyZ3MubGVuZ3RoIGlzIDFcbiAgICBjb252ZXJ0VG9BcnJheSBhcmdzWzBdXG4gIGVsc2VcbiAgICBmb3Igb2JqIGluIGFyZ3NcbiAgICAgIGNvbnZlcnRUb0FycmF5IG9ialxuXG4jIEFsaWFzIHRvIFV0aWxzLnJldHVybkJvb2xlYW5cbmV4cG9ydHMucmV0dXJuQm9vbCA9IEByZXR1cm5Cb29sZWFuXG5cbiMgV3JhcCBhIGZ1bmN0aW9uIGluIGEgdHJ5L2NhdGNoXG4jXG4jIEBwYXJhbSBmdW5jIFtGdW5jdGlvbl0gYSBmdW5jdGlvbiB0byBpbnZva2VcbiNcbiMgQHJldHVybiBbRnVuY3Rpb25dIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoaW4gdHJ5L2NhdGNoXG5leHBvcnRzLnRyeUNhdGNoID0gKGZ1bmMsIGxldmVsID0gJ3dhcm4nKSAtPlxuICAtPlxuICAgIHRyeVxuICAgICAgZnVuYygpXG4gICAgY2F0Y2ggZXJyb3JcbiAgICAgIGNvbnNvbGVbbGV2ZWxdIGVycm9yLm1lc3NhZ2VcbiAgICAgIG51bGxcblxuIyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoYXQgb2JqZWN0LiBJZiBhIGZ1bmN0aW9uIGlzXG4jIHBhc3NlZCBpbiB0aGVuIGl0IHdpbGwgc2ltcGx5IGJlIHJldHVybmVkLlxuI1xuIyBAcGFyYW0gb2JqIFtPYmplY3RdIGFuIG9iamVjdCB0byBjb252ZXJ0IHRvIGEgZnVuY3Rpb25cbiNcbiMgQHJldHVybiBbRnVuY3Rpb25dIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBvYmplY3QgcGFzc2VkIGludG8gdG9GdW5jdGlvbigpXG5leHBvcnRzLnRvRnVuY3Rpb24gPSAob2JqKSAtPlxuICB0aGVPYmogPSBvYmpcbiAgaWYgXy5pc0Z1bmN0aW9uIHRoZU9ialxuICAgIHRoZU9ialxuICBlbHNlXG4gICAgLT4gdGhlT2JqXG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcblhNUFBQcmVzZW5jZSA9IHJlcXVpcmUgJ2VudW0veG1wcF9wcmVzZW5jZSdcblByZXNlbmNlU2hvdyA9IHJlcXVpcmUgJ2VudW0vcHJlc2VuY2Vfc2hvdydcblN0cm9waGUgPSByZXF1aXJlICdzdHJvcGhlJ1xuXG4jIEV4dHJhY3QgdGhlIHVzZXIncyB4bXBwIGRvbWFpbiBmcm9tIHRoZWlyIGxvZ2luIEpJRFxuI1xuIyBAcGFyYW0gamlkIFtTdHJpbmddIGppZCB0byBiZSBwYXJzZWQgdG8gZ2V0IHRoZSBkb21haW4gKGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIEAuKVxuIyBAZXhhbXBsZVxuIyAgIGdldFhNUFBEb21haW4gJ3NvbWUudXNlci50aG9tc29ucmV1dGVycy5jb21AcmV1dGVycy5uZXQnXG4jXG4jIEByZXR1cm4gW1N0cmluZ10geG1wcCBkb21haW5cbmV4cG9ydHMuZ2V0WE1QUERvbWFpbiA9IChqaWQpIC0+XG4gIGppZCA9IFN0cm9waGUuZ2V0QmFyZUppZEZyb21KaWQgamlkXG4gIGlmIHhtcHBEb21haW4gPSAvQC4rJC8uZXhlYyBqaWRcbiAgICB4bXBwRG9tYWluWzBdLnN1YnN0ciAxXG4gIGVsc2VcbiAgICBcIlwiXG5cbiMgTWFwIGEgWE1QUHJlc2VuY2UgZW51bSB0byBhIGNvcnJlc3BvbmRpbmcgUHJlc2VuY2VTaG93IHZhbHVlLCBpZiBhbnlcbiNcbiMgQHBhcmFtIHByZXNlbmNlIFtTdHJpbmddIGEgWE1QUHJlc2VuY2UgZW51bSBjb25zdGFudFxuI1xuIyBAcmV0dXJuIFtTdHJpbmddIGEgUHJlc2VuY2VTaG93IGVudW0gY29uc3RhbnRcbiNcbiMgQHNlZSBYTVBQUHJlc2VuY2VcbiMgQHNlZSBQcmVzZW5jZVNob3dcbmV4cG9ydHMueG1wcFByZXNlbmNlVG9TaG93ID0gKHByZXNlbmNlKSAtPlxuICBzd2l0Y2ggcHJlc2VuY2VcbiAgICB3aGVuIFhNUFBQcmVzZW5jZS5BV0FZXG4gICAgICBQcmVzZW5jZVNob3cuQVdBWVxuICAgIHdoZW4gWE1QUFByZXNlbmNlLkVYVEVOREVEX0FXQVlcbiAgICAgIFByZXNlbmNlU2hvdy5FWFRFTkRFRF9BV0FZXG4gICAgd2hlbiBYTVBQUHJlc2VuY2UuRE5EXG4gICAgICBQcmVzZW5jZVNob3cuRE5EXG4gICAgZWxzZVxuICAgICAgJydcblxuIyBTaW1wbGUgbWFwIGZyb20gZGlzcGxheSB2YWx1ZSB0byB4bXBwIHByZXNlbmNlIHN0YXRlXG4jXG4jIEBwYXJhbSBwcmVzZW5jZSBbU3RyaW5nXSBYTVBQUHJlc2VuY2UgZW51bSB2YWx1ZVxuI1xuIyBAcmV0dXJuIFtTdHJpbmcsIG51bGxdIHZhbGlkIFhNUFBQcmVzZW5jZSBzdGF0ZSBvciBudWxsXG4jXG4jIEBzZWUgWE1QUFByZXNlbmNlXG5leHBvcnRzLnhtcHBQcmVzZW5jZVRvVHlwZSA9IChwcmVzZW5jZSkgLT5cbiAgaWYgcHJlc2VuY2UgaXMgWE1QUFByZXNlbmNlLlVOQVZBSUxBQkxFXG4gICAgWE1QUFByZXNlbmNlLlVOQVZBSUxBQkxFXG4gIGVsc2VcbiAgICBudWxsXG5cbiMgQ29udmVydCBhbiBlbWFpbCBhZGRyZXNzIHRvIGEgdmFsaWQgTml0cm8gSklELlxuI1xuIyBAcGFyYW0gZW1haWwgW1N0cmluZ10gdG8gY29udmVydFxuIyBAcGFyYW0geG1wcERvbWFpbiBbU3RyaW5nXSB0byBhZGQgYWZ0ZXIgQFxuI1xuIyBAcmV0dXJuIFtTdHJpbmddIHZhbGlkIEpJRFxuZXhwb3J0cy5lbWFpbFRvSklEID0gKGVtYWlsID0gJycsIHhtcHBEb21haW4pIC0+XG4gIHJldHVybiBlbWFpbCB1bmxlc3MgeG1wcERvbWFpbiBhbmQgL0AvLnRlc3QgZW1haWxcbiAgXCIje2VtYWlsLnJlcGxhY2UgJ0AnLCAnLid9QCN7eG1wcERvbWFpbn1cIlxuIl19
